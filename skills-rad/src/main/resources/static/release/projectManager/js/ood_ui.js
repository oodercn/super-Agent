new function () {

    // IE67 don't support :before/:after
    // and, IE8 is buggy, force to ignore :before/:after
    if (ood.browser.ie678) {
        // fonticon fixed
        ood.__iefix2 = ood.builtinFontIcon;
    }
};

//UIProfile Class
ood.Class('ood.UIProfile', 'ood.Profile', {
    Instance: {


        //readonly please
        renderId: null,
        _render: function () {
            var ns = this, ins = ns.boxing(), t, map = ood.$cache.profileMap;

            if (ns.beforeRender && false === ins.beforeRender(ns))
                return;

            //first render
            if (!ns.renderId) {
                var ele = ood.Dom.byId(ns.$domId);

                //for dynRender
                if (!ele) return;

                if (ns.domId != ns.$domId)
                    ele.id = ns.domId;

                map[ns.domId] = map[ns.$domId] = ns;

                //e.g. use div.innerHTML = ui.toHtml();
                if (!ele.$xid)
                    ood.UI.$addEventsHandler(ns, ele, true);

                // for svg widget
                if (ns._elset) {
                    for (var i = 1, l = ns._elset.length; i < l; i++)
                        ood.UI.$addEventsHandler(ns, ns._elset[i].node, true);
                }

                // unselectable="on" will kill onBlur
                if (ood.browser.ie && ood.browser.ver < 10 && 'selectable' in ns.properties)
                    ood.setNodeData(ele, "_onoodsel", ns.properties.selectable ? "true" : "false");

                ns.rendered = ns.renderId = ele.$xid;

                ele = null;
            }

            if (ns.CA && !ood.isEmpty(ns.CA)) {
                ins.setCustomAttr(ns.CA);
            }
            if (ns.CS && !ood.isEmpty(ns.CS)) {
                ins.setCustomStyle(ns.CS);
            }

            // For touch-only platform
            // In ipad or other touch-only platform, you have to decide the droppable order by youself
            // The later added to DOM the higher the priority
            // Add droppable links
            if (ood.browser.isTouch) {
                if ((t = ns.box.$Behaviors.DroppableKeys) && t.length) {
                    ood.arr.each(t, function (o) {
                        ins.getSubNode(o, true).each(function (node) {
                            var key = ns.box.getDropKeys(ns, node.$xid);
                            if (key) {
                                var c = ood.$cache.droppable, a = key.split(/[^\w-]+/);
                                for (var i = 0, l = a.length; i < l; i++) {
                                    c[a[i]] = c[a[i]] || [];
                                    c[a[i]].push(node.$xid);
                                }
                            }
                        });
                    });
                }
            }

            if (ood.browser.fakeTouch || (ood.browser.isTouch && (ood.browser.isAndroid || ood.browser.isBB))) {
                var check = {'auto': 1, 'scroll': 1}, dir;
                // for UI's appearances overflow
                ood.each(ns.box.$Appearances, function (o, i) {
                    dir = '';
                    if (check[o.overflow]) {
                        dir = 'xy';
                    } else {
                        if (check[o['overflow-x']]) dir += 'x';
                        if (check[o['overflow-y']]) dir += 'y';
                    }
                    if (dir) ns.getSubNode(i, true).$touchscroll(dir);
                });
                // for UI's overflow property
                if ('overflow' in ns.properties) {
                    if (ood.browser.fakeTouch) {
                        ood.asyRun(function () {
                            var dir = '', root = ns.getRoot();
                            if (root && !root.isEmpty()) {
                                if (root.isScrollBarShowed('x')) dir += 'x';
                                if (root.isScrollBarShowed('y')) dir += 'y';
                                if (dir) root.$touchscroll(dir);
                            }
                        });
                    } else {
                        if (check[ns.properties.overflow]) {
                            ins.setOverflow(ns.properties.overflow, true);
                        }
                    }
                }
            }

            //RenderTrigger
            if (t = ns.RenderTrigger) {
                for (var i = 0, l = t.length; i < l; i++)
                    t[i].call(ns);
                delete ns.RenderTrigger;
            }

            if (ns.onRender)
                ins.onRender(ns);
            ood.tryF(ns.$onrender, [], ns);

            if (arguments[0] === true && (t = ns.LayoutTrigger)) {
                for (var i = 0, l = t.length; i < l; i++)
                    t[i].call(ns);
                if (ns.onLayout)
                    ins.onLayout(ns);
            }
            if (!ns.properties.lazyAppend) {
                if (ns.children)
                    for (var i = 0, v; v = ns.children[i++];)
                        if (v[0]._render)
                            v[0]._render(true);

                if (ns.$attached) {
                    for (var i = 0, v; v = ns.$attached[i++];) {
                        //(ns.$innerObj||(ns.$innerObj=[])).push(v);
                        if (v._render) v._render(true);
                        if ((t = v._render_holder || v._inline_holder) && t.$afterAttached)
                            ood.tryF(t.$afterAttached, [v], t);
                        else
                            ood.tryF(ns.$afterAttached, [v], ns);
                    }
                    delete ns.$attached;
                }
                if (ns.exchildren) {
                    var arr = [];
                    for (var i = 0, v; v = ns.exchildren[i++];)
                        ins.append(v[0], v[1]);
                    delete ns.exchildren;
                }
                if (ns.exmodules) {
                    var arr = [];
                    for (var i = 0, v; v = ns.exmodules[i++];) {
                        v[0].show(null, ins, v[1], false);
                    }
                    delete ns.exmodules;
                }
            }


            ns.renderCompleted = 1;
        },
        __gc: function (ignoreEffects, purgeNow) {
            var ns = this, t, args = ood.toArr(arguments);
            if (ns.destroyed) return;
            if (ns.$beforeDestroy) {
                ood.each(ns.$beforeDestroy, function (f) {
                    ood.tryF(f, args, ns);
                });
                ood.breakO(ns.$beforeDestroy, 2);
            }
            ood.tryF(ns.$ondestory, args, ns);
            if (ns.onDestroy) ns.boxing().onDestroy();
            if (ns.destroyTrigger) ns.destroyTrigger();

            //gc already
            if (!ns.serialId) return;
            if (t = ns._$composed)
                ood.each(t, function (v) {
                    v.__gc(ignoreEffects, purgeNow);
                });

            //clear cache things
            ns.clearCache();

            //for refresh function
            if (!ns.$noReclaim) {
                //restore dom id
                t = ood.$cache.reclaimId;
                (t[ns.key] || (t[ns.key] = [])).push(ns.serialId);
            } else delete ns.$noReclaim

            //clear cache point
            delete ood.$cache.profileMap[ns.domId];
            delete ood.$cache.profileMap[ns.$domId];

            // try to clear parent host
            var o;
            if (ns.alias && ns.host && (o = ns.host[ns.alias]) && (o = o._nodes) && (o.length === 0 || o.length === 1 && o[0] == ns)) {
                ns.host[ns.alias] = null;
                if (!(ns.host === window && ood.browser.ie && ood.browser.ver <= 8))
                    delete ns.host[ns.alias];
            }

            //clear anti link
            ns.unLinkAll();

            if (ns.LayoutTrigger)
                ns.LayoutTrigger.length = 0;
            if (ns.RenderTrigger)
                ns.RenderTrigger.length = 0;

            //gc children
            if ((t = ns.children).length) {
                t = ood.copy(t);
                for (var i = 0; i < t.length; i++) {
                    t[i][0].__gc(ignoreEffects, purgeNow);
                    t[i].length = 0;
                }
                t.length = 0;
            }

            //set once
            ns.destroyed = true;
            //afterDestroy
            if (ns.$afterDestroy) {
                ood.each(ns.$afterDestroy, function (f) {
                    ood.tryF(f, args, ns);
                });
                ood.breakO(ns.$afterDestroy, 2);
            }
            if (ns.afterDestroy) ns.boxing().afterDestroy(ns);
            ood.breakO([ns.properties, ns.events, ns.CF, ns.CB, ns.CC, ns.CA, ns.CS, ns], 2);
            //set again
            ns.destroyed = true;
        },
        linkParent: function (parentProfile, linkId, index) {
            var profile = this;
            //unlink first
            profile.unlinkParent();
            if (!profile.destroyed) {
                //link
                profile.parent = parentProfile;
                profile.childrenId = linkId;
                profile.link(parentProfile.children, '$parent', [profile, linkId], index);
            }
            return profile;
        },
        unlinkParent: function () {
            var profile = this;
            delete profile.parent;
            delete profile.childrenId;
            profile.unLink('$parent');
            return profile;
        },
        getRootNode: function () {
            return ood.getNodeData(this.renderId, 'element');
        },
        getRoot: function () {
            var ns = this;
            return ns.renderId ? (ns['*'] || (ns['*'] = ood([ns.renderId], false))) : ood([], false);
        },
        getAllNodes: function () {
            return this.getRoot().query().merge(this.getRoot());
        },
        getContainer: function (subId) {
            if (subId !== true && (subId = typeof subId == 'string' ? subId : null)) subId = this.getSubIdByItemId(subId);
            return this.box._CONTAINERKEY ? this.getSubNodes(this.box._CONTAINERKEY, subId) : this.keys.PANEL ? this.getSubNodes(this.keys.PANEL, subId) : this.getRoot();
        },
        // wrap these functions from ood.CSS
        getEmSize: function (force) {
            var prf = this,
                root = prf.getRoot(),
                node = root.get(0);
            // for special parent css
            return (!force && prf._nodeEmSize) || (node && (prf._nodeEmSize = root._getEmSize())) || ood.CSS._getDftEmSize();
        },
        adjustSize: function (useProp, asy, flag) {
            var prf = this,
                t = prf.getRootNode();
            if (t && (useProp || (t = t.style))) {
                var f = function () {
                    ood.UI.$tryResize(prf, useProp ? prf.properties.width : t.width, useProp ? prf.properties.height : t.height, true, flag);
                };
                if (asy) ood.asyRun(f);
                f();
            }
        },
        // have to call these after rendered
        $px: function (value, node, roundPx) {
            var ns = this;
            return ood.CSS.$px(value, node || function () {
                return ns.getEmSize()
            }, roundPx);
        },
        $em: function (value, node, roundPx) {
            var ns = this;
            return ood.CSS.$em(value, node || function () {
                return ns.getEmSize()
            }, roundPx);
        },
        $px2em: function (value, node, roundPx) {
            var ns = this;
            return ood.CSS.$px2em(value, node || function () {
                return ns.getEmSize()
            }, roundPx);
        },
        $em2px: function (value, node, roundPx) {
            var ns = this;
            return ood.CSS.$em2px(value, node || function () {
                return ns.getEmSize()
            }, roundPx);
        },
        $forceu: function (value, u, node, roundPx) {
            var ns = this;
            return ood.CSS.$forceu(value, u, node || function () {
                return ns.getEmSize()
            }, roundPx);
        },
        $addpx: function (a, b, node) {
            var ns = this;
            return ood.CSS.$addpx(a, b, node || function () {
                return ns.getEmSize()
            });
        },
        $isEm: function (value) {
            return ood.CSS.$isEm(value);
        },
        $isPx: function (value) {
            return ood.CSS.$isPx(value);
        },
        $picku: function (value) {
            return ood.CSS.$picku(value);
        },
        $addu: function (value) {
            return ood.CSS.$addu(value);
        },

        _cacheR1: /^\w[\w_-]*$/,
        setDomId: function (id) {
            var t = this, c = ood.$cache.profileMap;
            //ensure the value
            if (typeof id == 'string' && (t._cacheR1.test(id) || id == t.$domId) && !ood.Dom.byId(id)) {
                //delete the original one
                if (t.domId != t.$domId) delete c[t.domId];
                //set profile's domId
                t.domId = id;

                //change the dom Node id value
                if (t.renderId)
                    t.getRootNode().id = id;

                //if doesn't create yet, don't set it to ood.$cache:
                if (c[t.$domId]) c[id] = t;
            }
            return t;
        },
        getDomId: function () {
            return this.domId;
        },
        clearCache: function () {
            var ns = this,
                t = ns.$_egetter;
            for (var i in t) {
                t[i].length = 0;
                delete t[i];
            }

            t = ns.$_domid;
            for (var i in t) {
                t[i].__gc(true, true);
                delete t[i];
            }
            delete ns['*'];

            return ns;
        },
        //get events function from profile
        _getEV: function (funs, id, name) {
            var self = this,
                $k = id + "+" + name,
                g = self.$_egetter || (self.$_egetter = {}),
                cache;
            if (g[$k]) {
                Array.prototype.push.apply(funs, g[$k]);
                return;
            } else cache = g[$k] = [];

            var dom = ood.$cache.profileMap, t, key;
            //for event attached on dom node
            if ((t = dom[id]) && (t = t.events) && (t = t[name]))
                for (var i = 0, l = t.length; i < l; i++)
                    if (typeof t[t[i]] == 'function')
                        cache.push(funs[funs.length] = t[t[i]]);

            //for event attached on ood widgets
            //get event function path of cache
            key = id.split(":")[0].split("-")[1];

            //for priority intercept
            if (typeof (((t = self._CB) && (key ? (t = t[key]) : 1)) && (t = t[name])) == 'function')
                cache.push(funs[funs.length] = t);
            else {
                //get event function from customBehavior first
                if (typeof (((t = self.CB) && (key ? (t = t[key]) : 1)) && (t = t[name])) == 'function')
                    cache.push(funs[funs.length] = t);
                else {
                    //get event function from public behavior
                    if (typeof (((t = self.behavior) && (key ? (t = t[key]) : 1)) && (t = t[name])) == 'function')
                        cache.push(funs[funs.length] = t);
                }
            }
        },
        _cacheR2: /<!--\x03([^>^\s]*)\x04-->/g,
        toHtml: function (force) {
            var self = this,
                prop = self.properties,
                c = self.box,
                h = {},
                str,
                k1 = 'ood.UIProfile',
                k2 = 'ood.Module',
                id, i, l, o, m, a, b, data;
            if (self.destroyed) return "";

            // create first
            if (c['ood.svg']) {
                c._RenderSVG(self);
                return "";
            } else {
                //before _dynamicTemplate
                data = c._prepareData(self);
                if (c._dynamicTemplate) c._dynamicTemplate(self);
                str = c._build(self, data);

                if ((!prop.lazyAppend || force) && (m = self.children)) {
                    for (i = 0, l = m.length; i < l; i++) {
                        o = m[i];
                        if (o && o[0]) {
                            if (o[0][k2]) {
                                var mh = new ood.UI.MoudluePlaceHolder({
                                    host: o[0].host,
                                    alias: o[0].alias
                                });
                                mh.get(0)._module = o[0];
                                o[0] = mh.get(0);
                            }
                            if (o[0][k1]) {
                                id = o[1] || '';
                                a = h[id] || (h[id] = []);
                                a[a.length] = o[0].toHtml(force);
                            }
                        }
                    }
                }

                return str.replace(self._cacheR2, function (a, b) {
                    return h[b] ? h[b].join('') : '';
                });
            }
        },
        _buildItems: function (key, items, addEventHandler) {
            var ns = this,
                box = ns.box,
                str = box._rpt(ns, ood.UI.$doTemplate(ns, ood.get(ood.$cache.template, [box.KEY, ns._hash]), items, key)),
                nodes = ood.UI.$toDom(ns, str.replace(ns._cacheR2, ''), addEventHandler);
            if (ns.CA && !ood.isEmpty(ns.CA)) {
                ns.boxing().setCustomAttr(ns.CA, undefined, nodes);
            }
            // set custom styles for the given nodes only
            if (ns.CS && !ood.isEmpty(ns.CS)) {
                ns.boxing().setCustomStyle(ns.CS, undefined, nodes);
            }
            return nodes;
        },
        serialize: function (rtnString, keepHost, children) {
            var t, m, moduleHash = {},
                self = this,
                o = (t = self.box._beforeSerialized) ? t(self) : self,
                r = {
                    alias: o.alias,
                    key: o.key,
                    host: o.host
                },
                zz = o.moduleClass + "[" + o.moduleXid + "]";
            //host
            if (r.host === self) {
                delete r.host;
            } else if (o.host && !keepHost) {
                if (rtnString !== false)
                    r.host = '@this';
                else
                    delete r.host;
            }
            if (typeof o.theme == "string")
                r.theme = o.theme;

            //domId
            if (o.$domId != o.domId) r.domId = o.domId;

            //properties
            var c = {}, p = o.box.$DataStruct, map = ood.absObj.$specialChars;
            ood.merge(c, o.properties, function (o, i) {
                return (i in p) && p[i] !== o && !map[i.charAt(0)]
            });
            if (!ood.isEmpty(c)) r.properties = c;

            //events
            if (!ood.isEmpty(t = this.getEvents())) r.events = t;
            var eh = o.box.$EventHandlers;
            ood.filter(r.events, function (o, i) {
                return o != eh[i];
            });
            if (ood.isEmpty(r.events)) delete r.events;

            if (!ood.isEmpty(o.CB)) r.CB = ood.copy(o.CB);
            if (!ood.isEmpty(o.CC)) r.CC = ood.copy(o.CC);
            if (!ood.isEmpty(o.CF)) r.CF = ood.copy(o.CF);
            if (!ood.isEmpty(o.CS)) r.CS = ood.clone(o.CS, function (o, i) {
                return !((i + "").charAt(0) == "$" && !o)
            });
            if (!ood.isEmpty(o.CA)) r.CA = ood.copy(o.CA);
            if (typeof o.theme == "string") r.theme = o.theme;

            //children
            if (false !== children && o.children && o.children.length) {
                if (o.box.KEY != "ood.UI.SVGPaper") {
                    ood.arr.stableSort(o.children, function (x, y) {
                        x = (x[0].properties.tabindex || 0);
                        y = (y[0].properties.tabindex || 0);
                        return x > y ? 1 : x == y ? 0 : -1;
                    });
                }
                t = r.children = [];
                ood.arr.each(o.children, function (v, w, y, z) {
                    w = v[0];
                    if (w.moduleClass && w.moduleXid && (y = ood.SC.get(w.moduleClass)) && (y = y.getInstance(w.moduleXid)) && y["ood.Module"]) {
                        z = w.moduleClass + "[" + w.moduleXid + "]";
                        // same module with the parent
                        if (z !== zz) {
                            // same module with another sibling
                            if (moduleHash[z]) {
                                return;
                            } else {
                                moduleHash[z] = 1;
                                w = y;
                            }
                        }
                    }
                    m = [w.serialize(false, keepHost)];
                    if (v[1]) m[1] = v[1];
                    t[t.length] = m
                });
            }
            if (false !== children && o.exchildren && o.exchildren.length) {
                r.exchildren = o.exchildren;
            }
            moduleHash = null;
            return rtnString === false ? r : ood.serialize(r);
        },
        _applySetAction: function (fun, value, ovalue, force, tag, tag2) {
            if (this.renderId)
                return fun.call(this, value, ovalue, force, tag, tag2);
        },
        getKey: function (id, tagOnly) {
            var t;
            if (id.charAt(0) == '!') id = ood.use(id).id();
            if (id.indexOf(':') == -1) id = (t = ood.$cache.profileMap[id]) && (t.$domId);
            if (id) {
                id = id.split(":")[0];
                if (tagOnly) id = id.split('-')[1] || "KEY";
            }
            return id || "";
        },
        getSubId: function (id) {
            var t;
            if (id.charAt(0) == '!') id = ood.use(id).id();
            if (id.indexOf(':') == -1) id = (t = ood.$cache.profileMap[id]) && (t.$domId);
            return id ? id.split(":")[2] : "";
        },
        pickSubId: function (key) {
            var self = this, r, o = self.cache_subid || (self.cache_subid = {});
            if ((o[key] || (o[key] = []))[0]) return o[key].shift();
            o = self.subId || (self.subId = {});
            r = (o[key] || (o[key] = new ood.id)).next();
            return r;
        },
        reclaimSubId: function (id, key) {
            var o = this.cache_subid || (this.cache_subid = {});
            (o[key] || (o[key] = [])).push(id);
        },
        /*
        *('KEY','-hover',false);
        */
        _cacheR3: /\./g,
        _cacheH1: {},
        getClass: function (key, tag) {
            key = this.keys[key] || key;
            var self = this,
                hash = key + ":" + (tag || '');
            return self._cacheH1[hash] || (self._cacheH1[hash] = key.replace(self._cacheR3, '-').toLowerCase().replace('ood-ui', 'ood') + (tag || ''));
        },
        _getSubNodeId: function (key, subId, tag) {
            var arr = this.$domId.split(':');
            arr[0] = key;
            arr[2] = ood.isSet(subId) ? (subId + "") : '';
            if (tag) arr[2] += '_' + tag;
            key = arr.join(':');
            return key == this.$domId
                ? ood.$cache.profileMap[key].domId
                : key;
        },
        //flag : remove from cache
        getSubNode: function (key, subId, tag) {
            var ns = this;

            // destroyed already
            if (!ns.renderId) return ood();

            var key = ns.keys[key] || key, r,
                h = ns.$_domid || (ns.$_domid = {});

            // by key only
            if (subId === true) {
                //key==ns.keys.KEY for domId!=$domId
                if (key == ns.keys.KEY) r = ood([ns.renderId]);
                if (!r || !r.get(0)) {
                    r = ood([ns.renderId]).query('*', 'id', new RegExp('^' + key + ':' + ns.serialId + (tag ? ("_" + tag) : "")));
                }
            } else {
                if (!ood.isSet(subId) && h[key] && h[key]._nodes.length == 1) return h[key];
                r = ood(ns._getSubNodeId(key, subId, tag));
                if (r._nodes.length == 1 && !ood.isSet(subId)) h[key] = r;
            }
            return r;
        },
        getSubNodes: function (arr, subId, tag) {
            var ns = this, a = [], s1 = !ood.isArr(arr), s2 = !ood.isArr(subId), a, o, v, push = Array.prototype.push;
            if (subId === true || ood.isNull(subId)) {
                if (!s1) {
                    a = [];
                    for (var i = 0; o = arr[i++];) a.push(ns.keys[o] || o);
                    arr = '(' + a.join('|') + ')';
                }
                // get call once for better performance
                push.apply(a, ns.getSubNode(arr, true, tag).get());
            } else {
                if (s1) {
                    if (s2)
                        push.apply(a, ns.getSubNode(arr, subId, tag).get());
                    else
                        for (var j = 0; v = subId[j++];)
                            push.apply(a, ns.getSubNode(arr, v, tag).get());
                } else {
                    for (var i = 0; o = arr[i++];) {
                        if (s2)
                            push.apply(a, ns.getSubNode(o, subId, tag).get());
                        else
                            for (var j = 0; v = subId[j++];)
                                push.apply(a, ns.getSubNode(o, v, tag).get());
                    }
                }
            }
            return ood(a);
        },

        getSubNodeByItemId: function (key, itemId, tag) {
            return (itemId = this.getSubIdByItemId(itemId)) ? this.getSubNode(key, itemId, tag) : ood();
        },
        getItemByItemId: function (itemId) {
            var prf = this, t;
            if (ood.isNumb(itemId)) itemId = ood.get(prf.properties.items, [itemId, "id"]);
            if ((t = prf.ItemIdMapSubSerialId) && (t = t[itemId]))
                return prf.SubSerialIdMapItem[t];
            t = prf.queryItems(prf.properties.items, function (v, k) {
                return v.id == itemId;
            }, 1, 1);
            return t && t[0];
        },
        getItemByItemCaption: function (caption) {
            var prf = this, t;
            if (ood.isNumb(caption)) caption = ood.get(prf.properties.items, [caption, "caption"]);
            if ((t = prf.ItemIdMapSubSerialId) && (t = t[caption]))
                return prf.SubSerialIdMapItem[t];
            t = prf.queryItems(prf.properties.items, function (v, k) {
                return v.caption == caption;
            }, 1, 1);
            return t && t[0];
        },
        getSubIdByItemId: function (itemId) {
            var prf = this, t;
            if (ood.isNumb(itemId)) itemId = ood.get(prf.properties.items, [itemId, "id"]);
            return (t = this.ItemIdMapSubSerialId) && t[itemId];
        },

        getItemByDom: function (src) {
            return this.SubSerialIdMapItem && this.SubSerialIdMapItem[
                this.getSubId(typeof src == 'string'
                    ? src.charAt(0) == '!'
                        ? ((src = ood.use(src).get(0)) && src.id)
                        : src
                    : src.id)
                ];
        },
        getItemIdByDom: function (src) {
            var t;
            return (t = this.getItemByDom(src)) && t.id;
        },
        queryItems: function (items, fun, deep, single, flag) {
            var r = [],
                me = arguments.callee,
                f = me.f || (me.f = function (items, fun, deep, single, flag, r) {
                    ood.arr.each(items, function (o, i) {
                        if (fun === true || fun.call(null, o, i, items)) {
                            r.push(flag ? [o, i, items] : o);
                            if (single)
                                return false;
                        }
                        if (deep && o.sub && o.sub.length)
                            f(o.sub, fun, deep, single, flag, r);
                    });
                });
            f(items, fun, deep, single, flag, r);
            return r;
        }
    },
    Static: {
        getFromDom: function (id) {
            if (
                (id = (id && id.KEY == "ood.Dom") ? id.get(0).id
                        : typeof id == 'string' ? id.charAt(0) == '!'
                            ? ((id = ood.use(id).get(0)) && id.id)
                            : id
                            : (id && id.id)
                ) &&
                (id = ood.Event._getProfile(id)) && id['ood.UIProfile']
            )
                return id;
        }
    }
});

//UI Class
ood.Class("ood.UI", "ood.absObj", {
    Before: function (key, parent_key, o) {
        ood.absBox.$type[key.replace("ood.UI.", "").replace("ood.", "")] = ood.absBox.$type[key] = key;
        return true;
    },
    After: function () {
        var self = this, me = arguments.callee,
            temp, t, k, u, c, i, j, e, w, v, b, d;

        ood.absObj.After.apply(this, arguments);

        // remove datafield for containers
        if (self.Behaviors && self.Behaviors.PanelKeys && self.$DataModel && self.$DataModel.dataField) {
            delete self.$DataModel.dataField;
            delete self.$DataStruct.dataField;
            delete self.prototype.setDataField;
            delete self.prototype.getDataField;
        }

        self._ctrlId = new ood.id();
        self._idCache = [];
        self.$cssKeys = {};

        /*change keys*/
        t = self.$Keys;
        t.KEY = t.$key = self.KEY;
        self.addTemplateKeys(ood.toArr(t, true));

        //Inheriates Behaviors
        v = '$Behaviors';
        k = {};
        if ((t = self.$parent) && (e = t.length)) {
            while (e--) {
                b = t[e][v];
                for (i in b) {
                    if (typeof b[i] == 'object') {
                        if (ood.isArr(b[i])) {
                            u = k[i] || (k[i] = []);
                            u.push.apply(u, b[i]);
                        } else {
                            u = k[i] || (k[i] = {});
                            ood.merge(u, b[i]);
                        }
                    } else
                        k[i] = b[i];
                }
            }
        }
        self[v] = k;

        //Inheriates Templates
        v = '$Templates';
        k = {};
        if ((t = self.$parent) && (e = t[0]))
            for (i in e[v])
                if (i.charAt(0) != '$')
                    k[i] = e[v][i];
        self[v] = ood.clone(k);

        //Inheriates Appearances
        v = '$Appearances';
        k = {};
        if ((t = self.$parent) && (e = t.length))
            while (e--) {
                b = t[e];
                for (i in b[v]) {
                    t = b[v][i];
                    u = k[i] || (k[i] = {});
                    ood.merge(u, t);
                }
            }
        self[v] = k;

        self.setTemplate(self.Templates);
        delete self.Templates;

        self.setBehavior(self.Behaviors || {});
        delete self.Behaviors;

        self.setAppearance(self.Appearances);
        delete self.Appearances;

        if (t = self.PublicAppearance) {
            ood.UI.$cache_css_before += self.buildCSSText(t);
            delete self.PublicAppearance;
        }
    },
    Instance: {
        animate: function (key, callback) {
            // only for the first profile
            var prf = this.get(0), t,
                node = prf.getRootNode(),
                tid = ood.getNodeData(node, '_inthread'),
                reset = ood.getNodeData(node, '_animationreset'), t;
            if (tid && ood.Thread.isAlive(tid)) {
                ood.Thread.abort(tid, 'force');
                ood.setNodeData(node, '_inthread', null);
            }
            if (typeof reset == "function") {
                reset();
                ood.setNodeData(node, '_animationreset', null);
            }

            if (key && (t = ood.AnimBinder.getFromName(key === true ? "blinkAlert" : key))) {
                return t.apply(node, callback);
            } else {
                if (!key) key = "blinkAlert";
                var item = (ood.isHash(key) && key.endpoints) ? key : ood.Dom.$preDefinedAnims[key];
                if (item && item.endpoints) {
                    var onEnd;
                    if (ood.isFun(callback)) {
                        if (ood.isFun(item.onEnd)) {
                            onEnd = function () {
                                item.onEnd.apply(this, arguments);
                                callback.apply(this, arguments);
                            };
                        } else {
                            onEnd = callback;
                        }
                    } else if (ood.isFun(item.onEnd)) {
                        onEnd = item.onEnd;
                    }
                    return prf.getRoot().animate(item.endpoints, item.onStart, onEnd, item.duration || 200, null, item.type || "linear", null, item.unit, item.restore, item.times).start();
                }
            }
        },
        hoverPop: function (node, type, beforePop, beforeHide, parent, groupid) {
            var prf = this.get(0), source = prf.boxing(), popmenu;
            if (!prf.box.$EventHandlers.beforeHoverEffect) {
                source.getRoot().hoverPop(node, type, beforePop, beforeHide, parent, groupid);
                return this;
            }
            node = ood(node);
            popmenu = ood.UIProfile.getFromDom(node.id());
            if (popmenu && popmenu.key === 'ood.UI.PopMenu') {
                popmenu = popmenu.boxing();
            } else {
                popmenu = null;
            }
            if (!ood.isDefined(type)) type = 'outer';
            var aysid = groupid || (source.getRoot().xid() + ":" + node.xid());
            source.each(function (o) {
                o.$beforeHover = type === null ? null : function (prf, item, e, src, mtype) {
                    if (e.$force) return;
                    if (mtype == 'mouseover') {
                        ood.resetRun(aysid, null);
                        var ignore = ood.getData([aysid, '$ui.hover.pop'])
                            && ood.getNodeData(node.get(0) || "empty", '$ui.hover.parent') == src;
                        if (!ignore) {
                            ood.setData([aysid, '$ui.hover.pop'], {item: item});
                            ood.setNodeData(node.get(0) || "empty", '$ui.hover.parent', src);
                            if (!beforePop || false !== beforePop(prf, node, e, src, item)) {
                                if (popmenu) popmenu.pop(src, type, parent);
                                else node.popToTop(src, type, parent);
                                node.onMouseover(function () {
                                    ood(src).onMouseover(true)
                                }, 'hoverPop')
                                node.onMouseout(function () {
                                    ood(src).onMouseout(true)
                                }, 'hoverPop');
                            }
                        }
                    } else {
                        ood.resetRun(aysid, function () {
                            ood.setData([aysid, '$ui.hover.pop']);
                            ood.setNodeData(node.get(0) || "empty", '$ui.hover.parent', 0);
                            if (!beforeHide || false !== beforeHide(prf, node, e, src, 'host', item)) {
                                if (popmenu) popmenu.hide();
                                else node.hide();
                                node.onMouseover(null, 'hoverPop').onMouseout(null, 'hoverPop');
                            }
                        });
                    }
                };
            });
            if (node) {
                node.onMouseover(type === null ? null : function (e) {
                    if (e.$force) return;
                    if (!ood.getData([aysid, '$ui.hover.pop'])) return;
                    ood.resetRun(aysid, null);
                }, 'hoverPop');
                node.onMouseout(type === null ? null : function (prf, e, src) {
                    if (e.$force) return;
                    if (!ood.getData([aysid, '$ui.hover.pop'])) return;
                    ood.resetRun(aysid, function () {
                        ood.setData([aysid, '$ui.hover.pop'])
                        ood.setNodeData(node.get(0) || "empty", '$ui.hover.parent', 0);
                        var item = ood.getData([aysid, '$ui.hover.pop']);
                        if (!beforeHide || false !== beforeHide(prf, node, e, src, 'pop', item && item.item)) {
                            if (popmenu) popmenu.hide();
                            else node.hide();
                            node.onMouseover(null, 'hoverPop').onMouseout(null, 'hoverPop');
                        }
                    });
                }, 'hoverPop');
                node.css('display', 'none');
            }
            return this;
        },
        setTheme: function (key) {
            if (typeof key != "string" || !key) key = null;
            var k, arr = [];
            this.each(function (o) {
                if (key != o.theme) {
                    if (key === null)
                        delete o.theme;
                    else
                        o.theme = key;
                    arr.push(o);
                }
            });
            ood.UI.pack(arr, false).refresh();
            return this;
        },
        getTheme: function () {
            return this.get(0) && this.get(0).theme;
        },
        getModule: function (top) {
            var prf = this.get(0);
            if (prf) return prf.getModule(top);
        },
        destroy: function (ignoreEffects, purgeNow) {
            var ns = this;
            this.each(function (o, i) {
                if (o.destroyed) return;
                var fun = function () {
                    if (o.beforeDestroy && false === o.boxing().beforeDestroy(ignoreEffects, purgeNow)) return;

                    if (o.$beforeDestroy) {
                        ood.each(o.$beforeDestroy, function (f) {
                            ood.tryF(f, [ignoreEffects, purgeNow], o);
                        });
                        ood.breakO(o.$beforeDestroy, 2);
                    }

                    if (o.renderId) {
                        o.getRoot().remove(true, purgeNow);
                    }
                    else {
                        o.__gc(ignoreEffects, purgeNow);
                    }
                    ood.arr.removeFrom(ns._nodes, i);

                    if (o.$afterDestroy) {
                        ood.each(o.$afterDestroy, function (f) {
                            ood.tryF(f, [ignoreEffects, purgeNow], o);
                        });
                        ood.breakO(o.$afterDestroy, 2);
                    }
                };
                var p = o.properties,
                    a = ignoreEffects ? null : ood.Dom._getEffects(p.hideEffects, 0);
                if (a) ood.Dom._vAnimate(o.getRoot(), false, fun);
                else fun();
            }, null, true);
        },
        isDestroyed: function () {
            return !!(this.get(0) ? this.get(0).destroyed : 1);
        },
        _toDomElems: function () {
            var arr = [];
            //collect those need to be rendered
            ood.arr.each(this._nodes, function (o) {
                if (!o.renderId)
                    arr.push(o);
            });
            //render those
            if (arr.length)
                ood.UI.pack(arr, false).render();

            //get rendered
            arr.length = 0;
            ood.arr.each(this._nodes, function (o) {
                arr.push(o.renderId);
            });
            return arr;
        },

        _ini: function (properties, events, host, theme, CS, CC, CB, CF, CA) {
            var self = this,
                c = self.constructor,
                profile,
                t = 'default',
                options,
                df1 = ood.UI.__resetDftProp,
                df2 = c.__resetDftProp,
                df3 = c.$adjustProp,
                ds = c.$DataStruct,
                alias, temp;
            if (properties && properties['ood.Profile']) {
                profile = properties;
                alias = profile.alias || c.pickAlias();
                ood.UIProfile.apply(profile, [host, self.$key, alias, c, null, events]);
            } else {
                if (properties && properties.key && ood.absBox.$type[properties.key]) {
                    options = properties;
                    properties = null;
                    alias = options.alias || c.pickAlias();
                } else
                    alias = c.pickAlias();
                profile = new ood.UIProfile(host, self.$key, alias, c, properties, events, options);
            }

            for (var i in ds) {
                if (!(i in profile.properties)) {
                    temp = df2 && (i in df2) ? df2[i] : df1 && (i in df1) ? df1[i] : ds[i];
                    profile.properties[i] = typeof temp == 'object' ? ood.clone(temp, true) : temp;
                }
            }
            if (typeof(df3) == "function") df3(profile);

            profile.keys = c.$Keys;

            // custom
            profile.CS = CS ? ood.copy(CS) : (profile.CS || {});
            profile.CB = CB ? ood.copy(CB) : (profile.CB || {});
            profile.CC = CC ? ood.copy(CC) : (profile.CC || {});
            profile.CF = CF ? ood.copy(CF) : (profile.CF || {});
            profile.CA = CA ? ood.copy(CA) : (profile.CA || {});
            if (typeof theme == "string") profile.theme = theme;

            profile.template = c.getTemplate();
            profile.behavior = c.$Behaviors;

            if (!profile.serialId) profile.serialId = c._pickSerialId();

            profile.$domId = profile.key + ":" + profile.serialId + ":";
            profile.domId = profile.domId || profile.$domId;

            profile.RenderTrigger = ood.copy(c.$RenderTrigger);
            profile.LayoutTrigger = ood.copy(c.$LayoutTrigger);

            //set links
            profile.link(ood.UI._cache, 'UI').link(c._cache, 'self').link(ood._pool, 'ood');

            temp = profile.children;
            profile.children = [];
            if (temp && temp.length) {
                for (var i = 0, v; v = temp[i++];) {
                    //from serialize
                    if (!v[0]['ood.UIProfile']) v[0] = ood.create(v[0]).get(0);
                    if (v[0]['ood.UIProfile']) v[0].linkParent(profile, v[1]);
                    else if (v[0]['ood.Module'])
                        v[0].getUIComponents().each(function (p) {
                            p.linkParent(profile, v[1]);
                        });
                }
            }
            self._nodes.push(profile);
            profile.Instace = self;
            self.n0 = profile;
            if (c.$onInited) ood.tryF(c.$onInited, [], profile);
            return self;
        },
        busy: function (coverAll, html, key, subId, bgStyle) {
            html = typeof html == 'string' ? html : 'Loading...';
            // busy dom too
            if (coverAll === true) ood.Dom.busy();

            return this.each(function (profile) {
                ood.resetRun(profile.$xid + ':busy', function (profile, key, subId) {
                    // destroyed
                    if (!profile.box) return;

                    var keys = profile.keys, node;
                    key = keys[key] || keys['BORDER'] || keys['PANEL'] || keys['KEY'];
                    var parentNode = profile.getSubNode(key, subId);
                    if (parentNode.isEmpty())
                        return;

                    if (!profile.$busy || profile.$busy.isEmpty()) {
                        node = profile.$busy = ood.create('<button class="ood-node ood-node-div oodcon ood-icon-loading ood-cover ood-custom" style="position:absolute;text-align:center;left:0;top:0;z-index:10;border:0;padding:0;margin:0;width:100%;height:100%;"><div class="ood-node ood-node-div ood-coverlabel ood-custom"></div></button>');
                    }
                    node = profile.$busy;

                    node.first().html(html, false);

                    parentNode.append(node);

                    node.removeClass(/^ood-rand-css-/);
                    node.query('style').remove(false);
                    if (bgStyle) {
                        var clsName = "ood-rand-css-" + ood.rand();
                        node.addClass(clsName);
                        ood.CSS._appendSS(node.get(0), "." + clsName + ":before{" + bgStyle + "}", clsName, true);
                    }
                    var pn = parentNode.get(0);
                    node._parentOST = pn.scrollTop || 0;
                    node._parentOSL = pn.scrollLeft || 0;
                    node._parentOverflow = pn.style.overflow || '';
                    node._busyP = parentNode.xid();

                    pn.scrollTop = pn.scrollLeft = 0;
                    pn.style.overflow = 'hidden';

                }, 50, [profile, key, subId]);
            });
        },
        free: function () {
            ood.Dom.free();
            return this.each(function (profile) {
                ood.resetRun(profile.$xid + ':busy');
                if (node = profile.$busy) {
                    var pn = ood(node._busyP).get(0);
                    if (pn) {
                        pn.scrollTop = node._parentOST || 0;
                        pn.scrollLeft = node._parentOSL || 0;
                        pn.style.overflow = node._parentOverflow || '';
                    }
                    node._parentOST = node._parentOSL = node._parentOverflow = node._busyP = null;
                    node.remove();
                    delete profile.$busy;
                }
            });
        },
        adjustSize: function (useProp, asy, flag) {
            return this.each(function (prf) {
                prf.adjustSize(useProp, asy, flag);
            });
        },
        reLayout: function (force) {
            return this.each(function (o) {
                if (!o.renderId) return;

                // have to refresh this
                delete o._nodeEmSize;

                var p = o.properties;

                if ((!o.$noB) && p.border && o.boxing()._border)
                    o.boxing()._border(null, false);
                o.$forceRelayout = 1;
                if (p.position == 'absolute' && p.dock && p.dock != 'none') {
                    o.boxing().adjustDock(force);
                } else {
                    if (force) {
                        o._resize_h = o._resize_w = -1;
                    }
                    ood.UI.$tryResize(o, p.width, p.height, force);
                }
                delete o.$forceRelayout;
            });
        },
        toHtml: function (force) {
            var a = [];
            ood.arr.each(this._nodes, function (o) {
                a[a.length] = o.toHtml(force);
            });
            return a.join('');
        },
        render: function (triggerLayOut) {
            var ns = this, arr = [], i, l, o, n = ns._nodes, matrix, a = [], byId = ood.Dom.byId;

            ood.UI.$trytoApplyCSS();

            //get those no-html items
            for (i = 0; o = n[i++];)
                if (!o.renderId && !ood.Dom.byId(o.domId) && !ood.Dom.byId(o.$domId))
                    arr[arr.length] = o;

            //build html and to dom
            if (l = arr.length) {
                for (i = 0; i < l; i++)
                    if (o = arr[i].toHtml())
                        a[a.length] = o;
                if (a.length)
                    ood.UI.$toDom(ns.get(0)/*first represents all*/, a.join(''));
            }

            //render all UIProfiles
            for (i = 0; o = n[i++];)
                o._render(triggerLayOut);

            a.length = arr.length = 0;
            return ns;
        },
        renderOnto: function (node, host, alias) {
            node = ood(node);
            if (node.isEmpty()) return this;

            var self = this,
                pro = self.get(0),
                me = arguments.callee,
                paras = me.paras || (me.paras = function (node) {
                    var r = node.cssRegion();
                    r.tabindex = node.attr('tabIndex');
                    if (r.tabindex <= 0) delete r.tabindex;
                    r.zIndex = node.css('zIndex');
                    r.position = node.css('position');
                    return r;
                }),
                CS = node.attr('style').replace(/\s*(left|top|width|height|right|bottom|position|z-index)\s*\:\s*[\w-.]+\s*/g, ''),
                CC = node.attr('class'),
                id = node.id();

            ood.merge(pro.properties, paras(node), 'all');
            pro.properties.dock = 'none';

            if (CS) self.setCustomStyle('KEY', CS);
            if (CC) self.setCustomClass('KEY', CC);

            if (id) self.setDomId(id);
            if (alias || id) self.setHost(host || window, alias || id);

            self.render(true);
            node.replace(self.getRoot());

            return self;
        },
        setDomId: function (id) {
            this.get(0).setDomId(id);
            return this;
        },
        hide: function (ignoreEffects) {
            return this.each(function (o) {
                if (o.renderId) {
                    var t = o.properties, a = ignoreEffects ? null : ood.Dom._getEffects(t.hideEffects, 0);
                    o.getRoot().hide(function () {
                        t.top = t.left = Math.round(parseFloat(ood.Dom.HIDE_VALUE) || 0);
                        t.dockIgnore = true;
                    }, a);
                }
            });
        },
        popUp: function (pos, type, parent, trigger, group) {
            var prf = this.get(0), t = prf.getRoot();
            if (t = t.get(0)) {
                ood(t).pop(pos, type, parent, trigger, group);
            }
        },
        show: function (parent, subId, left, top, ignoreEffects) {
            return this.each(function (o) {
                var t = o.properties,
                    ins = o.boxing(),
                    b,
                    root = o.getRoot();
                left = (left || left === 0) ? (left || 0) : null;
                top = (top || top === 0) ? (top || 0) : null;
                if (left !== null) t.left = left;
                if (top !== null) t.top = top;
                if (ood.getNodeData(o.renderId, '_oodhide')) {
                    b = 1;
                    t.dockIgnore = false;
                    root.show(left && o.$forceu(left), top && o.$forceu(top), null, ignoreEffects);
                    if (t.position == 'absolute' && t.dock && t.dock != 'none')
                        ood.UI.$dock(o, false, true);
                    //first call show
                } else {
                    parent = parent || o.parent;
                    if (!parent && (!o.renderId || (o.getRootNode().id || "").indexOf(ood.Dom._emptyDivId) === 0))
                        parent = ood('body');
                }
                var p = parent, n;
                if (p) {
                    if (p['ood.UIProfile']) {
                        n = p.renderId;
                        p = p.boxing()
                    }
                    else if (p['ood.UI']) n = (n = p.get(0)) && n.renderId;
                    else n = (p = ood(p)) && p._nodes[0];
                    if (n) {
                        p.append(ins, subId);
//                        if(t.visibility=="hidden")ins.setVisibility("",true);
//                        if(t.display=="none")ins.setDisplay("",true);
                        if (!b) root.show(left && o.$forceu(left), top && o.$forceu(top));
                    }
                }
            });
        },
        clone: function () {
            return arguments.callee.upper.apply(this, ["domId"]);
        },
        refresh: function (remedy) {
            var paras, node, b, p, s, $xid, $inDesign, locked, serialId, renderConf, renderHolder, inlineConf,
                inlineHolder, mcls, mxid, ar, fun, box, children, uiv, save, special, ns = this;
            return ns.each(function (o, i) {
                if (!o.renderId) return;

                box = o.box;

                var host = o.host,
                    alias = o.alias;
                if (o.host && o.host['ood.Module']) {
                    o.host.$ignoreAutoDestroy = true;
                }
                //save related id
                $xid = o.$xid;
                $inDesign = o.$inDesign;
                locked = o.locked;

                serialId = o.serialId;
                mcls = o.moduleClass;
                mxid = o.moduleXid;
                renderConf = o._render_conf;
                renderHolder = o._render_holder;
                inlineConf = o._inline_conf;
                inlineHolder = o._inline_holder;
                ar = o.$afterRefresh;
                special = o.$handleCustomVars;
                if (special) save = special();

                if (typeof o.boxing().getUIValue == 'function') {
                    uiv = o.boxing().getUIValue();
                    if ((o.boxing().getValue() + " ") == (uiv + " "))
                        uiv = null;
                }

                //keep parent
                if (b = !!o.parent) {
                    p = o.parent.boxing();
                    paras = o.childrenId;
                } else
                    p = o.getRoot().parent();

                //protect children's dom node
                //no need to trigger layouttrigger here
                //for example: if use getGhostDiv, upload input cant show file name
                node = remedy ? ood.Dom.getEmptyDiv(o.$inDesign).get(0) : ood.$getGhostDiv();
                o.boxing().getChildren().reBoxing().each(function (v) {
                    node.appendChild(v);
                });
                node = null;

                //keep children
                children = ood.copy(o.children);
                o.boxing().removeChildren();

                //unserialize
                s = o.serialize(false, true);
                fun = o.$refreshTrigger;

                //replace
                var replace = ood.create('span');
                o.getRoot().replace(replace);

                //destroy it
                //avoid reclaiming serialId
                o.$noReclaim = 1;

                // keep cache refrence
                var _c = o.Instace;
                o.boxing().destroy(true, true);

                //set back
                ood.merge(o, s, 'all');
                // notice: remove destroyed here
                delete o.destroyed;
                o.$xid = $xid;
                o.$inDesign = $inDesign;
                o.locked = locked;
                o.$handleCustomVars = special;
                o.serialId = serialId;
                o.moduleClass = mcls;
                o.moduleXid = mxid;
                if (renderConf) o._render_conf = renderConf;
                if (renderHolder) o._render_holder = renderHolder;
                if (inlineConf) o._inline_conf = inlineConf;
                if (inlineHolder) o._inline_holder = inlineHolder;

                // set children link first
                if (children) o.children = children;
                //create
                var n = new box(o).render();

                // set cache refrence
                if (_c) {
                    ood.merge(_c, n, 'all');
                    n.get(0).Instace = _c;
                    // must reset it to keep memory pointer
                    n = _c;
                }
                ns[i] = n.get(0);

                //for functions like: UI refresh itself
                if (fun)
                    fun.call(fun.target, n.get(0));

                //add to parent, and trigger RenderTrigger
                if (b)
                    p.append(n, paras);
                else
                    p.append(n);

                if (host) n.setHost(host, alias);

                //restore children
                ood.arr.each(children, function (v) {
                    delete v[0].$dockParent;
                    n.append.apply(n, v);
                });

                //back to original position
                replace.replace(n.get(0).getRoot());
                replace.remove();
                replace = null;

                if (uiv)
                    n.setUIValue(uiv, true, null, 'refresh');

                if (ar) {
                    n.get(0).$afterRefresh = ar;
                    ar(n.get(0));
                }
                // call it anyway => another $afterRefresh
                if (special && save) o.$handleCustomVars(save);

                if (n.host && n.host['ood.Module']) {
                    delete n.host.$ignoreAutoDestroy;
                }
            });
        },
        append: function (target, subId, pre, base) {
            var pro = this.get(0), prop = pro.properties;
            // default is append to last
            var index, baseN,
                inParent = arguments[4],
                parentNode = arguments[5];
            // add to first, or previous of base
            pre = !!pre;
            if (base) {
                if (base['ood.UI']) {
                    base = base.get(0);
                }
                ood.arr.each(pro.children, function (o, i) {
                    if (o[0] === base) {
                        index = i;
                        return false;
                    }
                });
                if (ood.isNumb(index)) {
                    index = pre ? index : (index + 1);
                    baseN = base.getRoot();
                    if (baseN.isEmpty()) baseN = null;
                }
            } else {
                index = pre ? 0 : -1;
            }

            if (ood.isHash(target) || ood.isStr(target))
                target = ood.create(target);
            if (target['ood.UIProfile']) target = target.boxing();

            // illegal nesting
            /* for performance
            var detect = function(arr){
                ood.arr.each(arr, function(c){
                    if((c[0]||c)==pro)throw new Error('Illegal nesting!');
                    else detect(c.children);
                });
            };
            detect(target._nodes);
            */
            if (!pro.box) {
                return true;
            }
            if (pro.box._IllegalDetect)
                pro.box._IllegalDetect(pro, target, true);

            if (pro.box.$beforeAppend && false === pro.box.$beforeAppend(pro, target, subId, pre, base))
                return;
            if (pro.beforeAppend && false === this.beforeAppend(pro, target, subId, pre, base))
                return;
            if (!target) {
                return;
            }
            if (target['ood.Module']) {
                if (subId !== false) {
                    var i = index;
                    target.getUIComponents().each(function (profile) {
                        profile.linkParent(pro, subId, base ? (i++) : i);
                    });
                }
                if (pro.renderId) {
                    parentNode = inParent ? parentNode : pro.getContainer(subId);
                    if (parentNode && (!parentNode.isEmpty()) && (!prop.lazyAppend || parentNode.css('display') != 'none')) {
                        if (!base) {
                            parentNode[pre ? 'prepend' : 'append'](target);
                        } else if (baseN) {
                            baseN[pre ? 'addPrev' : 'addNext'](target);
                        }
                    }
                }
                else {
                    ood.arr.insertAny(pro.exmodules || (pro.exmodules = []), [target, subId], index, true);
                }
            } else {
                if (subId !== false) {
                    if (target['ood.UI']) {
                        var i = index;
                        target.each(function (profile) {
                            if (profile.linkParent) profile.linkParent(pro, subId, base ? (i++) : i);
                        });
                    }
                }
                if (pro.renderId) {
                    var oldp;
                    parentNode = inParent ? parentNode : pro.getContainer(subId);
                    if (parentNode && (!parentNode.isEmpty()) && (!prop.lazyAppend || parentNode.css('display') != 'none')) {
                        if (pro.parent && ood.get(pro, ["properties", "dock"]) != 'none' && 'absolute' == ood.get(pro, ["properties", "position"]) && !ood.get(pro, ["properties", "dockIgnore"]) && !ood.get(pro, ["properties", "dockFloat"])) {
                            if (target['ood.absBox'])
                                oldp = target.reBoxing().parent();
                        }
                        if (!base) {
                            parentNode[pre ? 'prepend' : 'append'](target);
                        } else if (baseN) {
                            baseN[pre ? 'addPrev' : 'addNext'](target);
                        }
                        //adjust old parent
                        if (oldp && oldp.get(0))
                            oldp.onSize();
                    }
                } else {
                    if (!target['ood.UI']) {
                        ood.arr.insertAny(pro.exchildren || (pro.exchildren = []), [target, subId], index, true);
                    }
                }
            }

            if (pro.box.$afterAppend)
                pro.box.$afterAppend(pro, target, subId, pre, base);
            if (pro.afterAppend)
                this.afterAppend(pro, target, subId, pre, base);
            return this;
        },
        getParent: function () {
            var prf = this.get(0);
            if (prf) return prf.parent && prf.parent.boxing();
        },
        getChildrenId: function () {
            var prf = this.get(0);
            if (prf) return prf.childrenId;
        },
        // type: [true]/penetrate, all even in sub moudles
        // type: [false]/include, with moudles
        // type: [other], ignore moudles
        getChildren: function (subId, type) {
            // return array only, don't recursive call in any module
            if (type === false || type == "include") {
                var prf = this.get(0),
                    moduleHash = {},
                    a = [], z,
                    moduleClass = prf.moduleClass,
                    moduleXid = prf.moduleXid,
                    getModlue = function (p) {
                        if (p.moduleClass && p.moduleXid) {
                            // exclude the container's module
                            if (p.moduleClass !== moduleClass && p.moduleXid !== moduleXid) {
                                // got it already
                                if (moduleHash[z = p.moduleClass + "'" + p.moduleXid + "]"]) {
                                    return null;
                                } else {
                                    moduleHash[z] = 1;
                                    var q = p.getModule();
                                    // module in module, we use the top mudule only( exclude the container's module )
                                    // look up toward top layer
                                    if (q && q.moduleClass && q.moduleXid && q.moduleClass !== moduleClass && q.moduleXid !== moduleXid) {
                                        return getModlue(q);
                                    } else if (q) {
                                        return q;
                                    }
                                }
                            }
                        }
                        return p;
                    },
                    f = function (p) {
                        ood.arr.each(p.children, function (v, t) {
                            t = getModlue(v[0]);
                            if (t) {
                                a.push(t);
                                if (t['ood.UIProfile'] && t.children && t.children.length)
                                    f(t);
                            }
                        });
                    };
                ood.arr.each(prf.children, function (v, t) {
                    if ((subId && typeof(subId) == "string") ? v[1] === subId : 1) {
                        t = getModlue(v[0]);
                        if (t) {
                            a.push(t);
                            if (t['ood.UIProfile'] && t.children && t.children.length)
                                f(t);
                        }
                    }
                });
                // return array only
                return a;
            } else {
                var a = [], f = function (prf) {
                    ood.arr.each(prf.children, function (v) {
                        a.push(v[0]);
                        if (v[0].children && v[0].children.length)
                            f(v[0]);
                    });
                };
                ood.arr.each(this.get(0).children, function (v) {
                    if ((subId && typeof(subId) == "string") ? v[1] === subId : 1) {
                        a.push(v[0]);
                        if ((type === true || type == "penetrate") && v[0].children && v[0].children.length)
                            f(v[0]);
                    }
                });
                return ood.UI.pack(a);
            }
        },
        /**
         * subId:
         *     "id1"
         *     ["id1","id2"]
         *     ["id1;id2"]
         *     [ood.UIProfile]
         *     [ood.UIProfile, [ood.UIProfile]
         *     [ood.UI]
         *     [ood.UI, [ood.UI]
         **/
        removeChildren: function (subId, bDestroy, purgeNow) {
            return this.each(function (o) {
                var c = ood.copy(o.children),
                    s = o.box.$DataModel.valueSeparator || ";",
                    b, arr;
                ood.arr.each(c, function (v) {
                    b = 0;
                    if (!subId || subId === true) {
                        b = 1;
                    } else {
                        if (ood.isStr(subId) || ood.isArr(subId)) {
                            arr = ood.isArr(subId) ? subId : (subId + "").split(s);
                            b = ood.arr.indexOf(arr, v[1]) != -1 || ood.arr.indexOf(arr, v[0]) != -1 || ood.arr.indexOf(arr, v[0].boxing()) != -1;
                        } else {
                            b = v[0] == subId["ood.UI"] ? subId.get(0) : subId;
                        }
                    }
                    if (b) {
                        if (o.beforeRemove && false === o.boxing().beforeRemove(o, v[0], v[1], bDestroy))
                            return;

                        v[0].unlinkParent();

                        if (o.afterRemove)
                            o.boxing().afterRemove(o, v[0], v[1], bDestroy);

                        if (bDestroy && !v[0].destroyed)
                            v[0].boxing().destroy(true, purgeNow);
                    }
                });
            });
        },
        draggable: function (dragKey, dragData, key, options, target) {
            return this.each(function (o) {
                o.getSubNode(o.keys[key] || 'KEY', true)
                    .removeClass('ood-ui-selectable').addClass('ood-ui-unselectable')
                    .beforeMousedown(dragKey ? function (pro, e, src) {
                        if (ood.Event.getBtn(e) != "left") return;
                        if (pro.properties.disabled) return;

                        var target = target ? typeof(target) == "function" ? ood.tryF(getTarget, [], o) : ood(target) : null;
                        if (!target || !target.get(0)) {
                            target = ood(src);
                        }

                        options = options || {};
                        options.dragKey = dragKey;
                        options.dragData = typeof dragData == 'function' ? dragData() : dragData;
                        ood.merge(options, {
                            dragCursor: 'pointer',
                            dragType: 'icon',
                            dragDefer: 2
                        });
                        target.startDrag(e, options);
                    } : null, '_d', -1)
                    .beforeDragbegin(dragKey ? function (profile, e, src) {
                        ood.use(src).onMouseout(true, {$force: true}).onMouseup(true);
                    } : null, '_d', -1);
                if (!dragKey)
                    o.clearCache();
            });
        },
        setCustomFunction: function (key, value) {
            return this.each(function (o) {
                if (typeof key == 'string') {
                    if (value) o.CF[key] = value;
                    else delete o.CF[key];
                } else
                    o.CF = key || {};
            });
        },
        setCustomClass: function (key, value) {
            var me = arguments.callee,
                fun = (me.fun || (me.fun = function (pro, i, h, flag) {
                    if (!h[i]) return;
                    var node = pro.getSubNode(i, true), b;
                    if (!node.isEmpty())
                        ood.arr.each(h[i].split(/\s+/), function (o) {
                            node[flag ? 'removeClass' : 'addClass'](o);
                        });
                }));
            return this.each(function (o) {
                var bak = ood.copy(o.CC), t;

                //set key and value
                if (typeof key == 'string') {
                    t = key;
                    key = ood.copy(o.CC);
                    key[t] = value;
                }
                ood.filter(key, function (o, i) {
                    if (!/^[A-Z][A-Z0-9]*$/.test(i)) {
                        t = key.KEY = key.KEY || {};
                        if (!(i in t)) t[i] = o;
                        return false;
                    }
                    if (!o) return false;
                });
                if (key && typeof key == 'object') {
                    if (o.renderId) {
                        for (var i in bak)
                            fun(o, i, bak, true);
                        for (var i in key)
                            fun(o, i, key);
                    }
                    o.CC = key;
                    //clear all
                } else {
                    if (o.renderId)
                        for (var i in bak)
                            fun(o, i, bak, true);
                    o.CC = {};
                }
                delete o._nodeEmSize;
            });
        },
        setCustomAttr: function (key, value, nodes) {
            var me = arguments.callee,
                fun = (me.fun || (me.fun = function (pro, key, CAObj, clear, nodes) {
                    if (!CAObj[key]) return;
                    var hkey = pro.keys[key] || key,
                        tnodes, b;
                    // get target nodes fromin given nodes
                    if (nodes) {
                        tnodes = nodes.query('*', 'id', hkey == pro.keys.KEY ? pro.domId : new RegExp('^' + hkey + ':' + pro.serialId));
                    }
                    // get target nodes from the whole widget
                    else {
                        tnodes = pro.getSubNode(key, true);
                    }
                    if (!tnodes.isEmpty()) {
                        if (ood.isHash(CAObj[key])) {
                            ood.each(CAObj[key], function (o, i) {
                                tnodes.attr(i, clear ? '' : (o && typeof o == "string") ? ood.adjustRes(o, 0, 1) : o);
                            });
                        }
                    }
                }));
            return this.each(function (o) {
                var bak = ood.copy(o.CA), t;
                if (typeof key == 'string') {
                    t = key;
                    key = ood.copy(o.CA);
                    key[t] = value;
                }
                ood.filter(key, function (o, i) {
                    if (!/^[A-Z][A-Z0-9]*$/.test(i)) {
                        t = key.KEY = key.KEY || {};
                        if (!(i in t)) t[i] = o;
                        return false;
                    }
                    if (!o) return false;
                });
                //set key and value
                if (!!key && typeof key == 'object') {
                    if (key) {
                        ood.filter(key, function (o, i) {
                            return i != 'id' && i != 'class' && i != 'style' && i != '$xid'
                        });
                    }
                    if (o.renderId) {
                        for (var i in key)
                            fun(o, i, bak, true, nodes);
                        for (var i in key)
                            fun(o, i, key, false, nodes);
                    }
                    o.CA = key;
                    //clear all
                } else {
                    if (o.renderId)
                        for (var i in bak)
                            fun(o, i, bak, true, nodes);
                    o.CA = {};
                }
            });
        },
        setCustomStyle: function (key, value, nodes) {
            var me = arguments.callee,
                fun = (me.fun || (me.fun = function (prf, key, CSObj, clear, nodes) {
                    if (!CSObj[key]) return;
                    var hkey = prf.keys[key] || key,
                        tnodes, b;
                    // get target nodes fromin given nodes
                    if (nodes) {
                        tnodes = nodes.query('*', 'id', hkey == prf.keys.KEY ? prf.domId : new RegExp('^' + hkey + ':' + prf.serialId));
                    }
                    // get target nodes from the whole widget
                    else {
                        tnodes = prf.getSubNode(key, true);
                    }
                    if (!tnodes.isEmpty()) {
                        if (ood.isStr(CSObj[key]))
                            ood.arr.each(CSObj[key].split(';'), function (o, i) {
                                if ((b = o.split(':')).length >= 2) {
                                    i = b.shift();
                                    o = b.join(':');
                                    i = i.replace(/\-(\w)/g, function (a, b) {
                                        return b.toUpperCase()
                                    });
                                    tnodes.css(i, (clear ? '' : (o && typeof o == "string") ? ood.adjustRes(o, 0, 1) : o) || "");
                                }
                            });
                        else if (ood.isHash(CSObj[key]))
                            ood.each(CSObj[key], function (v, i) {
                                if (ood.isStr(v)) {
                                    // "cursor":"point"
                                    if (i.indexOf('background') === 0 || v.indexOf(';') == -1) {
                                        tnodes.css(i, (clear ? '' : (v && typeof v == "string") ? ood.adjustRes(v, 0, 1) : v) || "");
                                    }
                                    // "overflow":"overflow-x:auto;overflow-y:hidden"
                                    else {
                                        ood.arr.each(v.split(';'), function (o) {
                                            if ((b = o.split(':')).length >= 2) {
                                                i = b.shift();
                                                o = b.join(':');
                                                i = i.replace(/\-(\w)/g, function (a, b) {
                                                    return b.toUpperCase()
                                                });
                                                tnodes.css(i, (clear ? '' : (o && typeof o == "string") ? ood.adjustRes(o, 0, 1) : o) || "");
                                            }
                                        });
                                    }
                                } else {
                                    i = i.replace(/\-(\w)/g, function (a, b) {
                                        return b.toUpperCase()
                                    });
                                    tnodes.css(i, (clear ? '' : (v && typeof v == "string") ? ood.adjustRes(v, 0, 1) : v) || "");
                                }
                            });
                    }
                }));
            return this.each(function (o) {
                var bak = ood.copy(o.CS), t;

                if (typeof key == 'string') {
                    t = key;
                    key = ood.copy(o.CS);
                    key[t] = value;
                }
                ood.filter(key, function (o, i) {
                    if (!/^[A-Z][A-Z0-9]*$/.test(i)) {
                        t = key.KEY = key.KEY || {};
                        if (!(i in t)) t[i] = o;
                        return false;
                    }
                    if (!o) return false;
                });
                //set hash dir
                if (!!key && typeof key == 'object') {
                    if (o.renderId) {
                        for (var i in bak)
                            fun(o, i, bak, true, nodes);
                        for (var i in key)
                            fun(o, i, key, false, nodes);
                    }
                    o.CS = key;
                    //clear all
                } else {
                    if (o.renderId)
                        for (var i in bak)
                            fun(o, i, bak, true, nodes);
                    o.CS = {};
                }
                delete o._nodeEmSize;
            });
        },
        setCustomBehavior: function (key, value) {
            return this.each(function (o) {
                if (typeof key == 'string') {
                    if (o.keys[key])
                        o.CB[key] = value || {};
                } else
                    o.CB = key || {};
                if (o.CB.KEY) {
                    ood.merge(o.CB, o.CB.KEY, 'all');
                    delete o.CB.KEY;
                }
                o.clearCache();
            });
        },
        adjustDock: function (force) {
            return this.each(function (o) {
                if (!o.renderId) return;
                var prop = o.properties;
                if (prop.conDockRelative || prop.conLayoutColumns) {
                    o.boxing().adjustSize();
                }
                // adjust self
                if (prop.position == 'absolute') {
                    if ('dock' in prop && prop.dock && prop.dock != 'none' && o.renderId) {
                        var n = o.getRootNode();
                        // ensure display
                        if (n && n.clientHeight) {
                            if (force) {
                                var style = n.style;
                                // ensure force 1
                                style.width = ((parseFloat(o.$px(style.width)) || 0) + 1) + 'px';
                                style.height = ((parseFloat(o.$px(style.height)) || 0) + 1) + 'px';
                                // ensure force
                                o._resize_h = o._resize_w = -1;
                            }
                            ood.UI.$dock(o, true, true);
                        }
                    }
                } else {
                    if (ood.get(o, ['parent', 'properties', 'conDockRelative']) || ood.get(o, ['parent', 'properties', 'conLayoutColumns'])) {
                        //ood.resetRun('conLayoutColumns:'+o.parent.$xid, function(){
                        //    if(!o.destroyed && !o.parent.destroyed)
                        ood.UI._adjustConW(o.parent, o.getRoot().parent(), o);
                        //});
                    }
                }
                // adjust children
                if (o.$onDock) {
                    var n = o.boxing().getContainer(true);
                    if (n && n.onSize && n.get(0)) n.onSize();
                }
            });
        }
    },
    Initialize: function () {
        var ns = this.prototype;
        ood.arr.each('getSubNode,getSubNodes,getDomId,getRootNode,getRoot,getContainer'.split(','), function (o) {
            if (!ns[o]) {
                ns[o] = function () {
                    var p = this.get(0);
                    return p ? p[o].apply(p, arguments) : null;
                };
                ns[o].$original$ = 'ood.UI';
                ns[o].$type$ = 'instance';
                ns[o].$name$ = o;
            }
        });

        var self = this, hash = {};
        ood.each(ood.UI.$ps, function (i, o) {
            hash[o] = {
                $spaceunit: 1,
                ini: 'auto',
                action: function (value) {
                    var self = this,
                        p = self.properties, b = false,
                        args;
                    self.getRoot()[o] ? self.getRoot()[o](value) : ood.Dom._setUnitStyle(self.getRootNode(), o, value);
                    if (o == 'width' || o == 'height') {
                        // for no _onresize widget only
                        if (!self.box._onresize && self.onResize)
                            self.boxing().onResize(self, o == 'width' ? value : null, o == 'height' ? value : null)
                    } else {
                        if (self.onMove)
                            self.boxing().onMove(self, o == 'left' ? value : null, o == 'top' ? value : null, o == 'right' ? value : null, o == 'bottom' ? value : null)
                    }

                    if (p.position == 'absolute' && p.dock != 'none') {
                        args = {
                            $type: p.dock,
                            $dockid: ood.arr.indexOf(['width', 'height', 'fill', 'cover'], p.dock) != -1 ? self.$xid : null
                        };
                        switch (p.dock) {
                            case 'middle':
                                if (o != 'height' && o != 'top') return;
                                args.top = args.height = 1;
                                break;
                            case 'center':
                                if (o != 'width' && o != 'left') return;
                                args.left = args.width = 1;
                                break;
                            case 'top':
                                if (o != 'height' && o != 'top') return;
                                args.width = args.height = 1;
                                break;
                            case 'bottom':
                                if (o != 'height' && o != 'bottom') return;
                                args.width = args.height = 1;
                                break;
                            case 'left':
                                if (o != 'width' && o != 'left') return;
                                args.width = args.height = 1;
                                break;
                            case 'right':
                                if (o != 'width' && o != 'right') return;
                                args.width = args.height = 1;
                                break;
                            case 'width':
                                if ('width' == o) return;
                                args.width = 1;
                                break;
                            case 'height':
                                if ('height' == o) return;
                                args.height = 1;
                                break;
                            case 'fill':
                            case 'cover':
                                if (o == 'width' && o == 'height') return;
                                args.width = args.height = 1;
                                break;
                        }
                        var pp = ood.UIProfile.getFromDom(self.$dockParent);
                        if (pp) pp.boxing().adjustDock(true);
                    }
                }
            }
        });
        ood.merge(hash, {
            renderer: {
                ini: null
            },
            //invalid after dom dom Node
            zIndex: {
                ini: 1,
                action: function (value) {
                    this.getRoot().css('zIndex', value);
                }
            },
            tabindex: {
                ini: 1,
                action: function (value) {
                    var ns = this,
                        reg = new RegExp("^" + ns.key + "[-\\w]*" + ":" + ns.serialId + ":");
                    ns.getRoot().query("*", function (n) {
                        return n.id && reg.test(n.id) && n.getAttribute('tabIndex');
                    }).attr('tabIndex', value);
                }
            },
            position: {
                ini: 'absolute',
                listbox: ['', 'static', 'relative', 'absolute'],
                action: function (value) {
                    var prf = this, prop = prf.properties;
                    prf.getRoot().css('position', value);
                    if (('dock' in prf.box.$DataModel) && prop.dock != 'none' && !prop.dockIgnore) {
                        value = prop.dock;
                        prop.dock = 'none';
                        prf.boxing().adjustDock(true);
                        prop.dock = value;
                    }
                }
            },
            visibility: {
                listbox: ['', 'visible', 'hidden'],
                action: function (value) {
                    if (this.box['ood.svg']) this.boxing().getAllNodes().css('visibility', value);
                    else this.getRoot().css('visibility', value);
                    // special for resizer
                    if (this.$resizer) {
                        if (value == 'hidden')
                            this.$resizer.hide();
                        else
                            this.$resizer.show();
                    }

                    ood.setNodeData(this.getRootNode(), '_setVisibility', 1);
                }
            },
            display: {
                listbox: ['', 'none', 'block', 'inline', 'inline-block'],
                action: function (value) {
                    var n = this.box['ood.svg'] ? this.boxing().getAllNodes() : this.getRoot();
                    if (value == 'inline-block')
                        n.setInlineBlock();
                    else
                        n.css('display', value);
                }
            },
            selectable: {
                ini: false,
                action: function (value) {
                    this.getRoot().setSelectable(!!value);
                }
            }
        });

        self.setDataModel(hash);

        ood.UI.$cache_css_before += ood.UI.buildCSSText({
                '.ood-css-viewport': {
                    '-webkit-text-size-adjust': '100%',
                    '-ms-text-size-adjust': '100%',
                    '-ms-overflow-style': 'scrollbar',
                    '-webkit-tap-highlight-color': 'transparent',
                    'font-size': '75%'
                },
                '.ood-css-viewport, .ood-css-viewport body': {
                    height: '100%',
                    border: '0 none',
                    margin: '0',
                    padding: '0'
                },
                '.ood-css-viewport body': {
                    'font-size': '1rem'
                },
                '@-ms-viewport': {
                    width: 'device-width'
                },
                '.ood-ui-draggable': {},
                '.ood-inline-block': {
                    display: ood.$inlineBlock,
                    zoom: ood.browser.ie ? 1 : null
                },
                ".ood-ui-input": {},
                '.ood-ui-shadow-input': {
                    '-moz-box-shadow': 'inset 2px 2px 2px #EEEEEE',
                    '-webkit-box-shadow': 'inset 2px 2px 2px #EEEEEE',
                    'box-shadow': 'inset 2px 2px 2px #EEEEEE'
                },
                '.ood-ui-shadow': {
                    '-moz-box-shadow': '2px 2px 4px #CCC',
                    '-webkit-box-shadow': '2px 2px 4px #CCC',
                    'box-shadow': '2px 2px 4px #CCC',
                    /* For IE 8 */
                    '-ms-filter': (ood.browser.ie && ood.browser.ver == 8) ? "progid:DXImageTransform.Microsoft.Shadow(Strength=4, Direction=135, Color='#9f9f9f')" : null,
                    /* For IE 5.5 - 7 */
                    'filter': (ood.browser.ie && ood.browser.ver <= 8) ? "progid:DXImageTransform.Microsoft.Shadow(Strength=4, Direction=135, Color='#9f9f9f')" : null
                },
                '.ood-ui-shadow-r': {
                    '-moz-box-shadow': '1px 0  1px #CCC',
                    '-webkit-box-shadow': '1px 0  1px #CCC',
                    'box-shadow': '1px 0  1px #CCC',
                    'z-index': 10
                },
                '.ood-ui-shadow-b': {
                    '-moz-box-shadow': '0 1px 1px #CCC',
                    '-webkit-box-shadow': '0 1px 1px #CCC',
                    'box-shadow': '0 1px 1px #CCC',
                    'z-index': 10
                },
                '.ood-ui-image': {
                    'vertical-align': 'middle',
                    width: '1.3333333333333333em',
                    height: '1.3333333333333333em',
                    'background-repeat': 'no-repeat'
                },
                '.ood-uicmd-none, .ood-display-none': {
                    display: 'none'
                },
                ".ood-uitembg": {
                    padding: '.25em .5em',
                    'background-color': 'transparent'
                    //  border: 'solid 1px transparent'
                },
                ".ood-uitembg-hover": {
                    $order: 1,

                },
                ".ood-uitembg-active": {
                    $order: 2,


                },
                ".ood-uitembg-checked": {
                    $order: 3,

                },

                ".ood-uicell": {},
                ".ood-uicell-hover": {
                    $order: 1,

                },
                ".ood-uicell-checked": {
                    $order: 2,

                },
                ".ood-uicell-alt": {
                    $order: 3,

                },
                '.ood-special-icon': {},
                '.ood-uibar-top, .ood-uibar-bottom, .ood-uibar-top-s, .ood-uibar-bottom-s': {
                    position: 'relative',
                    //for avoiding extra space after table in IE
                    'vertical-align': 'baseline'
                },
                '.ood-uibar-top td, .ood-uibar-top-s td, .ood-uibar-bottom td, .ood-uibar-bottom-s td': {},
//uibar-top
                '.ood-uibar-top': {
                    height:'2em'
                },
                '.ood-uibar-top .ood-uibar-tdl': {
                    $order: 1,
                    position: 'absolute',
                    width: '12px',
                    left: 0,
                    top: 0,
                    height: '100%'
                },
                '.ood-uibar-top .ood-uibar-tdm': {
                    $order: 1,
                    position: 'absolute',
                    top: 0,
                    left: '12px',
                    right: '12px',
                    height: '100%',
                    width: ood.browser.ie && ood.browser.ver <= 7 ? "expression((this.parentNode.offsetWidth - 24)+'px')" : null
                },
                '.ood-uibar-top .ood-uibar-tdr': {
                    $order: 1,
                    position: 'absolute',
                    width: '12px',
                    top: 0,
                    right: 0,
                    height: '100%'
                },
                '.ood-uibar-top .ood-uibar-tdlt': {
                    $order: 1,
                    position: 'absolute',
                    width: '12px',
                    left: 0,
                    top: 0,
                    height: '1.5em'
                },
                '.ood-uibar-top .ood-uibar-tdmt': {
                    $order: 1,
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    right: 0,
                    height: '1.5em',
                    width: ood.browser.ie && ood.browser.ver <= 7 ? "expression((this.parentNode.offsetWidth)+'px')" : null
                },
                '.ood-uibar-top .ood-uibar-tdrt': {
                    $order: 1,
                    position: 'absolute',
                    width: '12px',
                    right: 0,
                    top: 0,
                    height: '1.5em'
                },
                '.ood-uibar-focus, .ood-uibar-top-focus .ood-uibar-tdl, .ood-uibar-top-focus .ood-uibar-tdm, .ood-uibar-top-focus .ood-uibar-tdr': {},
                '.ood-uibar-top-focus .oodfont, .ood-uibar-top-focus .oodcon, .ood-uibar-top-focus .ood-uicaption': {},
                '.ood-uibar-top .ood-uibar-cmdl': {
                    overflow: 'hidden',
                    position: 'relative',
                    'padding': '.125em .75em .125em',
                    'white-space': 'nowrap'
                },
                '.ood-uibar-top2 .ood-uibar-cmdr': {
                    position: 'absolute',
                    top: '-.334em',
                    right: '0',
                    'text-align': 'right'
                },
                '.ood-uibar-top .ood-uibar-cmdr': {
                    position: 'absolute',
                    top: '.5em',
                    right: '.5em',
                    'text-align': 'right'
                },
                '.ood-uibar-top .ood-uibar-tdb': {
                    position: 'relative',
                    display: 'none',
                    margin: '.16667em .16667em 0 .16667em'
                },
                '.ood-uicon-main': {
                    position: 'relative',
                    'padding-left': '.3333em',
                    'z-index': 1,
                    overflow: 'visible'
                },
                '.ood-uicon-maini': {
                    'padding-right': '.3333em'
                },
//uibar-bottom
                '.ood-uibar-bottom': {
                    'padding': '3px 0'
                },
                '.ood-uibar-bottom .ood-uibar-tdl': {
                    $order: 1,
                    position: 'absolute',
                    width: '12px',
                    left: 0,
                    bottom: 0,
                    height: '100%'
                },
                '.ood-uibar-bottom .ood-uibar-tdm': {
                    $order: 1,
                    position: 'absolute',
                    bottom: 0,
                    left: '12px',
                    right: '12px',
                    height: '100%',
                    width: ood.browser.ie && ood.browser.ver <= 7 ? "expression((this.parentNode.offsetWidth - 24)+'px')" : null
                },
                '.ood-uibar-bottom .ood-uibar-tdr': {
                    $order: 1,
                    position: 'absolute',
                    width: '12px',
                    right: 0,
                    bottom: 0,
                    height: '100%'
                },
//uibar-top-s
                '.ood-uibar-top-s, .ood-uibar-bottom-s, .ood-uibar-top-s .ood-uibar-t': {
                    $order: 3,
                    height: '5px'
                },
                '.ood-uibar-top-s .ood-uibar-tdl': {
                    $order: 3,
                    position: 'absolute',
                    width: '12px',
                    left: 0,
                    top: 0,
                    height: '100%'
                },
                '.ood-uibar-top-s .ood-uibar-tdm': {
                    $order: 3,
                    position: 'absolute',
                    top: 0,
                    left: '12px',
                    right: '12px',
                    height: '100%',
                    width: ood.browser.ie && ood.browser.ver <= 7 ? "expression((this.parentNode.offsetWidth - 24)+'px')" : null
                },
                '.ood-uibar-top-s .ood-uibar-tdr': {
                    $order: 3,
                    position: 'absolute',
                    width: '12px',
                    top: 0,
                    right: 0,
                    height: '100%'
                },
                '.ood-uibar-top-s .ood-uibar-cmdl': {
                    $order: 3,
                    display: 'none'
                },
                '.ood-uibar-top-s .ood-uibar-cmdr': {
                    $order: 3,
                    display: 'none'
                },
//uibar-bottom-s
                '.ood-uibar-bottom-s .ood-uibar-tdl': {
                    $order: 3,
                    position: 'absolute',
                    width: '12px',
                    left: 0,
                    bottom: 0,
                    height: '100%'
                },
                '.ood-uibar-bottom-s .ood-uibar-tdm': {
                    $order: 3,
                    position: 'absolute',
                    bottom: 0,
                    left: '12px',
                    right: '12px',
                    height: '100%',
                    width: ood.browser.ie && ood.browser.ver <= 7 ? "expression((this.parentNode.offsetWidth - 24)+'px')" : null
                },
                '.ood-uibar-bottom-s .ood-uibar-tdr': {
                    $order: 3,
                    position: 'absolute',
                    width: '12px',
                    right: 0,
                    bottom: 0,
                    height: '100%'
                }
            })
            + ood.UI.buildCSSText({
                '.ood-ui-unselectable': {
                    $order: 0,
                    '-moz-user-select': ood.browser.gek ? '-moz-none' : null,
                    '-khtml-user-select': ood.browser.kde ? 'none' : null,
                    '-webkit-user-select': ood.browser.kde ? 'none' : null,
                    '-o-user-select': ood.browser.opr ? 'none' : null,
                    '-ms-user-select': (ood.browser.ie || ood.browser.newie) ? 'none' : null,
                    'user-select': 'none',
                    'touch-action': 'none'
                },
                '.ood-ui-selectable': {
                    $order: 1,
                    '-moz-user-select': ood.browser.gek ? 'text' : null,
                    '-khtml-user-select': ood.browser.kde ? 'text' : null,
                    '-webkit-user-select': ood.browser.kde ? 'text' : null,
                    '-o-user-select': ood.browser.opr ? 'text' : null,
                    '-ms-user-select': (ood.browser.ie || ood.browser.newie) ? 'text' : null,
                    'user-select': 'text',
                    'touch-action': 'auto'
                },
                '.ood-uiw-shell': {
//                background:'transparent',
                    display: ood.$inlineBlock,
                    zoom: ood.browser.ie && ood.browser.ver <= 7 ? 1 : null,
                    //overflow:'hidden',
                    /*opera must be 0 not 'none'*/
                    border: 0,
                    padding: 0,
                    margin: 0
                },
                /*span*/
                '.ood-uiw-frame': {
                    $order: 1,
                    display: 'block',
                    position: 'relative',
                    //overflow:'hidden',
                    border: 0,
                    padding: 0,
                    margin: 0,
                    width: '100%',
                    height: '100%',
                    '-moz-box-flex': '1'
                },
                /*span*/
                '.ood-uiw-border': {
                    $order: 2,
                    display: 'block',
                    //position:'absolute',
                    // modify to relative for 'auto' height
                    position: 'relative',
                    border: 0,
                    padding: 0,
                    margin: 0,
                    left: 0,
                    top: 0,
                    width: '100%',
                    height: '100%'
                }
            })
            + ood.UI.buildCSSText({
                '.ood-uibase': {},
                '.ood-uicontainer': {},
                '.ood-uibar': {
                    $order: 1
                },
                '.ood-uibar-hover': {
                    $order: 1
                },
                ".ood-uibar-active, .ood-uibar-checked, .ood-uibar-expand, .ood-uimenu-hover, .ood-uimenu-active": {
                    $order: 2
                },
                ".ood-ui-ctrl-highlight, .ood-node-highlight, .ood-uibar-checked,  .ood-uibar-expand, .ood-uimenu-hover, .ood-uimenu-active": {
                    $order: 3,

                },
                ".ood-ui-btn::-moz-focus-inner": {
                    $order: 3,
                    padding: "0 !important",
                    border: "0 none !important"
                },
                ".ood-uigradient": {
                    $order: 4
                },
                ".ood-uigradient-hover, .ood-uigradient:hover": {
                    $order: 5
                },
                ".ood-uigradient-active, .ood-uigradient-checked, .ood-uigradient-expand, .ood-uigradient:active, .ood-uigradient-active:hover, .ood-uigradient-checked:hover, .ood-uigradient-expand:hover": {
                    $order: 6
                },
                ".ood-ui-btn": {
                    $order: 7,
                    padding: ".334em",
                    'white-space': 'normal',
                    cursor: 'pointer',

                    display: ood.$inlineBlock,
                    'text-align': 'center',
                    'line-height': '1',
                    zoom: ood.browser.ie ? 1 : null,
                    // for IE6
                    'width_1': (ood.browser.ie && ood.browser.ver <= 7) ? 'auto' : null,
                    'overflow': (ood.browser.ie && ood.browser.ver <= 7) ? 'visible' : null
                },
                ".ood-ui-btn:hover, .ood-ui-btn-hover": {
                    $order: 8,

                },
                '.ood-uiborder-l': {
                    'border-left-style': 'solid',
                    'border-left-width': '1px',

                },
                '.ood-uiborder-r': {
                    'border-right-style': 'solid',
                    'border-right-width': '1px',

                },
                '.ood-uiborder-t': {
                    'border-top-style': 'solid',
                    'border-top-width': '1px',

                },
                '.ood-uiborder-b, .ood-uitem-split': {
                    'border-bottom-style': 'solid',
                    'border-bottom-width': '1px',

                },
                '.ood-uiborder-nob': {
                    $order: 1,
                    'border-bottom-width': 0,
                    'border-bottom-style': 'none'
                },
                '.ood-uiborder-hidden': {
                    border: 'solid 1px transparent',
                    background: 'none'
                },
                '.ood-uiborder-hidden-active, .ood-uiborder-hidden-checked': {},
                '.ood-uiborder-flat': {},
                '.ood-uiborder-outset': {
                    $order: 8,
                    border: 'solid 1px',

                },
                // '.ood-uiborder-inset, .ood-uiborder-hidden-active, .ood-uiborder-hidden-checked': {
                //     $order: 10,
                //     border: 'solid 1px',
                //     'border-color': '#B6B6B6 #F6F6F6 #F6F6F6 #B6B6B6'
                // },
                '.ood-uiborder-dark, .ood-uiborder-flat-hover': {},
                '.ood-uiborder-light, .ood-uiborder-hidden-hover': {},
                '.ood-uiborder-radius': {
                    $order: 11,
                    //  'border-radius': '3px',
                    '-moz-border-radius': '3px',
                    //  '-webkit-border-radius': '3px',
                    '-o-border-radius': '3px',
                    '-ms-border-radius': '3px',
                    '-khtml-border-radius': '3px'
                },
                '.ood-uiborder-radius-big': {
                    $order: 11,
                    //   'border-radius': '6px',
                    '-moz-border-radius': '6px',
                    //      '-webkit-border-radius': '6px',
                    '-o-border-radius': '6px',
                    '-ms-border-radius': '6px',
                    '-khtml-border-radius': '6px'
                },
                '.ood-uiborder-radius-tl': {
                    $order: 12,
                    //    'border-top-left-radius': '3px',
                    '-moz-border-top-left-radius': '3px',
                    //     '-webkit-border-top-left-radius': '3px',
                    '-o-border-top-left-radius': '3px',
                    '-ms-border-top-left-radius': '3px',
                    '-khtml-border-top-left-radius': '3px'
                },
                '.ood-uiborder-radius-tr': {
                    $order: 12,
                    //   'border-top-right-radius': '3px',
                    '-moz-border-top-right-radius': '3px',
                    //    '-webkit-border-top-right-radius': '3px',
                    '-o-border-top-right-radius': '3px',
                    '-ms-border-top-right-radius': '3px',
                    '-khtml-border-top-right-radius': '3px'
                },
                '.ood-uiborder-radius-br': {
                    $order: 12,
                    //     'border-bottom-right-radius': '3px',
                    '-moz-border-bottom-right--radius': '3px',
                    // '-webkit-border-bottom-right--radius': '3px',
                    '-o-border-bottom-right--radius': '3px',
                    '-ms-border-bottom-right--radius': '3px',
                    '-khtml-border-bottom-right--radius': '3px'
                },
                '.ood-uiborder-radius-bl': {
                    $order: 12,
                    //    'border-bottom-left-radius': '3px',
                    '-moz-border-bottom-left-radius': '3px',
                    //    '-webkit-border-bottom-left-radius': '3px',
                    '-o-border-bottom-left-radius': '3px',
                    '-ms-border-bottom-left-radius': '3px',
                    '-khtml-border-bottom-left-radius': '3px'
                },
                '.ood-uiborder-radius-big-tl': {
                    $order: 13,
                    //   'border-top-left-radius': '6px',
                    '-moz-border-top-left-radius': '6px',
                    //'-webkit-border-top-left-radius': '6px',
                    '-o-border-top-left-radius': '6px',
                    '-ms-border-top-left-radius': '6px',
                    '-khtml-border-top-left-radius': '6px'
                },
                '.ood-uiborder-radius-big-tr': {
                    $order: 13,
                    //  'border-top-right-radius': '6px',
                    '-moz-border-top-right-radius': '6px',
                    // '-webkit-border-top-right-radius': '6px',
                    '-o-border-top-right-radius': '6px',
                    '-ms-border-top-right-radius': '6px',
                    '-khtml-border-top-right-radius': '6px'
                },
                '.ood-uiborder-radius-big-br': {
                    $order: 13,
                    //   'border-bottom-right-radius': '6px',
                    '-moz-border-bottom-right--radius': '6px',
                    // '-webkit-border-bottom-right--radius': '6px',
                    '-o-border-bottom-right--radius': '6px',
                    '-ms-border-bottom-right--radius': '6px',
                    '-khtml-border-bottom-right--radius': '6px'
                },
                '.ood-uiborder-radius-big-bl': {
                    $order: 13,
                    //  'border-bottom-left-radius': '6px',
                    '-moz-border-bottom-left-radius': '6px',
                    //   '-webkit-border-bottom-left-radius': '6px',
                    '-o-border-bottom-left-radius': '6px',
                    '-ms-border-bottom-left-radius': '6px',
                    '-khtml-border-bottom-left-radius': '6px'
                },

                '.ood-uiborder-noradius': {
                    $order: 15,
                    'border-radius': '0 !important',
                    '-moz-border-radius': '0 !important',
                    '-webkit-border-radius': '0 !important',
                    '-o-border-radius': '0 !important',
                    '-ms-border-radius': '0 !important',
                    '-khtml-border-radius': '0 !important'
                },
                '.ood-uiborder-noradius-l': {
                    $order: 15,
                    'border-top-left-radius': '0 !important',
                    '-moz-border-top-left-radius': '0 !important',
                    '-webkit-border-top-left-radius': '0 !important',
                    '-o-border-top-left-radius': '0 !important',
                    '-ms-border-top-left-radius': '0 !important',
                    '-khtml-border-top-left-radius': '0 !important',

                    'border-bottom-left-radius': '0 !important',
                    '-moz-border-bottom-left-radius': '0 !important',
                    '-webkit-border-bottom-left-radius': '0 !important',
                    '-o-border-bottom-left-radius': '0 !important',
                    '-ms-border-bottom-left-radius': '0 !important',
                    '-khtml-border-bottom-left-radius': '0 !important'
                },
                '.ood-uiborder-noradius-r': {
                    $order: 15,
                    'border-top-right-radius': '0 !important',
                    '-moz-border-top-right-radius': '0 !important',
                    '-webkit-border-top-right-radius': '0 !important',
                    '-o-border-top-right-radius': '0 !important',
                    '-ms-border-top-right-radius': '0 !important',
                    '-khtml-border-top-right-radius': '0 !important',

                    'border-bottom-right-radius': '0 !important',
                    '-moz-border-bottom-right-radius': '0 !important',
                    '-webkit-border-bottom-right-radius': '0 !important',
                    '-o-border-bottom-right-radius': '0 !important',
                    '-ms-border-bottom-right-radius': '0 !important',
                    '-khtml-border-bottom-right-radius': '0 !important'
                },
                '.ood-uiborder-noradius-t': {
                    $order: 15,
                    'border-top-left-radius': '0 !important',
                    '-moz-border-top-left-radius': '0 !important',
                    '-webkit-border-top-left-radius': '0 !important',
                    '-o-border-top-left-radius': '0 !important',
                    '-ms-border-top-left-radius': '0 !important',
                    '-khtml-border-top-left-radius': '0 !important',

                    'border-top-right-radius': '0 !important',
                    '-moz-border-top-right-radius': '0 !important',
                    '-webkit-border-top-right-radius': '0 !important',
                    '-o-border-top-right-radius': '0 !important',
                    '-ms-border-top-right-radius': '0 !important',
                    '-khtml-border-top-right-radius': '0 !important'
                },
                '.ood-uiborder-noradius-b': {
                    $order: 15,
                    'border-bottom-left-radius': '0 !important',
                    '-moz-border-bottom-left-radius': '0 !important',
                    '-webkit-border-bottom-left-radius': '0 !important',
                    '-o-border-bottom-left-radius': '0 !important',
                    '-ms-border-bottom-left-radius': '0 !important',
                    '-khtml-border-bottom-left-radius': '0 !important',

                    'border-bottom-right-radius': '0 !important',
                    '-moz-border-bottom-right-radius': '0 !important',
                    '-webkit-border-bottom-right-radius': '0 !important',
                    '-o-border-bottom-right-radius': '0 !important',
                    '-ms-border-bottom-right-radius': '0 !important',
                    '-khtml-border-bottom-right-radius': '0 !important'
                },
                '.ood-ui-noshadow, .ood-ui-noshadow .ood-ui-shadow-input, .ood-ui-noshadow .ood-ui-shadow, .ood-ui-noshadow .ood-ui-shadow-b, .ood-ui-noshadow .ood-ui-shadow-r,  .ood-ui-disabled .ood-ui-shadow-input,  .ood-ui-readonly .ood-ui-shadow-input,  .ood-ui-inputreadonly .ood-ui-shadow-input': {
                    $order: 15,
                    '-moz-box-shadow': 'none !important',
                    '-webkit-box-shadow': 'none !important',
                    'box-shadow': 'none !important'
                },
                '.ood-uiborder-circle': {
                    $order: 16,
                    'border-radius': '50%',
                    '-moz-border-radius': '50%',
                    // '-webkit-border-radius': '50%',
                    '-o-border-radius': '50%',
                    '-ms-border-radius': '50%',
                    '-khtml-border-radius': '50%'
                },
                '.ood-uiflag-1': {
                    $order: 16,
                    'border-radius': '50%',
                    '-moz-border-radius': '50%',
                    //  '-webkit-border-radius': '50%',
                    '-o-border-radius': '50%',
                    '-ms-border-radius': '50%',
                    '-khtml-border-radius': '50%',

                    width: ood.browser.contentBox ? '1em' : '1.625em',
                    height: ood.browser.contentBox ? '1em' : '1.625em',
                    padding: '.334em',
                    'background-color': '#eb6e1a',
                    color: '#fff !important',
                    overflow: 'hidden',
                    'text-align': 'center'
                },

                '.ood-uiborder-none': {
                    $order: 20,
                    border: 'none'
                },
                '.ood-uisb': {
                    position: 'absolute'
                },
                '.ood-uisb-none': {
                    display: 'none'
                },
                '.ood-uisb-left': {
                    left: 0,
                    top: 0,
                    width: '3em',
                    height: '100%'
                },
                '.ood-uisb-right': {
                    top: 0,
                    right: 0,
                    width: '3em',
                    height: '100%'
                },
                '.ood-uisb-top': {
                    left: 0,
                    top: 0,
                    width: '100%',
                    height: '3em'
                },
                '.ood-uisb-bottom': {
                    left: 0,
                    bottom: 0,
                    width: '100%',
                    height: '3em'
                },
                '.ood-uisbbtn': {
                    position: 'absolute',
                    cursor: 'pointer',
                    'z-index': 1,
                    width: '1em',
                    height: '1em'
                },
                '.ood-uisb-left .ood-uisbbtn': {
                    left: 0,
                    top: 0
                },
                '.ood-uisb-right .ood-uisbbtn': {
                    right: 0,
                    top: 0
                },
                '.ood-uisb-top .ood-uisbbtn': {
                    right: 0,
                    bottom: 0
                },
                '.ood-uisb-bottom .ood-uisbbtn': {
                    right: 0,
                    top: 0
                },
                '.ood-uisbcap': {
                    position: 'relative',
                    'text-align': 'center',
                    width: '100%',
                    height: '100%'
                },
                '.ood-uisb-left .ood-uisbcap, .ood-uisb-right .ood-uisbcap': {
                    'writing-mode': 'tb-rl',
                    filter: 'flipv fliph'
                },
                '.ood-ltag-cmds': {
                    margin: 0,
                    padding: 0,
                    'vertical-align': 'middle'
                },
                '.ood-rtag-cmds': {
                    margin: 0,
                    padding: 0,
                    'vertical-align': 'middle'
                },
                '.ood-tag-cmd': {
                    "margin": '0 .125em',
                    "padding": '.1667em',
                    'vertical-align': 'middle'
                },
                '.ood-inline-object': {
                    'vertical-align': 'middle',
                    'margin': '0 .16666667em'
                }
            });

        ood.UI.$cache_css_after += ood.UI.buildCSSText({
            '.ood-css-innerimage': {
                'vertical-align': 'middle'
            },
            '.ood-uitem-split': {
                display: 'block',
                position: 'relative',
                overflow: 'visible',
                'white-space': 'nowrap',
                margin: '2px 0',
                padding: 0
            },
            '.ood-css-noscroll, .ood-css-noscroll body': {
                overflow: 'hidden',
                'overflow-x': 'hidden',
                'overflow-y': 'hidden'
            },
            '.ood-css-noscrollx, .ood-css-noscroll body': {
                'overflow-x': 'hidden'
            },
            '.ood-css-noscrolly, .ood-css-noscroll body': {
                'overflow-y': 'hidden'
            },
            '.ood-css-dockparent': {
                overflow: 'hidden'
            },
            '.ood-ui-dirty': {
                $order: 1,
                'background-image': 'url(data:image/gif;base64,R0lGODlhBwAHAPcAAAAAADDSEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAP8ALAAAAAAHAAcAAAgYAAMIHPhvoMB/BQkiVLgwAMKHDh9KnBgQADs=)',
                'background-repeat': 'no-repeat',
                'background-position': 'left top'
            },
            '.ood-float-clear': {
                'clear': 'both'
            },
            '.ood-float-left': {
                'float': 'left'
            },
            '.ood-float-right': {
                'float': 'right'
            },
            /*
            ".ood-ui-diry:after":{
                content: "";
                position: 'absolute',
                top: 0,
                left: 0,
                width: 0,
                height: '1px',
                'z-index':100,
                'border-top': '8px solid #f44',
                'border-right': '8px solid transparent'
            },*/
            '.ood-ui-ellipsis': {
                "max-width": "100%",
                "text-overflow": "ellipsis",
                "white-space": "nowrap",
                "overflow": "hidden"
            },
            '.ood-ui-ruler': {
                width: 0,
                height: '1.22em',
                'vertical-align': 'middle'
            },
            '.ood-nodatauri .ood-ui-dirty': {
                $order: 2,
                'background-image': ood.UI.$oldBg('dirtymark.gif', 'no-repeat left top')
            },
            // Firefox will ignore input:read-only
            '.ood-ui-ctrl-readonly, .ood-node-readonly, input[readonly], textarea[readonly], input:read-only, textarea:read-only, .ood-ui-readonly, .ood-ui-itemreadonly, .ood-ui-readonly .ood-node, .ood-ui-itemreadonly .ood-node, ood-ui-inputreadonly input, ood-ui-inputreadonly textarea': {
                $order: 2,
                color: 'var( --text-input-readonly)'
            },
            'button::-moz-focus-inner, input::-moz-focus-inner': {
                padding: 0,
                border: 0
            },
            '.ood-ui-ctrl-disabled, .ood-node-disabled, button:disabled, a:disabled, input:disabled, textarea:disabled,  .ood-ui-disabled,  .ood-ui-itemdisabled,  .ood-ui-disabled .ood-node, .ood-ui-itemdisabled .ood-node, .ood-uicell-disabled, .ood-uicell-disabled .ood-node': {
                $order: 2,
                cursor: 'not-allowed',
                color: '#808080 '
            },
            '.ood-ui-ctrl-disabled, .ood-node-disabled, button:disabled, a:disabled, input:disabled, textarea:disabled,  .ood-ui-disabled input,.ood-ui-disabled textarea, .ood-ui-itemdisabled input, .ood-ui-itemdisabled textarea, .ood-uicell-disabled': {
                $order: 3,
                'background-color': '#eee '
            },
            '.ood-ui-invalid, .ood-ui-invalid .ood-node': {
                $order: 1,
                'background-color': '#FFEBCD !important'
            },
            '.ood-item-row': {
                display: "block",
                'white-space': 'nowrap'
            },
            '.ood-item-cell': {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie ? 1 : null,
                'white-space': 'normal'
            },
            ".ood-required": {
                "color": "#ff0000 !important"
            },
            '.ood-alert': {
                'background-color': '#ff6600 !important'
            },
            ".ood-uisyle-mobile": {
                "background-clip": "padding-box",
                border: "10px solid #333333",
                "border-radius": "12px",
                "box-shadow": "0 0 15px rgba(0, 0, 0, 0.28), 0 1px 1px rgba(255, 255, 255, 0.45) inset, 0 0 2px rgba(255, 255, 255, 0.2) inset"
            },
            ".ood-uisyle-mobile, .ood-uisyle-mobile *, .ood-cursor-touch, .ood-cursor-touch *": {
                cursor: 'url(' + ood.ini.img_touchcur + ') 8 8,auto!important'
            },
            '.ood-icon-loading': {
                $order: 7,
                width: (ood.browser.ie && ood.browser.ver <= 8) ? '1em' : null,
                height: (ood.browser.ie && ood.browser.ver <= 8) ? '1em' : null,
                'background-image': (ood.browser.ie && ood.browser.ver < 10) ? 'url(' + ood.ini.img_busy + ')' : null,
                "background-repeat": (ood.browser.ie && ood.browser.ver < 10) ? "no-repeat" : null,
                "background-position": (ood.browser.ie && ood.browser.ver < 10) ? "center center" : null
            },
            ".ood-icon-loading:before": {
                $order: 7,
                visibility: (ood.browser.ie && ood.browser.ver < 10) ? 'hidden' : null
            },
            ".ood-load-error": {
                width: (ood.browser.ie && ood.browser.ver <= 8) ? '1em' : null,
                height: (ood.browser.ie && ood.browser.ver <= 8) ? '1em' : null,
                "background-image": (ood.browser.ie && ood.browser.ver <= 8) ? "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAAJdnBBZwAAABAAAAAQAFzGrcMAAADdSURBVCjPfdGxTsJQGIbhpw20GgN1IZQBDQnGxvu/FEU3IjEBB5SKUsGkdTiCYeGb/pw803uixum1iMJ1KZdp40dpYQWNqBERuXItRY1YrPJspmm0wNAYlZkvdPR1jTVmtJAZgUhliaWFQs9IqYwxkKhUUnf64NuTD6kBMTK8mKgkigNZaGQBJGqfVh6PyFotCWC/NxMbiUL+/xhjJ9Y5kEriVk9HbBdAKZI7A+8ebLQVhigDmNvqKg7k3kZbamceOpSmbvSkXq1xIfSfKh2lPlf/pWa7Tx3A6c86vV+v4FNOkQDWwAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMC0wMi0xMVQxMTo1MDowOC0wNjowMNYQZfsAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMDYtMDUtMDVUMTM6MjI6NDAtMDU6MDC/5P4aAAAAAElFTkSuQmCC)" : null,
                "background-repeat": (ood.browser.ie && ood.browser.ver <= 8) ? "no-repeat" : null,
                "background-position": (ood.browser.ie && ood.browser.ver <= 8) ? "center center" : null
            },
            ".ood-load-error:before": {
                $order: 7,
                visibility: (ood.browser.ie && ood.browser.ver <= 8) ? 'hidden' : null
            },
            ".ood-ui-clear": {
                $order: 10,
                border: 'none',
                background: 'none'
            }
        });
    },
    $End: function () {
        var hash = {}, keys = this.$Keys;
        ood.filter(this.getAppearance(), function (o, i) {
            var arr1 = i.split(/\s*,\s*/), arr2;
            for (var l = arr1.length - 1; l >= 0; l--) {
                arr2 = arr1[l].match(/[A-Z][A-Z0-9]*/g);
                if (arr2 && arr2.length) {
                    for (var j = 0, m = arr2.length; j < m; j++) {
                        if (!keys[arr2[j]]) {
                            arr1.splice(l, 1);
                            break;
                        }
                    }
                }
            }
            if (arr1.length) hash[arr1.join(", ")] = o;
        });
        this.setAppearance(hash);
        ood.UI.$cache_css_before += this.buildCSSText(this.$Appearances);
    },
    Static: {
        $cache_css_before: '',
        $cache_css_after: '',
        $css_tag_dirty: "ood-ui-dirty",
        $css_tag_invalid: "ood-ui-invalid",
        $tag_left: "{",
        $tag_right: "}",
        $tag_subId: "_serialId",
        $tag_subId_c: "_serialId_c",

        $x01: /\x01/img,
        $x01r: / \x01 /img,

        $tag_special: '\x01',
        $ID: "\x01id\x01",
        $DOMID: '\x01domid\x01',
        $CLS: "\x01cls\x01",
        $MODULECLS: "\x01modulecls\x01",
        $TAGCLASS: "\x01tagcls\x01",
        $childTag: "<!--\x03{id}\x04-->",

        $ps: {left: 1, top: 1, width: 1, height: 1, right: 1, bottom: 1},
        objectProp: {},
        $toDom: function (profile, str, addEventHandler) {
            if (addEventHandler === false)
                return ood.str.toDom(str);

            //must use empty div for RenderTriggers
            var matrix = ood.Dom.getEmptyDiv(profile.$inDesign).get(0), r = [], style = matrix.style;
            // for control size
            style.position = 'relative';
            style.display = 'none';
            matrix.innerHTML = str;
            //add event handlers
            this.$addEventsHandler(profile, matrix);
            for (var i = 0, t = matrix.childNodes, l = t.length; i < l; i++) {
                //ensure the root nodes
                ood.$registerNode(t[i]);
                r[r.length] = t[i].$xid;
            }
            style.display = '';
            matrix = null;
            return ood(r, false);
        },
        $evtsindesign: {
            "onload": 1,
            "onerror": 1,
            "onscroll": 1,
            "onunload": 1,
            "onsize": 1,
            "onmousedown": 1,
            "onmouseup": 1
        },
        _handleEventConf: function (conf, args) {
            var ns = this;
        },
        $addEventsHandler: function (profile, node, includeSelf) {
            var ch = ood.$cache.UIKeyMapEvents,
                event = ood.Event,
                eh = event._eventHandler,
                hash = this.$evtsindesign,
                handler = event.$eventhandler,
                children = ood.toArr(node.getElementsByTagName('*')),
                i, l, j, k, id, t, v;

            if (includeSelf)
                children.push(node);
            if (l = children.length) {
                for (i = 0; i < l; i++) {
                    if ((node = children[i]).nodeType != 1) continue;
                    if (id = node.id) {
                        if (t = ch[id] || ch[id.substr(0, id.indexOf(':'))]) {
                            v = ood.$registerNode(node);
                            v = v.eHandlers || (v.eHandlers = {});
                            for (j in t) {
                                if (profile.$inDesign && !hash[j]) continue;
                                //attach event handler to domPurgeData
                                v[j] = t[j];
                                //attach event handler to dom node
                                if (k = eh[j]) {
                                    v[k] = t[j];
                                    event._addEventListener(node, k, t[j]);
                                    if (ood.browser.isTouch && k == 'onmousedown') {
                                        v['onoodtouchdown'] = handler;
                                        event._addEventListener(node, "oodtouchdown", handler);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            children.length = 0;
            node = t = null;
        },
        setDftProp: function (prop) {
            this.__resetDftProp = prop;
            return this;
        },
        getFromDom: function (id) {
            if (id = ood.UIProfile.getFromDom(id))
                return id.boxing();
        },
        _ensureValues: function (arr) {
            var a = [], i = 0, k = 0, o, key = this.KEY, cache = ood.$cache.profileMap, getData = ood.getNodeData;
            if (arr['ood.absBox']) arr = arr._nodes;
            for (; o = arr[i++];)
                if ((o.box && o.box[key]) || ((o = cache[getData(o.renderId ? o.renderId : o, ['element', 'id'])]) && o.box && o.box[key]))
                    a[k++] = o;
            return a.length <= 1 ? a : this._unique(a);
        },

        __gc: function () {
            var self = this, k = self.$key, cache = ood.$cache;
            //clear templates memory in ood.$cache
            ood.breakO([cache.template[k], cache.reclaimId[k], self._cache, self._idCache, self.$DataModel, self.$Templates, self.$Behaviors, self], 2);
            delete ood.absBox.$type[k.replace("ood.UI.", "")];
            delete ood.absBox.$type[k];
            ood.filter(ood.$cache.UIKeyMapEvents, function (o, i) {
                return !(i == k || i.indexOf(k + '-') == 0);
            });
            // add for base class
            ood.Class.__gc(k);
        },
        _pickSerialId: function () {
            //get id from cache or id
            var arr = ood.$cache.reclaimId[this.$key];
            if (arr && arr[0]) return arr.pop();
            return this._ctrlId.next();
        },
        $oldBg: function (path, paras, forceKey, root) {
            return function (key) {
                //ood.asyRun(function(){new Image().src=p;});
                return 'url(' + ood.ini.path + 'appearance/_oldbrowser/' + path + ') ' + (paras || '');
            }
        },
        $ieOldBg: function (path) {
            return function (key) {
                //ood.asyRun(function(){new Image().src=p;});
                return 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src="' + ood.ini.path + 'appearance/_oldbrowser/' + path + '",sizingMethod="crop")';
            }
        },
        /* deep template function
           template: string
           properties: hash

           $doTemplate("{a}{b}{c}{a}{b}{/c}", {a:'*',b:'#',c:[{a:'1',b:'.'},{a:'2',b:'.'},{a:'3',b:'.'},{a:'4',b:'.'}]})
               will return "*#1.2.3.4."
           doTemplate("{a}{b}{c}{}{/c}", {a:'*',b:'#',c:['1','2','3','4']})
               will return "*#1234"

           flag: default flase => no clear not mactched symbols
         */
        $doTemplate: function (profile, template, properties, tplTag, result, index, realTag) {
            var self = ood.UI.$doTemplate,
                s, t, n,
                x01 = ood.UI.$x01,
                x01r = ' \x01 ',
                str = '',
                isA = ood.isArr(properties),
                // this one maybe a fake tamplate tag, for switch function
                temp = template[tplTag || ''],
                r = !result,
                result = result || [];
            // get the real tag
            tplTag = realTag || tplTag;
            if (isA) {
                if (typeof temp != 'function') temp = self;
                for (var i = 0; t = properties[i++];) {
                    if (false === temp(profile, template, t, tplTag, result, i)) {
                        break;
                    }
                }
            } else {
                if (t = properties['object']) {
                    //[properties] is for ood.Template
                    result[result.length] = t.toHtml();
                } else {
                    if (typeof temp == 'function') {
                        t = temp(profile, template, properties, tplTag, result);
                        if (t) tplTag = t;
                    } else {
                        tplTag = tplTag ? tplTag + '.' : '';
                        var a0 = temp[0], a1 = temp[1];
                        for (var i = 0, l = a0.length; i < l; i++) {
                            if (n = a1[i]) {
                                if (n in properties) {
                                    t = properties[n];
                                    if (n.substr(0, 4) == "_fi_") {
                                        // for ie67 fonticon text
                                        if (ood.__iefix2 && (a0[i - 1] == "_the_next_is_fonticon_" || n == "_fi_")) {
                                            t = ood.str.trim(t).split(/\s+/).pop();
                                            t = (t in ood.__iefix2) ? ood.__iefix2[t] : str;
                                        } else if (n == "_fi_") {
                                            t = str;
                                        }
                                    }
                                    //if sub template exists
                                    if (template[s = tplTag + n] && t)
                                        self(profile, template, t, s, result);
                                    else
                                        result[result.length] = (t === undefined || t === null || t === NaN) ? str : typeof t == 'string' ? t.replace(x01, x01r) : t;
                                }
                            } else
                                result[result.length] = (a0[i] === undefined || a0[i] === null || a0[i] === NaN) ? str : a0[i];
                        }
                    }
                }
            }
            if (r) return result.join('');
        },
        /*
        set properties default map and set properties handler
        It's a merge function, not replace

        this.$DataStruct: {a:,b:,c}
        this.$DataModel: from hash, for example:
        hash:{
            key1:{
                ini:xx,
                set:fun..,
                get:fun..,
                action: fun
            },
            key2:null,
            key3:'abc
        }
        */
        $buildTemplate: function (profile, template, key, obj, arr) {
            if (template && (template.tagName + "").toLowerCase() == 'text') {
                arr[arr.length] = template.text;
                return;
            }
            var self = arguments.callee,
                behavior = profile.behavior ? key ? profile.behavior[key] : profile.behavior : null,
                prop = profile.properties,
                map1 = self.map1 || (self.map1 = {tagName: 1, text: 1}),
                map2 = self.map2 || (self.map2 = {image: 1, input: 1, br: 1, meta: 1, hr: 1, abbr: 1, embed: 1}),
                map3 = self.map3 || (self.map3 = {input: 1, textarea: 1, pre: 1, code: 1}),
                r2 = self.r2 || (self.r2 = /[a-z]/),
                r3 = self.r3 || (self.r3 = /^(on|before|after)/),
                r7 = self.r7 || (self.r7 = /([^{}]*)\{([\w]+)\}([^{}]*)/g),
                first = false,
                u = ood.UI,
                ts = u.$tag_special,
                t, o, bak, tagN, cls1, lkey;

            if (!template) template = profile.template;
            lkey = key ? profile.keys[key] : profile.key;

            //tagName
            if (!template.tagName) template.tagName = "span";

            if (template.id !== null) {
                //id
                template.id = key ? lkey + ":" + u.$ID + ":" + u.$tag_left + (template.$customId ? u.$tag_subId_c : u.$tag_subId) + u.$tag_right : u.$DOMID;
            } else
                delete template.id;

            if (template.className !== null) {
                //save bak
                bak = template.className || '';
                if (!template._NativeElement) {
                    //className
                    t = u.$CLS + (key ? '-' + key.toLowerCase() : '');
                    tagN = template.tagName.charAt(0) != "{" ? template.tagName.toLowerCase() : template.tagName;
                    cls1 = (tagN == "button" || tagN == "input" || tagN == "textarea" || tagN == "select" || tagN == "keygen") ? 'ood-ui-reset' : '';

                    //default class first
                    template['class'] = 'ood-node' + (cls1 ? (' ' + cls1) : '') + ' ood-node-' + tagN + (t ? (' ' + t) : '') +
                        //custom class here
                        (bak ? (' ' + bak) : '') +
                        (template.$fonticon ? (' ' + template.$fonticon) : '') +
                        //add a special
                        (lkey == profile.key ? (' ood-ui-ctrl ' + ((ood.browser.ie && ood.browser.ver < 10) ? '' : '{_selectable} ')) : '');
                } else {
                    //default class first
                    template['class'] = bak + ' ' +
                        //add a special
                        (lkey == profile.key ? ((ood.browser.ie && ood.browser.ver < 10) ? '' : '{_selectable} ') : '');
                }
                template['class'] += ' ' +
                    //custom style
                    ts + (key || 'KEY') + '_CT' + ts + ' ' +
                    //custom class
                    ts + (key || 'KEY') + '_CC' + ts + ' ' +
                    u.$MODULECLS + ' ' + u.$TAGCLASS + (prop._tagClass ? ' ' + prop._tagClass : '') + " ood-custom"
            }
            delete template.className;

            template.style = (template.style ? (template.style + ';') : '')
                + ts + (key || 'KEY') + '_CS' + ts;

            var a = [], b = {},
                tagName = template.tagName.charAt(0) != "{" ? template.tagName.toLowerCase() : template.tagName,
                text = template.text,
                sc = ood.absObj.$specialChars;

            for (var i in template) {
                if (!template[i]) continue;
                if (!sc[i.charAt(0)] && !map1[i]) {
                    o = template[i];
                    if (!r2.test(i)) {
                        // collect sub node
                        if (typeof o == 'object') {
                            if (!o.$order) o.$order = 0;
                            o.$key = i;
                            a[a.length] = o;
                        }
                    } else
                        b[i] = o;
                }
            }
            // sort sub node
            ood.arr.stableSort(a, function (x, y) {
                x = x.$order || 0;
                y = y.$order || 0;
                return x > y ? 1 : x == y ? 0 : -1;
            });

            //first
            if (!arr) {
                first = true;
                arr = [];
            }
            //<span id="" style="">
            arr[arr.length] = '<' + tagName + ' ';

            for (var i in b)
                if (b[i])
                    arr[arr.length] = i + '="' + b[i] + '" ';

            //set className bak
            if (template.className !== null)
                template.className = bak;

            delete template['class'];

            arr[arr.length] = ts + (key || 'KEY') + '_CA' + ts;
            arr[arr.length] = '>';

            if (!map2[tagName] && text)
                arr[arr.length] = text;
            // for ie67
            if (template.$fonticon && ood.__iefix2) {
                template.$fonticon = ood.str.trim(template.$fonticon);
                if (ood.__iefix2[template.$fonticon]) arr[arr.length] = ood.__iefix2[template.$fonticon];
                else if (/^\s*\{\s*_fi_[\w\s]+\}\s*$/.test(template.$fonticon)) arr[arr.length] = "{_the_next_is_fonticon_}" + template.$fonticon;
            }
            delete template.$fonticon;

            // add sub node
            for (var i = 0, l = a.length; i < l;) {
                o = a[i++];
                self(profile, o, o.$key, obj, arr)
            }
            if (!map2[tagName])
                arr[arr.length] = '</' + tagName + '>';

            if (first) {
                var a0 = obj[0], a1 = obj[1], str = arr.join(''), has = false;
                str.replace(r7, function (a, b, c, d) {
                    if (b) a0[a0.length] = b;
                    a1[a0.length] = a0[a0.length] = c;
                    if (d) a0[a0.length] = d;
                    has = true;
                    return '';
                });
                if (!has) {
                    a0[0] = str;
                }
            }
        },
        _rpt: function (profile, temp) {
            var me = arguments.callee,
                host = profile.host,
                moduleCls = (host && host['ood.Module'] && host.customStyle && !ood.isEmpty(host.customStyle)) ? (" ood-module-" + host.$xid) : null,
                ui = ood.UI,
                tag = ui.$tag_special,
                ca = function (h, s, i) {
                    s = "";
                    for (i in h) s += (i + '="' + h[i] + '" ');
                    return s;
                },
                r = me._r || (me._r = new RegExp(tag + '([0-9A-Z_]+)_C([CTA])' + tag + '|' + tag + '([\\w_\\-\\.]*)' + tag, 'img')),
                h1 = {
                    id: profile.serialId,
                    cls: profile.getClass('KEY'),
                    domid: profile.$domId,
                    modulecls: moduleCls,
                    tagcls: (profile.tagcls || '')
                },
                h2 = {
                    A: profile.CA,
                    C: profile.CC,
                    T: profile._CT
                };
            return temp.replace(r, function (a, b, c, d) {
                return h1[d] || (h2[c] ? (c == "A" ? ca(h2[c][b]) : (h2[c][b] || "")) : '');
            }).replace(ui.$x01r, '\x01');
        },
        _build: function (profile, data) {
            var template, t, m,
                u = ood.UI,
                temp = [[], []],
                self = this,
                key = self.KEY,
                cache = ood.$cache.template,
                hash = profile._hash =
                    'b:' + (profile.template._subid || '') + ';' +
                    '!' + (profile._exhash || '');

            //build custom theme hash here
            if (typeof profile.theme == "string") {
                var h = profile._CT = {},
                    pre = profile.key.replace(/\./g, '-').toLowerCase().replace('ood-ui', 'ood') + "-";
                ood.each(profile.keys, function (o, i) {
                    if (i.charAt(0) != '$')
                        h[i] = pre + profile.theme + "-" + i.toLowerCase();
                });
            }
            //get template
            if (!(template = ood.get(cache, [key, hash]))) {

                //get main template
                u.$buildTemplate(profile, null, null, temp);
                //split sub template from main template

                //set main template
                ood.set(cache, [key, hash, ''], temp);
                //set sub template
                if (t = profile.template.$submap)
                    for (var i in t) {
                        if (typeof (m = t[i]) != 'function') {
                            var temp = [[], []];
                            for (var j in m)
                                if (typeof m[j] == 'object')
                                    u.$buildTemplate(profile, m[j], j, temp);
                            m = temp;
                        }
                        ood.set(cache, [key, hash, i], m);
                    }

                template = ood.get(cache, [key, hash]);
            }
            if (!template) return '';

            //replace main template
            return self._rpt(profile, u.$doTemplate(profile, template, data));
        },
        /*
        allow function input, for some css bug
        */
        _setDefaultBehavior: function (hash) {
            var self = this,
                me = arguments.callee,
                map = me._m || (me._m = {'': 1, KEY: 1, $key: 1}),
                f = me._f1 || (me._f1 = function (arr, type, mode) {
                    var fun = function (profile, e, src) {
                        var t,
                            id = ood.use(src).id(),
                            item,
                            cid = profile.getSubId(id),
                            prop = profile.properties, nodes, funs, box;
                        if (prop.disabled || prop.readonly) return;
                        item = profile.SubSerialIdMapItem && profile.SubSerialIdMapItem[cid];
                        if (item && item.disabled) return;
                        if (item && item.readonly) return;
                        switch (typeof arr) {
                            case 'string':
                                nodes = profile.getSubNode(arr, cid)._get();
                                break;
                            case 'function':
                                funs = [arr];
                                break;
                            case 'object':
                                nodes = [];
                                funs = [];
                                for (var o, i = 0, l = arr.length; i < l; i++) {
                                    o = arr[i];
                                    if (typeof o == 'string')
                                        nodes.push.apply(nodes, profile.getSubNode(o, cid)._get());
                                    else
                                        funs.push(o);
                                }
                        }

                        if (nodes && nodes.length) {
                            nodes = ood(nodes);
                            box = profile.boxing();
                            if (mode == 1) {
                                if (/*!ood.browser.fakeTouch &&*/ ood.browser.deviceType != 'touchOnly' && type == 'mouseover') {
                                    if (profile.$beforeHover && false == profile.$beforeHover(profile, item, e, src, 'mouseover'))
                                        return;
                                    if (prop.disableHoverEffect === true) return;
                                    if (prop.disableHoverEffect && (new RegExp("\\b" + profile.getKey(src, true) + "\\b")).test(prop.disableHoverEffect || "")) return;
                                    if (profile.beforeHoverEffect && false === box.beforeHoverEffect(profile, item, e, src, 'mouseover'))
                                        return;
                                }
                                if (type == 'mousedown') {
                                    if (profile.$beforeClick && false == profile.$beforeClick(profile, item, e, src, 'mousedown'))
                                        return;
                                    if (prop.disableClickEffect)
                                        return;
                                    if (profile.beforeClickEffect && false === box.beforeClickEffect(profile, item, e, src, 'mousedown'))
                                        return;
                                }

                                //default action
                                nodes.tagClass('-' + ((/*!ood.browser.fakeTouch &&*/ ood.browser.deviceType != 'touchOnly') && type == 'mouseover' ? 'hover' : type == 'mousedown' ? 'active' : type));
                            } else {
                                if (type == 'mouseup') {
                                    if (profile.$beforeClick && false == profile.$beforeClick(profile, item, e, src, 'mouseup'))
                                        return;
                                    if (prop.disableClickEffect)
                                        return;
                                    if (profile.beforeClickEffect && false === box.beforeClickEffect(profile, item, e, src, 'mouseup'))
                                        return;
                                    nodes.tagClass('-active', false);
                                } else {
                                    if (profile.$beforeHover && false == profile.$beforeHover(profile, item, e, src, 'mouseout'))
                                        return;
                                    if (prop.disableHoverEffect === true) return;
                                    if (prop.disableHoverEffect && (new RegExp("\\b" + profile.getKey(src, true) + "\\b")).test(prop.disableHoverEffect || "")) return;

                                    if (profile.beforeHoverEffect && false === box.beforeHoverEffect(profile, item, e, src, 'mouseout'))
                                        return;
                                    nodes.tagClass('(-hover|-active)', false);
                                }
                            }
                        }
                        if (funs && funs.length) {
                            ood.arr.each(funs, function (o) {
                                ood.tryF(o, [profile], profile)
                            });
                            funs.length = 0;
                        }
                    };
                    return fun;
                }),
                hls = {}, t;
            if (!ood.SC.get('ood.absContainer'))
                ood.Class('ood.absContainer', 'ood.absObj', {
                    Instance: {
                        addPanel: function (paras, children, item) {
                            var pro = ood.clone(ood.UI.Panel.$DataStruct, true);
                            ood.merge(pro, paras, 'with');
                            ood.merge(pro, {
                                dock: 'fill',
                                tag: paras.tag || paras.id
                            }, 'all');

                            var pb = new ood.UI.Panel(pro), arr = [];
                            this.append(pb, item && item.id);
                            ood.arr.each(children, function (o) {
                                arr.push(o[0]);
                            });
                            pb.append(ood.UI.pack(arr, false));
                            return this;
                        },
                        removePanel: function () {
                            this.destroy(true);
                        },
                        getPanelPara: function () {
                            return ood.clone(this.get(0).properties, true);
                        },
                        dumpContainer: function (subId, purgeNow) {
                            return this.each(function (profile) {
                                var dm = profile.box.$DataModel,
                                    s = dm.valueSeparator || ";",
                                    p = profile.properties,
                                    hasitems = 'items' in p,
                                    b, id, arr, con;
                                if (!hasitems) {
                                    if (con = profile.boxing().getContainer()) con.html("", true, false, purgeNow);
                                } else {
                                    ood.arr.each(p.items, function (item) {
                                        id = item.id;
                                        if (!subId || subId === true) {
                                            b = 1;
                                        } else {
                                            arr = ood.isArr(subId) ? subId : (subId + "").split(s);
                                            b = ood.arr.indexOf(arr, id) != -1;
                                        }
                                        if (b) {
                                            if (con = profile.boxing().getContainer(id)) con.html("", true, false, purgeNow);
                                        }
                                    });
                                }
                            });
                        },
                        getPanelChildren: function () {
                            return this.get(0).children;
                        },
                        getFormValues: function (dirtiedOnly, subId, penetrate, withCaption, withCaptionField) {
                            var hash = {};
                            this.getFormElements(false, subId, penetrate).each(function (prf) {
                                var p = prf.properties, key = p.name || prf.alias, keys,
                                    ins = prf.boxing(),
                                    // maybe return array
                                    uv = ins.getUIValue();
                                // v and uv can be object(Date,Number)
                                if (!dirtiedOnly || (uv + " ") !== (ins.getValue() + " ")) {
                                    if (ins.getCaption && (withCaption || withCaptionField)) {
                                        if (withCaptionField && key.indexOf(":") != -1) {
                                            keys = key.split(':');
                                        }
                                        if (keys && keys[0] && keys[1]) {
                                            hash[keys[0]] = uv;
                                            hash[keys[1]] = ins.getCaption();
                                        } else if (withCaption) {
                                            hash[key] = {
                                                value: uv,
                                                caption: ins.getCaption()
                                            };
                                        } else {
                                            hash[key] = uv;
                                        }
                                    } else {
                                        if (!hash[key.split(':')[0]]) {
                                            hash[key.split(':')[0]] = uv;
                                        } else {
                                            hash[key.split(':')[0]] = uv;
                                        }

                                    }
                                }
                            });


                            return hash;
                        },
                        setFormValues: function (values, subId, penetrate) {
                            if (!ood.isEmpty(values)) {
                                this.getFormElements(false, subId, penetrate).each(function (prf) {
                                    var prop = prf.properties, ins = prf.boxing(), key = prop.name || prf.alias, keys,
                                        cap;
                                    if (typeof(ins.setCaption) == "function" && key.indexOf(":") != -1) {
                                        keys = key.split(':');
                                        if (keys && keys[0] && keys[1]) {
                                            key = keys[0];
                                            cap = keys[1];
                                        }
                                    }
                                    var v = values[key], b = ood.isHash(v);
                                    if ('value' in prop && key in values) {
                                        ins.setValue((b && ('value' in v)) ? v.value : v, true, 'form');
                                    }
                                    if (typeof(ins.setCaption) == "function") {
                                        if (cap in values)
                                            ins.setCaption(values[cap], null, true, 'form');
                                        else if (b && ('caption' in v))
                                            ins.setCaption(v.caption, null, true, 'form');
                                    }
                                });
                            }
                            return this;
                        },
                        getFormElements: function (dirtiedOnly, subId, penetrate) {
                            var a = this.getChildren(subId, penetrate !== false),
                                elems = ood.absValue.pack(a);
                            ood.filter(elems._nodes, function (prf) {
                                return prf.box._isFormField ? prf.box._isFormField(prf) : !!ood.get(prf, ['properties', 'isFormField']);
                            });
                            if (dirtiedOnly) {
                                var arr = [], ins, t;
                                elems.each(function (p, z) {
                                    ins = p.boxing();
                                    if ((ins.getUIValue() + " ") !== (ins.getValue() + " ")) {
                                        arr.push(p);
                                    }
                                });
                                return ood.absValue.pack(arr);
                            }
                            return elems;
                        },
                        isDirtied: function (subId, penetrate) {
                            var elems = this.getFormElements(false, subId, penetrate).get();
                            for (var i = 0, l = elems.length; i < l; i++) {
                                var profile = elems[i], ins;
                                if (profile.box["ood.absValue"]) {
                                    ins = profile.boxing();
                                    if ((ins.getUIValue() + " ") !== (ins.getValue() + " ")) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        },
                        checkValid: function (ignoreAlert, subId, penetrate) {
                            var ns = this, profile = ns.get(0), result = true;
                            // check required first
                            if (!ns.checkRequired(ignoreAlert, subId, penetrate)) {
                                return false;
                            }
                            ns.getFormElements(false, subId, penetrate).each(function (prf) {
                                var prop = prf.properties, ins = prf.boxing();
                                if (!ins.checkValid(ignoreAlert, subId, penetrate)) {
                                    if (!ignoreAlert) {
                                        if (!profile.beforeInputAlert || false !== profile.boxing().beforeInputAlert(profile, prf, 'invalid')) {
                                            ood.alert('$inline.invalid', ood.getRes('$inline.invalid2') + (prop.labelCaption ? (" : " + prop.labelCaption) : prop.name), function () {
                                                if (prf && prf.renderId)
                                                    ins.activate();
                                            });
                                        }
                                        return result = false;
                                    }
                                    result = false;
                                }
                            });
                            return result;
                        },
                        checkRequired: function (ignoreAlert, subId, penetrate) {
                            var profile = this.get(0), result = true;
                            this.getFormElements(false, subId, penetrate).each(function (prf, i) {
                                var prop = prf.properties, ins = prf.boxing();
                                if (prop.required && (!(i = ins.getUIValue())) && i !== 0) {
                                    if (!ignoreAlert) {
                                        if (!profile.beforeInputAlert || false !== profile.boxing().beforeInputAlert(profile, prf, 'required')) {
                                            ood.alert('$inline.required', ood.getRes('$inline.required2') + (prop.labelCaption ? (" : " + prop.labelCaption) : ""), function () {
                                                if (prf && prf.renderId)
                                                    ins.activate();
                                            });
                                        }
                                        return result = false;
                                    }
                                    result = false;
                                }
                            });
                            return result;
                        },
                        formClear: function (subId, penetrate) {
                            return this.each(function (prf) {
                                prf.boxing().getFormElements(false, subId, penetrate).resetValue(null);
                            });
                        },
                        formReset: function (subId, penetrate) {
                            return this.each(function (prf) {
                                var p = prf.properties,
                                    elems = prf.boxing().getFormElements(false, subId, penetrate);
                                if (prf.beforeFormReset && false === prf.boxing().beforeFormReset(prf, elems, subId, penetrate)) {
                                    return;
                                }
                                elems.each(function (p, i) {
                                    if ((i = p.properties.value) !== p.properties.$UIvalue)
                                        p.boxing().resetValue(i);
                                });
                                if (prf.afterFormReset) {
                                    prf.boxing().afterFormReset(prf, elems, subId, penetrate);
                                }
                            });
                        },
                        updateFormValues: function (subId, penetrate) {
                            this.getFormElements(false, subId, penetrate).updateValue();
                        },
                        formSubmit: function (ignoreAlert, subId, penetrate, withCaption, withCaptionField) {
                            var ns = this;
                            // check valid first
                            if (!ignoreAlert && !ns.checkValid(false, subId, penetrate)) {
                                return;
                            }
                            var prf = ns.get(0),
                                p = prf.properties, f,
                                data = ns.getFormValues(false, subId, penetrate, withCaption, withCaptionField),
                                apicaller;
                            // call before event
                            if (prf.beforeFormSubmit && false === prf.boxing().beforeFormSubmit(prf, data, subId, penetrate, withCaption, withCaptionField)) {
                                return;
                            }

                            if (p.formTarget == "Alert") {
                                data = ood.stringify(data);
                                if (ood.Coder && ood.Coder.formatText)
                                    data = ood.Coder.formatText(data);
                                alert(data);
                            } else if (/^\s*\{[^}]+\}\s*$/.test(p.formTarget)) {
                                f = ood.adjustVar(p.formTarget);
                                f(data);
                            } else if (/^((\s*function\s*([\w$]+\s*)?\(\s*([\w$\s,]*)\s*\)\s*)(\{([^\{\}]*)\}))\s*$/.test(p.formTarget)) {
                                if (f = ood.unserialize(p.formTarget)) {
                                    f(data);
                                }
                            }
                            else {
                                // try to get APICaller
                                if (ood.APICaller && ood.arr.indexOf(['_blank', '_self', '_parent', '_top'], p.formTarget) == -1) {
                                    apicaller = ood.APICaller.getFromName(p.formTarget);
                                }
                                if (apicaller) {
                                    apicaller.setQueryData(data, p.formDataPath);
                                    apicaller.invoke();
                                } else {
                                    ood.Dom.submit(p.formAction, data, p.formMethod, p.formTarget, p.formEnctype);
                                }
                            }
                            // update UI
                            ns.getFormElements(dirtiedOnly, subId, penetrate).updateValue();

                            if (prf.afterFormSubmit) prf.boxing().afterFormSubmit(prf, data, subId, penetrate, withCaption, withCaptionField);
                        },
                        // use refrence to keep the Class's function mark
                        _e1: function (profile, item, e, src, type) {
                        },
                        _e2: function (profile, keyboard, e, src) {
                        },
                        _e3: function (profile, e, shiftKey, src) {
                        },
                        _e4: function (profile, e, src, dragKey, dragData, item) {
                        },
                        _e5: function (profile, e, src) {
                        },
                        _e6: function (profile, ctrlPrf, type) {
                        },
                        _e7: function (profile, elems, subId) {
                        },
                        _e8: function (profile, data, subId) {
                        }
                    },
                    Static: {
                        $abstract: true,
                        DataModel: {
                            dragKey: '',
                            dropKeys: '',
                            overflow: {
                                ini: ood.browser.deviceType == "touchOnly" ? 'auto' : undefined,
                                combobox: ['', 'visible', 'hidden', 'scroll', 'auto', 'overflow-x:hidden;overflow-y:auto', 'overflow-x:auto;overflow-y:hidden'],
                                action: function (v) {
                                    var prf = this;
                                    ood.arr.each(prf.box.$Behaviors.PanelKeys, function (k) {
                                        var node = prf.getSubNode(k, true);
                                        if (v) {
                                            if (v.indexOf(':') != -1) {
                                                ood.arr.each(v.split(/\s*;\s*/g), function (s) {
                                                    var a = s.split(/\s*:\s*/g);
                                                    if (a.length > 1) node.css(ood.str.trim(a[0]), ood.str.trim(a[1] || ''));
                                                });
                                                return;
                                            }
                                        }
                                        node.css('overflow', v || '');
                                    });
                                }
                            },
                            panelBgClr: {
                                type: 'color',
                                ini: "",
                                action: function (v) {
                                    var prf = this;
                                    ood.arr.each(prf.box.$Behaviors.PanelKeys, function (k) {
                                        prf.getSubNode(k, true).css('background-color', v);
                                    });
                                }
                            },
                            panelBgImg: {
                                format: 'image',
                                ini: "",
                                action: function (v) {
                                    var prf = this;
                                    ood.arr.each(prf.box.$Behaviors.PanelKeys, function (k) {
                                        prf.getSubNode(k, true).css('background-image', v ? ('url(' + ood.adjustRes(v || '') + ')') : '');
                                    });
                                }
                            },
                            panelBgImgPos: {
                                ini: "",
                                combobox: ["", "top left", "top center", "top right", "center left", "center center", "center right", "bottom left", "bottom center", "bottom right", "0% 0%", "-0px -0px"],
                                action: function (v) {
                                    var prf = this;
                                    ood.arr.each(prf.box.$Behaviors.PanelKeys, function (k) {
                                        prf.getSubNode(k, true).css('background-position', v);
                                    });
                                }
                            },
                            panelBgImgRepeat: {
                                ini: "",
                                combobox: ["", "repeat", "repeat-x", "repeat-y", "no-repeat"],
                                action: function (v) {
                                    var prf = this;
                                    ood.arr.each(prf.box.$Behaviors.PanelKeys, function (k) {
                                        prf.getSubNode(k, true).css('background-repeat', v);
                                    });
                                }
                            },
                            panelBgImgAttachment: {
                                ini: "",
                                combobox: ["", "scroll", "fixed"],
                                action: function (v) {
                                    var prf = this;
                                    ood.arr.each(prf.box.$Behaviors.PanelKeys, function (k) {
                                        prf.getSubNode(k, true).css('background-attachment', v);
                                    });
                                }
                            },
                            conLayoutColumns: {
                                ini: 0,
                                action: function () {
                                    this.adjustSize();
                                }
                            },
                            conDockRelative: {
                                hidden: true,
                                ini: false,
                                get: function () {
                                    return this.boxing().getConLayoutColumns();
                                },
                                set: function (value) {
                                    return this.boxing().setConLayoutColumns(value ? 1 : 0);
                                }
                            },
                            conDockPadding: {
                                ini: {left: 0, top: 0, right: 0, bottom: 0},
                                action: function () {
                                    this.boxing().adjustDock(true);
                                }
                            },
                            conDockSpacing: {
                                ini: {width: 0, height: 0},
                                action: function () {
                                    this.boxing().adjustDock(true);
                                }
                            },
                            conDockFlexFill: {
                                ini: "",
                                combobox: ['none', 'width', 'height', 'both'],
                                action: function () {
                                    this.boxing().adjustDock(true);
                                }
                            },
                            conDockStretch: {
                                ini: "",
                                combobox: ['fixed', 'forward', 'rearward', 'stretch', '0.25', '0.33', '0.5', '0.25,0.5,0.25'],
                                action: function () {
                                    this.boxing().adjustDock(true);
                                }
                            },
                            sandboxTheme: {
                                ini: "",
                                action: function (v, ov, force, tag1, tag2) {
                                    ood.UI._refreshSBTheme(this, v, tag1, tag2);
                                }
                            },
                            formMethod: {
                                ini: 'get',
                                listbox: ['get', 'post']
                            },
                            formTarget: {
                                ini: 'Alert',
                                combobox: ['Alert', '_blank', '_self', '_parent', '_top', '[framename]', '[APICaller]', 'function(d){ood.log(d)}']
                            },
                            formDataPath: "",
                            formAction: "",
                            formEnctype: {
                                ini: 'application/x-www-form-urlencoded',
                                listbox: ['application/x-www-form-urlencoded', 'multipart/form-data', 'text/plain']
                            },
                            readonly: {
                                ini: false,
                                action: function (v) {
                                    this.boxing().getChildren().each(function (prf) {
                                        var ins = prf.boxing();
                                        if (typeof ins.setReadonly == 'function')
                                            ins.setReadonly(v || false);
                                        else if (typeof ins.setDisabled == 'function')
                                            ins.setDisabled(v || false);
                                    });
                                }
                            }
                        }
                    }
                });
            var src = ood.absContainer.prototype;

            if (hash.HoverEffected) {
                ood.each(hash.HoverEffected, function (o, i) {
                    t = map[i] ? hash : (hash[i] || (hash[i] = {}));
                    if (!o)
                        t.afterMouseover = t.afterMouseout = null;
                    else {
                        t.afterMouseover = f(o, 'mouseover', 1);
                        t.afterMouseout = f(o, 'mouseout', 2);
                    }
                });
                hls.beforeHoverEffect = src._e1;
            }
            if (hash.ClickEffected) {
                ood.each(hash.ClickEffected, function (o, i) {
                    t = map[i] ? hash : (hash[i] || (hash[i] = {}));
                    if (!o)
                        t.afterMousedown = t.afterMouseup = null;
                    else {
                        t.afterMousedown = f(o, 'mousedown', 1);
                        t.afterMouseup = f(o, 'mouseup', 2);
                    }
                });
                hls.beforeClickEffect = src._e1;
            }

            if (hash.HotKeyAllowed) {
                //for onHotKey
                ood.merge(hash, {
                    beforeKeydown: function (profile, e, src) {
                        if (profile.onHotKeydown)
                            return false !== profile.boxing().onHotKeydown(profile, ood.Event.getKey(e), e, src);
                    },
                    beforeKeypress: function (profile, e, src) {
                        if (profile.onHotKeypress)
                            return false !== profile.boxing().onHotKeypress(profile, ood.Event.getKey(e), e, src);
                    },
                    beforeKeyup: function (profile, e, src) {
                        if (profile.onHotKeyup)
                            return false !== profile.boxing().onHotKeyup(profile, ood.Event.getKey(e), e, src);
                    }
                });

                hls.onHotKeydown = hls.onHotKeypress = hls.onHotKeyup = src._e2;
            }

            //for focus action
            if (hash.NavKeys) {
                ood.each(hash.NavKeys, function (o, i) {
                    var map = arguments.callee, k, m1 = map.m1 || (map.m1 = {KEY: 1, $key: 1});
                    if (m1[i]) return;
                    var m2 = map.m2 || (map.m2 = {input: 1, textarea: 1}),
                        m3 = map.m3 || (map.m3 = {tab: 1, enter: 1, up: 1, down: 1, left: 1, right: 1}),
                        m4 = map.m4 || (map.m4 = {tab: 1, up: 1, down: 1, left: 1, right: 1}),
                        t = hash[i] || (hash[i] = {});

                    var t = hash[i] || (hash[i] = {});

                    if (null === o)
                        t.afterKeydown = null;
                    else {
                        t.afterKeydown = function (profile, e, src) {
                            var k = ood.Event.getKey(e), key = k.key, ctrl = k.ctrlKey, shift = k.shiftKey,
                                alt = k.altKey, b = false, smartnav = profile._smartnav;
                            if (smartnav) {
                                var node = ood.use(src).get(0);
                                if (m2[k = node.tagName.toLowerCase()]) {
                                    if (key && k == "input" && node.type.toLowerCase() != 'text' && node.type.toLowerCase() != 'password') {
                                        b = true;
                                    } else if (m3[key]) {
                                        var reg = ood.use(src).caret(), txt = ood.use(src).get(0).value;

                                        switch (key) {
                                            case 'up':
                                                if (!/[\n\r]/.test(txt.substr(0, reg[0]))) b = true;
                                                break;
                                            case 'left':
                                                if (!shift && (ctrl || (reg[0] === 0 && (reg[1] !== txt.length || reg[1] === 0)))) b = true;
                                                break;
                                            case 'down':
                                                if (!/[\n\r]/.test(txt.substr(reg[1], txt.length))) b = true;
                                                break;
                                            case 'right':
                                                if (!shift && (ctrl || (reg[1] === txt.length && (reg[0] !== 0 || reg[1] === 0)))) b = true;
                                                break;
                                            case 'enter':
                                                if (k == 'input' || alt) b = true;
                                                break;
                                            case "tab":
                                                b = true;
                                                break;
                                        }
                                    }
                                } else {
                                    if (m4[key])
                                        b = true;
                                }
                                node = null;
                            } else
                                b = key === 'tab';

                            //hanlder focus
                            if (b) {
                                //export event
                                if (profile.beforeNextFocus && false === profile.boxing().beforeNextFocus(profile, e, k.shiftKey, src)) {
                                    // fake a tab key, to envoke onHotKeydown/onHotKeyup
                                    switch (k.key) {
                                        case 'tab':
                                        case 'enter':
                                            if (profile.onHotKeydown) profile.boxing().onHotKeydown(profile, ood.Event.getKey(e), e, src);
                                        case 'esc':
                                            if (profile.onHotKeyup) profile.boxing().onHotKeyup(profile, ood.Event.getKey(e), e, src);
                                            break;
                                    }
                                    return false;
                                }

                                if (smartnav) {
                                    if (key != 'tab')
                                        ood.use(src).nextFocus(('up' == key || 'left' == key) ? false : true);
                                }
                            }
                        }
                    }
                });
                hls.beforeNextFocus = src._e3;
            }
            if ((t = hash.DroppableKeys) && t.length) {
                ood.arr.each(t, function (o) {
                    self._droppable(o)
                });

                t = self.prototype;
                ood.arr.each('getDropKeys,setDropKeys'.split(','), function (o) {
                    if (!t[o]) t[o] = src[o];
                });
                if (hash.PanelKeys) {
                    ood.arr.each('addPanel,removePanel,dumpContainer,getPanelPara,getPanelChildren,getFormValues,setFormValues,getFormElements,isDirtied,checkValid,checkRequired,formClear,formReset,updateFormValues,formSubmit'.split(','), function (o) {
                        if (!t[o]) t[o] = src[o];
                    });
                }
                self.$DataModel.dropKeys = self.$DataStruct.dropKeys = '';
                hls.onDragEnter = hls.onDragLeave = hls.beforeDrop = hls.onDrop = hls.afterDrop = hls.onDropTest = hls.onDropMarkShow = hls.onDropMarkClear = src._e4;
            }
            if ((t = hash.DraggableKeys) && t.length) {
                ood.arr.each(t, function (o) {
                    self._draggable(o)
                });
                t = self.prototype;
                ood.arr.each('getDragKey,setDragKey'.split(','), function (o) {
                    if (!t[o]) t[o] = src[o];
                });
                self.$DataModel.dragKey = self.$DataStruct.dragKey = '';
                hls.onGetDragData = hls.onStartDrag = hls.onDragStop = src._e5;
            }
            if ((t = hash.NoDraggableKeys) && t.length) {
                self.NoDraggableKeys = t;
            }
            if ((t = hash.NoDroppableKeys) && t.length) {
                self.NoDroppableKeys = t;
            }
            if ((t = hash.PanelKeys) && t.length) {
                ood.each(hash.PanelKeys, function (i) {
                    t = map[i] ? hash : (hash[i] || (hash[i] = {}));
                    t.onMousewheel = function (profile, e, src) {
                        var id = ood.use(src).id(),
                            cid = profile.getSubId(id),
                            item = profile.SubSerialIdMapItem && profile.SubSerialIdMapItem[cid];
                        if (profile.onMousewheel)
                            return profile.boxing().onMousewheel(profile, ood.Event.getWheelDelta(e), item, e, src);
                    };
                });

                t = self.prototype;
                ood.arr.each('overflow,panelBgClr,panelBgImg,panelBgImgPos,panelBgImgRepeat,panelBgImgAttachment,conDockRelative,conLayoutColumns,conDockPadding,conDockSpacing,conDockFlexFill,conDockStretch,sandboxTheme,formMethod,formTarget,formDataPath,formAction,formEnctype,readonly'.split(','), function (o) {
                    var f = 'get' + ood.str.initial(o), dm;
                    if (!t[f]) t[f] = src[f];
                    f = 'set' + ood.str.initial(o);
                    if (!t[f]) t[f] = src[f];
                    dm = ood.absContainer.$DataModel[o];
                    if (!(self._NoProp && self._NoProp[o])) {
                        self.$DataStruct[o] = ood.isSet(dm.ini) ? ood.copy(dm.ini) : "";
                        self.$DataModel[o] = ood.copy(dm);
                    }
                });

                ood.merge(hls, ood.absContainer.$EventHandlers);
                // form

                hls.beforeInputAlert = src._e6;
                hls.beforeFormReset = hls.afterFormReset = src._e7;
                hls.beforeFormSubmit = hls.afterFormSubmit = src._e8;
                hls.onMousewheel = function (profile, delta, item, e, src) {
                };

                self['ood.absContainer'] = true;
            }
            self.setEventHandlers(hls);
            self.$RenderTrigger = self.$RenderTrigger || [];
            self.$RenderTrigger.push(function () {
                if (this.properties.readonly) {
                    this.boxing().setReadonly(true, true);
                }
            });

        },

        addTemplateKeys: function (arr) {
            var self = this, key = self.KEY, me = arguments.callee, reg = me._reg || (me._reg = /\./g);
            ood.arr.each(arr, function (i) {
                self.$cssKeys[i] = (self.$Keys[i] = i == 'KEY' ? key : key + "-" + i).replace(reg, '-').toLowerCase().replace('ood-ui', 'ood');
            });
            return self;
        },
        _refreshSBTheme: function (profile, cssSetting, tag, callback, relayout) {
            var domId = profile.getDomId(),
                id = domId + "sandboxtheme",
                // escape special char
                prevId = this._getThemePrevId(profile),
                old = ood(id).get(0),
                applyCss = function (css) {
                    if (profile.destroyed) return;
                    ood.CSS._appendSS(profile.getRootNode(), ood.UI._adjustCSS(css, prevId, tag), id, true);

                    if (relayout || profile.$inDesign) {
                        profile.boxing().reLayout(true)
                            .getChildren(true, "penetrate").reLayout(true);
                    }
                };
            if (old) {
                old.disabled = true;
                ood(id).remove(false);
            }
            if (cssSetting) {
                if (/^[a-zA-Z-]+$/.test(cssSetting + '') && (cssSetting + '') !== 'default') {
                    var path = ood.getPath('ood.appearance.' + cssSetting, '');
                    ood.getFileAsync(path + 'theme.css', function (rsp) {
                        applyCss(rsp.replace(/\.setting-uikey\{[^}]+\}/, '').replace(/url\(([^)]+)\)/g, "url(" + path + "$1)"));
                        ood.tryF(callback, [profile, cssSetting]);
                    });
                } else {
                    applyCss(cssSetting + '');
                }
            }
        },
        _getThemePrevId: function (profile/*UIProfile or dom id*/) {
            return profile ? '#' + (profile['ood.UIProfile'] ? profile.getDomId() : profile).replace(/([.:])/g, "\\$1") : "";
        },
        _adjustCSS: function (css, prevId, tag) {
            prevId = prevId || "";
            if (tag) {
                css = ood.replace(css, [
                    [/(\/\*[^*]*\*+([^\/][^*]*\*+)*\/)/, '$0'],
                    [/\{[^}]*\}/, '$0'],
                    [/([^\/{},]+)/, function (a) {
                        return a[0].replace(/([^\s>]+)/, "$1" + tag)
                    }]
                ]);
            }
            return css
                .replace(/(\/\*[^*]*\*+([^\/][^*]*\*+)*\/)/g, '')
                .replace(/^\s*(\.)/, function (a, b) {
                    return prevId + " " + b;
                }).replace(/([},])\s*(\.)/g, function (a, b, c) {
                    return b + "\n" + prevId + " " + c;
                }).replace(/([{;])\s*(.)/g, function (a, b, c) {
                    return b + '\n' + (c == '}' ? '' : '    ') + c;
                }).replace(/url\(([^)]+)\)/g, function (a, b) {
                    return "url(" + ood.adjustRes(b, 0, 1) + ")";
                });
        },
        setAppearance: function (hash) {
            ood.merge(this.$Appearances, hash, 'all');
            return this;
        },
        getAppearance: function () {
            return this.$Appearances;
        },
        /*replace mode*/
        setTemplate: function (hash, cacheId) {
            if (hash) {
                var self = this,
                    tagNames = self.$tagName || (self.$tagName = {}),
                    me = arguments.callee,
                    r2 = me.r2 || (me.r2 = /[a-z]/),
                    sc = ood.absObj.$specialChars,
                    _ks = ['KEY'],
                    fun = me._fun || (me._fun = function (hash, arr, tagNames) {
                        var o, i;
                        for (i in hash) {
                            if (!sc[i.charAt(0)])
                                if (!r2.test(i)) {
                                    arr[arr.length] = i;
                                    o = hash[i];
                                    if (o && typeof o == 'object') {
                                        tagNames[i] = o.tagName || '';
                                        arguments.callee(o, arr, tagNames);
                                    }
                                }
                        }
                        ;
                    })
                    , t;
                tagNames.KEY = hash.tagName || '';
                fun(hash, _ks, tagNames);
                self.addTemplateKeys(_ks);

                t = self.$Templates;

                // for sub template,
                if (typeof cacheId == 'string') {
                    hash._subid = cacheId;
                    t[cacheId] = hash;
                } else
                    t._ = hash;

                //set sub
                if (t = hash.$submap)
                    for (var i in t)
                        for (var j in t[i])
                            me.call(self, t[i], j);
            }
            return this;
        },
        getTemplate: function (cacheId) {
            return this.$Templates[cacheId || '_'];
        },
        /*replace mode*/
        setBehavior: function (hash) {
            if (hash) {
                var self = this,
                    ch = ood.$cache.UIKeyMapEvents,
                    skey = self.$key,
                    check = ood.absObj.$specialChars,
                    event = ood.Event,
                    handler = event.$eventhandler,
                    eventType = event._eventMap,
                    me = arguments.callee,
                    r1 = me.r1 || (me.r1 = /[a-z]/),
                    r2 = me.r2 || (me.r2 = /^(on|before|after)/),
                    t = self.$Behaviors,
                    m, i, j, k, o, v, type;


                //remove all handler cache
                ood.filter(ch, function (o, i) {
                    return !(i == skey || i.indexOf(skey + '-') == 0);
                });

                //set shortcut first
                self._setDefaultBehavior(hash);
                //merge KEY
                if (hash.KEY) {
                    ood.merge(hash, hash.KEY, 'all');
                    delete hash.KEY;
                }

                //merge hash
                for (i in hash) {
                    o = hash[i];
                    if (!check[i.charAt(0)]) {
                        //only two layer
                        if (!r1.test(i)) {
                            m = t[i] || (t[i] = {});
                            for (j in o) {
                                v = o[j];
                                if (!check[j.charAt(0)]) {
                                    /*set to behavior*/
                                    if (v)
                                        m[j] = v;
                                    else
                                        delete m[j];
                                }
                            }
                        } else if (r2.test(i)) {
                            /*set to behavior*/
                            if (o)
                                t[i] = o;
                            else
                                delete t[i];
                            //for those special keys
                        } else
                            t[i] = o;
                    }
                }

                //add handler cache
                for (i in t) {
                    o = t[i];
                    if (!check[i.charAt(0)]) {
                        //only two layer
                        if (!r1.test(i)) {
                            for (j in o) {
                                if (!check[j.charAt(0)] && o[j]) {
                                    k = skey + '-' + i;
                                    ch[k] = ch[k] || {};
                                    ch[k]['on' + eventType[j]] = ch[k]['on' + eventType[j]] || handler;
                                }
                            }
                        } else if (r2.test(i) && o) {
                            k = skey;
                            ch[k] = ch[k] || {};
                            ch[k]['on' + eventType[i]] = ch[k]['on' + eventType[i]] || handler;
                        }
                    }
                }
            }

            return self;
        },
        getBehavior: function () {
            return this.$Behaviors;
        },
        $trytoApplyCSS: function () {
            var self = ood.UI, css = ood.CSS, id = 'ood.UI-CSS', cache1 = self.$cache_css_before,
                cache2 = self.$cache_css_after;
            // only the first time
            if (!self.$cssNo) {
                self.$cssNo = 1;
                var b = ood.browser;
                ood('body').addClass(
                    (b.ie ? ("ood-css-ie ood-css-ie" + b.ver + " ") :
                        b.gek ? ("ood-css-gek ood-css-gek" + b.ver + " ") :
                            b.kde ? ("ood-css-kde ood-css-kde" + b.ver + " ") :
                                b.opr ? ("ood-css-opr ood-css-opr" + b.ver + " ") : "")
                    + (b.isSafari ? "ood-css-safari " : b.isChrome ? "ood-css-chrome " : "")
                    + (b.isMac ? "ood-css-mac" : b.isLinux ? "ood-css-linux " : "")
                );
                ood('html').addClass("ood-css-base ood-css-viewport ood-uicontainer" + (b.isStrict ? " ood-css-strict" : ""));
                css.includeLink(ood.ini.path + "iconfont/iconfont.css", 'ood-font-icon', true);
            }
            // maybe more times for new UI widgets
            if (cache1) {
                css.addStyleSheet(cache1, id + (self.$cssNo++));
                self.$cache_css_before = '';
            }
            // only the first time
            if (cache2) {
                css.addStyleSheet(cache2, id + (self.$cssNo++), true);
                self.$cache_css_after = '';
            }
        },
        buildCSSText: function (hash) {
            var self = this,
                r1 = /(^|\s|,)([0-9A-Z_]+)/g,
                h = [], r = [],
                browser = ood.browser,
                ie6 = browser.ie6,
                ie = browser.ie,
                gek = browser.gek,
                ks = self.$cssKeys,
                t, v, o;

            for (var i in hash) {
                if (o = hash[i]) {
                    t = i.replace(r1, function (a, b, c) {
                        return b + '.' + (ks[c] || c)
                    }).toLowerCase();
                    o.$order = parseInt(o.$order, 10) || 0;
                    o.$ = t;
                    h[h.length] = o;
                }
            }
            ;
            ood.arr.stableSort(h, function (x, y) {
                x = x.$order || 0;
                y = y.$order || 0;
                return x > y ? 1 : x == y ? 0 : -1;
            });

            for (var i = 0, l = h.length; i < l;) {
                o = h[i++];
                r[r.length] = o.$ + "{";
                if (t = o.$before) r[r.length] = t;
                if (t = o.$text) r[r.length] = t;
                for (var j in o) {
                    if (j.charAt(0) == '$') continue;
                    //neglect '' or null
                    if ((v = o[j]) || o[j] === 0) {
                        j = j.replace(/_[0-9]+$/, '');
                        //put string dir
                        switch (typeof v) {
                            case 'string':
                            case 'number':
                                r[r.length] = j + ":" + v + ";";
                                break;
                            case 'function':
                                r[r.length] = j + ":" + v(self.KEY) + ";";
                                break;
                            //arrray
                            default:
                                ood.arr.each(v, function (k) {
                                    //neglect '' or null
                                    if (k) r[r.length] = j + ":" + k + ";";
                                });
                        }
                    }
                }
                if (v = o.$after) r[r.length] = v;
                r[r.length] = "}";
            }
            return r.join('');
        },
        _prepareCmds: function (profile, item, filter) {
            var ns = this,
                p = profile.properties,
                cmds = item.tagCmds || ood.clone(p.tagCmds, true);
            if (cmds && cmds.length) {
                var sid = ood.UI.$tag_subId, a = [], b = [], c;
                for (var i = 0, t = cmds, l = t.length; i < l; i++) {
                    if (typeof t[i] == 'string') c = {id: t[i]};
                    else c = ood.clone(t[i]);

                    if (filter && ood.isFun(filter)) {
                        if (!filter(c)) {
                            continue;
                        }
                    } else {
                        if (item.tag && item.tag.match((new RegExp("\\b" + "no~" + c.id + "\\b"))))
                            continue;
                    }

                    if ('id' in c) c.id += ''; else c.id = 'cmds' + profile.$xid + i;
                    if (c['object']) {
                        c['object'] = ns._prepareInlineObj(profile, c, p.tabindex);
                        c.type = 'profile';
                    } else {
                        if (!'caption' in c) c.caption = c.id;
                        if (!('tips' in c)) c.tips = c.caption;

                        c.id = c.id.replace(/[^0-9a-zA-Z]/g, '');
                        if (!c.buttonType) c.buttonType = "text";
                        if (!c.tagCmdsAlign) c.tagCmdsAlign = "left";
                        if (!c.itemClass) c.itemClass = c.imageClass;
                        if (!c.pos) c.pos = "row";

                        if (c.caption) c.caption = ood.adjustRes(c.caption);
                        if (c.tips) c.tips = ood.adjustRes(c.tips);
                        if (c.image) c.image = ood.adjustRes(c.image) || ood.ini.img_bg;
                        c._style = "";
                        if ('width' in c) c._style += c.width + (ood.isFinite(c.width) && "px") + ";";
                        if ('height' in c) c._style += c.height + (ood.isFinite(c.height) && "px") + ";";
                        c[sid] = (item[sid] ? item[sid] : "") + '_' + c.id;
                    }

                    var tagCmdsAlign = c["location"] || c["tagCmdsAlign"] || 'right';

                    if (tagCmdsAlign == "left")
                        b.push(c);
                    else {
                        a.push(c);
                        if (tagCmdsAlign == 'right-float' || tagCmdsAlign == 'floatright')
                            c._exstyle = 'float:right;';
                    }
                }
                item.ltagCmds = b
                item.rtagCmds = a;
            }
            item._ltagDisplay = item.ltagCmds ? '' : 'display:none';
            item._rtagDisplay = item.rtagCmds ? '' : 'display:none';
        },


        $getTagCmdsTpl: function (key) {

            var tpl = {
                'ltagCmds': function (profile, template, v, tag, result) {
                    var buttonType = v.buttonType || v.type;
                    var me = arguments.callee,
                        map = me._m || (me._m = {'text': '.text', 'button': '.button', 'image': '.image'});
                    ood.UI.$doTemplate(profile, template, v, "tagCmds" + (map[buttonType] || '.button'), result)
                },
                'rtagCmds': function (profile, template, v, tag, result) {
                    var buttonType = v.buttonType || v.type;
                    var me = arguments.callee,
                        map = me._m || (me._m = {'text': '.text', 'button': '.button', 'image': '.image'});
                    ood.UI.$doTemplate(profile, template, v, "tagCmds" + (map[buttonType] || '.button'), result)
                },
                'tagCmds.text': {
                    CMD: {
                        tagName: "span",
                        title: "{tips}",
                        style: '{_style}{itemStyle}',
                        className: 'ood-node ood-tag-cmd {itemClass}',
                        tabindex: '{_tabindex}',
                        text: "{caption}",
                        tips: "{tips}",
                        alt: "{tips}"
                    }
                },
                'tagCmds.button': {
                    CMD: {
                        tagName: "button",
                        title: "{tips}",
                        style: '{_style}{itemStyle}',
                        className: 'ood-node ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius ood-list-cmd ood-tag-cmd {itemClass}',
                        tabindex: '{_tabindex}',
                        text: "{caption}",
                        alt: "{tips}"
                    }
                },
                'tagCmds.image': {
                    CMD: {
                        title: "{tips}",
                        tagName: "image",
                        src: "{image}",
                        border: "0",
                        style: '{_style}{itemStyle}',
                        className: 'ood-node ood-tag-cmd {itemClass}',
                        tabindex: '{_tabindex}',
                        alt: "{tips}"
                    }
                }
            };
            return key ? tpl['tagCmds.' + key] : tpl;
        },
        _droppable: function (key) {
            var self = this,
                h2 = ood.Event.$eventhandler,
                o = self.$Behaviors,
                v = key == 'KEY' ? o : (o[key] || (o[key] = {})),
                handler = ood.$cache.UIKeyMapEvents,
                k2 = key == 'KEY' ? self.KEY : (self.KEY + '-' + key),
                ch = handler[k2] || (handler[k2] = {});

            //attach Behaviors
            ood.merge(v, {
                beforeMouseover: function (profile, e, src) {
                    var prop = profile.properties;
                    if (prop.disabled || prop.readonly) return;

                    // avoid no droppable keys
                    if (profile.behavior.NoDroppableKeys) {
                        var sk = profile.getKey(ood.Event.getSrc(e).id || "").split('-')[1];
                        if (sk && ood.arr.indexOf(profile.behavior.NoDroppableKeys, sk) != -1) return;
                    }

                    var ns = src, t,
                        dd = ood.DragDrop,
                        pp = dd.getProfile(),
                        key = pp.dragKey,
                        data = pp.dragData,
                        isPanelN = (t = profile.box.$Behaviors.PanelKeys) && ood.arr.indexOf(t, profile.getKey(src, true)) !== -1,
                        item, box, args;

                    //not include the dragkey
                    if (data &&
                        (
                            (prop.dragSortable && profile.$xid == ood.get(data, ['profile', '$xid']) && !isPanelN) ||
                            (key && (new RegExp('\\b' + key + '\\b')).test(profile.box.getDropKeys(profile, ns)))
                        )
                    ) {
                        box = profile.boxing();
                        if (box.getItemByDom)
                            item = box.getItemByDom(src);

                        args = [profile, e, ns, key, data, item];
                        if ((t = profile.onDropTest) && (false === box.onDropTest.apply(box, args)))
                            return;
                        if ((t = profile.box._onDropTest) && (false === t.apply(profile.host || profile, args)))
                            return;
                        //for trigger onDrop
                        dd.setDropElement(src);
                        if (profile.onDropMarkShow && (false === box.onDropMarkShow.apply(box, args))) {
                        }
                        else if ((t = profile.box._onDropMarkShow) && (false === t.apply(profile.host || profile, args))) {
                        }
                        else
                        //show region
                            ood.resetRun('setDropFace', dd.setDropFace, 0, [ns], dd);

                        if (t = profile.box._onDragEnter) t.apply(profile.host || profile, args);
                        if (profile.onDragEnter) box.onDragEnter.apply(box, args);
                        //dont return false, multi layer dd wont work well
                        //return false;
                    }
                },
                beforeMouseout: function (profile, e, src) {
                    if (profile.properties.disabled || profile.properties.readonly) return;
                    var dd = ood.DragDrop,
                        pp = dd.getProfile(),
                        key = pp.dragKey,
                        data = pp.dragData,
                        item, box, args;

                    //not include the dragkey
                    if (pp.dropElement == src) {
                        box = profile.boxing();
                        if (box.getItemByDom)
                            item = box.getItemByDom(src);

                        args = [profile, e, src, key, data, item];
                        if (profile.onDropMarkClear && (false === box.onDropMarkClear.apply(box, args))) {
                        }
                        else if ((t = profile.box._onDropMarkClear) && (false === t.apply(profile.host || profile, args))) {
                        }
                        else ood.resetRun('setDropFace', dd.setDropFace, 0, [null], ood.DragDrop);

                        if (t = profile.box._onDragLeave) t.apply(profile.host || profile, args);
                        if (profile.onDragLeave) box.onDragLeave.apply(box, args);
                        dd.setDropElement(null);
                    }
                    //return false;
                },
                beforeDrop: function (profile, e, src) {
                    var dd = ood.DragDrop,
                        pp = dd.getProfile(),
                        key = pp.dragKey,
                        data = pp.dragData,
                        item, t, args,
                        box = profile.boxing();
                    if (box.getItemByDom)
                        item = box.getItemByDom(src);
                    args = [profile, e, src, key, data, item];

                    if (profile.onDropMarkClear && (false === box.onDropMarkClear.apply(box, args))) {
                    }
                    else if ((t = profile.box._onDropMarkClear) && (false === t.apply(profile.host || profile, args))) {
                    }

                    if (profile.beforeDrop && (false === box.beforeDrop.apply(box, args)))
                        return;

                    if (!profile.onDrop || (profile.onDrop && false === box.onDrop.apply(box, args))) {
                        if (profile.box._onDrop)
                            profile.box._onDrop.apply(profile.host || profile, args);
                    }

                    if (profile.afterDrop)
                        box.afterDrop.apply(box, args);
                }
            }, 'all');

            ood.merge(ch, {
                onmouseover: h2,
                onmouseout: h2,
                ondrop: h2,
                afterDrop: h2,
                beforeDrop: h2
            });
            return self;
        },
        _draggable: function (key) {
            var self = this,
                h2 = ood.Event.$eventhandler,
                o = self.$Behaviors,
                v = key == 'KEY' ? o : (o[key] || (o[key] = {})),
                handler = ood.$cache.UIKeyMapEvents,
                k2 = key == 'KEY' ? self.KEY : (self.KEY + '-' + key),
                ch = handler[k2] || (handler[k2] = {});
            //attach Behaviors
            ood.merge(v, {
                beforeMousedown: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != "left") return;
                    var prop = profile.properties;
                    if (prop.disabled) return;
                    // not resizable or drag
                    if (!(prop.dragSortable || prop.dragKey)) return;

                    // avoid nodraggable keys
                    if (profile.behavior.NoDraggableKeys) {
                        var sk = profile.getKey(ood.Event.getSrc(e).id || "").split('-')[1];
                        if (sk && ood.arr.indexOf(profile.behavior.NoDraggableKeys, sk) != -1) return;
                    }

                    var pos = ood.Event.getPos(e), box = profile.boxing(), args = [profile, e, src], t;
                    if (profile.onStartDrag && (false === box.onStartDrag.apply(box, args))) {
                    }
                    else if ((t = profile.box._onStartDrag) && (false === t.apply(profile.host || profile, args))) {
                    }
                    else {
                        var con = profile.box;
                        ood.use(src).startDrag(e, {
                            dragType: 'icon',
                            targetLeft: pos.left + 12,
                            targetTop: pos.top + 12,
                            dragCursor: 'pointer',
                            dragDefer: 2,
                            dragKey: con.getDragKey(profile, src),
                            dragData: con.getDragData(profile, e, src)
                        });
                    }
                },
                beforeDragbegin: function (profile, e, src) {
                    ood.use(src).onMouseout(true, {$force: true}).onMouseup(true);
                },
                beforeDragstop: function (profile, e, src) {
                    var t;
                    if (profile.onDragStop) profile.boxing().onDragStop(profile.e, src);
                    if (t = profile.box._onDragStop) t.apply(profile.host || profile, arguments);
                }
            }, 'all');
            ood.merge(ch, {
                onmousedown: h2,
                ondragbegin: h2
            });

            return self;
        },
        //for relative , static children
        _adjustConW: function (profile, container, trigger, _adjust) {
            var prop = profile.properties, cols, containerWidth;
            if (!(cols = prop.conLayoutColumns))
                cols = prop.conDockRelative ? 1 : 0;
            if (!cols) return;
            // container width
            containerWidth = profile._containerWidth = container.scrollWidth();

            // if it's an adjust action, check first
            if (_adjust && _adjust == containerWidth) return;

            var pad = prop.conDockPadding,
                spc = prop.conDockSpacing,
                c = container.children(),
                l = c.size(), off, pw, w, tw, index = 0, ww, rowtotal = 0,
                allCtrls = [],
                // redo last row
                redoLastRow = function (pw, row, allCtrls) {
                    var rowLen = row.length,
                        colW = Math.floor(pw / rowLen),
                        rowtotal = 0,
                        rw, ww, prf, node, min, max;
                    for (var i = 0; i < rowLen; i++) {
                        node = row[i][0];
                        prf = row[i][1];
                        min = row[i][2];
                        max = row[i][3];
                        if (i == rowLen - 1) {
                            ww = prf.$forceu(Math.min(max, Math.max(min, pw - rowtotal)));
                        } else {
                            ww = prf.$forceu(rw = Math.min(max, Math.max(min, colW)));
                            rowtotal += rw;
                        }
                        allCtrls.push([node, prf, ww, rw]);
                    }
                };

            if (!l) return;
            // ensure inline block
            c.each(function (n, i, prf, p) {
                //if(trigger && n!=trigger)return;
                if (n.id && (prf = ood.$cache.profileMap[n.id]) && prf.Class && prf.Class['ood.UIProfile']) {
                    p = ood(n).css('position');
                    if (p == 'relative' || p == 'static')
                        ood(n).setInlineBlock();
                }
            });
            off = pad.left + pad.right + (cols - 1) * spc.width;
            pw = containerWidth - off;
            // It must be integer
            w = Math.floor(pw / cols);
            var curCtrl, lastRow = [], min, max;
            // set width
            c.each(function (n, i, prf, p, rw) {
                //if(trigger && n!=trigger)return;
                if (n.id && (prf = ood.$cache.profileMap[n.id]) && prf.Class && prf.Class['ood.UIProfile']) {
                    curCtrl = ood(n);
                    p = curCtrl.css('position');
                    if (p == 'relative' || p == 'static') {
                        if (prf) {
                            curCtrl.css({
                                position: 'relative',
                                left: 'auto',
                                top: 'auto',
                                right: 'auto',
                                bottom: 'auto',
                                'margin-left': (i === 0 ? pad.left : spc.width) + 'px',
                                'margin-top': (i === 0 ? pad.top : spc.height) + 'px'
                            });
                            min = ood.CSS.$px(prf.properties.dockMinW) || 0;
                            max = ood.CSS.$px(prf.properties.dockMaxW) || (pw + off);
                            ww = prf.$forceu(rw = Math.min(max, Math.max(min, w)));
                            rowtotal += rw;
                            if (rowtotal > pw) {
                                // redo last row
                                redoLastRow(pw + (cols - lastRow.length) * spc.width, lastRow, allCtrls);
                                lastRow = [];
                                rowtotal = rw;
                            }
                            lastRow.push([curCtrl, prf, min, max]);
                        }
                    }
                }
            });
            // redo last row
            if (lastRow.length)
                redoLastRow(pw + (cols - lastRow.length) * spc.width, lastRow, allCtrls);

            // set width to ctrls (properties.width + dom width);
            for (var i = 0, l = allCtrls.length; i < l; i++) {
                var node = allCtrls[i][0];
                //if(trigger && node.get(0)!=trigger)return;
                // to trigger onsize
                node.width(allCtrls[i][1].properties.width = allCtrls[i][2]);
                allCtrls[i][1]._conLayout = 1;
                // set %
                // node.get(0).style.width = Math.floor(allCtrls[i][3]  / containerWidth * 10000)/100 +'%';
            }
            var checkScroll = function (profile, container) {
                if (profile.destroyed || !profile._containerWidth || container.isEmpty()) return;
                if (profile._containerWidth != container.scrollWidth() &&profile._containerWidth != container.scrollWidth()-24  ){
                    ood.UI._adjustConW(profile, container, profile, profile._containerWidth);
                }

            };
            // caculate again for container's scrollbar show/hide
            checkScroll(profile, container);
            // caculate asyn for parent's scrollbar show/hide
            ood.asyRun(checkScroll, 0, [profile, container]);
        },
        /*copy item to hash, use 'without'
        exception: key start with $
        value(start with $) get a change to get value from setting
        */
        adjustData: function (profile, hashIn, hashOut, type) {
            if (!hashOut) hashOut = {};

            var box = profile.box, dm = box.$DataModel, i, o;

            for (i in hashIn) {
                if (i.charAt(0) == '$' || i == 'renderer') continue;
                if (hashIn.hasOwnProperty(i) && !hashOut.hasOwnProperty(i)) {
                    hashOut[i] = typeof (o = hashIn[i]) == 'string' ? i == 'html' ? ood.adjustRes(o, 0, 1, false, null, null, type == 'sub' && hashIn) : ood.adjustRes(o, true, false, null, null, type == 'sub' && hashIn) : o;
                }
            }
            if ('hidden' in hashIn)
                hashOut.hidden = hashIn.hidden;
            // filter: hidden
            var itemFilter = hashIn.itemFilter || profile.$itemFilter;
            if (itemFilter) hashOut.hidden = !!itemFilter(hashIn, 'prepareItem', profile);

            hashOut._itemDisplay = hashIn.hidden ? 'display:none;' : '';

            if ('disabled' in dm)
                hashOut.disabled = (ood.isSet(hashOut.disabled) && hashOut.disabled) ? 'ood-ui-itemdisabled' : '';
            if ('readonly' in dm)
                hashOut.readonly = (ood.isSet(hashOut.readonly) && hashOut.readonly) ? 'ood-ui-itemreadonly' : '';

            //todo:remove the extra paras
            hashOut.imageDisplay = (hashOut.imageClass || hashOut.image || hashOut.iconFontCode) ? '' : 'display:none';
            var ifc;
            if (hashOut.iconFontCode) {
                // iconFontCode + imageClass
                if (hashOut.imageClass) {
                    // filter built-in class
                    var arr = hashOut.imageClass.split(/\s+/);
                    ood.filter(arr, function (s) {
                        return !ood.builtinFontIcon[s];
                    });
                    hashOut.imageClass = arr.join(' ');
                }
            } else {
                // for ie687
                if (hashOut.imageClass) {
                    var arr = hashOut.imageClass.split(/\s+/);
                    ood.arr.each(arr, function (s) {
                        if (ood.builtinFontIcon[s]) {
                            ifc = ood.builtinFontIcon[s];
                            return;
                        }
                    }, null, true);

                    if (ifc && ood.__iefix2) {
                        hashOut.iconFontCode = ifc;
                        ood.filter(arr, function (s) {
                            return !ood.builtinFontIcon[s];
                        });
                    }
                    hashOut.imageClass = arr.join(' ');
                }
                if (!ifc) {
                    hashOut.picClass = 'ood-css-innerimage';
                    // imageClass + image
                    if (hashOut.image) {
                        hashOut.imageClass = 'ood-icon-placeholder';
                        hashOut.backgroundImage = "background-image:url(" + hashOut.image + ");";
                    }
                    if (hashOut.imagePos)
                        hashOut.backgroundPosition = 'background-position:' + hashOut.imagePos + ';';
                    else if (hashOut.image)
                        hashOut.backgroundPosition = 'background-position:center;';

                    if (hashOut.imageBgSize)
                        hashOut.backgroundSize = 'background-size:' + hashOut.imageBgSize + ';';
                    else if (hashOut.image)
                        hashOut.backgroundSize = 'background-size:initial;';

                    if (hashOut.imageRepeat)
                        hashOut.backgroundRepeat = 'background-repeat:' + hashOut.imageRepeat + ';';
                    else if (hashOut.image)
                        hashOut.backgroundRepeat = 'background-repeat:no-repeat;';
                }
            }
            if (hashOut.iconFontSize)
                hashOut.iconFontSize = 'font-size:' + hashOut.iconFontSize + ';';
            //must be here
            //Avoid Empty Image src
            // ensoure to trigger load event of img
            if (!hashOut.image && box.IMGNODE) hashOut.image = ood.ini.img_blank;
            if (o = hashOut.renderer || hashIn.renderer) {
                hashOut.caption = ood.UI._applyRenderer(profile, o, hashIn, hashOut);
            }
            return hashOut;
        },
        _applyRenderer: function (profile, renderer, hashIn, hashOut) {
            if (ood.isFun(renderer)) {
                return ood.adjustRes(renderer.call(profile, hashIn, hashOut));
            } else if (ood.isStr(renderer)) {
                var obj, prf, alias, prop = {}, events = {}, t,
                    clsReg = /^\s*[a-zA-Z]+([\w]+\.?)+[\w]+\s*$/,
                    adjustRenderer = function (hash, prop, events) {
                        if (hash) {
                            var mapReg = /^\s*([^>\s]+)?\s*>\s*([^>\s]+)\s*$/;
                            // 'alias > propName' in item
                            ood.each(hash, function (o, i) {
                                // alias > key =>alias > key
                                // > key => key
                                if (mapReg.test(i)) prop[i.replace(/^\s*>\s*/, '')] = o;
                            });
                            // 'ModuleProp' in item
                            if (ood.isHash(hash.ModuleProp)) prop = ood.merge(prop, hash.ModuleProp, 'all');
                            // 'ModuleEvents' in item
                            if (ood.isHash(hash.ModuleEvents)) events = ood.merge(events, hash.ModuleEvents, 'all');
                        }
                    };

                if (clsReg.test(renderer) && (obj = ood.SC.get(renderer))) {
                    if (obj['ood.UI'] || obj['ood.Module']) {
                        obj = new obj();
                        prf = obj.get(0);
                        alias = ood.get(hashOut, ['tagVar', 'alias']) || prf.alias;
                        if (hashIn) {
                            hashIn._render_xid = prf.$xid;
                            hashIn._render_obj = prf;
                            prf._render_conf = hashIn;
                        }
                        prf._render_holder = profile;

                        if (obj['ood.Module']) {
                            var mp = (new ood.UI.MoudluePlaceHolder());
                            prf = mp.get(0);
                            prf._module = obj;
                            obj = mp;
                        } else {
                            if (obj.setPosition) obj.setPosition('relative');
                            if (obj.setDisplay) obj.setDisplay('inline-block');
                        }

                        obj.setHost(profile.host, alias);

                        // after host setting
                        // for item/cell/row/col etc.
                        if (hashIn !== profile.properties) {
                            if (t = profile.box._applyRendererEx) t.call(profile.box, profile, prop, events, hashOut, adjustRenderer);
                            // 'alias > propName' in item
                            // 'ModuleProp' in item
                            // 'ModuleEvents' in item
                            adjustRenderer(hashOut, prop, events);
                        }
                        // 'alias > propName' in tagVar
                        // 'ModuleProp' in tagVar
                        // 'ModuleEvents' in tagVar
                        adjustRenderer(hashOut.tagVar, prop, events);

                        // ensure no renderer
                        delete prop.renderer;
                        if (!ood.isEmpty(prop)) obj.setProperties(prop);
                        if (!ood.isEmpty(events)) obj.setEvents(events);

                        (profile.$attached || (profile.$attached = [])).push(prf);
                        return obj.toHtml();
                    }
                }
                return ood.adjustVar(renderer, hashOut)
            }
        },
        $iconAction: function (profile, key, oldImageClass) {
            var p = profile.properties,
                icon = profile.getSubNode(key || 'ICON'),
                dispaly = (p.imageClass || p.image || p.iconFontCode) ? '' : 'display:none',
                ifc;

            // clear all first
            icon.css('backgroundImage', "none");
            icon.removeClass('ood-icon-placeholder');
            if (p.imageClass) icon.removeClass(p.imageClass);
            if (oldImageClass) icon.removeClass(oldImageClass);
            icon.html('');

            if (p.iconFontCode) {
                icon.html(p.iconFontCode);
                // iconFontCode + imageClass
                if (p.imageClass) {
                    // filter built-in class
                    var arr = p.imageClass.split(/\s+/);
                    ood.filter(arr, function (s) {
                        return !ood.builtinFontIcon[s];
                    });
                    icon.addClass(arr.join(' '));
                }
            } else {
                // for ie687
                if (p.imageClass) {
                    var arr = p.imageClass.split(/\s+/);
                    ood.arr.each(arr, function (s) {
                        if (ood.builtinFontIcon[s]) {
                            ifc = ood.builtinFontIcon[s];
                            return;
                        }
                    }, null, true);
                    if (ifc && ood.__iefix2) {
                        p.iconFontCode = ifc;
                        ood.filter(arr, function (s) {
                            return !ood.builtinFontIcon[s];
                        });
                    }
                    icon.addClass(arr.join(' '));
                }
                if (p.iconFontCode) {
                    icon.html(p.iconFontCode);
                }
                if (!ifc) {
                    // imageClass + image
                    if (p.image) {
                        icon.addClass('ood-icon-placeholder');
                        icon.css('backgroundImage', 'url(' + ood.adjustRes(p.image) + ')');
                    }
                }
            }
            icon.css('display', dispaly);
        },
        cacheData: function (key, obj) {
            ood.set(ood.$cache, ['UIDATA', key], obj);
            return this;
        },
        getCachedData: function (key) {
            var r = ood.get(ood.$cache, ['UIDATA', key]);
            if (typeof r == 'function') r = r();
            return r;
        },

        Behaviors: {
            onSize: function (profile, e) {
                var root = profile.getRootNode(), style = root && root.style;
                if (style && (e.width || e.height))
                    ood.UI.$tryResize(profile, style.width, style.height);
            },
            HotKeyAllowed: true,
            onContextmenu: function (profile, e, src) {
                if (profile.onContextmenu)
                    return profile.boxing().onContextmenu(profile, e, src, null, ood.Event.getPos(e)) !== false;
            }
        },
        DataModel: {
            autoTips: true,
            "className": {
                ini: "",
                action: function (v, ov) {
                    if (ov)
                        this.getRoot().removeClass(ov);
                    this.getRoot().addClass(v);
                    delete this._nodeEmSize;
                }
            },
            disableClickEffect: false,
            disableHoverEffect: false,
            disableTips: false,
            disabled: {
                ini: false,
                action: function (v) {
                    var i = this.getRoot();
                    if (v)
                        i.addClass('ood-ui-disabled');
                    else
                        i.removeClass('ood-ui-disabled');
                }
            },
            spaceUnit: {
                listbox: ['', 'px', 'em'],
                action: function () {
                    this.boxing().reLayout(true).getChildren(true, "penetrate").reLayout(true);
                }
            },
            defaultFocus: false,
            hoverPop: {
                ini: '',
                action: function (v, ov) {
                    var ns = this, b = ns.boxing(), p = ns.properties, t;
                    if (!ns.destroyed && ns.host) {
                        if (ov && (t = ns.host[ov]) && (t = t.get(0)) && t.renderId && !t.destroyed)
                            b.hoverPop(t, null);
                        if (v && (t = ns.host[v]) && (t = t.get(0)) && t.renderId && !t.destroyed)
                            b.hoverPop(t, p.hoverPopType, function () {
                                t.properties.tagVar.hoverFrom = arguments;
                            }, function () {
                                delete t.properties.tagVar.hoverFrom;
                            }, t.getRoot().parent(), v);
                    }
                }
            },
            hoverPopType: {
                ini: 'outer',
                dftWidth: 180,
                listbox: ['outer', 'inner',
                    'outerleft-outertop', 'left-outertop', 'center-outertop', 'right-outertop', 'outerright-outertop',
                    'outerleft-top', 'left-top', 'center-top', 'right-top', 'outerright-top',
                    'outerleft-middle', 'left-middle', 'center-middle', 'right-middle', 'outerright-middle',
                    'outerleft-bottom', 'left-bottom', 'center-bottom', 'right-bottom', 'outerright-bottom',
                    'outerleft-outerbottom', 'left-outerbottom', 'center-outerbottom', 'right-outerbottom', 'outerright-outerbottom'
                ]
            },
            locked: {
                ini: false,
                action: function () {
                    if (this.$inDesign) {
                        this.boxing().refresh(true);
                    }
                }
            },
            dock: {
                ini: 'none',
                listbox: ['none', 'top', 'bottom', 'left', 'right', 'center', 'middle', 'origin', 'width', 'height', 'fill', 'cover'],
                action: function (v) {
                    ood.UI.$dock(this, true, true);
                }
            },
            dockIgnore: {
                ini: false,
                action: function (v) {
                    var self = this;
                    if (self.properties.dock != 'none')
                        ood.UI.$dock(self, true, true);
                }
            },
            dockFloat: {
                ini: false,
                action: function (v) {
                    var self = this;
                    if (self.properties.dock != 'none')
                        ood.UI.$dock(self, true, true);
                }
            },
            // dockOrder is for compitable with older version only
            dockOrder: {
                hidden: true
            },
            showEffects: "",
            hideEffects: "",
            dockMargin: {
                ini: {left: 0, top: 0, right: 0, bottom: 0},
                action: function (v) {
                    var self = this;
                    v = v || {};
                    v.left = v.left || 0;
                    v.top = v.top || 0;
                    v.right = v.right || 0;
                    v.bottom = v.bottom || 0;
                    if (self.properties.dock != 'none')
                        ood.UI.$dock(self, true, true);
                }
            },

            dockMinW: {
                $spaceunit: 1,
                ini: 0
            },
            dockMinH: {
                $spaceunit: 1,
                ini: 0
            },
            dockMaxW: {
                $spaceunit: 1,
                ini: 0
            },
            dockMaxH: {
                $spaceunit: 1,
                ini: 0
            },

            // to stop conDockFlexFill
            dockIgnoreFlexFill: {
                ini: false,
                action: function (v) {
                    var self = this;
                    if (self.properties.dock != 'none')
                        ood.UI.$dock(self, true, true);
                }
            },
            // for top/left/right/bottom only
            // "" can be reset by container's conDockStretch
            dockStretch: {
                ini: "",
                combobox: ['fixed', 'forward', 'rearward', 'stretch', '0.25', '0.33', '0.5'],
                set: function (value) {
                    var o = this, t = o.properties;
                    t.dockStretch = value;
                    if (t.dock == "fill" || t.dock == "cover" || t.dock == "width" || t.dock == "height") {
                        if (value != 'forward' && value != 'rearward' && value != 'stretch') {
                            t.dockStretch = "stretch";
                        }
                    }
                    if (o.rendered && t.dock != 'none') {
                        ood.UI.$dock(o, true, true);
                    }
                }
            },
            tips: {
                ini: '',
                action: function (v) {
                    var t = ood.Tips;
                    if (t && t._showed) {
                        if (ood.UIProfile.getFromDom(t._markId) == this) {
                            t.setTips(v, true);
                        }
                    }
                }
            },
            rotate: {
                ini: 0,
                action: function (v) {
                    var root = this.getRoot(), ins = this.boxing();
                    v = parseFloat(v) || 0;
                    v = v % 360;
                    if (v < 0) v = v + 360;
                    if (this.box['ood.svg']) {
                        ins.setAttr("KEY", {transform: 'r' + v}, false);
                    } else {
                        root.rotate(v);
                    }
                }
            },
            activeAnim: {
                ini: "",
                caption: ood.getResText("DataModel.activeAnim") || '',
                action: function (key) {
                    var prf = this, okey, t;
                    if (okey = prf._activeAnim) {
                        ood.Thread.abort(okey);
                        delete prf._activeAnim;
                    }
                    if (key) prf._activeAnim = (t = prf.boxing().animate(key)) && t.id;
                }
            }
        },
        EventHandlers: {
            beforeRender: function (profile) {
            },
            onRender: function (profile) {
            },
            onLayout: function (profile) {
            },
            onResize: function (profile, width, height) {
            },
            onMove: function (profile, left, top, right, bottom) {
            },
            onDock: function (profile, region) {
            },
            beforePropertyChanged: function (profile, name, value, ovalue) {
            },
            afterPropertyChanged: function (profile, name, value, ovalue) {
            },
            beforeAppend: function (profile, child) {
            },
            afterAppend: function (profile, child) {
            },
            beforeRemove: function (profile, child, subId, bdestroy) {
            },
            afterRemove: function (profile, child, subId, bdestroy) {
            },
            onDestroy: function (profile) {
            },
            beforeDestroy: function (profile) {
            },
            afterDestroy: function (profile) {
            },
            onShowTips: function (profile, node, pos) {
            },
            onContextmenu: function (profile, e, src, item, pos) {
            }
        },
        RenderTrigger: function () {
            var prf = this, b = prf.boxing(), p = prf.properties, t,
                node = prf.getRootNode(),
                style = node.style;

            if (p.sandboxTheme) {
                ood.UI._refreshSBTheme(prf, p.sandboxTheme);
            }

            if (prf.box._onresize) {
                //avoid UI blazzing
                if (!prf._syncResize && !prf.box._syncResize) {
                    var style = prf.getRootNode().style, t
                    if ((t = style.visibility) != 'hidden') {
                        prf._$visibility = t;
                        style.visibility = 'hidden';
                    }
                    style = null;
                }
                ood.UI.$tryResize(prf, p.width, p.height);
            }
            if (p.disabled) b.setDisabled(true, true);
            if (p.rotate) b.setRotate(p.rotate, true);
            if (!prf.$inDesign && p.hoverPop) {
                ood.asyRun(function () {
                    b.setHoverPop(p.hoverPop, true);
                });
            }
            // set dataBinder for container
            if (prf.behavior.PanelKeys) {
                if (t = p.dataBinder) b.setDataBinder(t, true);
            }

            // attention animation
            if (p.activeAnim) {
                ood.asyRun(function () {
                    if (prf && !prf.destroyed)
                        prf.boxing().setActiveAnim(p.activeAnim, true);
                });
            }
            (prf.$beforeDestroy = (prf.$beforeDestroy || {}))["activeAnim"] = function (t) {
                if (t = prf._activeAnim)
                    ood.Thread.abort(t);
            }

            prf._inValid = 1;
        },
        $doResize: function (profile, w, h, force, key) {
            if (force || ((w || h) && (profile._resize_w != w || profile._resize_h != h))) {
                var root = profile.getRootNode(), con;
                //destroyed before resize
                if (!root) return false;

                profile._resize_w = w;
                profile._resize_h = h;
                ood.tryF(profile.box._onresize, [profile, w, h, force, key], profile.box);

                // to resize auto-width children for flow layout
                if ((force || w)
                    && profile.box && profile.box['ood.absContainer']
                    && (con = profile.getContainer(true))
                ) {
                    con.children().each(function (o, i, p) {
                        if ((i = ood.UIProfile.getFromDom(o.id))
                            && i.box && i.box._onresize
                            && (p = i.properties)
                            && (('position' in p) && ('width' in p))
                            && (p.position == 'static' || p.position == 'relative')
                            && (p.width === '' || p.width == 'auto')
                        ) ood.UI.$doResize(i, ood(o).width(), null, force, key);
                    });
                }
                // for have _onresize widget only
                if (profile.onResize)
                    profile.boxing().onResize(profile, w, h);
            }

            //some control will set visible to recover the css class
            if ('_$visibility' in profile) {
                var node = profile.getRootNode(),
                    style = node.style;
                if (style.visibility != 'visible' && !ood.getNodeData(node, '_setVisibility'))
                    style.visibility = profile._$visibility;
                node = style = null;
                ood.clearTimeout(profile._$rs_timer);
                delete profile._$rs_timer;
                delete profile._$rs_args;
                delete profile._$visibility;
            }
        },
        $tryResize: function (profile, w, h, force, key) {
            var s = profile.box, t = s && s._onresize;
            if (t && (force || w || h)) {
                //adjust width and height
                //w=parseFloat(w)||null;
                w = ((w === "" || w == 'auto') ? "auto" : ((ood.isFinite(w) || profile.$isPx(w)) ? (parseFloat(w) || 0) : w)) || null
                h = ((h === "" || h == 'auto') ? "auto" : ((ood.isFinite(h) || profile.$isPx(h)) ? (parseFloat(h) || 0) : h)) || null;

                //if it it has delay resize, overwrite arguments
                if ('_$visibility' in profile) {
                    var args = profile._$rs_args;
                    // asyrun once only
                    if (!args) {
                        args = profile._$rs_args = [profile, null, null];
                        profile._$rs_timer = ood.asyRun(function () {
                            // destroyed
                            if (!profile.box) return;
                            try {
                                if (profile && profile._$rs_args)
                                    ood.UI.$doResize.apply(null, profile._$rs_args);
                            } catch (e) {

                            }

                        });
                    }
                    //keep the last one, neglect zero and 'auto'
                    args[1] = w;
                    args[2] = h;
                    args[3] = force;
                    args[4] = key;
                    //else, call resize right now
                } else {
//for performance checking
//console.log('resize',profile.$xid,w,h,force,key);
                    ood.UI.$doResize(profile, w, h, force, key);
                }
            }
        },
        LayoutTrigger: function () {
            var self = this, b = self.boxing(), p = self.properties;
            // have to refresh this
            delete self._nodeEmSize;

            if (p.position == 'absolute') {
                if (p.dock && p.dock != 'none') {
                    //first time, ensure _onresize to be executed.
                    if (!self.$laidout) {
                        self.$laidout = 1;
                        var stl = self.getRootNode().style,
                            wu = 0 + self.$picku(stl.width),
                            hu = 0 + self.$picku(stl.height);
                        switch (p.dock) {
                            case 'top':
                            case 'bottom':
                            case 'width':
                                stl.width = 0;
                                break;
                            case 'left':
                            case 'right':
                            case 'height':
                                stl.height = 0;
                                break;
                            default:
                                stl.width = 0;
                                stl.height = 0;
                        }
                    }
                    ood.UI.$dock(this, false, true);
                }
            } else {
                if (ood.get(self, ['parent', 'properties', 'conDockRelative']) || ood.get(self, ['parent', 'properties', 'conLayoutColumns'])) {
                    if (!self._conLayout) {
                        ood.resetRun('conLayoutColumns:' + self.parent.$xid, function () {
                            if (!self._conLayout && !self.destroyed && !self.parent.destroyed)
                                ood.UI._adjustConW(self.parent, self.getRoot().parent(), self);
                        });
                    }
                }
            }
        },
        $dock_args: ['top', 'bottom', 'left', 'right', 'center', 'middle', 'width', 'height'],
        $dock_map: {middle: 1, center: 1},
        $dock: function (profile, force, trigger) {
            var node = profile.getRoot(),
                isSVG = profile.box['ood.svg'],
                ins = profile.boxing(),
                i1 = -1, i2 = -1, i3 = -1, i4 = -1,
                p = ood((node.get(0) && node.get(0).parentNode) || profile.$dockParent),
                //for ie6 1px bug
                _adjust = function (v) {
                    return ood.browser.ie && ood.browser.ver <= 6 ? v - v % 2 : v
                },
                adjustOverflow = function (p, isWin) {
                    var f, t, c, x, y;
                    if (isWin) {
                        // $frame.type has high priority
                        if (ood.ini.$frame && !ood.isNumb(ood.ini.$frame.zoom)) return;

                        f = ood.win.$getEvent('onSize', 'dock');
                    } else if (p && p.get(0)) {
                        f = p.$getEvent('onSize', 'dock');
                    }

                    if (f && f.dockall && f.dockall.length) {
                        for (var i = 0, l = f.dockall.length, s; i < l; i++) {
                            s = f.dockall[i].$dockType;
                            switch (s) {
                                case "fill":
                                case "cover":
                                    x = y = 1;
                                    break;
                                case "top":
                                case "bottom":
                                case "width":
                                    x = 1;
                                    break;
                                case "left":
                                case "right":
                                case "height":
                                    y = 1;
                                    break;
                            }
                        }
                    }
                    if (x && y) {
                        c = "ood-css-noscroll";
                    } else if (x) {
                        c = "ood-css-noscrollx";
                    } else if (y) {
                        c = "ood-css-noscrolly";
                    }
                    if (isWin) {
                        ood('html').removeClass(/^ood-css-noscroll(x|y)?$/);
                        t = ood('body').get(0);
                        if (t) t.scroll = '';
                        if (c) {
                            if (x) ood.win.scrollLeft(0);
                            if (y) ood.win.scrollTop(0);
                            ood('html').addClass(c);
                            if (x && y && t) {
                                t.scroll = 'no';
                            }
                        }
                    } else {
                        p.removeClass(/^ood-css-noscroll(x|y)?$/);
                        if (c) {
                            if (x) p.scrollLeft(0);
                            if (y) p.scrollTop(0);
                            p.addClass(c);
                        }
                    }
                },
                // adjust min/max
                checkLimits = function (profile, prop, dir, value) {
                    var t;
                    if (parseFloat(prop['dockMin' + dir]) && (t = profile.$px(prop['dockMin' + dir]))) value = _adjust(t <= value ? value : t);
                    if (parseFloat(prop['dockMax' + dir]) && (t = profile.$px(prop['dockMax' + dir]))) value = _adjust(t <= value ? t : value);
                    return value;
                },
                apply2Ctrl = function (profile, isSvg, ins, node, style, region) {
                    var us = ood.$us(profile),
                        adjustunit = function (v) {
                            return profile.$forceu(v, us > 0 ? 'em' : 'px', null, true)
                        };
                    // apply to UI
                    if (('left' in region) && profile.$px(style.left) !== region.left) region.left = adjustunit(region.left);
                    if (('top' in region) && profile.$px(style.top) !== region.top) region.top = adjustunit(region.top);
                    if (('right' in region) && profile.$px(style.right) !== region.right) region.right = adjustunit(region.right);
                    if (('bottom' in region) && profile.$px(style.bottom) !== region.bottom) region.bottom = adjustunit(region.bottom);
                    if (('width' in region) && profile.$px(style.width) !== region.width) region.width = adjustunit(region.width);
                    if (('height' in region) && profile.$px(style.height) !== region.height) region.height = adjustunit(region.height);
                    if (!ood.isEmpty(region)) {
                        if (isSVG) ins._setBBox(region);
                        else node.cssRegion(region, true);
                    }
                },
                applyPrevLine = function (obj, space/*spaceW*/, all/*obj.ww*/, p2/*width*/, p3/*dockMaxW*/, p4/*left*/, p5/*right*/) {
                    if (!obj.prevLine.length) return;
                    var pct = [], size, t, l, region, node, prop, margin, style,
                        ll = obj.prevLine.length - 1, preAll = 0,
                        start = obj[p4],
                        css = ood.CSS;

                    all -= ll * space;
                    // get [all] available
                    ood.arr.each(obj.prevLine, function (n) {
                        if (n.pct) {
                            pct.push(n);
                        } else {
                            all -= n.region[p2] + n.margin[p4] + n.margin[p5];
                        }
                    });

                    // determine pct's size
                    if (l = pct.length) {
                        // sum pct
                        var pctSum = 0;
                        ood.arr.each(pct, function (n, i) {
                            pctSum += n.pct;
                        });
                        ood.arr.each(pct, function (n, i) {
                            prop = n.prop;
                            region = n.region;
                            nodefz = n.nodefz;

                            // recaculate pct
                            n.pct = n.pct / pctSum;

                            // caculate size
                            size = all * n.pct - n.margin[p4] - n.margin[p5];
                            // adjust max only
                            if (parseFloat(prop[p3]) && (t = css.$px(prop[p3], nodefz))) size = _adjust(t <= size ? t : size);
                            if (i == l - 1) {
                                size = all - preAll;
                                // adjust max only
                                if (parseFloat(prop[p3]) && (t = css.$px(prop[p3], nodefz))) size = _adjust(t <= size ? t : size);
                                region[p2] = size;
                            } else {
                                preAll += (region[p2] = parseInt(size, 10));
                            }
                        });
                    }

                    // determine pct's start pos, and set to UI
                    ood.arr.each(obj.prevLine, function (n, i) {
                        region = n.region;
                        // left, top, bottom, right
                        region[p4] = parseInt(start + n.margin[p4], 10);
                        start += region[p2] + n.margin[p4] + n.margin[p5] + space;
                        apply2Ctrl(n.profile, n.isSVG, n.ins, n.node, n.style, region);
                    });
                    // rest the prev line
                    obj.prevLine = [];
                };

            if (!p.get(0))
                return;
            var prop = profile.properties,
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate, true)
                },
                margin = prop.dockMargin,
                auto = 'auto',
                value = prop.dock || 'none',
                pid = ood.Event.getId(p.get(0)),
                order = function (x, y) {
                    // _dockOrder is for designer mode only
                    // dockOrder is for compitable with older version only
                    x = parseInt(x.properties._dockOrder || x.properties.dockOrder, 10) || 0;
                    y = parseInt(y.properties._dockOrder || y.properties.dockOrder, 10) || 0;
                    return x > y ? 1 : x == y ? 0 : -1;
                },
                region,
                inMatrix = '$inMatrix',
                f, t, isWin,
                rootfz = node._getEmSize(),
                umargin = {
                    top: adjustunit(margin.top || 0, rootfz),
                    left: adjustunit(margin.left || 0, rootfz),
                    right: adjustunit(margin.right || 0, rootfz),
                    bottom: adjustunit(margin.bottom || 0, rootfz)
                };

            if (isSVG) {
                var bbox = ins._getBBox();
                prop.left = bbox.x;
                prop.top = bbox.y;
                prop.width = bbox.width;
                prop.height = bbox.height;
            }
            if (p.get(0) === document.body || p.get(0) === document || p.get(0) === window) {
                pid = '!document';
                isWin = true;
            }

            //attached to matrix
            if (pid && (pid == ood.Dom._ghostDivId || ood.str.startWith(pid, ood.Dom._emptyDivId)))
                return;

            if (profile.$dockParent != pid || profile.$dockType != value || force) {
                profile.$dockParent = pid;
                profile.$dockType = value;

                //unlink first
                i1 = profile.unLink('$dockall');
                i2 = profile.unLink('$dock');
                i3 = profile.unLink('$dock1');
                i4 = profile.unLink('$dock2');

                //set the fix value first
                switch (value) {
                    case 'middle':
                        region = {
                            right: prop.right == auto ? auto : (prop.right || ''),
                            bottom: auto,
                            left: prop.left == auto ? auto : (prop.left || ''),
                            width: prop.width || '',
                            height: prop.height || ''
                        };
                        break;
                    case 'center':
                        region = {
                            right: auto,
                            bottom: prop.bottom == auto ? auto : (prop.bottom || ''),
                            top: prop.top == auto ? auto : (prop.top || ''),
                            width: prop.width || '',
                            height: prop.height || ''
                        };
                        break;
                    case 'origin':
                        region = {right: auto, bottom: auto, width: prop.width || '', height: prop.height || ''};
                        break;
                    case 'top':
                        region = {left: umargin.left, right: umargin.right, bottom: auto, height: prop.height || ''};
                        //width top
                        break;
                    case 'bottom':
                        region = {left: umargin.left, right: umargin.right, top: auto, height: prop.height || ''};
                        //width bottom
                        break;
                    case 'left':
                        region = {right: auto, width: prop.width || ''};
                        //height top left
                        break;
                    case 'right':
                        region = {left: auto, width: prop.width || ''};
                        //height top right
                        break;
                    case 'width':
                        region = {bottom: auto, height: prop.height || '', top: prop.top || ''};
                        //width left
                        break;
                    case 'height':
                        region = {right: auto, width: prop.width || '', left: prop.left || ''};
                        //height top
                        break;
                    case 'fill':
                    case 'cover':
                        region = {right: auto, bottom: auto};
                        break;
                    case 'none':
                        region = {left: prop.left, top: prop.top, width: prop.width || '', height: prop.height || ''};
                        break;
                }
                if (node.get(0)) {
                    if (isSVG)
                        ins._setBBox(region);
                    else
                        node.cssRegion(region, true);
                }
                //if in body, set to window
                if (isWin) {
                    p = ood.win;
                    if (!ood.$cache._resizeTime) ood.$cache._resizeTime = 1;
                }
                //set dynamic part
                if (value != 'none') {
                    f = p.$getEvent('onSize', 'dock');
                    if (!f) {
                        f = function (arg) {
                            //get self vars
                            var me = arguments.callee,
                                css = ood.CSS,
                                map = ood.UI.$dock_map,
                                arr = ood.UI.$dock_args,
                                rePos = me.rePos,
                                pid = me.pid,
                                // the dock parent is window
                                isWin = me.pid == "!window" || me.pid == "!document",
                                pprf = isWin ? 0 : ood.UIProfile.getFromDom(pid),
                                pprop = pprf && pprf.properties,
                                proot = pprf && pprf.getRoot(),
                                pstyle = proot && proot.get(0) && proot.get(0).style,
                                prootfz = pstyle && proot._getEmSize(),
                                conDockSpacing = (pprop && ('conDockSpacing' in pprop)) ? pprop.conDockSpacing : {
                                    width: 0,
                                    height: 0
                                },
                                conDockPadding = (pprop && ('conDockPadding' in pprop)) ? pprop.conDockPadding : {
                                    left: 0,
                                    top: 0,
                                    right: 0,
                                    bottom: 0
                                },
                                conDockFlexFill = (pprop && ('conDockFlexFill' in pprop)) ? pprop.conDockFlexFill : '',
                                conDockStretch = (pprop && ('conDockStretch' in pprop)) ? pprop.conDockStretch.split(/[,;\s]+/) : [],
                                perW = conDockFlexFill == "width" || conDockFlexFill == "both",
                                perH = conDockFlexFill == "height" || conDockFlexFill == "both",
                                // if enable zoom, use a visualized frame (in <html> tag style)
                                node = isWin ? ood.frame : ood(pid);

                            if (!node.get(0))
                                return;

                            var pn = node.get(0),
                                style = pn.style,
                                us = ood.$us(profile),
                                nodefz = node._getEmSize(),
                                adjustunit = function (v, emRate) {
                                    return css.$forceu(v, us > 0 ? 'em' : 'px', emRate || nodefz)
                                },
                                obj, i, k, o, key, target,
                                ofs = isWin ? ood('body').get(0).style : style,
                                old_of = ofs.overflow,
                                old_ofx = ofs.overflowX,
                                old_ofy = ofs.overflowY;

                            // 1. set overflow for size
                            if (style) style.overflow = style.overflowX = style.overflowY = "hidden";
                            var hasCover;
                            for (var i in me.dockall) {
                                if (me.dockall[i].$dockType == "cover") {
                                    hasCover = 1;
                                    break;
                                }
                            }

                            //2. get width / height
                            var width = (style && css.$px(style.width, nodefz)) || node.width() || 0,
                                height = (style && css.$px(style.height, nodefz)) || node.height() || 0,
                                offsetH = hasCover ? node.offsetHeight() : height,
                                offsetW = hasCover ? node.offsetWidth() : width;

                            if (width == 'auto') width = 0;
                            if (height == 'auto') height = 0;
                            //width=Math.max( node.scrollWidth()||0,  (style&&css.$px(style.width,nodefz))||node.width()||0);
                            //height=Math.max( node.scrollHeight()||0, (style&&css.$px(style.height,nodefz))||node.height()||0);

                            // 3.reset overflow
                            if (style) {
                                style.overflow = old_of;
                                style.overflowX = old_ofx;
                                style.overflowY = old_ofy;
                            }
                            conDockSpacing = {
                                width: css.$px(conDockSpacing.width || 0, prootfz),
                                height: css.$px(conDockSpacing.height || 0, prootfz)
                            };
                            conDockPadding = {
                                left: css.$px(conDockPadding.left || 0, prootfz),
                                top: css.$px(conDockPadding.top || 0, prootfz),
                                right: css.$px(conDockPadding.right || 0, prootfz),
                                bottom: css.$px(conDockPadding.bottom || 0, prootfz)
                            };

                            //window resize: check time span, for window resize in firefox
                            //force call when input $dockid
                            //any node resize
                            if (arg.$dockid || !isWin || ((ood.stamp() - ood.$cache._resizeTime) > 50)) {
                                //recruit call, give a short change
                                obj = {
                                    // padding
                                    left: conDockPadding.left,
                                    top: conDockPadding.top,
                                    right: conDockPadding.right,
                                    bottom: conDockPadding.bottom,
                                    // size
                                    width: width,
                                    height: height,
                                    // for dock='cover'
                                    offsetW: offsetW || width,
                                    offsetH: offsetH || height
                                };
                                obj.preX = obj.oX = obj.left;
                                obj.preY = obj.oY = obj.top;
                                obj.prevLine = [];
                                // space avaiable
                                obj.ww = obj.width - obj.left - obj.right;
                                obj.hh = obj.height - obj.top - obj.bottom;
                                obj.leftHolder = obj.topHolder = obj.rightHolder = obj.bottomHolder = 0;


                                // adjust  aother dimension first
                                if (perW || perH) {
                                    var wCount = 0, wSum = 0, hCount = 0, hSum = 0, tmp, hMax = 0,
                                        adjustMM = function (prf, direction, numb, prop, t) {
                                            prop = prf.properties;
                                            if (parseFloat(t = prop['dockMin' + direction])) numb = Math.max(prf.$px(t), numb);
                                            if (parseFloat(t = prop['dockMax' + direction])) numb = Math.min(prf.$px(t), numb);
                                            return numb;
                                        }, originalSize = function (prf, dir) {
                                            return parseFloat(prf.$px(prf.properties[dir])) || 0;
                                        };
                                    // collect controls (w/h) to be percentaged, no dockIgnore
                                    for (k = 0; key = arr[k++];) {
                                        target = me[key];
                                        if (target.length) {
                                            for (i = 0; o = target[i++];) {
                                                if (!(o.properties.position != 'absolute' || o.properties.dockIgnore || o.properties.dockIgnoreFlexFill)) {
                                                    var node = o.getRoot();
                                                    if (perW && (key == 'left' || key == 'right' || key == 'width')) {
                                                        wCount++;
                                                        tmp = adjustMM(o, "W", originalSize(o, 'width'));
                                                        wSum += tmp;
                                                        if (o.properties.dock != "fill") {
                                                            hMax = Math.max(hMax, adjustMM(o, "H", originalSize(o, 'height')));
                                                        }
                                                    }
                                                    if (perH && (key == 'top' || key == 'bottom' || key == 'height')) {
                                                        hCount++;
                                                        hSum += adjustMM(o, "H", originalSize(o, 'height'));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (hSum && hMax) {
                                        hSum += hMax;
                                    }
                                    // for w percent
                                    if (wCount >= 1 && wSum && obj.width) {
                                        var innerW = obj.width - conDockPadding.left - conDockPadding.right - (wCount - 1) * conDockSpacing.width;
                                        for (k = 0; key = arr[k++];) {
                                            target = me[key];
                                            if (target.length) {
                                                for (i = 0; o = target[i++];) {
                                                    if (o.properties.position == 'absolute' && !o.properties.dockIgnore && o.properties.dockIgnoreFlexFill) {
                                                        var node = o.getRoot();
                                                        if (key == 'left' || key == 'right' || key == 'width') {
                                                            innerW -= adjustMM(o, "W", originalSize(o, 'width'));
                                                            innerH -= conDockSpacing.width;
                                                        }
                                                    }
                                                }
                                                for (i = 0; o = target[i++];) {
                                                    if (!(o.properties.position != 'absolute' || o.properties.dockIgnore || o.properties.dockIgnoreFlexFill)) {
                                                        var node = o.getRoot();
                                                        if (key == 'left' || key == 'right' || key == 'width') {
                                                            node.width(adjustunit(adjustMM(o, "W", Math.min(1, originalSize(o, 'width') / wSum) * innerW)));
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    // for h percent
                                    if (hCount >= 1 && hSum && obj.height) {
                                        var innerH = obj.height - conDockPadding.top - conDockPadding.bottom - (hCount - 1) * conDockSpacing.height;
                                        for (k = 0; key = arr[k++];) {
                                            target = me[key];
                                            if (target.length) {
                                                for (i = 0; o = target[i++];) {
                                                    if (o.properties.position == 'absolute' && !o.properties.dockIgnore && o.properties.dockIgnoreFlexFill) {
                                                        var node = o.getRoot();
                                                        if (key == 'top' || key == 'bottom' || key == 'height') {
                                                            innerH -= adjustMM(o, "H", originalSize(o, 'height'));
                                                            innerH -= conDockSpacing.height;
                                                        }
                                                    }
                                                }
                                                for (i = 0; o = target[i++];) {
                                                    if (!(o.properties.position != 'absolute' || o.properties.dockIgnore || o.properties.dockIgnoreFlexFill)) {
                                                        var node = o.getRoot();
                                                        if (key == 'top' || key == 'bottom' || key == 'height') {
                                                            node.height(adjustunit(adjustMM(o, "H", Math.min(1, originalSize(o, 'height') / hSum) * innerH)));
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (pprf && perW) pprf._conDockFlexFillW = 1;
                                    if (pprf && perH) pprf._conDockFlexFillH = 1;
                                }
                                if (conDockFlexFill != "both") {
                                    for (k = 0; key = arr[k++];) {
                                        target = me[key];
                                        if (target.length) {
                                            for (i = 0; o = target[i++];) {
                                                if (!(o.properties.position != 'absolute' || o.properties.dockIgnore || o.properties.dockIgnoreFlexFill)) {
                                                    var node = o.getRoot();
                                                    if (pprf && pprf._conDockFlexFillW && !perW && (key == 'left' || key == 'right' || key == 'width')) {
                                                        node.width(adjustunit(o.properties.width));
                                                    }
                                                    if (pprf && pprf._conDockFlexFillH && !perH && (key == 'top' || key == 'bottom' || key == 'height')) {
                                                        node.height(adjustunit(o.properties.height));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                if (pprf && pprf._conDockFlexFillW) delete pprf._conDockFlexFillW;
                                if (pprf && pprf._conDockFlexFillH) delete pprf._conDockFlexFillH;

                                // repos && resize
                                for (k = 0; key = arr[k++];) {
                                    obj.preX = obj.oX;
                                    obj.preY = obj.top;

                                    target = me[key];
                                    var ii = 0, ll;
                                    if (ll = target.length) {
                                        if (!map[key]) arg.width = arg.height = 1;
                                        for (i = 0; o = target[i++];) {
                                            if (o.properties.position == 'absolute' && !o.properties.dockIgnore) {
                                                rePos(o, ii++, ll, obj, key, arg.$dockid, isWin || arg.width, isWin || arg.height, conDockSpacing.width, conDockSpacing.height, conDockStretch);
                                            }
                                        }
                                    }
                                }

                                if (obj.later) {
                                    ood.each(obj.later, function (o) {
                                        var profile;
                                        //for safari
                                        try {
                                            if (o.isSVG)
                                                o.ins._setBBox(o);
                                            else
                                                o.node.cssRegion(o, true);
                                            if (profile = ood.UIProfile.getFromDom(o.node.get(0))) {
                                                delete o.node;
                                                // for no _onresize widget only
                                                if (!profile.box._onresize && profile.onResize && (o.width !== null || o.height !== null))
                                                    profile.boxing().onResize(profile, o.width, o.height);
                                                if (profile.onDock) profile.boxing().onDock(profile, o);
                                                if (profile.$onDock) profile.$onDock(profile, o);
                                            }
                                        } catch (e) {
                                            ood.asyRun(function () {
                                                // destroyed
                                                if (!o.node) return;

                                                var ow = o.width,
                                                    oh = o.height;
                                                o.width = ((parseFloat(o.width) || 0) + 1) + ood.CSS.$picku(o.width);
                                                o.height = ((parseFloat(o.width) || 0) + 1) + ood.CSS.$picku(o.height);

                                                if (o.isSVG) o.ins._setBBox(o);
                                                else o.node.cssRegion(o);

                                                o.width = ow;
                                                o.height = oh;

                                                if (o.isSVG) o.ins._setBBox(o);
                                                else o.node.cssRegion(o, true);

                                                if (profile = ood.UIProfile.getFromDom(o.node.get(0))) {
                                                    delete o.node;
                                                    // for no _onresize widget only
                                                    if (!profile.box._onresize && profile.onResize && (o.width !== null || o.height !== null))
                                                        profile.boxing().onResize(profile, o.width, o.height);
                                                    if (profile.onDock) profile.boxing().onDock(profile, o);
                                                    if (profile.$onDock) profile.$onDock(profile, o);
                                                }
                                            })
                                        }
                                    });
                                }
                                // for those are not in obj.later
                                for (k = 0; key = arr[k++];) {
                                    target = me[key];
                                    if (target.length) {
                                        for (i = 0; o = target[i++];) {
                                            if (o.properties.position == 'absolute' && !o.properties.dockIgnore) {
                                                if (!obj.later || !obj.later[o.$xid]) {
                                                    if (o.onDock) o.boxing().onDock(o);
                                                    if (o.$onDock) o.$onDock(o);
                                                }
                                            }
                                        }
                                    }
                                }

                                //if window resize, keep the timestamp
                                if (isWin)
                                    ood.$cache._resizeTime = ood.stamp();
                            }

                            me = rePos = node = style = null;
                        };
                        f.pid = pid;
                        ood.arr.each(ood.UI.$dock_args, function (key) {
                            f[key] = [];
                        });
                        f.dockall = [];
                        f.rePos = function (profile, index, ll, obj, value, id, w, h, spaceW, spaceH, conDockStretch) {
                            //if $dockid input, and not the specific node, return
                            var flag = false;
                            if (id && profile.$xid != id) flag = true;
                            var prop = profile.properties,
                                css = ood.CSS,
                                flt = prop.dockFloat,
                                margin = prop.dockMargin,
                                stretch = prop.dockStretch,
                                sStart, sEnd, noStretch, pct, isCover,
                                tempW = 0, tempH = 0,
                                node = profile.getRoot(),
                                ins = profile.boxing(),
                                root = node.get(0),
                                style = root.style,
                                us = ood.$us(profile),
                                nodefz = node._getEmSize(),
                                adjustunit = function (v) {
                                    return css.$forceu(v, us > 0 ? 'em' : 'px', nodefz)
                                },
                                left, top, right, bottom, temp, other,
                                x = css.$px(prop._dockBorderWidth, nodefz) || 0,
                                y = css.$px(prop._dockBorderHeight, nodefz) || 0,
                                region = {}, t,
                                isSVG = profile.box['ood.svg'], bbox;

                            // caculate with px
                            margin.top = css.$px(margin.top, nodefz);
                            margin.left = css.$px(margin.left, nodefz);
                            margin.right = css.$px(margin.right, nodefz);
                            margin.bottom = css.$px(margin.bottom, nodefz);

                            if (isSVG) {
                                bbox = ins._getBBox();
                                prop.left = bbox.x;
                                prop.top = bbox.y;
                                prop.width = bbox.width;
                                prop.height = bbox.height;
                            }

                            if (style.display == 'none')
                                return;
                            switch (value) {
                                case 'middle':
                                case 'center':
                                    sStart = sEnd = 0;
                                    break;
                                default:
                                    // flow stretch can be copy from container
                                    stretch = stretch || ((value == "width" || value == "height") ? "" : conDockStretch[index % conDockStretch.length]) || "stretch";

                                    // width/height support 3 only:
                                    if (value == "width" || value == "height") {
                                        if (stretch != "stretch" && stretch != "forward" && stretch != "rearward") {
                                            stretch = 'stretch';
                                        }
                                    }
                                    switch (stretch) {
                                        case 'stretch':
                                            sStart = 1;
                                            sEnd = 1;
                                            noStretch = 0;
                                            break;
                                        case 'forward':
                                            sStart = 1;
                                            sEnd = 0;
                                            noStretch = 0;
                                            break;
                                        case 'rearward':
                                            sStart = 0;
                                            sEnd = 1;
                                            noStretch = 0;
                                            break;
                                        case 'fixed':
                                            noStretch = 1;
                                            break;
                                        default:
                                            noStretch = 1;
                                            pct = Math.min(1, Math.max(0, parseFloat(stretch) || 0));
                                    }
                            }

                            isCover = prop.dock == 'cover';
                            //top/bottom/left/right must be set by order first
                            switch (value) {
                                case 'middle':
                                    //use height() is ok
                                    if (isSVG)
                                        ins.setTop(Math.max(0, (obj.height - bbox.height) / 2));
                                    else
                                        node.top(adjustunit(Math.max(0, (obj.height - node.height()) / 2)));
                                    break;
                                case 'center':
                                    if (isSVG)
                                        ins.setLeft(Math.max(0, (obj.width - bbox.width) / 2));
                                    else
                                        node.left(adjustunit(Math.max(0, (obj.width - node.width()) / 2)));
                                    break;
                                case 'top':
                                    if (!flag) {
                                        if (noStretch) {
                                            // calculate width
                                            temp = pct ? (parseFloat(obj.ww * pct) || 0) : _adjust(isSVG ? bbox.width : css.$px(prop.width, nodefz)) + margin.left + margin.right;
                                            if (pct) {
                                                temp -= spaceW;
                                                tempW = checkLimits(profile, prop, 'W', temp - margin.left - margin.right);
                                                temp = tempW + margin.left + margin.right;
                                            }

                                            // if overflow, wrap to new line
                                            if ((obj.preX + temp - obj.oX) > obj.ww) {
                                                // new line
                                                obj.top += obj.topHolder;
                                                obj.topHolder = 0;
                                                obj.preX = obj.oX;

                                                applyPrevLine(obj, spaceW, obj.ww, 'width', 'dockMaxW', 'left', 'right');
                                            }

                                            obj.prevLine.push({
                                                profile: profile,
                                                prop: prop,
                                                node: node,
                                                style: style,
                                                isSVG: isSVG,
                                                ins: ins,
                                                pct: pct,
                                                margin: margin,
                                                region: {
                                                    top: obj.top + margin.top,
                                                    width: temp
                                                }
                                            });

                                            // keep for next calculation
                                            obj.preX += temp + spaceW;
                                            obj.topHolder = Math.max(obj.topHolder, (isSVG ? bbox.height : node.offsetHeight()) + margin.top + margin.bottom + spaceH);
                                        } else {
                                            // new line
                                            applyPrevLine(obj, spaceW, obj.ww, 'width', 'dockMaxW', 'left', 'right');

                                            if (obj.topHolder) {
                                                obj.top += obj.topHolder;
                                                obj.preX = obj.oX;
                                            }
                                            left = sStart ? ((flt ? 0 : obj.left) + margin.left) : css.$px(prop.left, nodefz);
                                            right = sEnd ? ((flt ? 0 : obj.right) + margin.right) : (obj.width - css.$px(prop.width, nodefz) - css.$px(prop.left, nodefz));
                                            top = (flt ? 0 : obj.top) + margin.top;

                                            temp = checkLimits(profile, prop, 'W', obj.width - left - right - x);

                                            apply2Ctrl(profile, isSVG, ins, node, style, {
                                                left: left,
                                                top: top,
                                                width: _adjust(temp)
                                            });

                                            if (!flt)
                                                obj.top += (isSVG ? bbox.height : node.offsetHeight()) + margin.top + margin.bottom + spaceH;
                                        }
                                        // the last pct one
                                        if (ll == index + 1) {
                                            // new line
                                            applyPrevLine(obj, spaceW, obj.ww, 'width', 'dockMaxW', 'left', 'right');
                                        }
                                    }
                                    break;
                                case 'bottom':
                                    if (!flag) {
                                        if (noStretch) {
                                            // calculate width
                                            temp = pct ? (parseFloat(obj.ww * pct) || 0) : _adjust(isSVG ? bbox.width : css.$px(prop.width, nodefz)) + margin.left + margin.right;
                                            if (pct) {
                                                temp -= spaceW;
                                                tempW = checkLimits(profile, prop, 'W', temp - margin.left - margin.right);
                                                temp = tempW + margin.left + margin.right;
                                            }

                                            // if overflow, wrap to new line
                                            if ((obj.preX + temp - obj.oX) > obj.ww) {
                                                // new line
                                                obj.bottom += obj.bottomHolder;
                                                obj.bottomHolder = 0;
                                                obj.preX = obj.oX;

                                                applyPrevLine(obj, spaceW, obj.ww, 'width', 'dockMaxW', 'left', 'right');
                                            }

                                            obj.prevLine.push({
                                                profile: profile,
                                                prop: prop,
                                                node: node,
                                                style: style,
                                                isSVG: isSVG,
                                                ins: ins,
                                                pct: pct,
                                                margin: margin,
                                                region: {
                                                    bottom: obj.bottom + margin.bottom,
                                                    width: temp
                                                }
                                            });

                                            // keep for next calculation
                                            obj.preX += temp + spaceW;
                                            obj.bottomHolder = Math.max(obj.bottomHolder, (isSVG ? bbox.height : node.offsetHeight()) + margin.top + margin.bottom + spaceH);
                                        }
                                        else {
                                            // new line
                                            applyPrevLine(obj, spaceW, obj.ww, 'width', 'dockMaxW', 'left', 'right');

                                            if (obj.bottomHolder) {
                                                obj.bottom += obj.bottomHolder;
                                                obj.bottomHolder = 0;
                                                obj.preX = obj.oX;
                                            }
                                            left = sStart ? ((flt ? 0 : obj.left) + margin.left) : css.$px(prop.left, nodefz);
                                            right = sEnd ? ((flt ? 0 : obj.right) + margin.right) : (obj.width - css.$px(prop.width, nodefz) - css.$px(prop.left, nodefz));
                                            bottom = (flt ? 0 : obj.bottom) + margin.bottom;

                                            temp = checkLimits(profile, prop, 'W', obj.width - left - right);

                                            apply2Ctrl(profile, isSVG, ins, node, style, {
                                                left: left,
                                                bottom: bottom,
                                                width: _adjust(temp)
                                            });

                                            if (!flt)
                                                obj.bottom += (isSVG ? bbox.height : node.offsetHeight()) + margin.top + margin.bottom + spaceH;
                                        }
                                        // the last pct one
                                        if (ll == index + 1) {
                                            // new line
                                            applyPrevLine(obj, spaceW, obj.ww, 'width', 'dockMaxW', 'left', 'right');
                                        }
                                    }
                                    break;
                                case 'left':
                                    if (!flag) {
                                        if (obj.topHolder) {
                                            obj.top += obj.topHolder + spaceH;
                                            obj.topHolder = 0;
                                            // reset preY
                                            obj.oY = obj.preY = obj.top;
                                        }
                                        if (obj.bottomHolder) {
                                            obj.bottom += obj.bottomHolder + spaceH;
                                            obj.bottomHolder = 0;
                                        }
                                        // reset hh
                                        obj.hh = obj.height - obj.top - obj.bottom;
                                        if (obj.hh <= 0) return;

                                        if (noStretch) {
                                            // calculate height
                                            temp = pct ? (parseFloat(obj.hh * pct) || 0) : _adjust(isSVG ? bbox.height : css.$px(prop.height, nodefz)) + margin.top + margin.bottom;
                                            if (pct) {
                                                temp -= spaceH;
                                                tempH = checkLimits(profile, prop, 'H', temp - margin.top - margin.bottom);
                                                temp = tempH + margin.top + margin.bottom;
                                            }

                                            // if overflow, wrap to new line
                                            if ((obj.preY + temp - obj.oY) > obj.hh) {
                                                // new line
                                                obj.left += obj.leftHolder;
                                                obj.leftHolder = 0;
                                                obj.preY = obj.oY;

                                                applyPrevLine(obj, spaceH, obj.hh, 'height', 'dockMaxH', 'top', 'bottom');
                                            }

                                            obj.prevLine.push({
                                                profile: profile,
                                                prop: prop,
                                                node: node,
                                                style: style,
                                                isSVG: isSVG,
                                                ins: ins,
                                                pct: pct,
                                                margin: margin,
                                                region: {
                                                    left: obj.left + margin.left,
                                                    height: temp
                                                }
                                            });

                                            // keep for next calculation
                                            obj.preY += temp + spaceH;
                                            obj.leftHolder = Math.max(obj.leftHolder, (isSVG ? bbox.width : node.offsetWidth()) + margin.left + margin.right + spaceW);
                                        }
                                        else {
                                            // new line
                                            applyPrevLine(obj, spaceW, obj.hh, 'height', 'dockMaxH', 'top', 'bottom');

                                            if (obj.leftHolder) {
                                                obj.left += obj.leftHolder;
                                                obj.leftHolder = 0;
                                                obj.preY = obj.top;
                                            }

                                            left = (flt ? 0 : obj.left) + margin.left;
                                            top = sStart ? ((flt ? 0 : obj.top) + margin.top) : css.$px(prop.top, nodefz);
                                            bottom = sEnd ? ((flt ? 0 : obj.bottom) + margin.bottom) : (obj.height - css.$px(prop.height, nodefz) - css.$px(prop.top, nodefz));

                                            temp = checkLimits(profile, prop, 'H', obj.height - top - bottom - y);

                                            apply2Ctrl(profile, isSVG, ins, node, style, {
                                                left: left,
                                                top: top,
                                                height: _adjust(temp)
                                            });

                                            if (!flt)
                                                obj.left += (isSVG ? bbox.width : node.offsetWidth()) + margin.left + margin.right + spaceW;
                                        }
                                        // the last pct one
                                        if (ll == index + 1) {
                                            // new line
                                            applyPrevLine(obj, spaceW, obj.hh, 'height', 'dockMaxH', 'top', 'bottom');
                                        }
                                    }
                                    break;
                                case 'right':
                                    //if no top/bottom and change w only
                                    if (!flag) {
                                        if (obj.topHolder) {
                                            obj.top += obj.topHolder;
                                            obj.topHolder = 0;
                                            // reset preY
                                            obj.oY = obj.preY = obj.top;
                                        }
                                        if (obj.bottomHolder) {
                                            obj.bottom += obj.bottomHolder;
                                            obj.bottomHolder = 0;
                                        }
                                        // reset hh
                                        obj.hh = obj.height - obj.top - obj.bottom;

                                        if (obj.hh <= 0) return;

                                        if (noStretch) {
                                            // calculate height
                                            temp = pct ? (parseFloat(obj.hh * pct) || 0) : _adjust(isSVG ? bbox.height : css.$px(prop.height, nodefz)) + margin.top + margin.bottom;
                                            if (pct) {
                                                temp -= spaceH;
                                                tempH = checkLimits(profile, prop, 'H', temp - margin.top - margin.bottom);
                                                temp = tempH + margin.top + margin.bottom;
                                            }

                                            // if overflow, wrap to new line
                                            if ((obj.preY + temp - obj.oY) > obj.hh) {
                                                // new line
                                                obj.right += obj.rightHolder;
                                                obj.rightHolder = 0;
                                                obj.preY = obj.oY;

                                                applyPrevLine(obj, spaceH, obj.hh, 'height', 'dockMaxH', 'top', 'bottom');
                                            }

                                            obj.prevLine.push({
                                                profile: profile,
                                                prop: prop,
                                                node: node,
                                                style: style,
                                                isSVG: isSVG,
                                                ins: ins,
                                                pct: pct,
                                                margin: margin,
                                                region: {
                                                    right: obj.right + margin.right,
                                                    height: temp
                                                }
                                            });

                                            // keep for next calculation
                                            obj.preY += temp + spaceH;
                                            obj.rightHolder = Math.max(obj.rightHolder, (isSVG ? bbox.width : node.offsetWidth()) + margin.left + margin.right + spaceW);
                                        }
                                        else {
                                            // new line
                                            applyPrevLine(obj, spaceW, obj.hh, 'height', 'dockMaxH', 'top', 'bottom');

                                            if (obj.rightHolder) {
                                                obj.right += obj.rightHolder;
                                                obj.rightHolder = 0;
                                                obj.preY = obj.top;
                                            }

                                            right = (flt ? 0 : obj.right) + margin.right;
                                            top = sStart ? ((flt ? 0 : obj.top) + margin.top) : (css.$px(prop.top, nodefz));
                                            bottom = sEnd ? ((flt ? 0 : obj.bottom) + margin.bottom) : (obj.height - css.$px(prop.height, nodefz) - css.$px(prop.top, nodefz));

                                            temp = checkLimits(profile, prop, 'H', obj.height - top - bottom - y);

                                            apply2Ctrl(profile, isSVG, ins, node, style, {
                                                right: right,
                                                top: top,
                                                height: _adjust(temp)
                                            });

                                            if (!flt)
                                                obj.right += (isSVG ? bbox.width : node.offsetWidth()) + margin.left + margin.right + spaceW;
                                        }
                                        // the last pct one
                                        if (ll == index + 1) {
                                            // new line
                                            applyPrevLine(obj, spaceW, obj.hh, 'height', 'dockMaxH', 'top', 'bottom');
                                        }
                                    }
                                    break;
                                case 'width':
                                    //if no top/bottom/left/right and change h only
                                    if (!w) return;
                                    if (obj.leftHolder) {
                                        obj.left += obj.leftHolder;
                                        obj.leftHolder = 0;
                                    }
                                    if (obj.rightHolder) {
                                        obj.right += obj.rightHolder;
                                        obj.rightHolder = 0;
                                    }

                                    left = sStart ? ((isCover ? 0 : (flt ? 0 : obj.left)) + margin.left) : css.$px(prop.left, nodefz);
                                    right = sEnd ? ((isCover ? 0 : (flt ? 0 : obj.right)) + margin.right) : (obj.width - css.$px(prop.width, nodefz) - css.$px(prop.left, nodefz));
                                    top = prop.dock == 'width' ? (css.$px(prop.top, nodefz) || 0) : (sStart ? ((isCover ? 0 : (flt ? 0 : obj.top)) + margin.top) : css.$px(prop.top, nodefz));
                                    //later call for w/h change once
                                    temp = checkLimits(profile, prop, 'W', (isCover ? obj.offsetW : obj.width) - left - right - x);

                                    obj.later = obj.later || {};
                                    obj.later[profile.$xid] = obj.later[profile.$xid] || {};
                                    ood.merge(obj.later[profile.$xid], {
                                        isSVG: isSVG,
                                        ins: ins,
                                        node: node,
                                        width: adjustunit(temp),
                                        left: adjustunit(left),
                                        top: adjustunit(top)
                                    }, 'all');
                                    break;
                                case 'height':
                                    //if no top/bottom/left/right and change w only
                                    if (!h) return;
                                    if (obj.topHolder) {
                                        obj.top += obj.topHolder;
                                        obj.topHolder = 0;
                                        obj.preX = obj.oX;
                                    }
                                    if (obj.bottomHolder) {
                                        obj.bottom += obj.bottomHolder;
                                        obj.bottomHolder = 0;
                                        obj.preX = obj.oX;
                                    }

                                    top = sStart ? ((isCover ? 0 : (flt ? 0 : obj.top)) + margin.top) : css.$px(prop.top, nodefz);
                                    bottom = sEnd ? ((isCover ? 0 : (flt ? 0 : obj.bottom)) + margin.bottom) : (obj.height - css.$px(prop.height, nodefz) - css.$px(prop.top, nodefz));
                                    left = prop.dock == 'height' ? (css.$px(prop.left, nodefz) || 0) : (sStart ? ((isCover ? 0 : (flt ? 0 : obj.left)) + margin.left) : css.$px(prop.left, nodefz));

                                    //later call for w/h change once
                                    temp = checkLimits(profile, prop, 'H', (isCover ? obj.offsetH : obj.height) - top - bottom - y);

                                    obj.later = obj.later || {};
                                    obj.later[profile.$xid] = obj.later[profile.$xid] || {};
                                    ood.merge(obj.later[profile.$xid], {
                                        isSVG: isSVG,
                                        ins: ins,
                                        node: node,
                                        height: adjustunit(temp),
                                        left: adjustunit(left),
                                        top: adjustunit(top)
                                    }, 'all');

                                    break;
                            }
                        };

                        //add handler to window or node
                        p.onSize(f, 'dock');
                    }
                    //set link to node
                    if (value == 'fill' || value == 'cover') {
                        profile.link(f.height, '$dock1', null, i3);
                        profile.link(f.width, '$dock2', null, i4);
                        ood.arr.stableSort(f.height, order);
                        ood.arr.stableSort(f.width, order);
                    } else if (value == 'origin') {
                        profile.link(f.center, '$dock1', null, i3);
                        profile.link(f.middle, '$dock2', null, i4);
                    } else {
                        profile.link(f[value], '$dock', null, i2);
                        ood.arr.stableSort(f[value], order);
                    }
                    profile.link(f.dockall, '$dockall', null, i1);

                    //
                    ood.$cache._resizeTime = 1;

                    //set shortuct
                    profile.$dockFun = f;
                }

                // adjust dock parent's overflow
                adjustOverflow(p, isWin);

                if (value != 'none') {
                    (profile.$beforeDestroy = (profile.$beforeDestroy || {}))["releaseDock"] = function () {
                        profile.unLink('$dockall');
                        profile.unLink('$dock');
                        profile.unLink('$dock1');
                        profile.unLink('$dock2');
                        adjustOverflow(p, isWin);

                        if (p && p.get(0) && (p = ood.UIProfile.getFromDom(p.id()))) {
                            // affect dock parent
                            p.boxing().adjustDock();
                            ood.tryF(p.clearCache, [], p);
                        }
                        profile = p = null;
                    }
                } else {
                    if (profile.$beforeDestroy)
                        delete profile.$beforeDestroy["releaseDock"];
                }

            }

            //run once now
            if (trigger)
                p.onSize();
        },

        _beforeSerialized: function (profile) {
            var b, t, r, o = {};
            ood.merge(o, profile, 'all');
            var p = o.properties = ood.clone(profile.properties, true),
                ds = o.box.$DataStruct, t,
                dm = o.box.$DataModel;

            for (var i in ood.UI.$ps) {
                if ((i in p) && p[i] === '') p[i] = 'auto';
            }

            // *** force to rem/px
            for (var i in dm) {
                if (dm[i].ini === p[i]) delete p[i];
                else if (dm[i] && dm[i]['$spaceunit']) {
                    if ((dm[i].ini === 0 || dm[i].ini === '0' || dm[i].ini === '0px' || dm[i].ini === '0em')
                        && (p[i] === 0 || p[i] === '0' || p[i] === '0px' || p[i] === '0em')) delete p[i];
                    else if ((dm[i].ini + (ood.isFinite(dm[i].ini) ? 'px' : '')) == (p[i] + (ood.isFinite(p[i]) ? 'px' : ''))) delete p[i];
                    else if (p[i] != 'auto') {
                        t = ood.$us(o);
                        p[i] = profile.$forceu(p[i], t == 2 ? 'em' : t == -2 ? 'px' : null);
                    }
                }
            }
            if (p.position == 'absolute') {
                switch (p.dock) {
                    case 'top':
                    case 'bottom':
                        delete delete p.top;
                        delete p.bottom;
                        delete p.right;
                        break;
                    case 'left':
                    case 'right':
                        delete p.left;
                        delete p.right;
                        delete p.bottom;
                        break;
                }
            }
            for (var i in ood.UI.$ps) {
                if ((i in p) && ood.isNaN(p[i])) delete p[i];
            }

            if (p.items && p.items.length) {
                t = ood.absObj.$specialChars;
                p.items = ood.clone(p.items, function (o, i, d) {
                    return !t[((d === 1 ? o.id : i) + '').charAt(0)] && o != undefined;
                });
            }
            if (p.tagCmds && p.tagCmds.length) {
                t = ood.absObj.$specialChars;
                p.tagCmds = ood.clone(p.tagCmds, function (o, i, d) {
                    return !t[((d === 1 ? o.id : i) + '').charAt(0)] && o != undefined;
                });
            }
            // for empty object
            for (var i in profile.box._objectProp)
                if ((i in p) && p[i] && (ood.isHash(p[i]) || ood.isArr(p[i])) && ood.isEmpty(p[i])) delete p[i];
            // special for tagVar
            var i = 'tagVar';
            if ((i in p) && p[i] && (ood.isHash(p[i]) || ood.isArr(p[i])) && ood.isEmpty(p[i])) delete p[i];

            ood.arr.each(["dockMargin", "conDockPadding", "conDockSpacing", "sandboxTheme", "propBinder"], function (key) {
                if (t = p[key]) {
                    if (!ood.isHash(t)) {
                        return;
                    }
                    r = ds[key];
                    for (var i in t) {
                        if (r[i] !== t[i]) {
                            return;
                        }
                    }
                    delete p[key];
                }
            });

            if (ood.isEmpty(p.resizerProp))
                delete p.resizerProp;
            if (p.items && (p.items.length == 0 || p.listKey))
                delete p.items;
            if (p.tagCmds && (p.tagCmds.length == 0 || p.listKey))
                delete p.tagCmds;

            return o;
        },
        getDropKeys: function (profile, node) {
            return profile.properties.dropKeys;
        },
        getDragKey: function (profile, node) {
            return profile.properties.dragKey || (profile.properites.dragSortable && (profile.key + ":" + profile.$xid));
        },
        getDragData: function (profile, event, node) {
            return {
                profile: profile,
                domId: ood.use(node).id(),
                data: profile.onGetDragData ? profile.boxing().onGetDragData(profile, event, node) : null
            };
        },
        _prepareData: function (profile, data) {
            var prop = profile.properties,
                dm = this.$DataModel,
                me = arguments.callee,
                map = me.map || (me.map = ood.toArr('left,top,bottom,right,width,height')),
                a = [],
                box = profile.box,
                ajd = profile.box.adjustData,
                t;
            data = data || {};
            //can't input id in properties
            if (prop.id) delete prop.id;

            if ('required' in dm) {
                //prop._required = prop.required ? "ood-required" : "";
                prop._requiredfld = prop.required ? "ood-required-field" : "";
            }

            // cant null
            if ('nodeName' in dm && !prop.nodeName)
                prop.nodeName = "ood";

            //give default caption
            if ('caption' in dm && prop.caption !== null)
                prop.caption = prop.caption === undefined ? profile.alias : prop.caption;

            if ('html' in dm && prop.html)
                data.html = ood.adjustRes(prop.html, 0, 1);
            if ('src' in dm && prop.src)
                data.src = ood.adjustRes(prop.src, 0, 1);

            // *** force to em
            ood.each(prop, function (o, i) {
                if (dm[i] && dm[i]['$spaceunit']) {
                    if (ood.$us(profile) > 0)
                        if (prop[i] === 0 || prop[i] == '0') prop[i] = '0em';
                        else if (prop[i] === 0 || prop[i] == '0') prop[i] = '0px';
                }
            });

            //give border width
            if ('$hborder' in dm && dm.$hborder) {
                if (profile.$isEm(prop.width)) {
                    data.bWidth = profile.$px2em(profile.$em2px(prop.width) - prop.$hborder * 2, null, true) + 'em';
                } else {
                    data.bWidth = (parseFloat(prop.width) || 0) - prop.$hborder * 2;
                }
            }
            if ('$vborder' in dm && dm.$vborder) {
                if (profile.$isEm(prop.height)) {
                    data.bHeight = profile.$px2em(profile.$em2px(prop.height) - prop.$vborder * 2, null, true) + 'em';
                } else {
                    data.bHeight = (parseFloat(prop.height) || 0) - prop.$vborder * 2;
                }
            }
            //set left,top,bottom,right,width,height
            for (var j = 0, i; i = map[j]; j++) {
                var t = (i in data) ? data[i] : prop[i];
                if (t || t === 0) {
                    if (t != 'auto') a[a.length] = i + ':' + profile.$addu(t);
                }
            }
            // position,z-index,visibility,display
            if (prop.position) a[a.length] = 'position:' + prop.position;
            if (prop.visibility) a[a.length] = 'visibility:' + prop.visibility;
            if ('zIndex' in prop) a[a.length] = 'z-index:' + prop.zIndex;
            if (prop.display) a[a.length] = prop.display == 'inline-block' ? ('display:' + ood.$inlineBlock.join('; display:') + ';') : ('display:' + prop.display);

            data._style = a.join(';') + ';';
            if (box.$Behaviors.PanelKeys && !box["ood.absList"]) {
                a = [];
                if (prop.panelBgClr) a[a.length] = 'background-color:' + prop.panelBgClr;
                if (prop.panelBgImg) a[a.length] = 'background-image:url(' + ood.adjustRes(prop.panelBgImg) + ')';
                if (prop.panelBgImgPos) a[a.length] = 'background-position:' + prop.panelBgImgPos;
                if (prop.panelBgImgRepeat) a[a.length] = 'background-repeat:' + prop.panelBgImgRepeat;
                if (prop.panelBgImgAttachment) a[a.length] = 'background-attachment:' + prop.panelBgImgAttachment;
                data._panelstyle = a.join(';');
            }

            if ('className' in dm)
                data._className = prop.className || "";

            if ('readonly' in dm) data.readonly = prop.readonly ? "ood-ui-readonly" : "";
            if ('href' in dm) data.href = prop.href || ood.$DEFAULTHREF;
            if ('tabindex' in dm) data.tabindex = prop.tabindex || '-1';
            if ('items' in dm) {
                profile.ItemIdMapSubSerialId = {};
                profile.SubSerialIdMapItem = {};

                prop.items = profile.box._adjustItems(prop.items);
                data.items = this._prepareItems(profile, prop.items);
            }

            if ('selectable' in dm)
                data._selectable = (ood.browser.ie && ood.browser.ver < 10)
                    ? ""
                    : (prop.selectable ? "ood-ui-selectable" : "ood-ui-unselectable");

            //default prepare
            data = ajd(profile, prop, data);

            profile.prepared = true;
            return data;
        },
        _prepareInlineObj: function (profile, item, tabindex) {
            var obj = item['object'];
            obj = obj['ood.absBox'] ? obj.get(0) : obj['ood.UIProfile'] ? obj : ood.create(obj).get(0);
            if (obj.destroyed) return null;
            if (obj['ood.UIProfile']) {
                obj.properties.position = 'relative';
                if ('tabindex' in obj.properties) obj.properties.tabindex = tabindex;
                var addcls = 'ood-inline-object', cck = obj.CC.KEY || (cck = obj.CC.KEY = '');
                if (cck.indexOf(addcls) === -1) obj.CC.KEY = cck + " " + addcls;
            }

            item._inline_xid = obj.$xid;
            item._inline_obj = obj;
            obj._inline_conf = item;
            obj._inline_holder = profile;

            if (obj.alias && (!obj.host || obj.host === obj)) obj.boxing().setHost(profile.host, obj.alias);
            (profile.$attached || (profile.$attached = [])).push(obj);
            return obj;
        },
        _prepareItems: function (profile, items, pid, mapCache, serialId) {
            var ns = this,
                result = [],
                item, dataItem, t,
                SubID = ood.UI.$tag_subId, id,
                prop = profile.properties,
                tabindex = prop.tabindex,
                ajd = profile.box.adjustData,
                itemFilter = profile.$itemFilter;
            if (itemFilter) itemFilter('begin', 'prepareItem', profile);

            //set map
            for (var i = 0, l = items.length; i < l; i++) {
                if (ood.isHash(items[i])) {
                }
                else if (ood.isArr(items[i])) {
                    items[i] = {id: items[i][0]};
                    if (items.length > 1) items[i].caption = items[i][1];
                } else {
                    items[i] = {id: items[i]};
                }

                if (items[i].id === '?') items[i].id = ood.rand();

                item = items[i];

                if (profile.beforePrepareItem && false === profile.boxing().beforePrepareItem(profile, item, pid, mapCache, serialId)) {
                    continue;
                }

                if (!item.hasOwnProperty('caption')) item.caption = item.id;

                dataItem = {id: item.id};
                if (pid) dataItem._pid = pid;
                dataItem.renderer = item.renderer || prop.renderer;

                id = dataItem[SubID] = typeof serialId == 'string' ? serialId : profile.pickSubId('items');

                if (false !== mapCache) {
                    profile.ItemIdMapSubSerialId[item.id] = id;
                    profile.SubSerialIdMapItem[id] = item;
                }
                if (item['object']) {
                    dataItem['object'] = ns._prepareInlineObj(profile, item, tabindex);
                } else {
                    dataItem._tabindex = tabindex;

                    //others
                    ajd(profile, item, dataItem, 'sub');
                    if (ns._prepareItem)
                        ns._prepareItem(profile, dataItem, item, pid, i, l, mapCache, serialId);
                }
                result.push(dataItem);
            }

            if (itemFilter) itemFilter('end', 'prepareItem', profile);
            return result;
        },
        _showTips: function (profile, node, pos) {
            if (profile.properties.disableTips) return;
            if (profile.onShowTips)
                return profile.boxing().onShowTips(profile, node, pos);
        }
    }
});

//absList Class
ood.Class("ood.absList", "ood.absObj", {
    Instance: {
        activate: function () {
            var profile = this.get(0),
                items = profile.getSubNode('ITEM', true);
            if (!items.isEmpty())
                items.focus(true);
            return this;
        },


        _initIconColors: function (type, p) {
            var colors = [],
                iconColors = ["#E6945C", "#46C37B", "#195ead", "#9E8CE0", "#1f8d9b", "#87CEEB", "#e04d7f"],
                fontColors = ["#E6945C", "#46C37B", "#195ead", "#9E8CE0", "#1f8d9b", "#87CEEB", "#e04d7f"],
                itemColors = ["#F19B60", "#49CD81", "#0277bd", "#A693EB", "#42a3af", "#B0E0E6", "#F06292"];

            switch (type) {
                case 'icon':
                    colors = iconColors;
                    if (p.iconColors && p.iconColors.length > 0) {
                        colors = p.iconColors;
                    }
                    break;
                case 'font':
                    colors = fontColors;
                    if (p.fontColors && p.fontColors.length > 0) {
                        colors = p.fontColors;
                    }
                    break;
                case 'item':
                    colors = itemColors;
                    if (p.itemColors && p.itemColors.length > 0) {
                        colors = p.itemColors;
                    }
                    break;
            }
            return colors;
        },

        _autoColor: function (item, index, p) {
            index = index || 0;

            if (p.autoFontColor || item.fontColor) {
                var fontColors = this._initIconColors('font', p);
                while (index && index > (fontColors.length - 1)) {
                    index = index - fontColors.length;
                }

                if (!item.fontColor) {
                    item.fontColor = fontColors[index];
                }
                item._fontColor = item.fontColor ? ";color:" + item.fontColor : '';
            }

            if (p.autoIconColor || item.iconColor) {
                var iconColors = this._initIconColors('icon', p);
                while (index && index > (iconColors.length - 1)) {
                    index = index - iconColors.length;
                }
                if (!item.iconColor) {
                    item.iconColor = iconColors[index];
                }
                item._iconColor = item.iconColor ? ";color:" + item.iconColor : '';
            }

            if (p.autoItemColor || item.itemColor) {
                var itemColors = this._initIconColors('item', p);
                while (index && index > (itemColors.length - 1)) {
                    index = index - itemColors.length;
                }
                if (!item.itemColor) {
                    item.itemColor = itemColors[index];
                }
                item._itemColor = item.itemColor ? ";background-color:" + item.itemColor : '';
                item._fontColor = ';color:#ffffff';
                item._iconColor = ';color:#ffffff';
            }
        },


        updateTagVar: function (tagVar) {
            var items = this.getItems();
            ood.each(items, function (item) {
                if (!item.tagVar) {
                    item.tagVar = {};
                }
                ood.merge(item.tagVar, tagVar, 'all');
            })
        },


        /*
        [x] ,valid id   ,true  => insert [x] before node
        [x] ,valid id   ,false => insert [x ]after node
        [x] ,null ,true  => insert [x ] to head
        [x] ,null ,false => insert [x ] to tail
        */
        insertItems2: function (arr, base/*true: the current item*/, before, all) {
            var arr2 = ood.clone(arr);
            if (ood.isHash(arr2)) {
                delete arr2.sub;
                delete arr2.bindClass;
                delete arr2.currentClassName;
            }
            this.insertItems(arr2, base/*true: the current item*/, before, all);
        },
        insertItems: function (arr, base/*true: the current item*/, before, all) {
            var node, arr2,
                items, index, r, v, prop,
                data, box,
                ns = this,
                b = ns._afterInsertItems;
            return this.each(function (profile) {
                box = profile.box;
                arr2 = box._adjustItems(arr);
                prop = profile.properties;

                if (base === true) {
                    v = prop.$UIvalue || prop.value;
                    if (v) v = (v + '').split(prop.valueSeparator);
                    k = profile.getItemByItemId(v[0]);
                    base = k ? k.id : null;
                }

                items = profile.properties.items;
                index = ood.arr.subIndexOf(items, 'id', base);

                //if in dom, create it now
                if (profile.renderId) {
                    // prepare properties format
                    data = box._prepareItems(profile, arr2);

                    r = profile._buildItems('items', data);

                    // try to render inner ood.UI
                    if (profile.$attached) {
                        for (var i = 0, v; v = profile.$attached[i++];) {
                            //(profile.$innerObj||(profile.$innerObj=[])).push(v);
                            if (v._render) v._render(true);
                            if ((t = v._render_holder || v._inline_holder) && t.$afterAttached)
                                ood.tryF(t.$afterAttached, [v], t);
                            else
                                ood.tryF(ns.$afterAttached, [v], ns);
                        }
                        delete profile.$attached;
                    }

                    if (index == -1) {
                        //if no base specified
                        node = profile.getSubNode(box._ITEMSKEY || profile.keys.ITEMS || profile.keys.KEY);
                        //items.length==1 for that one have fake item(for example: editable poll)
                        if (before)
                            node.prepend(r);
                        else
                            node.append(r);
                    } else {
                        node = profile.getSubNodeByItemId(box._ITEMKEY || 'ITEM', base);
                        if (before)
                            node.addPrev(r);
                        else
                            node.addNext(r);
                    }
                }

                //must be here
                if (index == -1) {
                    ood.arr.insertAny(items, arr2, before ? 0 : -1);
                } else
                    ood.arr.insertAny(items, arr2, before ? index : index + 1);

                if (b)
                    profile.boxing()._afterInsertItems(profile, data, base, before);

                // try to hide ui-no-children node
                // logic must same to doFilter
                if (profile.$itemFilter) {
                    var hideItems = [];
                    ood.arr.each(arr, function (item) {
                        if (item.sub && !item.hidden) {
                            //  if(!item._checked && item.id)
                            //      ns.toggleNode(item.id, true, false, true);
                            if (true !== profile.$itemFilter(item, 'checkSub', profile)) {
                                var flag;
                                for (var i = 0, l = item.sub.length; i < l; i++) {
                                    if (!item.sub[i].hidden) {
                                        flag = 1;
                                        break;
                                    }
                                }
                                if (!flag) hideItems.push(item.id);
                            } else {
                                hideItems.push(item.id);
                            }
                        }
                    });
                    if (hideItems.length) ns.showItems(hideItems, false);
                }
            });
        },
        removeItems: function (arr/*default is the current*/, key, purgeNow) {
            var obj, v,
                b = this._afterRemoveItems;
            remove = function (profile, arr, target, data, ns, force) {
                var self = arguments.callee;
                if (!ns) ns = ood();
                ood.filter(arr, function (o) {
                    var serialId, b;
                    if (force || (b = (ood.arr.indexOf(target, o.id) != -1))) {
                        if (profile.renderId) {
                            if (serialId = profile.ItemIdMapSubSerialId[o.id]) {
                                data.push(ood.copy(profile.SubSerialIdMapItem[serialId]));
                                // clear maps
                                delete profile.SubSerialIdMapItem[serialId];
                                delete profile.ItemIdMapSubSerialId[o.id];
                                profile.reclaimSubId(serialId, 'items');

                                //parent node is deleted
                                if (!force) {
                                    if (!(obj = profile.getSubNode(profile.keys[key] ? key : (profile.box._ITEMKEY || 'ITEM'), serialId)).isEmpty())
                                        ns.merge(obj);
                                    //for inner template or ood.UI
                                    if (o.$xid) ns.get().push(ood.getObject(o.$xid).getRootNode());
                                }
                            }
                        }
                    }
                    //check sub
                    if (o.sub) self(profile, o.sub, target, data, ns, force || b);
                    //filter it
                    if (b) {
                        for (var i in o) o[i] = null;
                        return false;
                    }
                });
                ns.remove(true, purgeNow);
            };
            return this.each(function (profile) {
                var p = profile.properties, data = [];
                arr = ood.isHash(arr) ? [arr.id] : ood.isArr(arr) ? arr : arr === 0 ? [0] : arr ? (arr + "").split(p.valueSeparator) : null;
                if (!arr) arr = ((p.$UIvalue || p.value) + "").split(p.valueSeparator);
                ood.arr.each(arr, function (o, i) {
                    arr[i] = '' + (ood.isNumb(o) ? p.items && p.items[o].id : ood.isHash(o) ? o.id : o)
                });
                // clear properties
                remove(profile, p.items, arr, data);
                // clear value
                if (v = p.$UIvalue) {
                    if ((v = ('' + v).split(p.valueSeparator)).length > 1) {
                        ood.filter(v, function (o) {
                            return ood.arr.indexOf(arr, o) == -1;
                        });
                        p.$UIvalue = v.join(p.valueSeparator);
                    } else {
                        if (ood.arr.indexOf(arr, p.$UIvalue) != -1)
                            p.$UIvalue = null;
                    }
                }
                if (b && profile.renderId)
                    profile.boxing()._afterRemoveItems(profile, data);
            });
        },
        clearItems: function (purgeNow) {
            return this.each(function (profile) {
                var prop = profile.properties;
                if (profile.SubSerialIdMapItem) {
                    //empty dom
                    if (profile.renderId) {
                        profile.getSubNode(profile.keys[profile.box._ITEMKEY || 'ITEM'], true).remove(true, purgeNow);
                    }
                    //save subid
                    ood.each(profile.SubSerialIdMapItem, function (o, serialId) {
                        profile.reclaimSubId(serialId, 'items');
                    });
                    //clear cache
                    profile.SubSerialIdMapItem = {};
                    profile.ItemIdMapSubSerialId = {};
                }

                //delete items
                prop.items.length = 0;
                prop.$UIvalue = null;
                //keep the value
                //prop.value=null;
            });
        },
        updateItem: function (itemId/*default is the current*/, options) {
            var self = this,
                profile = self.get(0), v,
                prop = profile.properties;

            itemId = ood.isHash(itemId) ? itemId.id : itemId === 0 ? 0 : itemId ? (itemId + '') : null;
            if (ood.isNumb(itemId)) itemId = ood.get(prop.items, [itemId, "id"]);
            if (!itemId) {
                v = prop.$UIvalue || prop.value;
                if (v) v = (v + '').split(prop.valueSeparator);
                v = profile.getItemByItemId(v[0]);
                itemId = v ? v.id : null;
            }
            var box = profile.box,
                items = prop.items,
                rst = profile.queryItems(items, function (o) {
                    return typeof o == 'object' ? o.id === itemId : o == itemId
                }, true, true, true),
                nid, item, serialId, arr, node, oldsub, t;
            if (!ood.isHash(options)) options = {caption: options + ''};

            if (rst && rst.length) {
                rst = rst[0];
                if (typeof rst[0] != 'object')
                    item = rst[2][rst[1]] = {id: rst[0]};
                else
                    item = rst[0];

                // [[modify id
                if (ood.isSet(options.id)) options.id += "";
                if (options.id && itemId !== options.id) {
                    nid = options.id;
                    var m2 = profile.ItemIdMapSubSerialId, v;
                    if (!m2[nid]) {
                        if (v = m2[itemId]) {
                            m2[nid] = v;
                            delete m2[itemId];
                            profile.SubSerialIdMapItem[v].id = nid;
                        } else {
                            item.id = nid;
                        }
                    }
                }
                delete options.id;
                // modify id only
                if (ood.isEmpty(options))
                    return self;
                //]]

                //in dom already?
                node = profile.getSubNodeByItemId('ITEM', nid || itemId);
                if (!node.isEmpty()) {
                    //for the sub node
                    if ('sub' in options) {
                        delete item._created;
                        delete item._checked;
                        delete item._inited;

                        // destroy all sub dom
                        if (item.sub) {
                            var sub = [];
                            ood.arr.each(item.sub, function (o) {
                                sub.push(o.id);
                            });
                            self.removeItems(sub);
                        }
                    }
                    // keep sub nodes
                    else if (item.sub) {
                        oldsub = profile.getSubNodeByItemId('SUB', nid || itemId);
                    }

                    //merge options
                    ood.merge(item, options, 'all');
                    //prepared already?
                    serialId = ood.get(profile, ['ItemIdMapSubSerialId', nid || itemId]);
                    arr = box._prepareItems(profile, [item], item._pid, false, serialId);
                    node.replace(profile._buildItems(arguments[2] || 'items', arr), false);

                    // restore sub nodes
                    if (oldsub && !oldsub.isEmpty()) {
                        if (!(t = profile.getSubNodeByItemId('SUB', nid || itemId)).isEmpty())
                            t.replace(oldsub);
                    }
                    if (typeof self.setUIValue == 'function') {
                        var uiv = prop.$UIvalue || "", arr = ('' + uiv).split(prop.valueSeparator);
                        if (arr.length && ood.arr.indexOf(arr, itemId) != -1) {
                            if (nid) {
                                ood.arr.removeValue(arr, itemId);
                                arr.push(item.id);
                                // id changed
                                self.setUIValue(arr.join(prop.valueSeparator), true, null, 'update');
                            } else {
                                // id didn't change, but item refreshed
                                self._setCtrlValue(uiv)
                            }
                        }
                    }
                } else {
                    //merge options
                    ood.merge(item, options, 'all');
                }

                if (box.$Behaviors.PanelKeys) {
                    var hash = {};
                    if (options.hasOwnProperty('panelBgClr')) hash["background-color"] = options.panelBgClr;
                    if (options.hasOwnProperty('panelBgImg')) {
                        hash["background-image"] = options.panelBgImg ? ("url(" + ood.adjustRes(options.panelBgImg) + ")") : "";
                    }
                    if (options.hasOwnProperty('panelBgImgPos')) hash["position-color"] = options.panelBgImgPos;
                    if (options.hasOwnProperty('panelBgImgRepeat')) hash["background-repeat"] = options.panelBgImgRepeat;
                    if (options.hasOwnProperty('panelBgImgAttachment')) hash["background-attachment"] = options.panelBgImgAttachment;
                    if (options.hasOwnProperty('overflow')) {
                        var v = options.overflow;
                        if (v) {
                            if (v.indexOf(':') != -1) {
                                ood.arr.each(v.split(/\s*;\s*/g), function (s) {
                                    var a = s.split(/\s*:\s*/g);
                                    if (a.length > 1) {
                                        hash[ood.str.trim(a[0])] = ood.str.trim(a[1] || '');
                                    }
                                });
                            }
                        }
                        hash.overflow = v || "";
                    }
                    if (!ood.isEmpty(hash)) {
                        ood.arr.each(box.$Behaviors.PanelKeys, function (k) {
                            panel = profile.getSubNode(k, nid || itemId).css(hash);
                        });
                    }
                }
            }
            return self;
        },
        // filter: [true] => filter out
        doFilter: function (itemFilter, helper, reLayout) {
            var ns = this,
                profile = ns.get(0);
            if (profile) {
                if (!itemFilter) {
                    if (profile.$itemFilter) {
                        delete profile.$itemFilter;
                        itemFilter = function () {
                            return false
                        };
                    } else return this;
                } else if (ood.isFun(itemFilter)) {
                    profile.$itemFilter = itemFilter;
                } else if (itemFilter === true) {
                    itemFilter = profile.$itemFilter;
                }
                ood.resetRun(profile.$xid + ':itemFilter', function () {
                    itemFilter('begin', 'doFilter', profile)

                    var prop = profile.properties,
                        items = prop['rows'] || prop['items'],
                        showItems = [],
                        hideItems = [],
                        f1 = function (items, showItems, hideItems) {
                            var count = 0, rtn;
                            ood.arr.each(items, function (item) {
                                if (item.sub) {
                                    // check parent node first
                                    if (true === itemFilter(item, helper, profile)) {
                                        count++;
                                        if (item.hidden) showItems.push(item.id);
                                    } else {
                                        // ensure open all tree nodes
                                        //if(!item._checked && item.id)
                                        //    (ns['toggleRow']||ns['toggleNode']).call(ns, item.id, true, false, true);
                                        // check sub showed count next
                                        if (f1(item.sub, showItems, hideItems)) {
                                            count++;
                                            if (item.hidden) showItems.push(item.id);
                                        } else {
                                            if (!item.hidden) hideItems.push(item.id);
                                        }
                                    }
                                } else {
                                    if (itemFilter(item, helper, profile)) {
                                        if (!item.hidden) hideItems.push(item.id);
                                    } else {
                                        count++;
                                        if (item.hidden) showItems.push(item.id);
                                    }
                                }
                            });
                            return count;
                        };
                    f1(items, showItems, hideItems);
                    itemFilter('end', 'doFilter', profile)

                    // reflect to dom
                    if (showItems.length) (ns['showRows'] || ns['showItems']).call(ns, showItems);
                    if (hideItems.length) (ns['showRows'] || ns['showItems']).call(ns, hideItems, false);
                    if (reLayout !== false) ns.reLayout(true);
                });
            }
            return this;
        },


        hideItems: function (itemId) {
            return this.showItems(itemId, false);
        },
        showItems: function (itemId/*default is the current*/, show) {
            var ns = this,
                profile = ns.get(0),
                showNodes = ood(),
                hideNodes = ood(),
                prop = profile.properties;
            itemId = ood.isHash(itemId) ? itemId.id : ood.isArr(itemId) ? itemId : itemId === 0 ? [0] : itemId ? (itemId + "").split(prop.valueSeparator) : null;
            if (!itemId) itemId = ((prop.$UIvalue || prop.value) + "").split(prop.valueSeparator);
            if (itemId && itemId.length) {
                ood.arr.each(itemId, function (r, item) {
                    if (item = ns.getItemByItemId(r)) {
                        if (show === false) {
                            if (!item.hidden) hideNodes.merge(ns.getSubNodeByItemId('ITEM', item.id));
                        } else {
                            if (item.hidden) showNodes.merge(ns.getSubNodeByItemId('ITEM', item.id));
                        }
                        item.hidden = show === false;
                    }
                });
            }
            // reflect to dom
            if (!showNodes.isEmpty()) showNodes.css('display', '');
            if (!hideNodes.isEmpty()) hideNodes.css('display', 'none');
            return this;
        },
        getItems: function (type, v) {
            v = v || this.get(0).properties.items;
            if (type == 'data')
                return ood.clone(v, true);
            else if (type == 'min') {
                var a = ood.clone(v, true), b;
                ood.arr.each(a, function (o, i) {
                    a[i] = o.id;
                });
                return a;
            } else
                return v;
        },
        focusItem: function (itemId) {
            this.getSubNodeByItemId(this.constructor._focusNodeKey, itemId).focus(true);
            return this;
        },
        scrollIntoView: function (itemId) {
            itemId = this.getSubNodeByItemId(this.constructor._focusNodeKey, itemId);
            if (itemId = itemId.get(0)) itemId.scrollIntoView();
            return this;
        },
        selectItem: function (itemId) {
            return this.fireItemClickEvent(itemId);
        },
        fireItemClickEvent: function (itemId) {
            this.getSubNodeByItemId(this.constructor._focusNodeKey, itemId).onClick();
            return this;
        },
        editItem: function (itemId/*default is the current*/) {
            var profile = this.get(0),
                prop = profile.properties,
                item, source, v;
            if (profile && profile.renderId && !profile.destroyed) {
                itemId = ood.isHash(itemId) ? itemId.id : itemId === 0 ? 0 : itemId ? (itemId + '') : null;
                if (ood.isNumb(itemId)) itemId = ood.get(prop.items, [itemId, "id"]);
                if (!itemId) {
                    v = prop.$UIvalue || prop.value;
                    if (v) v = (v + '').split(prop.valueSeparator);
                    v = profile.getItemByItemId(v[0]);
                    itemId = v ? v.id : null;
                }
                if (itemId) {
                    if (item = profile.getItemByItemId(itemId)) {
                        source = profile.getSubNodeByItemId('ITEMCAPTION', itemId);
                        if (source.isEmpty()) source = profile.getSubNodeByItemId('CAPTION', itemId);
                        if (!source.isEmpty()) {
                            var pp = source.parent(),
                                cb = ood.browser.contentBox,
                                pos = source.offset(null, pp.get(0)),
                                size = source.cssSize(),
                                pos2 = pp.offset(),
                                size2 = pp.cssSize();

                            // adjust
                            pos2.left += !cb ? 0 : source._paddingW('left');
                            pos2.top += !cb ? 0 : source._paddingH('top');
                            size2.height += !cb ? 0 : source._paddingH();

                            var editor;
                            if (profile.beforeIniEditor) {
                                editor = profile.boxing().beforeIniEditor(profile, item, source);
                                if (editor === false)
                                    return;
                            }

                            if (!editor || !editor['ood.UI']) {
                                var editor = new ood.UI.ComboInput({type: "input"});
                                editor.setWidth(Math.max(size2.width - pos.left, 40))
                                    .setHeight(Math.max(size2.height, 20))
                                    .setResizer(true)
                                    .setValue(item.caption || "");
                                if (profile.onBeginEdit) profile.boxing().onBeginEdit(profile, item, editor);
                                var undo = function () {
                                    // ays is a must
                                    ood.resetRun('absList_editor_reset', function () {
                                        if (editor && !editor.isDestroyed()) {
                                            editor.getRoot().setBlurTrigger("absList_editor_blur", null);
                                            editor.destroy();
                                            editor = null;
                                        }
                                    });
                                };
                                editor.beforeUIValueSet(function (prf, ov, nv, force, tag) {
                                    if (false !== (profile.beforeEditApply && profile.boxing().beforeEditApply(profile, item, nv, editor, tag))) {
                                        profile.boxing().updateItem(item.id, {caption: nv});
                                        if (profile.onEndEdit) profile.boxing().onEndEdit(profile, item, editor);
                                        undo();
                                    }
                                }).onCancel(function () {
                                    undo();
                                });
                                ood('body').append(editor);
                                var root = editor.getRoot();

                                root.popToTop({
                                    left: pos.left + pos2.left,
                                    top: pos2.top
                                });
                                // For scroll to undo
                                root.setBlurTrigger("absList_editor_blur", function () {
                                    undo();
                                });
                                editor.activate();
                            }
                        }
                    }
                }
            }
            return this;
        },
        getSelectedItem: function () {
            var uiv = this.getUIValue(true),
                prf = this.get(0),
                items = [],
                item;
            if (ood.isArr(uiv)) {
                if (uiv.length) {
                    ood.arr.each(uiv, function (id) {
                        if (item = prf.getItemByItemId(id)) {
                            items.push(item);
                        }
                    });
                    return items;
                }
            } else if (uiv) {
                return prf.getItemByItemId(uiv);
            }
        }
    },
    Initialize: function () {
        var o = this.prototype;
        ood.arr.each(ood.toArr('getItemByItemId,getItemByItemCaption,getItemByDom,getSubIdByItemId,getSubNodeByItemId'), function (s) {
            o[s] = function () {
                var t = this.get(0);
                return t[s].apply(t, arguments);
            };
            ood.Class._fun(o[s], s, o.KEY, null, 'instance');
        });
    },
    Static: {
        _focusNodeKey: 'ITEM',
        $abstract: true,
        // for item in box array
        _ensureValues: ood.UI._ensureValues,

        DataModel: {
            listKey: {
                set: function (value) {
                    var o = this,
                        t = o.box.getCachedData(value);
                    if (t)
                        o.boxing().setItems(ood.clone(t));
                    else
                        o.boxing().setItems(o.properties.items);
                    o.properties.listKey = value;
                }
            },
            items: {
                ini: [],
                set: function (value) {
                    var o = this,
                        ins = o.boxing(),
                        items = o.properties.items,
                        children, ia, bv;

                    //bak value
                    if (typeof ins.setValue == 'function') {
                        bv = o.properties.value;
                        if (bv && value && value.length) {
                            var i = ood.arr.indexOf(value, bv);
                            if (i === -1)
                                i = ood.arr.subIndexOf(value, "id", o.properties.value);
                            //    if(i===-1)
                            //       bv=value?value[0]?value[0].id?value[0].id:value[0]:"":"";
                        }
                    }

                    // keep children objects
                    if (items && items.length) {
                        if (o.children && o.children.length) {
                            // use UIProfile's serialize function for module case
                            ood.arr.each(children = o.serialize(false, true).children, function (arr) {
                                if (arr[1]) {
                                    var i = ood.arr.indexOf(items, arr[1]);
                                    if (i === -1)
                                        i = ood.arr.subIndexOf(items, "id", arr[1]);
                                    if (i !== -1)
                                        arr[2] = i;
                                }
                            });
                            // destroy all
                            ins.removeChildren(true, true, true);
                        }
                        ins.clearItems(true, true);
                    }

                    ins.insertItems(value ? ood.copy(value) : null, null, null, true);

                    // restore children
                    if (value && value.length && children) {
                        var hash = {}, rhash = {}, len = value.length;
                        ood.arr.each(value, function (item, i) {
                            hash[item.id || item] = i;
                            rhash[i] = item.id || item;
                        });
                        ood.arr.each(children, function (arr) {
                            var added, t;
                            if (ood.isSet(arr[1])) {
                                // add by id
                                if (ood.isSet(hash[arr[1]])) {
                                    t = ood.create(arr[0]);
                                    if (o.$panelRestore) o.$panelRestore(t.get(0));
                                    ins.append(t, arr[1]);
                                    added = 1;
                                } else {
                                    // add by index
                                    if (rhash[arr[2]]) {
                                        t = ood.create(arr[0]);
                                        if (o.$panelRestore) o.$panelRestore(t.get(0));
                                        ins.append(t, rhash[arr[2]]);
                                        added = 1;
                                    }
                                }
                            }
                            if (!added) {
                                t = ood.create(arr[0]);
                                if (o.$panelRestore) o.$panelRestore(t.get(0));
                                ins.append(t, bv);
                            }
                        });
                    }

                    //try to set value
                    if (ood.isSet(bv)) {
                        ins.setValue(bv, true, 'items');
                    }

                    if (o.renderId) {
                        o.adjustSize();
                    }
                }
            },
            dragSortable: false,
            valueSeparator: ';'
        },
        RenderTrigger: function () {
            this.destroyTrigger = function () {
                ood.each(this.SubSerialIdMapItem, function (o) {
                    ood.breakO(o)
                });
                this.properties.items.length = 0;
            };
        },
        EventHandlers: {
            beforePrepareItem: function (profile, item, pid) {
            },
            beforeIniEditor: function (profile, item, captionNode) {
            },
            onBeginEdit: function (profile, item, editor) {
            },
            beforeEditApply: function (profile, item, caption, editor, tag) {
            },
            onEndEdit: function (profile, item, editor) {
            }
        },
        getDropKeys: function (profile, node) {
            var item = profile.getItemByDom(node);
            return (item && item.dropKeys) || profile.properties.dropKeys;
        },
        getDragKey: function (profile, node) {
            var item = profile.getItemByDom(node);
            return (item && item.dragKey) || profile.properties.dragKey || (profile.properties.dragSortable && (profile.key + ":" + profile.$xid));
        },
        _adjustItems: function (arr) {
            if (!ood.isSet(arr)) arr = [];
            if (!ood.isArr(arr)) arr = [arr];
            var a = ood.copy(arr), m;
            ood.arr.each(a, function (o, i) {
                if (ood.isArr(o) && o.length) {
                    a[i] = {id: o[0]};
                    a[i].id = ood.isSet(a[i].id) ? (a[i].id + '') : ood.id();
                    if (ood.isSet(o[1])) a[i].caption = o[1] + '';
                } else if (ood.isHash(o)) {
                    a[i] = ood.copy(o);
                    a[i].id = ood.isSet(a[i].id) ? (a[i].id + '') : ood.id();
                } else
                    a[i] = {id: o + ''};
            });
            return a;
        },
        //
        _showTips: function (profile, node, pos) {
            if (profile.properties.disableTips) return;
            if (profile.onShowTips)
                return profile.boxing().onShowTips(profile, node, pos);
            if (!ood.Tips) return;

            var t = profile.properties,
                id = node.id,
                sid = profile.getSubId(id),
                map = profile.SubSerialIdMapItem,
                item = map && map[sid];

            if (item && ('tips' in item)) {
                if (item.tips) ood.Tips.show(pos, item);
                else ood.Tips.hide();
                return false;
            } else if (profile.properties.autoTips && item && 'caption' in item) {
                if (item.caption || item.comment) ood.Tips.show(pos, {tips: ood.adjustRes((item.caption || '') + (item.caption || item.comment ? '<br/>' : '') + (item.comment || ''), true, false, null, null, item)});
                else ood.Tips.hide();
                return false;
            } else
                return true;
        }
    }
});

//absValue Class
ood.Class("ood.absValue", "ood.absObj", {
    Instance: {
        /*
        getUIValue:         return $UIvalue
        setUIValue:         set $UIvalue,and _setCtrlValue                   beforeUIValueSet/afterUIValueSet
        getValue:           return value
        setValue:           set value, set $UIvalue, and _setCtrlValue       beforeValueSet/afterValueSet
        resetValue:         reset value,UIvalue,Ctrlvalue not trigger event
        updateValue:        set $UIvalue to value

        _setCtrlValue:      change control value                *need to be overwritten
        _getCtrlValue:      get value from control              *need to be overwritten
        _setDirtyMark:      mark UI ctrl when value!==UIvalue   *need to be overwritten
        */
        _getCtrlValue: function () {
            return this.get(0).properties.$UIvalue
        },
        _getCtrlCatpionValue: function () {
            return this.get(0).properties.$UICatpionValue
        },
        _setCtrlValue: function (value) {
            return this
        },
        _setDirtyMark: function (key) {
            return this.each(function (profile) {
                if (!profile.renderId) return;
                var properties = profile.properties,
                    flag = properties.value !== properties.$UIvalue,
                    o = profile.getSubNode(key || profile.box.DIRYMARKICON || "KEY"),
                    d = ood.UI.$css_tag_dirty;
                if (profile._dirtyFlag !== flag) {
                    if (properties.dirtyMark && properties.showDirtyMark) {
                        if (profile.beforeDirtyMark && false === profile.boxing().beforeDirtyMark(profile, flag)) {
                        }
                        else {
                            if (flag) o.addClass(d);
                            else o.removeClass(d);
                        }
                    }
                    profile._dirtyFlag = flag;
                }
            });
        },
        getValue: function (returnArr) {
            var prf = this.get(0),
                prop = prf.properties,
                v = prop.value;

            if (prf.box.$valuemode == 'multi')
                if (returnArr)
                    if (ood.isStr(v))
                        v = v.split(prop.valueSeparator);

            if (prf.box.$DataModel.selMode && (prop.selMode == 'multi' || prop.selMode == 'multibycheckbox') && returnArr) {
                if (ood.isStr(v))
                    v = v.split(prop.valueSeparator);
                if (v && ood.isArr(v) && v.length > 1)
                    v.sort();
            }
            return v;
        },


        getSelectedItem: function () {
            var uiv = this.getUIValue(true),
                prf = this.get(0),
                items = [],
                item;
            if (ood.isArr(uiv)) {
                if (uiv.length) {
                    ood.arr.each(uiv, function (id) {
                        if (item = prf.getItemByItemCaption(id)) {
                            items.push(item);
                        }
                    });
                    return items;
                }
            } else if (uiv) {
                return prf.getItemByItemCaption(uiv);
            }
        },


        setCaptionValue: function (value) {
            var prf = this.get(0),
                prop = prf.properties;
            prop.$CaptionValue = value;

        },


        _eachValue: function (captionarr, item, key) {
            var values = this.getUIValue(true);
            var ui = this;
            ood.each(item.sub, function (subitem) {
                if (ood.arr.indexOf(values, subitem[key]) > -1) {
                    captionarr.push(subitem.caption)
                }

                if (subitem.sub) {
                    captionarr = ui._eachValue(captionarr, subitem, key);
                }
            });
            return captionarr;
        },

        getCaptionValue: function (key) {
            var prf = this.get(0), prop = prf.properties;
            var cationarr = [];
            var ui = this;
            var items = this.getItems('data');
            var values = this.getUIValue(true);
            if (!key) {
                key = 'id'
            }
            ood.each(items, function (item) {
                if (ood.isArr(values)) {
                    if (ood.arr.indexOf(values, item[key]) > -1) {
                        cationarr.push(item.caption)
                    }
                }
                cationarr = ui._eachValue(cationarr, item, key);
            })
            captionvalue = cationarr.join(prop.valueSeparator);
            return captionvalue;

        },

        getUICationValue: function (returnArr) {
            var prf = this.get(0),
                prop = prf.properties;

            if (!prf.renderId)
                return prop && prop.value;

            var cv = this._getCtrlValue(), v;
            if (!prf.box._checkValid || false !== prf.box._checkValid(prf, cv))
                prop.caption = cv;
            v = prop.caption;

            if (prf.box.$valuemode == 'multi')
                if (returnArr)
                    if (ood.isStr(v))
                        v = v.split(prop.valueSeparator);

            if (prf.box.$DataModel.selMode && (prop.selMode == 'multi' || prop.selMode == 'multibycheckbox') && returnArr) {
                if (ood.isStr(v))
                    v = v.split(prop.valueSeparator);
                if (v && ood.isArr(v) && v.length > 1)
                    v.sort();
            }
            return v;
        },

        getUIValue: function (returnArr) {
            var prf = this.get(0),
                prop = prf.properties;

            if (!prf.renderId)
                return prop && prop.value;

            var cv = this._getCtrlValue(), v;
            if (!prf.box._checkValid || false !== prf.box._checkValid(prf, cv))
                prop.$UIvalue = cv;
            v = prop.$UIvalue;

            if (prf.box.$valuemode == 'multi')
                if (returnArr)
                    if (ood.isStr(v))
                        v = v.split(prop.valueSeparator);

            if (prf.box.$DataModel.selMode && (prop.selMode == 'multi' || prop.selMode == 'multibycheckbox') && returnArr) {
                if (ood.isStr(v))
                    v = v.split(prop.valueSeparator);
                if (v && ood.isArr(v) && v.length > 1)
                    v.sort();
            }
            return v;
        },
        resetValue: function (value) {
            var self = this;
            self.each(function (profile) {
                var r, pro = profile.properties, ins = profile.boxing(),
                    v = typeof (r = profile.box._ensureValue) == 'function' ? r.call(profile.box, profile, value) : value;
                if (pro.value !== v || pro.$UIvalue !== v) {
                    if (profile.box._beforeResetValue) profile.box._beforeResetValue(profile);
                    if (typeof(r = profile.$onValueSet) == 'function') {
                        r = r.call(profile, pro.value, v);
                        if (ood.isSet(r)) v = r;
                    }

                    // _setCtrlValue maybe use $UIvalue
                    profile.boxing()._setCtrlValue(pro.value = v);
                    // So, maintain $UIvalue during _setCtrlValue call
                    pro.$UIvalue = v;
                }
                profile._inValid = 1;
                ins._setDirtyMark();
            });
            return self;
        },
        setUIValue: function (value, force, triggerEventOnly, tag) {
            var self = this;
            this.each(function (profile) {
                var prop = profile.properties, r,
                    ovalue = prop.$UIvalue,
                    box = profile.boxing();
                if (force || (ovalue !== value)) {
                    if (
                        (profile.box._checkValid && false === profile.box._checkValid(profile, value)) ||
                        (profile.beforeUIValueSet && false === (r = box.beforeUIValueSet(profile, ovalue, value, force, tag)))
                    )
                        return;

                    //can get return value
                    if (r !== undefined && typeof r !== 'boolean') value = r;
                    //before _setCtrlValue
                    if (profile.box && (typeof (r = profile.box._ensureValue) == 'function'))
                        value = r.call(profile.box, profile, value);
                    if (typeof(r = profile.$onUIValueSet) == 'function') {
                        r = r.call(profile, value, force, tag);
                        if (ood.isSet(r)) value = r;
                    }

                    //before value copy
                    var cv;
                    if (profile.renderId && !triggerEventOnly) {
                        cv = 1;
                        box._setCtrlValue(value);
                    }

                    //value copy
                    prop.$UIvalue = value;

                    if (profile.renderId && !triggerEventOnly) box._setDirtyMark();

                    if (profile.afterUIValueSet) box.afterUIValueSet(profile, ovalue, value, force, tag);
                    if (profile._onChange) box._onChange(profile, ovalue, value, force, tag);
                    if (profile.onChange) box.onChange(profile, ovalue, value, force, tag);

                    if (!prop.dirtyMark)
                        box.setValue(value, false, 'uiv', cv || triggerEventOnly);

                    if (prop.excelCellId && box.notifyExcel) {
                        box.notifyExcel(false);
                    }
                }
            });
            return this;
        },
        updateValue: function () {
            return this.each(function (profile) {
                var prop = profile.properties;
                if (prop.value !== prop.$UIvalue) {
                    var ins = profile.boxing();
                    if (ins.checkValid()) {
                        // prop.value = ins.getUIValue();
                        ins.setValue(ins.getUIValue(), true, 'update');
                        ins._setDirtyMark();
                    }
                }
            });
        },
        isDirtied: function () {
            var dirtied = false;
            this.each(function (profile) {
                var p = profile.properties;

                // inner value is alway string
                dirtied = (p.value + " ") !== (p.$UIvalue + " ");
                if (dirtied)
                    return false;
            });
            return dirtied
        },
        checkValid: function (value) {
            var prop, tr, r = true, outv = ood.isSet(value);
            this.each(function (profile) {
                prop = profile.properties;
                tr = true;

                // for checking html ctrl valid, <input> only
                if (profile.box._checkValid2)
                // r must be at the end
                    r = (tr = profile.box._checkValid2(profile)) && r;
                if (tr && profile.box._checkValid)
                //r must be at the end
                    r = profile.box._checkValid(profile, outv ? value : prop.$UIvalue) && r;

                if (!outv && profile.renderId)
                    profile.boxing()._setDirtyMark();
            });
            return r;
        }
    },
    Static: {
        $abstract: true,
        DataModel: {
            readonly: {
                ini: false,
                action: function (v) {
                    var i = this.getRoot();
                    if (v)
                        i.addClass('ood-ui-readonly');
                    else
                        i.removeClass('ood-ui-readonly');
                }
            },
            required: {
                ini: false,
                // mark required
                action: function (v) {
                    // if (this.keys['LABEL']) {
                    //     var node = this.getSubNode('LABEL');
                    //     if (v) node.addClass('ood-required');
                    //     else node.removeClass('ood-required');
                    // }
                    if (v) this.getRoot().addClass('ood-required-field');
                    else this.getRoot().removeClass('ood-required-field');
                }
            },
            // setValue and getValue
            value: {
                ini: null,
                set: function (value, force, tag, triggerEventOnly) {
                    var profile = this,
                        p = profile.properties, r,
                        ovalue = p.value,
                        box = profile.boxing();

                    //check format
                    if (profile.box._checkValid && profile.box._checkValid(profile, value) === false) return;
                    //if return false in beforeValueSet, not set
                    if (profile.beforeValueSet && false === (r = box.beforeValueSet(profile, ovalue, value, force, tag))) return;
                    // can get return value
                    if (r !== undefined) value = r;
                    //before _setCtrlValue
                    //ensure value
                    if (typeof (r = profile.box._ensureValue) == 'function')
                        value = r.call(profile.box, profile, value);

                    if (typeof(r = profile.$onValueSet) == 'function') {
                        r = r.call(profile, ovalue, value, force, tag);
                        if (ood.isSet(r)) value = r;
                    }

                    //before value copy
                    if (profile.renderId && !triggerEventOnly) box._setCtrlValue(value);
                    //value copy
                    p.value = p.$UIvalue = value;

                    if (!profile._inValid) profile._inValid = 1;
                    if (profile.renderId) box._setDirtyMark();
                    if (profile.afterValueSet) box.afterValueSet(profile, ovalue, value, force, tag);
                    if (profile.onValueChange) box.onValueChange(profile, ovalue, value, force, tag);
                }
            },
            isFormField: true,
            dirtyMark: true,
            showDirtyMark: true
        },
        // for item in box array
        _ensureValues: ood.UI._ensureValues,
        // for value
        _ensureValue: function (profile, value) {
            var prop = profile.properties;
            if (profile.box.$DataModel.selMode && (prop.selMode == 'multi' || prop.selMode == 'multibycheckbox')) {
                if (!ood.isArr(value)) {
                    value = (value ? ('' + value) : '').split(prop.valueSeparator);
                }
                value.sort();
                return value.join(prop.valueSeparator);
            } else
                return ood.isArr(value) ? value[0] : value;
        },
        EventHandlers: {
            //real value set
            beforeValueSet: function (profile, oldValue, newValue, force, tag) {
            },
            afterValueSet: function (profile, oldValue, newValue, force, tag) {
            },
            onValueChange: function (profile, oldValue, newValue, force, tag) {
            },

            //ui value set
            beforeUIValueSet: function (profile, oldValue, newValue, force, tag) {
            },
            afterUIValueSet: function (profile, oldValue, newValue, force, tag) {
            },
            onChange: function (profile, oldValue, newValue, force, tag) {
            },
            _onChange: function (profile, oldValue, newValue, force, tag) {
            },

            beforeDirtyMark: function (profile, dirty) {
            }
        },
        RenderTrigger: function () {
            var self = this, b = self.boxing(), p = self.properties, t;
            // disable dataField for container control
            if (!self.behavior.PanelKeys) {
                if (t = p.dataBinder) b.setDataBinder(t, true);
                if (t = p.dataField) b.setDataField(t);
            }

            if (p.value !== undefined) {
                if (typeof (t = self.box._ensureValue) == 'function') {
                    p.value = t.call(self.box, self, p.value);
                    if (p.$UIvalue)
                        p.$UIvalue = t.call(self.box, self, p.$UIvalue);
                }
                if (!p.$UIvalue)
                    p.$UIvalue = p.value;
                b._setCtrlValue(p.$UIvalue, true);
            }
        }
    }
});

ood.Class("ood.UI.Widget", "ood.UI", {
    Static: {
        Appearances: {
            KEY: {},
            IE67_SHADOW: (ood.browser.ie && ood.browser.ver <= 8) ? {
                'z-index': '-1',
                position: 'absolute',
                left: 0,
                top: 0,
                width: '100%',
                height: '100%',
                overflow: 'visible'
            } : null
        },
        Templates: {
            className: 'ood-uiw-shell {_className} {_requiredfld}',
            style: '{_style}',

            IE67_SHADOW: (ood.browser.ie && ood.browser.ver <= 8) ? {} : null,
            FRAME: {
                $order: 2,
                className: 'ood-uiw-frame ',
                BORDER: {
                    $order: 1,
                    style: 'width:{bWidth};height:{bHeight};',
                    className: 'ood-uiw-border'
                }
            }
        },
        DataModel: {
            width: {
                $spaceunit: 1,
                ini: '10em'
            },
            height: {
                $spaceunit: 1,
                ini: '10em'
            },
            shadow: {
                ini: false,
                action: function (v) {
                    if (ood.browser.ie && ood.browser.ver <= 8) {
                        var node = this.getSubNode('IE67_SHADOW');
                        if (v) node.addClass('ood-ui-shadow ood-uiborder-r ood-uiborder-b ood-uiborder-radius-br');
                        else node.removeClass('ood-ui-shadow ood-uiborder-r ood-uiborder-b ood-uiborder-radius-br');
                    } else {
                        var node = this.getSubNode('BORDER');
                        if (v) node.addClass('ood-ui-shadow');
                        else node.removeClass('ood-ui-shadow');
                    }
                }
            },
            //hide props( with px)
            $hborder: 0,
            $vborder: 0
        },
        RenderTrigger: function () {
            var self = this, p = self.properties, o = self.boxing();

            if (self.renderId)
                if ((!self.$noB) && p.border && o._border) o._border();

            if ((!self.$noR) && p.resizer && o.setResizer) o.setResizer(p.resizer, true);
            if ((!self.$noS) && p.shadow && o.setShadow) o.setShadow(true, true);
        },
        _onresize: function (profile, width, height) {
            var prop = profile.properties,
                border = profile.getSubNode('BORDER'),
                cb = border.contentBox(),
                shadow = (ood.browser.ie && ood.browser.ver <= 8) ? profile.getSubNode('IE67_SHADOW') : null,
                region,
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                //caculate with px
                ww = profile.$px(width),
                hh = profile.$px(height),
                left = !cb ? 0 : Math.max(0, (prop.$b_lw || 0) - (prop.$hborder || 0)),
                top = !cb ? 0 : Math.max(0, (prop.$b_tw || 0) - (prop.$vborder || 0));

            if (ww && 'auto' !== ww) {
                ww -= !cb ? 0 : Math.max((prop.$hborder || 0) * 2, (prop.$b_lw || 0) + (prop.$b_rw || 0));
                /*for ie6 bug*/
                /*for example, if single number, 100% width will add 1*/
                /*for example, if single number, attached shadow will overlap*/
                if (ood.browser.ie && ood.browser.ver <= 6) ww = (profile.$px(ww / 2)) * 2;
            }
            if (hh && 'auto' !== hh) {
                hh -= !cb ? 0 : Math.max((prop.$vborder || 0) * 2, (prop.$b_lw || 0) + (prop.$b_rw || 0));

                if (ood.browser.ie && ood.browser.ver <= 6) hh = (profile.$px(hh / 2)) * 2;
                /*for ie6 bug*/
                if (ood.browser.ie && ood.browser.ver <= 6 && null === width) {
                    border.ieRemedy();
                    if (shadow) shadow.ieRemedy();
                }
            }
            region = {
                left: adjustunit(left),
                top: adjustunit(top),
                width: adjustunit(ww),
                height: adjustunit(hh)
            };
            border.cssRegion(region);
            if (shadow) shadow.cssRegion(region);

            /*for ie6 bug*/
            if ((profile.$resizer) && ood.browser.ie) {
                border.ieRemedy();
                if (shadow) shadow.ieRemedy();
            }
            return region;
        }
    }
});

ood.Class("ood.UI.Link", "ood.UI", {
    Instance: {
        fireClickEvent: function () {
            this.getRoot().onClick();
            return this;
        }
    },
    Static: {
        Appearances: {
            KEY: {
                cursor: 'pointer'
            }
        },
        Templates: {
            tagName: 'a',
            className: '{_className}',
            style: '{_style}',
            href: "{href}",
            target: '{target}',
            tabindex: '{tabindex}',
            text: '{caption}'
        },
        Behaviors: {
            HoverEffected: {KEY: 'KEY'},
            ClickEffected: {KEY: 'KEY'},
            onClick: function (profile, e, src) {
                var r;
                if (!profile.properties.disabled && profile.onClick)
                    r = profile.boxing().onClick(profile, e, src);
                //**** if dont return false, this click will break jsonp in IE
                //**** In IE, click a fake(javascript: or #) href(onclick not return false) will break the current script downloading
                var href = ood.use(src).attr('href');
                return typeof r == 'boolean' ? r : (href.indexOf('javascript:') === 0 || href.indexOf('#') === 0) ? false : true;
            }
        },
        DataModel: {
            caption: {
                ini: undefined,
                action: function (v) {
                    v = (ood.isSet(v) ? v : "") + "";
                    this.getRoot().html(ood.adjustRes(v, true));
                }
            },
            href: {
                ini: ood.$DEFAULTHREF,
                action: function (v) {
                    this.getRoot().attr('href', v);
                }
            },
            target: {
                action: function (v) {
                    this.getRoot().attr('target', v);
                }
            }
        },
        EventHandlers: {
            onClick: function (profile, e) {
            }
        }
    }
});

ood.Class("ood.UI.Element", "ood.UI", {
    Instance: {
        fireClickEvent: function () {
            this.getRoot().onClick();
            return this;
        }
    },
    Static: {
        _objectProp: {attributes: 1},
        Templates: {
            _NativeElement: true,
            tagName: '{nodeName}',
            // dont set class to HTML Element
            className: 'ood-node ood-wrapper {_className}',
            style: '{_style};',
            //for firefox div focus bug: outline:none; tabindex:'-1'
            tabindex: '{tabindex}',
            text: '{html}' + ood.UI.$childTag
        },
        DataModel: {
            width: {
                $spaceunit: 1,
                ini: '8em'
            },
            height: {
                $spaceunit: 1,
                ini: '1em'
            },
            nodeName: {
                ini: "ood",
                action: function (v) {
                    this.boxing().refresh();
                }
            },
            selectable: true,
            html: {
                html: 1,
                action: function (v, ov, force) {
                    this.getRoot().html(ood.adjustRes(v, 0, 1), null, null, force);
                }
            },
            attributes: {
                ini: {},
                action: function (v, ov) {
                    var root = this.getRoot();
                    if (!ood.isEmpty(ov)) {
                        ood.each(ov, function (o, i) {
                            root.attr(i, null);
                        });
                    }
                    if (!ood.isEmpty(v)) {
                        ood.each(v, function (o, i) {
                            root.attr(i, o);
                        });
                    }
                }
            },
            tabindex: -1
        },
        Appearances: {
            KEY: {
                'line-height': 'normal'
            }
        },
        Behaviors: {
            HoverEffected: {KEY: 'KEY'},
            onClick: function (profile, e, src) {
                var p = profile.properties;
                if (p.disabled) return false;
                if (profile.onClick)
                    return profile.boxing().onClick(profile, e, src);
            }
        },
        EventHandlers: {
            onClick: function (profile, e, value) {
            }
        },
        RenderTrigger: function () {
            var v = this.properties.attributes;
            if (!ood.isEmpty(v)) {
                var root = this.getRoot();
                ood.each(v, function (o, i) {
                    root.attr(i, o);
                });
            }
        }
    }
});

ood.Class("ood.UI.Icon", "ood.UI", {
    Instance: {
        iniProp: {
            imageClass: 'ri-image-line',
            fontSize: '3em'
        },
        fireClickEvent: function () {
            this.getRoot().onClick();
            return this;
        }
    },
    Static: {
        Templates: {
            className: 'ood-node ood-wrapper {_className}  {picClass}',
            style: '{_style};',
            ICON: {
                className: 'oodcon {imageClass}',
                style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{imageDisplay}{_fontsize}{_fontclr}{iconStyle}',
                text: '{iconFontCode}'
            }
        },
        DataModel: {
            selectable: null,
            html: null,
            attributes: null,
            renderer: null,
            defaultFocus: null,
            tabindex: -1,
            image: {
                format: 'image',
                action: function (v) {
                    ood.UI.$iconAction(this);
                }
            },
            imagePos: {
                action: function (v) {
                    this.getSubNode('ICON').css('backgroundPosition', v || 'center');
                }
            },
            imageBgSize: {
                action: function (v) {
                    this.getSubNode('ICON').css('backgroundSize', v || '');
                }
            },
            imageClass: {
                ini: '',
                action: function (v, ov) {
                    ood.UI.$iconAction(this, 'ICON', ov);
                }
            },
            iconFontCode: {
                action: function (v) {
                    ood.UI.$iconAction(this);
                }
            },
            iconFontSize: {
                action: function (v) {
                    this.getSubNode('ICON').css('fontSize', v || '');
                }
            },
            iconColor: {
                type: 'color',
                action: function (v) {
                    this.getSubNode('ICON').css('color', v || '');
                }
            }
        },
        Appearances: {
            KEY: {
                'overflow': 'visible'
            },
            ICON: {
                'position': 'relative',
                display: ood.$inlineBlock,
                zoom: ood.browser.ie ? 1 : null
            }
        },
        Behaviors: {
            HoverEffected: {ICON: 'ICON'},
            ClickEffected: {ICON: 'ICON'},
            onClick: function (profile, e, src) {
                var p = profile.properties;
                if (p.disabled) return false;
                if (profile.onClick)
                    return profile.boxing().onClick(profile, e, src);
            }
        },
        EventHandlers: {
            onClick: function (profile, e, value) {
            }
        },
        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile);
            if (data.iconFontSize) data._fontsize = data.iconFontSize + ';';
            if (data.iconColor) data._fontclr = 'color:' + data.iconColor + ';';
            return data;
        }
    }
});

ood.Class("ood.UI.HTMLButton", "ood.UI.Element", {
    Instance: {
        activate: function () {
            this.getRoot().focus(true);
            return this;
        }
    },
    Static: {
        Templates: {
            tagName: 'button',
            className: 'ood-ui-unselectable ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius {_className}',
            style: '{_style}{_fc}{_fw}{_fs}{_ff};',
            tabindex: '{tabindex}',
            text: '{caption}' + ood.UI.$childTag
        },
        Appearances: {
            KEY: {
                cursor: 'pointer',
                padding: '.334em'
            }
        },
        DataModel: {
            nodeName: null,
            tabindex: 1,
            width: 'auto',
            height: 'auto',
            html: {
                hidden: 1,
                get: function () {
                    return this.boxing().getCaption()
                },
                set: function (v, ov) {
                    return this.boxing().setCaption(v, ov)
                }
            },
            caption: {
                ini: undefined,
                action: function (v) {
                    v = (ood.isSet(v) ? v : "") + "";
                    this.getRoot().html(ood.adjustRes(v, 0, 1));
                }
            },
            disabled: {
                ini: false,
                action: function (v) {
                    var i = this.getRoot(),
                        cls = "ood-ui-disabled";

                    if (v) this.getRoot().addClass(cls);
                    else this.getRoot().removeClass(cls);
                    i.attr('disabled', v ? "1" : null);
                }
            },
            shadow: {
                ini: false,
                action: function (v) {
                    var node = this.getRoot();
                    if (v) node.addClass('ood-ui-shadow');
                    else node.removeClass('ood-ui-shadow');
                }
            },
            fontColor: {
                ini: '',
                type: "color",
                action: function (value) {
                    this.getRoot().css('color', value);
                }
            },
            fontSize: {
                combobox: ["", "14px", "18px", "22px", "30px"],
                action: function (value) {
                    this.getRoot().css('fontSize', value);
                }
            },
            fontWeight: {
                combobox: ["", "normal", "bolder", "bold", "lighter", "100", "200", "300", "400", "500", "600", "700", "800", "900"],
                action: function (value) {
                    this.getRoot().css('fontWeight', value);
                }
            },
            fontFamily: {
                combobox: ["", "arial", "sans-serif", "comic", "courier new", "monospace", "serif", "times new roman", "wingdings"],
                action: function (value) {
                    this.getRoot().css('fontFamily', value);
                }
            }
        },
        _prepareData: function (profile, data) {
            data = arguments.callee.upper.call(this, profile, data);
            var v;
            if (data.clock) data.caption = '';
            if (v = data.fontSize) data._fs = 'font-size:' + v + ';';
            if (v = data.fontWeight) data._fw = 'font-weight:' + v + ';';
            if (v = data.fontColor) data._fc = 'color:' + v + ';';
            if (v = data.fontFamily) data._ff = 'font-family:' + v + ';';
            data._hAlign = 'text-align:' + (data.hAlign || '');
            data._vAlign = 'vertical-align:' + (data.vAlign || '');
            return data;
        },

        RenderTrigger: function () {
            var self = this, p = self.properties, o = self.boxing();
            if ((!self.$noS) && p.shadow && o.setShadow) o.setShadow(true, true);
        },
        Behaviors: {
            HoverEffected: {KEY: 'KEY'}
        }
    }
});

ood.Class("ood.UI.Button", ["ood.UI.HTMLButton", "ood.absValue"], {
    Initialize: function () {
        // compitable
        ood.UI.SButton = ood.UI.Button;
        var key = "ood.UI.SButton";
        ood.absBox.$type[key.replace("ood.UI.", "")] = ood.absBox.$type[key] = key;
        this.$activeClass$ = 'ood.UI.Button';
    },
    Instance: {
        activate: function () {
            this.getRoot().focus(true);
            return this;
        },
        _setCtrlValue: function (value) {
            if (ood.isNull(value) || !ood.isDefined(value)) value = false;
            return this.each(function (profile) {
                var pp = profile.properties;
                if (pp.type != 'status') return;
                profile.getRoot().tagClass('-checked', value);
            });
        },
        resetValue: function (value) {
            this.each(function (p) {
                if (p.properties.type == 'drop')
                    p.boxing().setCaption("", true);
            });
            var upper = arguments.callee.upper,
                rtn = upper.apply(this, ood.toArr(arguments));
            upper = null;
            return rtn;
        },
        setUIValue: function (value, force) {
            this.each(function (profile) {
                var p = profile.properties;
                if (p.$UIvalue !== value && p.type == 'drop')
                    profile.boxing().setCaption("", true);
            });
            var upper = arguments.callee.upper,
                rtn = upper.apply(this, ood.toArr(arguments));
            upper = null;
            return rtn;
        }
    },
    Static: {
        //for IE67 and dirtymark
        DIRYMARKICON: "BACKGROUND",
        Templates: {
            tagName: 'button',
            className: 'ood-ui-unselectable ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius {_className}',
            style: '{_align}{_style}{_fc}{_fw}{_fs}{_ff};',

            tabindex: '{tabindex}',
            BACKGROUND: {
                tagName: 'div'
            },
            ICON: {
                $order: 1,
                className: 'oodcon {imageClass}  {picClass}',
                style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{imageDisplay}{iconStyle}',
                text: '{iconFontCode}'
            },
            CAPTION: {
                $order: 2,
                className: '',

                text: '{caption}'
            },
            DROP: {
                $order: 3,
                className: 'oodcon ood-special-icon',
                style: '{_showDrop}',
                $fonticon: 'ood-uicmd-arrowdrop'
            }
        },
        Appearances: {
            //for IE67 and dirtymark
            BACKGROUND: {
                'z-index': -1,
                position: 'absolute',
                left: 0,
                top: 0,
                width: '100%',
                height: '100%'
            },
            DROP: {
                'vertical-align': 'middle',
                'padding-left': '.66667em'
            }
        },
        Behaviors: {
            HoverEffected: {KEY: ['KEY', 'DROP']},
            NavKeys: {KEY: 1},
            onClick: function (profile, e, src) {
                var p = profile.properties;
                if (p.disabled) return false;
                var b = profile.boxing();
                if (p.type == 'status') {
                    if (p.readonly) return false;
                    b.setUIValue(!p.$UIvalue, null, null, 'click');
                    if (profile.onChecked)
                        b.onChecked(profile, e, p.$UIvalue);
                }
                //onClick event
                if (profile.onClick)
                    return b.onClick(profile, e, src, p.$UIvalue);
                if (p.type == 'drop' && profile.onClickDrop)
                    return b.onClickDrop(profile, e, src, p.$UIvalue);
            },
            onKeydown: function (profile, e, src) {
                var keys = ood.Event.getKey(e), key = keys.key;
                if (key == ' ' || key == 'enter') {
                    profile.getSubNode('KEY').afterMousedown();
                    profile.__fakeclick = 1;
                }
            },
            onKeyup: function (profile, e, src) {
                var keys = ood.Event.getKey(e), key = keys.key;
                if (key == ' ' || key == 'enter') {
                    profile.getSubNode('KEY').afterMouseup();
                    if (profile.__fakeclick)
                        ood.use(src).onClick();
                }
                delete profile.__fakeclick;
            }
        },
        DataModel: {
            html: null,
            image: {
                format: 'image',
                action: function (v) {
                    ood.UI.$iconAction(this);
                }
            },
            imagePos: {
                action: function (value) {
                    this.getSubNode('ICON').css('backgroundPosition', value || 'center');
                }
            },
            imageBgSize: {
                action: function (value) {
                    this.getSubNode('ICON').css('backgroundSize', value || '');
                }
            },
            imageClass: {
                ini: '',
                action: function (v, ov) {
                    ood.UI.$iconAction(this, 'ICON', ov);
                }
            },
            iconFontCode: {
                action: function (v) {
                    ood.UI.$iconAction(this);
                }
            },
            caption: {
                ini: undefined,
                action: function (v) {
                    v = (ood.isSet(v) ? v : "") + "";
                    this.getSubNode('CAPTION').html(ood.adjustRes(v, 0, 1));
                }
            },
            hAlign: {
                ini: 'center',
                listbox: ['left', 'center', 'right'],
                action: function (v) {
                    this.getRoot().css('textAlign', v);
                }
            },
            vAlign: {
                ini: 'middle',
                listbox: ['top', 'middle', 'bottom'],
                action: function (v) {
                    //todo
                }
            },
            value: {
                ini: false
            },
            fontColor: {
                action: function (value) {
                    this.getSubNode("CAPTION").css('color', value);
                }
            },
            fontSize: {
                combobox: ["", "14px", "18px", "22px", ".75em", "1.5em", "2em", "3em"],
                action: function (value) {
                    this.getSubNode("CAPTION").css('fontSize', value);
                }
            },
            fontWeight: {
                action: function (value) {
                    this.getSubNode("CAPTION").css('fontWeight', value);
                }
            },
            fontFamily: {
                action: function (value) {
                    this.getSubNode("CAPTION").css('fontFamily', value);
                }
            },
            type: {
                ini: 'normal',
                listbox: ['normal', 'status', 'drop'],
                action: function (value) {
                    var self = this,
                        drop = self.getSubNode('DROP');
                    if (value == 'drop') {
                        drop.css('display', '');
                    }
                    else {
                        drop.css('display', 'none');
                    }
                }
            }
        },
        _isFormField: function (profile) {
            return profile.properties.type == "status" && profile.properties.isFormField;
        },
        _ensureValue: function (profile, value) {
            if (profile.properties.type == "status")
                return !!value;
            else
                return value;
        },
        _prepareData: function (profile, data) {
            var data = arguments.callee.upper.call(this, profile);
            var v;
            if (data.clock) data.caption = '';
            if (v = data.fontSize) data._fs = 'font-size:' + v + ';';
            if (v = data.fontWeight) data._fw = 'font-weight:' + v + ';';
            if (v = data.fontColor) data._fc = 'color:' + v + ';';
            if (v = data.fontFamily) data._ff = 'font-family:' + v + ';';
            data._hAlign = 'text-align:' + (data.hAlign || '');
            data._vAlign = 'vertical-align:' + (data.vAlign || '');

            data._showDrop = data.type == 'drop' ? '' : 'display:none';
            return data;
        },


        RenderTrigger: function () {
            var self = this, p = self.properties, o = self.boxing();
            //set value later
            if (p.type == 'status' && p.value)
                o.setValue(true, true, 'render');
        },
        EventHandlers: {
            onClick: function (profile, e, src, value) {
            },
            onClickDrop: function (profile, e, src, value) {
            },
            onChecked: function (profile, e, value) {
            }
        }
    }
});

ood.Class("ood.UI.Span", "ood.UI", {
    Instance: {
        fireClickEvent: function () {
            this.getRoot().onClick();
            return this;
        }
    },
    Static: {
        Templates: {
            className: '{_className}',
            style: '{_style};{_overflow};',
            //for firefox div focus bug: outline:none; tabindex:'-1'
            tabindex: '{tabindex}',
            text: '{html}' + ood.UI.$childTag
        },
        DataModel: {
            width: {
                $spaceunit: 1,
                ini: '2em'
            },
            height: {
                $spaceunit: 1,
                ini: '1em'
            },
            selectable: true,
            html: {
                html: 1,
                action: function (v, ov, force) {
                    this.getRoot().html(ood.adjustRes(v, 0, 1), null, null, force);
                }
            },
            overflow: {
                ini: ood.browser.deviceType == "touchOnly" ? 'auto' : undefined,
                combobox: ['', 'visible', 'hidden', 'scroll', 'auto', 'overflow-x:hidden;overflow-y:auto', 'overflow-x:auto;overflow-y:hidden'],
                action: function (v) {
                    var node = this.getContainer();
                    if (v) {
                        if (v.indexOf(':') != -1) {
                            ood.arr.each(v.split(/\s*;\s*/g), function (s) {
                                var a = s.split(/\s*:\s*/g);
                                if (a.length > 1) node.css(ood.str.trim(a[0]), ood.str.trim(a[1] || ''));
                            });
                            return;
                        }
                    }
                    node.css('overflow', v || '');
                }
            },
            tabindex: -1
        },
        Appearances: {
            KEY: {
                'line-height': 'normal'
            }
        },
        Behaviors: {
            HoverEffected: {KEY: 'KEY', ICON: 'ICON'},
            onClick: function (profile, e, src) {
                var p = profile.properties;
                if (p.disabled) return false;
                if (profile.onClick)
                    return profile.boxing().onClick(profile, e, src);
            }
        },
        EventHandlers: {
            onClick: function (profile, e, value) {
            }
        },
        _prepareData: function (profile, data) {
            data = arguments.callee.upper.call(this, profile, data);
            if (ood.isStr(data.overflow))
                data._overflow = data.overflow.indexOf(':') != -1 ? (data.overflow) : (data.overflow ? ("overflow:" + data.overflow) : "");
            return data;
        }
    }
});

ood.Class("ood.UI.Div", "ood.UI", {
    Initialize: function () {
        // compitable
        ood.UI.Pane = ood.UI.Div;
        var key = "ood.UI.Pane";
        ood.absBox.$type[key.replace("ood.UI.", "")] = ood.absBox.$type[key] = key;
        this.$activeClass$ = 'ood.UI.Div';
    },
    Instance: {
        fireClickEvent: function () {
            this.getRoot().onClick();
            return this;
        }
    },
    Static: {
        Appearances: {
            KEY: {
                // overflow:(ood.browser.gek && !ood.browser.gek3)?'auto':null,
                outline: ood.browser.gek ? 'none' : null,
                zoom: (ood.browser.ie && ood.browser.ver < 9) ? '1' : null,
                background: ood.browser.ie ? 'url(' + ood.ini.img_bg + ') no-repeat left top' : null,
                'line-height': 'normal'
            }
        },
        Templates: {
            tagName: 'div',
            className: 'ood-uicontainer {_className}',
            style: '{_style};{_panelstyle};{_overflow};',
            //for firefox div focus bug: outline:none; tabindex:'-1'
            tabindex: '{tabindex}',
            text: '{html}' + ood.UI.$childTag
        },
        DataModel: {
            iframeAutoLoad: {
                ini: "",
                action: function () {
                    this.box._applyAutoLoad(this);
                }
            },
            ajaxAutoLoad: {
                ini: "",
                action: function () {
                    this.box._applyAutoLoad(this);
                }
            },
            width: {
                $spaceunit: 1,
                ini: 'auto'
            },
            height: {
                $spaceunit: 1,
                ini: 'auto'
            },
            selectable: true,
            html: {
                html: 1,
                action: function (v, ov, force) {
                    this.getRoot().html(ood.adjustRes(v, 0, 1), null, null, force);
                }
            },
            overflow: {
                ini: ood.browser.deviceType == "touchOnly" ? 'auto' : undefined,
                combobox: ['', 'visible', 'hidden', 'scroll', 'auto', 'overflow-x:hidden;overflow-y:auto', 'overflow-x:auto;overflow-y:hidden'],
                action: function (v) {
                    var node = this.getContainer();
                    if (v) {
                        if (v.indexOf(':') != -1) {
                            ood.arr.each(v.split(/\s*;\s*/g), function (s) {
                                var a = s.split(/\s*:\s*/g);
                                if (a.length > 1) node.css(ood.str.trim(a[0]), ood.str.trim(a[1] || ''));
                            });
                            return;
                        }
                    }
                    node.css('overflow', v || '');
                }
            },
            tabindex: -1
        },
        RenderTrigger: function () {
            // only div
            var ns = this;
            if (ns.box.KEY == "ood.UI.Div")
                if (ns.properties.iframeAutoLoad || ns.properties.ajaxAutoLoad)
                    ns.box._applyAutoLoad(this);
        },
        Behaviors: {
            DroppableKeys: ['KEY'],
            PanelKeys: ['KEY'],
            onClick: function (profile, e, src) {
                var p = profile.properties;
                if (p.disabled) return false;
                if (profile.onClick)
                    return profile.boxing().onClick(profile, e, src);
            }
        },
        EventHandlers: {
            onClick: function (profile, e, value) {
            }
        },
        _prepareData: function (profile, data) {
            data = arguments.callee.upper.call(this, profile, data);
            if (ood.isStr(data.overflow))
                data._overflow = data.overflow.indexOf(':') != -1 ? (data.overflow) : (data.overflow ? ("overflow:" + data.overflow) : "");
            return data;
        },
        _applyAutoLoad: function (prf) {
            var prop = prf.properties, ins = prf.boxing();
            if (prop.iframeAutoLoad) {
                ins.getContainer().css('overflow', 'hidden');
                var _if = typeof prop.iframeAutoLoad == 'string' ? {url: prop.iframeAutoLoad} : ood.clone(prop.iframeAutoLoad, true),
                    id = "biframe_" + ood.stamp(),
                    e = ood.browser.ie && ood.browser.ver < 9,
                    ifr = document.createElement(e ? "<iframe name='" + id + "'>" : "iframe");

                _if.url = ood.adjustRes(_if.url, false, true);

                ifr.id = ifr.name = id;
                if (ood.isHash(prop.iframeAutoLoad)) prop.iframeAutoLoad.frameName = id;
                prop._frameName = id;

                if (!_if.query) _if.query = {};
                _if.query._rand = ood.rand();
                ifr.frameBorder = '0';
                ifr.marginWidth = '0';
                ifr.marginHeight = '0';
                ifr.vspace = '0';
                ifr.hspace = '0';
                ifr.allowTransparency = 'true';
                ifr.width = '100%';
                ifr.height = '100%';
                ins.getContainer().html("", false);
                ins.append(ifr);

                if ((_if.method || "").toLowerCase() == "post")
                    ood.Dom.submit(_if.url, _if.query, "post", id, _if.enctype);
                else
                    ifr.src = _if.url;
                if (prf.$afterAutoLoad) prf.$afterAutoLoad.call(prf.boxing(), prf);
            } else if (prop.ajaxAutoLoad) {
                var _ajax = typeof prop.ajaxAutoLoad == 'string' ? {url: prop.ajaxAutoLoad} : ood.clone(prop.ajaxAutoLoad, true),
                    options = {rspType: "text"};
                if (!_ajax.query) _ajax.query = {};
                _ajax.query._rand = ood.rand();
                ood.merge(options, _ajax.options);
                ins.busy();
                var node = ins.getContainer();
                ood.Ajax(ood.adjustRes(_ajax.url, false, true), _ajax.query, function (rsp) {
                    node.html(rsp, true, true);
                    if (prf.$afterAutoLoad) prf.$afterAutoLoad.call(prf.boxing(), prf);
                    ins.free();
                }, function (err) {
                    node.html("<div>" + err + "</div>", true, false);
                    if (prf.$afterAutoLoad) prf.$afterAutoLoad.call(prf.boxing(), prf);
                    ins.free();
                }, null, options).start();
            }
        },
        _onresize: function (profile, width) {
            if (width) ood.UI._adjustConW(profile, profile.getRoot(), profile);
        }
    }
});

ood.Class("ood.UI.CSSBox", "ood.UI.Span", {
    Instance: {
        fireClickEvent: null,
        adjustDock: null,
        draggable: null,
        busy: null,
        free: null
    },
    Static: {
        $initRootHidden: true,
        _objectProp: {normalStatus: 1, hoverStatus: 1, activeStatus: 1, focusStatus: 1},
        Templates: {
            style: 'left:' + ood.Dom.HIDE_VALUE + ';top:' + ood.Dom.HIDE_VALUE + ';width:12.5em;height:5em;visibility:hidden;display:none;position:absolute;z-index:0;',
            className: '{_className}',
            text: '{_html}'
        },
        DataModel: {
            customCss: {
                ini: null,
                action: function () {
                    this.box._refreshCSS(this);
                }
            },
            className: {
                ini: null,
                action: function () {
                    this.box._refreshCSS(this);
                }
            },
            sandbox: {
                ini: "",
                action: function (v) {
                    this.box._refreshCSS(this);
                }
            },
            normalStatus: {
                ini: {},
                action: function (v) {
                    this.box._refreshCSS(this);
                }
            },
            hoverStatus: {
                ini: {},
                action: function (v) {
                    this.box._refreshCSS(this);
                }
            },
            activeStatus: {
                ini: {},
                action: function (v) {
                    this.box._refreshCSS(this);
                }
            },
            focusStatus: {
                ini: {},
                action: function (v) {
                    this.box._refreshCSS(this);
                }
            },
            spaceUnit: null,
            showEffects: null,
            hideEffects: null,
            position: null,
            display: null,
            visibility: null,
            zIndex: null,
            left: null,
            top: null,
            width: null,
            height: null,
            right: null,
            bottom: null,
            rotate: null,
            activeAnim: null,
            hoverPop: null,
            hoverPopType: null,
            dock: null,
            dockStretch: null,
            dockIgnoreFlexFill: null,
            renderer: null,
            display: null,
            html: null,
            selectable: null,
            overflow: null,
            tabindex: null,
            autoTips: null,
            disableClickEffect: null,
            disableHoverEffect: null,
            disableTips: null,
            disabled: null,
            defaultFocus: null,
            dockStretch: null,
            dockIgnore: null,
            dockOrder: null,
            dockMargin: null,
            dockFloat: null,
            dockMinW: null,
            dockMinH: null,
            dockMaxW: null,
            dockMaxH: null,
            tips: null
        },
        $adjustProp: function (profile, force) {
            var prop = profile.properties, cls = (!force && prop.className) || ('ood-css-' + profile.$xid),
                ko, i = 1, hash = {};
            profile.box.getAll().each(function (prf) {
                if (prf !== profile) hash[prf.properties.className] = 1;
            });
            while (hash[cls]) cls = cls + (i++);
            prop.className = cls;
        },
        RenderTrigger: function () {
            var prf = this;
            if (!prf.$inDesign) {
                ood('body').append(prf.getRoot());
            }
        },
        _prepareData: function (profile, data) {
            data = arguments.callee.upper.call(this, profile, data);
            var css = this._getCon(profile);
            data._html = "Text" + (css ? ("<" + "style id='" + profile.getDomId() + "cssnode' type='text/css'>" + css + "<" + "/style>") : "");
            return data;
        },
        _getCon: function (prf) {
            var css = "", prevId = "", t,
                prop = prf.properties,
                cls = prop.className,
                customCss = prop.customCss,
                hash1 = prop.normalStatus,
                hash2 = prop.hoverStatus,
                hash3 = prop.activeStatus,
                hash4 = prop.focusStatus;

            if (!customCss) {
                if (hash1 && !ood.isEmpty(hash1)) {
                    css += "." + cls + "{" + ood.Dom.$adjustCss(hash1, true) + "}\n";
                    if (hash1.color) css += "." + cls + " .ood-node{color:" + hash1.color + "}";
                }
            } else {
                css = customCss;
            }
            if (hash2 && !ood.isEmpty(hash2)) {
                css += "." + cls + ":hover, ." + cls + "-hover{" + ood.Dom.$adjustCss(hash2, true) + "}\n";
                if (hash2.color) css += "." + cls + " .ood-node{color:" + hash2.color + "}";
            }
            // cover :hover effect for -chekced / -active
            if (hash3 && !ood.isEmpty(hash3)) {
                css += "." + cls + ":active, ." + cls + ":checked, ." + cls + "-active, ." + cls + "-checked, ." + cls + "-checked:hover, ." + cls + "-active:hover{" + ood.Dom.$adjustCss(hash3, true) + "}";
                if (hash3.color) css += "." + cls + " .ood-node{color:" + hash3.color + "}";
            }
            if (hash4 && !ood.isEmpty(hash4)) {
                css += "." + cls + ":focus, ." + cls + "-focus{" + ood.Dom.$adjustCss(hash4, true) + "}";
                if (hash4.color) css += "." + cls + " .ood-node{color:" + hash4.color + "}";
            }

            if (t = prop.sandbox) {
                // alias or domId
                t = (prf.host && prf.host[t] && prf.host[t].get(0)) || (ood(t).get(0) && t);
                if (t) prevId = ood.UI._getThemePrevId(t);
            } else if (prf.$inDesign) {
                // the canvas
                if (t = prf.parent) prevId = ood.UI._getThemePrevId(t);
            }

            return ood.UI._adjustCSS(css, prevId);
        },
        _refreshCSS: function (prf) {
            var ns = this;
            ood.resetRun(prf.key + ":" + prf.$xid, function () {
                if (prf.destroyed) return;
                var id = prf.getDomId() + "cssnode",
                    prop = prf.properties,
                    root = prf.getRoot(),
                    css = ns._getCon(prf);

                root.query('style').remove(false);

                ood.Dom._setClass(root.get(0), prop.className);
                if (css) ood.CSS._appendSS(root.get(0), css, id, false);
            });
        },
        EventHandlers: {
            beforeInputAlert: null,
            onContextmenu: null,
            onClick: null,
            onDock: null,
            onLayout: null,
            onMove: null,
            onRender: null,
            onResize: null,
            onShowTips: null,
            beforeHoverEffect: null,
            beforeAppend: null,
            afterAppend: null,
            beforeRender: null,
            afterRender: null,
            beforeRemove: null,
            afterRemove: null,
            onHotKeydown: null,
            onHotKeypress: null,
            onHotKeyup: null
        }
    }
});

ood.Class("ood.UI.MoudluePlaceHolder", "ood.UI.Div", {
    Instance: {
        destroy: function (ignoreEffects, purgeNow) {
            var o = this.get(0);
            if (!o) return;
            (o.$afterDestroy = (o.$afterDestroy || {}))["destroyAttachedModule"] = function () {
                if (!this._replaced && this._module) {
                    this._module.destroy(ignoreEffects, purgeNow);
                }
            };
            return arguments.callee.upper.apply(this, [ignoreEffects, purgeNow]);
        },
        adjustDock: null,
        draggable: null,
        busy: null,
        free: null,
        // for Module
        setProperties: function (key, value) {
            var self = this.get(0);
            if (!self._properties) self._properties = {};
            if (!key) self._properties = {};
            else if (typeof key == 'string') self._properties[key] = value;
            else {
                ood.merge(self._properties, key, 'all');
                if (value && ood.isHash(value))
                    ood.merge(self._properties, value, 'all');
            }
            return this;
        },
        getValue: function () {
            return ood.get(this.get(0), ['_properties', 'value']);
        },
        setValue: function (value) {
            ood.set(this.get(0), ['_properties', 'value'], value);
            return this;
        },
        getUIValue: function () {
            return this.get(0)._$UIvalue;
        },
        setUIValue: function (value) {
            this.get(0)._$UIvalue = value;
            return this;
        },
        getProperties: function (key) {
            var self = this.get(0);
            if (!self._properties) self._properties = {};
            return key ? self._properties[key] : self._properties;
        },
        setEvents: function (key, value) {
            var self = this.get(0);
            if (!self._events) self._events = {};
            if (!key)
                self._events = {};
            else if (typeof key == 'string')
                self._events[key] = value;
            else
                ood.merge(self._events, key, 'all');
            return this;
        },
        getEvents: function (key) {
            var self = this.get(0);
            if (!self._events) self._events = {};
            return key ? this._events[key] : this._events;
        },
        replaceWithModule: function (module) {
            var self = this,
                prf = self.get(0),
                m, t, parent, subId,
                onEnd = function (t) {
                    if (prf.$afterReplaced) prf.$afterReplaced.call(module);
                    if ((t = prf._render_holder || prf._inline_holder) && t.$afterAttached)
                        module.getUIComponents().each(function (prf) {
                            ood.tryF(t.$afterAttached, [prf], t);
                        });
                    // Avoid being removed from host
                    prf.alias = null;
                    prf._module = null;
                    if (prf.box) prf.boxing().destroy();
                };

            if (!prf || prf.destroyed || prf._replaced || !prf.getRootNode()) return;
            prf._replaced = 1;

            if (prf.$beforeReplaced) prf.$beforeReplaced.call(module);
            // host and alias
            if (prf.host || prf.alias) module.setHost(prf.host, prf.alias);
            if ('_$UIvalue' in prf) module.$UIvalue = prf._$UIvalue;
            if (t = prf._events) module.setEvents(t);
            if (t = prf._properties) module.setProperties(t);
            // maybe in other module
            if (prf.moduleClass && prf.moduleXid) {
                if (m = ood.Module.getInstance(prf.moduleClass, prf.moduleXid)) {
                    m.AddComponents(module);
                }
            }
            if (parent = prf.parent) {
                subId = prf.childrenId;
                module.show(onEnd, parent, subId);
            } else if (prf.rendered && (parent = prf.getRoot().parent()) && !parent.isEmpty()) {
                module.show(onEnd, parent);
            }

            if (prf.$afterReplaced) prf.$afterReplaced.call(module);
            // Avoid being removed from host
            prf.alias = null;
            prf._module = null;
            self.destroy();
        }
    },
    Static: {
        Templates: {
            tagName: 'div',
            style: 'left:0;top:0;width:0;height:0;visibility:hidden;display:none;position:absolute;z-index:0;'
        },
        DataModel: {
            showEffects: null,
            hideEffects: null,
            activeAnim: null,
            hoverPop: null,
            hoverPopType: null,
            dock: null,
            dockStretch: null,
            renderer: null,
            html: null,
            disableClickEffect: null,
            disableHoverEffect: null,
            disableTips: null,
            disabled: null,
            defaultFocus: null,
            dockStretch: null,
            dockIgnore: null,
            dockOrder: null,
            dockMargin: null,
            dockFloat: null,
            dockMinW: null,
            dockMinH: null,
            dockMaxW: null,
            dockMaxH: null,
            tips: null
        },
        EventHandlers: {
            onContextmenu: null,
            onDock: null,
            onLayout: null,
            onMove: null,
            onRender: null,
            onResize: null,
            onShowTips: null,
            beforeAppend: null,
            afterAppend: null,
            beforeRender: null,
            afterRender: null,
            beforeRemove: null,
            afterRemove: null,
            onHotKeydown: null,
            onHotKeypress: null,
            onHotKeyup: null
        },
        // for parent UIProfile toHtml case
        RenderTrigger: function () {
            var prf = this;
            if (prf && !prf._replaced && prf._module) {
                prf.boxing().replaceWithModule(prf._module);
            }
        },

        // Refresh theme for all UI components
        refreshAllThemes: function (theme) {
            var self = this;
            // Use the provided theme or fallback to the global theme
            if (!theme || (theme !== 'light' && theme !== 'dark')) {
                theme = ood.getGlobalTheme ? ood.getGlobalTheme() : 'light';
            }

            try {
                // Traverse all UI components and refresh their themes
                ood.each(ood.UIProfile.___all, function (profile) {
                    if (profile && profile.boxing && profile.boxing().setTheme) {
                        try {
                            profile.boxing().setTheme(theme);
                        } catch (e) {
                            if (window.console && window.console.warn) {
                                window.console.warn('Failed to refresh theme for component:', e);
                            }
                        }
                    }
                });

                // 
                // 
                localStorage.setItem('layout-theme', theme);
                localStorage.setItem('menubar-theme', theme);
                localStorage.setItem('dialog-theme', theme);
                localStorage.setItem('buttonlayout-theme', theme);
                localStorage.setItem('panel-theme', theme);
                localStorage.setItem('tabs-theme', theme);
                localStorage.setItem('statusbuttons-theme', theme);
                localStorage.setItem('infoblock-theme', theme);
                localStorage.setItem('formlayout-theme', theme);
                localStorage.setItem('popmenu-theme', theme);
                localStorage.setItem('datepicker-theme', theme);
                localStorage.setItem('toolbar-theme', theme);
                localStorage.setItem('treeview-theme', theme);
                localStorage.setItem('radiobox-theme', theme);
                localStorage.setItem('progressbar-theme', theme);
                localStorage.setItem('contentblock-theme', theme);
            } catch (e) {
                if (window.console && window.console.error) {
                    window.console.error('Error in refreshAllThemes:', e);
                }
            }
        }
    }
});

ood.Class("ood.AnimBinder", "ood.absObj", {
    Instance: {
        _ini: ood.Timer.prototype._ini,
        _after_ini: function (profile, ins, alias) {
            if (!profile.name) profile.Instace.setName(alias);
        },
        getParent: ood.Timer.prototype.getParent,
        getChildrenId: ood.Timer.prototype.getChildrenId,
        destroy: function () {
            this.each(function (profile) {
                var box = profile.box, name = profile.properties.name;
                //delete from pool
                delete box._pool[name];
                //free profile
                profile.__gc();
            });
        },
        setHost: function (value, alias) {
            var self = this;
            if (value && alias)
                self.setName(alias);
            return arguments.callee.upper.apply(self, arguments);
        },
        apply: function (node, onEnd) {
            var prf = this.get(0), fs = prf.properties['frames'], arr = [], frame, frame1, frame2, endpoints;
            for (var i = 0, l = fs.length; i < l - 1; i++) {
                endpoints = {};
                frame1 = fs[i];
                frame2 = fs[i + 1];
                frame = ood.copy(frame2);
                delete frame.status;
                for (var j in frame2.status) endpoints[j] = frame2.status[j];
                frame.endpoints = endpoints;
                frame['start'] = frame1;
                frame['end'] = frame2;
                arr.push(frame);
            }
            var fun = function () {
                if (!arr.length) {
                    if (prf.onEnd) prf.boxing().onEnd(prf);
                    if (ood.isFun(onEnd)) ood.tryF(onEnd);
                    return;
                }
                var frame = arr.shift();
                if (prf.beforeFrame && false === prf.boxing().beforeFrame(prf, frame)) return;

                return ood(node).animate(frame.endpoints, null, fun, frame.duration, frame.step, frame.type, null, null, frame.restore, frame.times).start();
            };
            return fun();
        }
    },
    Static: {
        _objectProp: {tagVar: 1, propBinder: 1, "frames": 1},
        _beforeSerialized: ood.Timer._beforeSerialized,
        $nameTag: "ani_",
        _pool: {},
        destroyAll: function () {
            this.pack(ood.toArr(this._pool, false), false).destroy();
            this._pool = {};
        },
        getFromName: function (name) {
            var o = this._pool[name];
            return o && o.boxing();
        },
        DataModel: {
            dataBinder: null,
            dataField: null,
            "name": {
                set: function (value) {
                    var o = this,
                        ovalue = o.properties.name,
                        c = o.box,
                        _p = c._pool,
                        _old = _p[ovalue],
                        _new = _p[value],
                        ui;

                    //if it exists, overwrite it dir
                    //if(_old && _new)
                    //    throw value+' exists!';

                    _p[o.properties.name = value] = o;

                    //pointer _old the old one
                    if (_new && !_old) o._n = _new._n;
                    //delete the old name from pool
                    if (_old) delete _p[ovalue];
                }
            },
            "frames": {
                ini: []
            }
        },
        EventHandlers: {
            beforeFrame: function (profile, frame) {
            },
            onEnd: function (profile) {
            }
        }
    }
});ood.Class("ood.UI.Image", "ood.UI", {

    Initialize: function () {
        var ns = this;
        ns._adjustItems = ood.absList._adjustItems;
        ns.prototype._prepareItems = function (a) {
            return a;
        };
    },
    Instance: {
        iniProp: {
            src:  "ri-image-line",
            IconFontSize:'3em'
        },
        fireClickEvent: function () {
            this.getRoot().onClick();
            return this;
        },
        getRate: function () {
            return parseFloat(this.get(0)._rate) || 1;
        },

        getUIValue: function () {

            return this.getSrc();
        },
        setUIValue: function (src) {
            this.setSrc(src);
        },
        getValue: function () {

            return this.getSrc();
        },
        setValue: function (src) {
            this.setSrc(src);
        },
        
        // 
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();

                // 
                root.removeClass('image-dark image-highcontrast');
                
                // 
                if (theme === 'dark') {
                    root.addClass('image-dark');
                } else if (theme === 'highcontrast') {
                    root.addClass('image-highcontrast');
                }
                
                // 
                root.addClass('ood-image');
                
                // 
                localStorage.setItem('image-theme', theme);
                
                // 
                if (profile.onThemeChange) {
                    profile.onThemeChange(theme);
                }
            });
        },
        
        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('image-theme') || 'light';
        },
        
        // 
        setResponsiveBreakpoint: function(breakpoint) {
            return this.each(function(profile) {
                profile.properties.responsiveBreakpoint = breakpoint;
                profile.boxing().adjustLayout();
            });
        },
        
        // 
        enableKeyboardNavigation: function() {
            return this.each(function(profile) {
                var root = profile.getRoot();
                root.attr('tabindex', '0');
                
                // 
                root.on('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        profile.boxing().fireClickEvent();
                    }
                });
            });
        },
        
        // 
        setScreenReaderLabel: function(label) {
            return this.each(function(profile) {
                profile.properties.ariaLabel = label;
                profile.getRoot().attr('aria-label', label);
            });
        },

        ImageTrigger: function() {
            var profile = this.get(0);
            var prop = profile.properties;
            var boxing = this;

            // 
            if (!profile.properties._originalMaxWidth) {
                profile.properties._originalMaxWidth = prop.maxWidth;
            }
            if (!profile.properties._originalMaxHeight) {
                profile.properties._originalMaxHeight = prop.maxHeight;
            }

            // 
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('image-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                boxing.adjustLayout();
            }

            // 
            boxing.enhanceAccessibility();
        },
        
        // 
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        
        // 
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('image-mobile');
                    
                    // 
                    var currentMaxWidth = prop.maxWidth || 800;
                    var newMaxWidth = Math.min(currentMaxWidth, width - 40);
                    
                    if (newMaxWidth !== prop.maxWidth) {
                        profile.properties.maxWidth = newMaxWidth;
                        profile.box._adjust(profile, prop.width, prop.height);
                    }
                } else {
                    root.removeClass('image-mobile');
                    
                    // 
                    if (profile.properties._originalMaxWidth) {
                        profile.properties.maxWidth = profile.properties._originalMaxWidth;
                        profile.box._adjust(profile, prop.width, prop.height);
                    }
                }

                // 
                if (width < 480) {
                    root.addClass('image-tiny');
                    
                    // 
                    var maxMobileHeight = Math.min(prop.maxHeight || 600, width * 0.75);
                    if (maxMobileHeight !== prop.maxHeight) {
                        profile.properties.maxHeight = maxMobileHeight;
                        profile.box._adjust(profile, prop.width, prop.height);
                    }
                } else {
                    root.removeClass('image-tiny');
                }
            });
        },
        
        // 
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'img',
                    'alt': properties.alt || '',
                    'aria-label': properties.alt || properties.tips || ''
                });
                
                // alt
                if (!properties.alt || properties.alt === '') {
                    root.attr('alt', '');
                }
                
                // 
                if (!properties.disabled) {
                    root.attr({
                        'tabindex': '0',
                        'aria-describedby': properties.tips ? profile.serialId + '_tips' : null
                    });
                }
            });
        }
    },
    Static: {
        IMGNODE: 1,
        Templates: {
            tagName: 'img',
            style: 'cursor:{cursor};{_style}',
            className: '{_className}',
            border: "0",
            src: ood.ini.img_bg,
            alt: "{alt}"
        },
        Behaviors: {
            HoverEffected: {KEY: 'KEY'},
            ClickEffected: {KEY: 'KEY'},
            DraggableKeys: ["KEY"],
            onError: function (profile, e, src) {
                profile.boxing().onError(profile);
            },
            onLoad: function (profile, e, src) {
                var img = ood.use(src).get(0), path;
                // for IE8 bug
                try {
                    path = img.src;
                } catch (e) {
                    return;
                }
                if (path != ood.ini.img_bg) {
                    var i = new Image();
                    i.onload = function () {
                        if (!profile || profile.destroyed) return;
                        var prop = profile.properties,
                            size = profile.box._adjust(profile, (prop.width === "" || prop.width == "auto") ? i.width : prop.width, (prop.height === "" || prop.height == "auto") ? i.height : prop.height);
                        if (profile.$afterLoad) profile.$afterLoad.apply(profile.host, [profile, path, size[0], size[1]]);
                        profile.boxing().afterLoad(profile, path, size[0], size[1]);
                        if (prop.dock != 'none')
                            profile.boxing().adjustDock();
                        i.onload = null;
                    }
                    // must after onload for IE<8 fix
                    i.src = path;
                    ood.Dom.fixPng(img);
                }
            },
            onClick: function (profile, e, src) {
                var p = profile.properties;
                if (p.disabled) return false;
                if (profile.onClick)
                    return profile.boxing().onClick(profile, e, src);
            },
            onDblclick: function (profile, e, src) {
                var p = profile.properties;
                if (p.disabled) return false;
                if (profile.onDblclick)
                    profile.boxing().onDblclick(profile, e, src);
            }
        },
        RenderTrigger: function () {
            var self = this, pro = self.properties,
                v = pro.src, v2 = pro.activeItem;
            if (v2 && -1 != ood.arr.subIndexOf(pro.items, "id", v2)) {
                self.boxing().setActiveItem(v2, true);
            } else if (v) self.boxing().setSrc(v, v != ood.ini.img_bg);
            
            // 
            ood.asyRun(function(){
                self.boxing().ImageTrigger();
            });
        },
        

        EventHandlers: {
            onClick: function (profile, e, src) {
            },
            onDblclick: function (profile, e, src) {
            },
            onError: function (profile) {
            },
            beforeLoad: function (profile) {
            },
            afterLoad: function (profile, path, width, height) {
            }
        },
        _adjust: function (profile, width, height) {
            var prop = profile.properties,
                src = profile.getRootNode(),
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                };

            width = width ? profile.$px(width, null, true) : width;
            height = height ? profile.$px(height, null, true) : height;

            src.style.width = src.style.height = '';
            if (width > 0 && height > 0) {
                var r1 = prop.maxWidth / width,
                    r2 = prop.maxHeight / height,
                    r = r1 < r2 ? r1 : r2;
                if (r >= 1) r = 1;
                profile._rate = r;
                return [src.width = width * r, src.height = height * r];
            }
            return [0, 0];
        },
        DataModel: {
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark', 'highcontrast'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            responsiveBreakpoint: {
                ini: 'md',
                listbox: ['sm', 'md', 'lg', 'xl'],
                action: function(value) {
                    this.boxing().adjustLayout();
                }
            },
            ariaLabel: {
                ini: '',
                action: function(value) {
                    this.getRoot().attr('aria-label', value);
                }
            },
            tabIndex: {
                ini: '0',
                action: function(value) {
                    this.getRoot().attr('tabindex', value);
                }
            },
            
            expression: {
                ini: '',
                action: function () {
                }
            },
            maxWidth: {
                ini: 800,
                action: function (v) {
                    var src = this.getRootNode(), prop = this.properties;
                    this.box._adjust(this, (prop.width === "" || prop.width == "auto") ? src.width : prop.width, (prop.height === "" || prop.height == "auto") ? src.height : prop.height);
                }
            },
            maxHeight: {
                ini: 600,
                action: function (v) {
                    var src = this.getRootNode(), prop = this.properties;
                    this.box._adjust(this, (prop.width === "" || prop.width == "auto") ? src.width : prop.width, (prop.height === "" || prop.height == "auto") ? src.height : prop.height);
                }
            },
            width: {
                ini: 'auto',
                action: function (v) {
                    var src = this.getRootNode(),
                        prop = this.properties,
                        i = new Image();
                    i.src = src.src;
                    this.box._adjust(this, (v === "" || v == "auto") ? i.width : v, (prop.height === "" || prop.height == "auto") ? i.height : prop.height);
                }
            },
            height: {
                ini: 'auto',
                action: function (v) {
                    var src = this.getRootNode(),
                        prop = this.properties,
                        i = new Image();
                    i.src = src.src;
                    this.box._adjust(this, (prop.width === "" || prop.width == "auto") ? i.width : prop.width, (v === "" || v == "auto") ? i.height : v);
                }
            },
            src: {
                format: 'image',
                ini: ood.ini.img_bg,
                linkage: ["activeItem"],
                //use asyn mode
                action: function (v) {
                    var self = this;
                    if (false !== self.boxing().beforeLoad(this))
                        ood.asyRun(function () {
                            var p = self.properties, r = self.getRoot(), src = ood.adjustRes(v);
                            if (p) {
                                if (r.attr('src') !== src) r.attr('src', src);
                            }

                        });
                    if (!self.$inner)
                        self.properties.activeItem = "";
                }
            },
            alt: {
                ini: "",
                action: function (v) {
                    this.getRoot().attr('alt', v);
                }
            },
            items: {
                ini: []
            },
            activeItem: {
                ini: "",
                linkage: ["src", "alt", "tips"],
                action: function (v) {
                    var items = this.properties.items,
                        i = ood.arr.subIndexOf(items, "id", "" + v),
                        item, ins = this.boxing(),
                        src = ood.ini.img_bg, alt, tips;
                    if ((i != -1) && (item = items[i])) {
                        src = item.image;
                        alt = item.alt || "";
                        tips = item.tips || "";
                    }
                    this.$inner = 1;
                    ins.setSrc(src, true);
                    delete this.$inner;
                    ins.setAlt(alt || "");
                    ins.setTips(tips || "");
                }
            },
            cursor: {
                ini: "auto",
                combobox: ["", "default", "text", "pointer", "move", "crosshair", "wait", "help", "e-resize", "ne-resize", "nw-resize", "n-resize", "se-resize", "sw-resize", "s-resize", "w-resize"],
                action: function (v) {
                    this.getRoot().css('cursor', v);
                }
            }
        }
    }
});ood.Class("ood.UI.Flash", "ood.UI",{
    Instance:{
        refreshFlash:function(){
            var html='', cls=this.constructor;
            return this.each(function(profile){
                ood.resetRun(profile.domId,function(){
                    // clear first
                    cls._clearMemory(profile);
    
                    // build and set flash
                    if(profile.properties.src)
                        cls._drawSWF(profile);
                });
            });
        },
        // Return the flash object
        getFlash:function(){
            return this.constructor._getSWF(this.get(0));
        }
    },
    Static:{
        Appearances:{
            KEY:{
                overflow:'hidden'
            },
            BOX:{
                position:'absolute',
                left:0,
                top:0,
                'z-index':1
            },
            COVER:{
                position:'absolute',
                left:'-1px',
                top:'-1px',
                width:0,
                height:0,
                'z-index':4
            }
        },
        Templates:{
            tagName:'div',
            className:'{_className}',
            style:'{_style}',
            BOX:{
                tagName:'div'
            },
            COVER:{
                tagName:'div',
                style:"background-image:url("+ood.ini.img_bg+");"
            }
        },
        DataModel:{
            selectable:true,
            width:{
                $spaceunit:1,
                ini:'30em'
            },
            height:{
                $spaceunit:1,
                ini:'25em'
            },
            cover:false,
            src:{
                format:'media',
                ini:'',
                action:function(v){
                    this.boxing().refreshFlash();
                }
            },
            parameters:{
                ini:{},
                action:function(v){
                    this.boxing().refreshFlash();
                }
            },
            flashvars:{
                ini:{},
                action:function(v){
                    this.boxing().refreshFlash();
                }
            }
        },
        RenderTrigger:function(){
            (this.$beforeDestroy=(this.$beforeDestroy||{}))["flashClearMem"]=function(){
                if(this.box)
                    this.box._clearMemory(this);
            };
            // add swf
            this.boxing().refreshFlash();
        },
        getFlashVersion:function(){
          if(ood.browser.ie){
            try {
              var axo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash.6');
              try{axo.AllowScriptAccess='always'}catch(e){return '6,0,0'}
            }catch(e){}finally{
                try{
                    return new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
                }catch(e){}
            }
          }else{
            try {
              if(navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin){
                return (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]).description.replace(/\D+/g, ",").match(/^,?(.+),?$/)[1];
              }
            }catch(e){}
          }
          return '0,0,0';
        },
        _getSWF:function(profile){
            var id= ood.isStr(profile)?profile:(this._idtag + profile.serialId);
            return (ood.browser.ie ? window[id] : ((document.embeds && document.embeds[id])||window.document[id])) || document.getElementById(id);
        }, 
        _clearMemory:function(profile){
            var id=this._idtag + profile.serialId;
            var _e=ood.fun(), chart = profile.box._getSWF(profile);
            if(chart){
                chart.style.display = 'none';
                if(ood.browser.ie){
                    for(var x in chart )
                        if(typeof chart[x]=='function')
                            chart[x]=_e;                        
                    if(window[id])
                        window[id]=undefined;
                }else{
                    if(document.embeds && document.embeds[id])
                        document.embeds[id]=undefined;
                    if(window.document[id])
                        window.document[id]=undefined;
                }
               chart=_e=null;
            }
        }, 
        _drawSWF:function(profile){
            var ns=this;
            var prop=profile.properties,
                serialId=profile.serialId,
                src=ood.adjustRes(prop.src),
                parameters=prop.parameters,
                options = ood.copy(prop.flashvars),
                xml="";

            options.DOMId = profile.box._idtag + profile.serialId;
            options.chartWidth=prop.width;
            options.chartHeight=prop.height;

            if(navigator.plugins&&navigator.mimeTypes&&navigator.mimeTypes.length){
                xml += '<embed type="application/x-shockwave-flash" src="'+ src +'?'+ood.urlEncode(parameters)+'" ';
                xml += 'width="'+prop.width+'" height="'+prop.height+'" ';
                xml += 'id="'+ options.DOMId +'" name="'+ options.DOMId +'" ';
                xml += 'wmode="opaque" ';
                xml += 'flashvars="'+ ood.urlEncode(options) +'" ';
                xml +=  '/>';
            }else{
                xml += '<object id="'+ options.DOMId +'" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" '
                xml += 'width="'+prop.width+'" height="'+prop.height+'">';
                xml += '<param name="movie" value="'+ src +'?'+ood.urlEncode(parameters)+'" />';
                xml += '<param name="wmode" value="opaque" />';
                xml += '<param name="flashvars" value="'+ ood.urlEncode(options) +'" />';
                xml += '</object>';
            }
            profile.getSubNode('BOX').html(xml, false);
        },
        _onresize:function(profile,width,height){
            var prop=profile.properties,
                us=ood.$us(profile),
                adjustunit = function(v,emRate){return profile.$forceu(v, us>0?'em':'px', emRate)},

                size = profile.getSubNode('BOX').cssSize(),

                // caculate by px
                ww=width?profile.$px(width):width, 
                hh=height?profile.$px(height):height;

            if( (width && !ood.compareNumber(size.width,ww,6)) || (height && !ood.compareNumber(size.height,hh,6)) ){
                // reset here
                if(width)prop.width=adjustunit(ww);
                if(height)prop.height=adjustunit(hh);

                size={
                    width:width?prop.width:null,
                    height:height?prop.height:null
                };
                profile.getSubNode('BOX').cssSize(size,true);
                if(profile.$inDesign || prop.cover){
                    profile.getSubNode('COVER').cssSize(size,true);
                }
                profile.boxing().refreshFlash();
            }
        }
    }
});ood.Class("ood.UI.Audio", "ood.UI",{
    Instance:{
        play:function(){
            var v = this.getSubNode("H5"), vn = v.get(0);if(vn&&this.getSrc())vn.play();
        },
        pause:function(){
            var v = this.getSubNode("H5"), vn = v.get(0);if(vn&&this.getSrc())vn.pause();
        },
        load:function(){
            var v = this.getSubNode("H5"), vn = v.get(0);if(vn&&this.getSrc())vn.load();
        },
        canPlayType:function(type){
            var v = this.getSubNode("H5"), vn = v.get(0);if(vn) return vn.canPlayType(type);
        },
        
        // 
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();
                
                // 
                root.removeClass('audio-dark audio-hc');
                
                // 
                if (theme === 'dark') {
                    root.addClass('audio-dark');
                } else if (theme === 'high-contrast') {
                    root.addClass('audio-hc');
                }
                
                // 
                localStorage.setItem('audio-theme', theme);
            });
        },
        
        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('audio-theme') || 'light';
        },
        
        // 
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        
        // 
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width;

                // 
                if (width < 768) {
                    root.addClass('audio-mobile');
                } else {
                    root.removeClass('audio-mobile');
                }

                // 
                if (width < 480) {
                    root.addClass('audio-tiny');
                } else {
                    root.removeClass('audio-tiny');
                }
            });
        },
        
        // 
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    h5 = profile.getSubNode('H5'),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'application',
                    'aria-label': ood.getRes('UI.audio.player'),
                    'aria-live': 'polite'
                });
                
                // ARIA
                if (h5 && !h5.isEmpty()) {
                    h5.attr({
                        'aria-label': ood.getRes('UI.audio.controls'),
                        'role': 'application',
                        'aria-disabled': properties.disabled ? 'true' : 'false',
                        'aria-hidden': 'false'
                    });
                    
                    // 
                    if (properties.controls) {
                        h5.attr('aria-controls', 'true');
                    }
                    
                    if (properties.muted) {
                        h5.attr('aria-label', ood.getRes('UI.audio.player.muted'));
                    }
                    
                    // 
                    h5.on('keydown', function(e) {
                        var key = e.keyCode;
                        // /
                        if (key === 32 || key === 13) {
                            e.preventDefault();
                            var audio = h5.get(0);
                            if (audio.paused) {
                                audio.play();
                            } else {
                                audio.pause();
                            }
                        }
                    });
                }
            });
        }
    },
    Static:{
        Appearances:{
            KEY:{
                className: 'ood-audio'
            },
            H5:{
                className: 'ood-audio-controls'
            },
            COVER:{
                className: 'ood-audio-cover'
            },
            'KEY:hover COVER': {
                className: 'ood-audio:hover .ood-audio-cover'
            }
        },
        Templates:{
            tagName:'div',
            className:'{_className}',
            style:'{_style}',
            H5:{
                tagName:'audio',
                crossOrigin:  'anonymous',
                autoplay:'{_autoplay}',
                controls:'{_controls}',
                loop:'{_loop}',
                muted:'{_muted}',

                preload:'{preload}',
                volume:'{volume}',
                src:'{src}',
                text:'Your browser does not support the audio element.'
            },
            COVER:{
                tagName:'div',
                style:"background-image:url("+ood.ini.img_bg+");"
            }
        },
        Behaviors:{
            HotKeyAllowed:false
        },
        DataModel:{
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            selectable:true,
            width:{
                $spaceunit:1,
                ini:'18em'
            },
            height:{
                $spaceunit:1,
                ini:'5em'
            },
            src:{
                format:'media',
                ini:'',
                action:function(v){
                    this.getSubNode("H5").attr("src", ood.adjustRes(v));
                }
            },
            cover:false,
            controls:{
                ini: true,
                action:function(v){
                    this.getSubNode("H5").attr("controls", v?'controls':null);
                }
            },
            preload:{
                ini: "none",
                listbox:["none", "metadata", "auto" ],
                action:function(v){
                    this.getSubNode("H5").attr("preload", (!v||v=='none')?null:v);
                }
            },
            loop:{
                ini: false,
                action:function(v){
                    this.getSubNode("H5").attr("loop", v?'loop':null);
                }
            },
            muted:{
                ini: false,
                action:function(v){
                    this.getSubNode("H5").attr("muted", v?'muted':null);
                }
            },
            volume:{
                ini: 1,
                action:function(v){
                    this.getSubNode("H5").attr("volume", v);
                }
            },
            autoplay:{
                ini: false,
                action:function(v){
                    this.getSubNode("H5").attr("autoplay", v?'autoplay':null);
                }
            }
        },
        RenderTrigger:function(){
            var prf = this,
                H5 = prf.getSubNode('H5'),
                prop = prf.properties,
                ef = function(event){
                    if(prf.onMediaEvent){
                        prf.boxing().onMediaEvent(prf, (event||window.event).type,  arguments);
                    }
                },t;
   
            ood.arr.each("loadstart progress durationchange seeked seeking timeupdate playing canplay canplaythrough volumechange ratechange loadedmetadata loadeddata play pause ended".split(" "), function(event, i){
                if(i = H5&&H5.get(0))
                    ood.Event._addEventListener(i, event, ef);
            });
            
            (prf.$beforeDestroy=(prf.$beforeDestroy||{}))["detachEvents"]=function(){
                ood.arr.each("loadstart progress durationchange seeked seeking timeupdate playing canplay canplaythrough volumechange ratechange loadedmetadata loadeddata play pause ended".split(" "),function(event, i){
                    if(i=H5&&H5.get(0))
                        ood.Event._removeEventListener(i, event, ef);
                });
            };

            if(!prop.controls)H5.attr("controls",null);
            if(!prop.loop)H5.attr("loop",null);
            if(!prop.muted)H5.attr("muted",null);

            if(!prop.autoplay)H5.attr("autoplay",null);
            else ood.asyRun(function(t){
                if(prf.$inDesign)return;
                if(prop.src && ood.isStr(prop.src) && (t=H5.get(0)))t.play();}
            );
            
            // 
            ood.asyRun(function(){
                prf.boxing().AudioTrigger();
            });
        },
        
        AudioTrigger: function() {
            var profile = this.get(0);
            var prop = profile.properties;
            var boxing = this;

            // 
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('audio-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                boxing.adjustLayout();
            }

            // 
            boxing.enhanceAccessibility();
        },
        _prepareData:function(profile){
            var data=arguments.callee.upper.call(this, profile);
            if(data.autoplay)data._autoplay = "autoplay";
            if(data.controls)data._controls = "controls";
            if(data.loop)data._loop = "loop";
            if(data.muted)data._muted = "muted";
            return data;
        },
        EventHandlers:{
            onMediaEvent:function(profile, eventType, params){}
        },
        _onresize:function(profile,width,height){
            var H5=profile.getSubNode('H5'), 
                size=H5.cssSize(),
                prop=profile.properties,
                us = ood.$us(profile),
                adjustunit = function(v,emRate){return profile.$forceu(v, us>0?'em':'px', emRate)},

                // caculate by px
                ww=width?profile.$px(width):width, 
                hh=height?profile.$px(height):height;

            if( (width && !ood.compareNumber(size.width,ww,6)) || (height && !ood.compareNumber(size.height,hh,6)) ){
                // reset here
                if(width){
                    H5.attr("width", ww).width(prop.width=adjustunit(ww));
                }
                if(height){
                    H5.attr("height", hh).height(prop.height=adjustunit(hh));
                }
                if(profile.$inDesign || prop.cover){
                    profile.getSubNode('COVER').cssSize({
                        width:width?prop.width:null,
                        height:height?prop.height:null
                    },true);
                }
            }
        }
    }
});ood.Class("ood.UI.FileUpload", "ood.UI", {
    iniProp: {dock: 'fill'},
    Instance: {
        setQueryData: function (data, path) {
            this.each(function (prf) {
                if (path) ood.set(prf.properties.params, (path || "").split("."), data);
                else prf.properties.params = data || {};
            });

        },

        reload: function (profile) {
            var src = this.getSrc(),
                uploadUrl = this.getUploadUrl(),
                host = profile.host,
                prepareFormData = this.getPrepareFormData(),
                params = this.getParams(), hash = {};
            if (!profile.$inDesign) {
                if (src && uploadUrl) {
                    if (host && prepareFormData) {
                        if (host.PAGECTX) {
                            ood.merge(hash, host.PAGECTX.getFormValues(), 'all');
                        } else {
                            ood.merge(hash, host.getData());
                        }
                    }
                    hash.uploadUrl = params.uploadUrl || uploadUrl;
                    for (key in params) {
                        if (key != 'uploadUrl') {
                            try {
                                var value = ood.adjustRes(params[key], true, 1, 1, null, {page: profile.module}, profile.module);
                                if (value) {
                                    hash[key] = ood.adjustRes(params[key], true, 1, 1, null, {page: profile.module}, profile.module)
                                }
                            } catch (e) {

                            }

                        }
                    }
                    var rulParams = ood.urlEncode(hash);
                    if (src.indexOf('?') > -1) {
                        src = src + "&" + rulParams;
                    } else {
                        src = src + "?" + rulParams;
                    }
                    profile.getSubNode("H5").attr("src", src);
                }
            }
            return src;
        },
        
        // 
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot(),
                    h5 = profile.getSubNode('H5'),
                    cover = profile.getSubNode('COVER');

                // 
                root.addClass('fileupload-themed');
                h5.addClass('fileupload-h5');
                cover.addClass('fileupload-cover');

                // 
                root.removeClass('fileupload-dark fileupload-hc');
                
                // 
                if (theme === 'dark') {
                    root.addClass('fileupload-dark');
                } else if (theme === 'high-contrast') {
                    root.addClass('fileupload-hc');
                }
                
                // 
                localStorage.setItem('fileupload-theme', theme);
            });
        },
        
        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('fileupload-theme') || 'light';
        },

        FileUploadTrigger: function() {
            var profile = this.get(0);
            var prop = profile.properties;
            var boxing = this;

            // 
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('fileupload-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                boxing.adjustLayout();
            }

            // 
            boxing.enhanceAccessibility();
        },


        // 
        toggleTheme: function() {
            const themes = ['light', 'dark', 'high-contrast'];
            const currentTheme = this.getTheme();
            const nextIndex = (themes.indexOf(currentTheme) + 1) % themes.length;
            this.setTheme(themes[nextIndex]);
            return this;
        },
        
        // 
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    h5 = profile.getSubNode('H5'),
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('fileupload-mobile');
                    
                    // 
                    h5.css({
                        'border-radius': '6px',
                        'min-height': '2.5em'
                    });
                } else {
                    root.removeClass('fileupload-mobile');
                    
                    // 
                    h5.css({
                        'border-radius': '',
                        'min-height': ''
                    });
                }

                // 
                if (width < 480) {
                    root.addClass('fileupload-tiny');
                    
                    // 
                    h5.css({
                        'min-height': '3em'
                    });
                } else {
                    root.removeClass('fileupload-tiny');
                }
            });
        },
        
        // 
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    h5 = profile.getSubNode('H5'),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'application',
                    'aria-label': ''
                });
                
                // iframeARIA
                if (h5 && !h5.isEmpty()) {
                    h5.attr({
                        'title': '',
                        'aria-label': '',
                        'role': 'document'
                    });
                }
            });
        }
    },


    Static: {
        Appearances: {
            KEY: {
                overflow: 'hidden'
            },
            H5: {
                position: 'absolute',
                left: '-1px',
                top: '-1px',
                'z-index': 1,
                'border': '1px solid var(--fileupload-border)'
            },
            COVER: {
                position: 'absolute',
                left: '-1px',
                top: '-1px',
                width: 0,
                height: 0,
                'z-index': 4,
                'opacity': '0.7'
            }
        },
        Templates: {
            tagName: 'div',
            className: '{_className}',
            style: '{_style}',
            H5: {
                tagName: 'iframe',
                src: '{src}',
                text: 'Your browser does not support the audio element.'
            },
            COVER: {
                tagName: 'div',
                style: "background-image:url(" + ood.ini.img_bg + ");"
            }
        },
        Behaviors: {
            HotKeyAllowed: false
        },
        DataModel: {
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark', 'high-contrast'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            selectable: true,
            width: {
                $spaceunit: 1,
                ini: '40em'
            },
            height: {
                $spaceunit: 1,
                ini: '30em'
            },

            src: {
                ini: '/plugins/fileupload/uploadgrid.html',
                action: function (v) {
                    this.getSubNode("H5").attr("src", ood.adjustRes(v));
                }
            },

            prepareFormData: {
                ini: true
            },
            uploadUrl: {
                ini: 'upload/',
                action: function (v) {
                    //  this.getSubNode("H5").attr("uploadUrl", ood.adjustRes(v));
                }
            },
            params: {
                ini: {},
                action: function (v) {
                    this.getSubNode("H5").attr("params", v);
                }
            }

        },
        RenderTrigger: function () {
            var prf = this,
                H5 = prf.getSubNode('H5'),
                prop = prf.properties;
            if (window['postMessage']) {
                self._msgcb = function (data) {
                    var e = ood.unserialize(data);
                    if (e.data) {
                        e = e.data
                    }
                    if (prf[e.eventType]) {
                        switch (e.eventType) {
                            case    'uploadfile':
                                prf.boxing().uploadfile(prf, e.eventType, e.item, e.response)
                                break;
                            case    'uploadfail':
                                prf.boxing().uploadfail(prf, e.eventType, e.item, e.response)
                                break;
                            case    'uploadcomplete':
                                prf.boxing().uploadcomplete(prf, e.eventType, e.item, e.response)
                                break;
                            case    'uploadprogress':
                                prf.boxing().uploadprogress(prf, e.eventType, e.item, e.response)
                                break;
                        }
                    }

                };
                if (window.addEventListener) window.addEventListener('message', self._msgcb, false);
                else window.attachEvent('onmessage', self._msgcb);
            }
            
            // 
            ood.asyRun(function(){
                prf.boxing().FileUploadTrigger();
            });
        },
        

        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile), hash = {}, host = profile.host, ns = this, src;
            if (!profile.$inDesign) {
                if (data.prepareFormData) {
                    var event = function (module) {
                        profile.boxing().reload(profile);
                    };
                    if (profile.getModule()) {
                        profile.getModule().setEvents("afterShow", event, false);
                    } else {
                        src = profile.boxing().reload(profile);
                    }
                }
            }
            if (src) {
                data.src = src;
            } else if (data.src && data.uploadUrl) {
                hash.uploadUrl = data.params.uploadUrl || data.uploadUrl;
                var rulParams = ood.urlEncode(hash);
                data.src = data.src + "?" + rulParams;
            }
            return data;
        },


        EventHandlers: {

            uploadfile: function (profile, eventType, item, response) {
            }
            ,
            uploadfail: function (profile, eventType, item, response) {
            }
            ,
            uploadcomplete: function (profile, eventType, item, response) {
            }
            ,
            uploadprogress: function (profile, eventType, item, response) {

            }
        }
        ,
        _onresize: function (profile, width, height) {
            var H5 = profile.getSubNode('H5'),
                size = H5.cssSize(),
                prop = profile.properties,
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },

                // caculate by px
                ww = width ? profile.$px(width) : width,
                hh = height ? profile.$px(height) : height;

            if ((width && !ood.compareNumber(size.width, ww, 6)) || (height && !ood.compareNumber(size.height, hh, 6))) {
                // reset here
                if (width) {
                    H5.attr("width", ww).width(prop.width = adjustunit(ww));
                }
                if (height) {
                    H5.attr("height", hh).height(prop.height = adjustunit(hh));
                }
                if (profile.$inDesign || prop.cover) {
                    profile.getSubNode('COVER').cssSize({
                        width: width ? prop.width : null,
                        height: height ? prop.height : null
                    }, true);
                }
            }
        }
    }

})
;ood.Class("ood.UI.Video", "ood.UI.Audio",{
    Instance:{
        // Video-specific methods
        enterFullscreen: function() {
            return this.each(function(profile) {
                var h5 = profile.getSubNode('H5').get(0);
                if (h5 && h5.requestFullscreen) {
                    h5.requestFullscreen();
                } else if (h5 && h5.webkitRequestFullscreen) {
                    h5.webkitRequestFullscreen();
                } else if (h5 && h5.mozRequestFullScreen) {
                    h5.mozRequestFullScreen();
                } else if (h5 && h5.msRequestFullscreen) {
                    h5.msRequestFullscreen();
                }
            });
        },
        
        exitFullscreen: function() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            return this;
        },
        
        // Override Audio's adjustLayout method for video features
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    h5 = profile.getSubNode('H5'),
                    canvas = profile.getSubNode('CANVAS'),
                    prop = profile.properties;

                // Adjust layout for small screens
                if (width < 768) {
                    root.addClass('video-mobile');
                    
                    // Adjust video player size for mobile
                    h5.css({
                        'width': '100%',
                        'height': 'auto',
                        'max-height': 'var(--ood-video-max-height, 60vh)',
                        'border-radius': 'var(--ood-border-radius-md)',
                        'box-shadow': 'var(--ood-shadow-sm)'
                    });
                    
                    if (canvas && !canvas.isEmpty()) {
                        canvas.css({
                            'width': '100%',
                            'height': 'auto',
                            'border-radius': 'var(--ood-border-radius-md)'
                        });
                    }
                } else {
                    root.removeClass('video-mobile');
                    
                    // Restore desktop styles
                    h5.css({
                        'width': '',
                        'height': '',
                        'max-height': ''
                    });
                    
                    if (canvas && !canvas.isEmpty()) {
                        canvas.css({
                            'width': '',
                            'height': ''
                        });
                    }
                }

                // Special handling for extra small screens
                if (width < 480) {
                    root.addClass('video-tiny');
                    
                    // Limit maximum height
                    h5.css({
                        'max-height': 'var(--ood-video-max-height-tiny, 40vh)',
                        'border-radius': 'var(--ood-border-radius-sm)'
                    });
                } else {
                    root.removeClass('video-tiny');
                }
            });
        }
    },


    // 
    setTheme: function(theme) {
        return this.each(function(profile) {
            var root = profile.getRoot();
            
            // 
            root.attr('data-theme', theme);
            
            // 
            root.addClass('ood-video');
            
            // 
            localStorage.setItem('video-theme', theme);
            profile.properties.theme = theme;
        });
    },
            


    // Get current theme
    getTheme: function() {
        var profile = this.get(0);
        return profile.properties.theme || localStorage.getItem('video-theme') || 'light';
    },

    VideoTrigger: function() {
        var profile = this.get(0);
        var prop = profile.properties;
        var boxing = this;

        // Initialize theme
        if (prop.theme) {
            boxing.setTheme(prop.theme);
        } else {
            // Restore theme from local storage
            var savedTheme = localStorage.getItem('video-theme') || localStorage.getItem('audio-theme');
            if (savedTheme) {
                boxing.setTheme(savedTheme);
            } else {
                // Use system theme by default
                var darkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                boxing.setTheme(darkMode ? 'dark' : 'light');
            }
        }

    // Initialize responsive design
    if (prop.responsive !== false) {
        boxing.adjustLayout();
    }

    // Initialize accessibility
    boxing.enhanceAccessibility();
}   ,


    // Enhance accessibility support
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    h5 = profile.getSubNode('H5'),
                    canvas = profile.getSubNode('CANVAS'),
                    properties = profile.properties;

                // Add ARIA attributes to container
                root.attr({
                    'role': 'application',
                    'aria-label': ood.getRes('UI.video.player')
                });
                
                // Add ARIA attributes to video element
                if (h5 && !h5.isEmpty()) {
                    h5.attr({
                        'aria-label': ood.getRes('UI.video.controls'),
                        'role': 'application'
                    });
                    
                    // Set attributes based on state
                    if (properties.controls) {
                        h5.attr('aria-controls', 'true');
                    }
                    
                    if (properties.muted) {
                        h5.attr('aria-label', ood.getRes('UI.video.player.muted'));
                    }
                    
                    if (properties.poster) {
                        h5.attr('aria-describedby', ood.getRes('UI.video.poster'));
                    }
                }
                
                // Add ARIA attributes to canvas
                if (canvas && !canvas.isEmpty()) {
                    canvas.attr({
                        'role': 'img',
                        'aria-label': ood.getRes('UI.video.canvas')
                    });
                }
            });
        },
    Static:{
        Templates:{
            tagName:'div',
            crossOrigin:  'anonymous',
            className:'{_className}',
            style:'{_style}',
            H5:{
                tagName:'video',
                autoplay:'{_autoplay}',
                controls:'{_controls}',
                loop:'{_loop}',
                muted:'{_muted}',
                type:'application/x-mpegURL',
                preload:'{preload}',
                volume:'{volume}',
                src:'{src}',
                width:'{width}',
                height:'{height}',
                text:'Your browser does not support the video element.'
            },
            CANVAS:{
                tagName:'canvas',
                style:"background-image:url("+ood.ini.img_bg+");"
            },
            COVER:{
                tagName:'div',
                style:"background-image:url("+ood.ini.img_bg+");"
            }
        },
        DataModel:{
            // Modern properties
            theme: {
                ini: 'dark',
                listbox: ['light', 'dark', 'high-contrast'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            width:{
                $spaceunit:1,
                ini:'34em'
            },
            height:{
                $spaceunit:1,
                ini:'25em'
            },
            poster:{
                format:'image',
                ini: '',
                action:function(v){
                    this.getSubNode("H5").attr("poster", v||null);
                }
            }
        },
        RenderTrigger:function(){
            var prf=this,
                H5 = prf.getSubNode('H5'),
                prop = prf.properties,
                t;
            if(t=prop.poster)H5.attr("poster",t);
            
            // Modern feature initialization
            ood.asyRun(function(){
                prf.boxing().VideoTrigger();
            });
        }
    }
});ood.Class("ood.UI.Tensor", "ood.UI", {

    Instance: {
        //  iniProp 
        iniProp: {
            patterned: false,
            dock: 'fill'
        },

        setQueryData: function (data, path) {
            this.each(function (prf) {
                if (path) ood.set(prf.properties.params, (path || "").split("."), data);
                else prf.properties.params = data || {};
            });

        },

        reload: function (profile) {
            var src = this.getSrc(),
                uploadUrl = this.getUploadUrl(),
                host = profile.host,
                prepareFormData = this.getPrepareFormData(),
                params = this.getParams(), hash = {};
            if (!profile.$inDesign) {
                if (src && uploadUrl) {
                    if (host && prepareFormData) {
                        if (host.PAGECTX) {
                            ood.merge(hash, host.PAGECTX.getFormValues(), 'all');
                        } else {
                            ood.merge(hash, host.getData());
                        }
                    }
                    hash.uploadUrl = params.uploadUrl || uploadUrl;
                    for (key in params) {
                        if (key != 'uploadUrl') {
                            try {
                                var value = ood.adjustRes(params[key], true, 1, 1, null, {page: profile.module}, profile.module);
                                if (value) {
                                    hash[key] = ood.adjustRes(params[key], true, 1, 1, null, {page: profile.module}, profile.module)
                                }
                            } catch (e) {

                            }

                        }
                    }
                    var rulParams = ood.urlEncode(hash);
                    if (src.indexOf('?') > -1) {
                        src = src + "&" + rulParams;
                    } else {
                        src = src + "?" + rulParams;
                    }
                    profile.getSubNode("H5").attr("src", src);
                }
            }
            return src;
        }
    },


    Static: {
        Appearances: {
            KEY: {
                overflow: 'hidden',
                'border': '1px solid var(--ood-border)',
                'background-color': 'var(--ood-bg)'
            },
            H5: {
                position: 'absolute',
                left: '-1px',
                top: '-1px',
                'z-index': 1,
                'border': 'none'
            },
            COVER: {
                position: 'absolute',
                left: '-1px',
                top: '-1px',
                width: 0,
                height: 0,
                'z-index': 4,
                'background-color': 'var(--ood-overlay)'
            }
        },
        Templates: {
            tagName: 'div',
            className: '{_className}',
            style: '{_style}',
            H5: {
                tagName: 'iframe',
                src: '{src}',
                text: 'Your browser does not support the audio element.'
            },
            COVER: {
                tagName: 'div',
                style: "background-image:url(" + ood.ini.img_bg + ");"
            }
        },
        Behaviors: {
            HotKeyAllowed: false
        },
        DataModel: {
            selectable: true,
            width: {
                $spaceunit: 1,
                ini: '40em'
            },
            height: {
                $spaceunit: 1,
                ini: '30em'
            },

            src: {
                ini: '/plugins/dist/index.html',
                action: function (v) {
                    this.getSubNode("H5").attr("src", ood.adjustRes(v));
                }
            },

            prepareFormData: {
                ini: true
            },
            uploadUrl: {
                ini: 'upload/',
                action: function (v) {
                    //  this.getSubNode("H5").attr("uploadUrl", ood.adjustRes(v));
                }
            },
            params: {
                ini: {},
                action: function (v) {
                    this.getSubNode("H5").attr("params", v);
                }
            }

        },
        RenderTrigger: function () {
            var prf = this,
                H5 = prf.getSubNode('H5'),
                prop = prf.properties;
            if (window['postMessage']) {
                self._msgcb = function (data) {
                    var e = ood.unserialize(data);
                    if (e.data) {
                        e = e.data
                    }
                    if (prf[e.eventType]) {
                        switch (e.eventType) {
                            case    'uploadfile':
                                prf.boxing().uploadfile(prf, e.eventType, e.item, e.response)
                                break;
                            case    'uploadfail':
                                prf.boxing().uploadfail(prf, e.eventType, e.item, e.response)
                                break;
                            case    'uploadcomplete':
                                prf.boxing().uploadcomplete(prf, e.eventType, e.item, e.response)
                                break;
                            case    'uploadprogress':
                                prf.boxing().uploadprogress(prf, e.eventType, e.item, e.response)
                                break;
                        }
                    }

                };
                if (window.addEventListener) window.addEventListener('message', self._msgcb, false);
                else window.attachEvent('onmessage', self._msgcb);
            }


        },

        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile), hash = {}, host = profile.host, ns = this, src;
            if (!profile.$inDesign) {
                if (data.prepareFormData) {
                    var event = function (module) {
                        profile.boxing().reload(profile);
                    };
                    if (profile.getModule()) {
                        profile.getModule().setEvents("afterShow", event, false);
                    } else {
                        src = profile.boxing().reload(profile);
                    }
                }
            }
            if (src) {
                data.src = src;
            } else if (data.src && data.uploadUrl) {
                hash.uploadUrl = data.params.uploadUrl || data.uploadUrl;
                var rulParams = ood.urlEncode(hash);
                data.src = data.src + "?" + rulParams;
            }
            return data;
        },


        EventHandlers: {

            uploadfile: function (profile, eventType, item, response) {
            }
            ,
            uploadfail: function (profile, eventType, item, response) {
            }
            ,
            uploadcomplete: function (profile, eventType, item, response) {
            }
            ,
            uploadprogress: function (profile, eventType, item, response) {

            }
        }
        ,
        _onresize: function (profile, width, height) {
            var H5 = profile.getSubNode('H5'),
                size = H5.cssSize(),
                prop = profile.properties,
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },

                // caculate by px
                ww = width ? profile.$px(width) : width,
                hh = height ? profile.$px(height) : height;

            if ((width && !ood.compareNumber(size.width, ww, 6)) || (height && !ood.compareNumber(size.height, hh, 6))) {
                // reset here
                if (width) {
                    H5.attr("width", ww).width(prop.width = adjustunit(ww));
                }
                if (height) {
                    H5.attr("height", hh).height(prop.height = adjustunit(hh));
                }
                if (profile.$inDesign || prop.cover) {
                    profile.getSubNode('COVER').cssSize({
                        width: width ? prop.width : null,
                        height: height ? prop.height : null
                    }, true);
                }
            }
        }
    }

})
;ood.Class("ood.UI.Camera", "ood.UI.Audio",{
    Instance:{
        //  iniProp 
        iniProp: {
            patterned: false,
            dock: 'fill'
        }
    },
    Static:{
        Templates:{
            tagName:'div',
            crossOrigin:  'anonymous',
            className:'{_className} ood-camera-container',
            style:'{_style};background-color:var(--ood-bg);border:1px solid var(--ood-border);',
            H5:{
                tagName:'camera',
                autoplay:'{_autoplay}',
                controls:'{_controls}',
                loop:'{_loop}',
                muted:'{_muted}',
                type:'application/x-mpegURL',
                preload:'{preload}',
                volume:'{volume}',
                src:'{src}',
                width:'{width}',
                height:'{height}',
                style:'background-color:var(--ood-bg-secondary)',
                text:'Your browser does not support the video element.'
            },
            COVER:{
                tagName:'div',
                style:"background-image:url("+ood.ini.img_bg+");background-color:var(--ood-overlay)"
            }
        },
        DataModel:{
            width:{
                $spaceunit:1,
                ini:'34em'
            },
            height:{
                $spaceunit:1,
                ini:'25em'
            },
            poster:{
                format:'image',
                ini: '',
                action:function(v){
                    this.getSubNode("H5").attr("poster", v||null);
                }
            }
        },
        RenderTrigger:function(){
            var prf=this,
                H5 = prf.getSubNode('H5'),
                prop = prf.properties,
                t;
            if(t=prop.poster)H5.attr("poster",t);
        }
    }
});//resizer class, add a plug in to ood.Dom
ood.Class("ood.UI.Resizer", "ood.UI", {
    Instance: {
        _attachTo: function (target, parent) {
            var self = this, v = self.get(0);

            //set target first
            v._target = ood(target);
            v._parent = parent || ood('body');

            //add to dom
            v._parent.append(self);

            v.$resizeId = ood(target).id();

            return self;
        },
        show: function () {
            var self = this;
            self.each(function (o) {
                o.getRoot().css('display', '');
            });
            if (ood.browser.ie)
                self.reBoxing().ieRemedy();
            return self;
        },
        hide: function () {
            var self = this;
            self.reBoxing().css('display', 'none');
            return self;
        }
    },
    Initialize: function () {
        this.addTemplateKeys(['HANDLER', 'HIDDEN', 'MOVE', 'CONF1', 'CONF2', 'ROTATE', 'L', 'R', 'T', 'B', 'LT', 'RT', 'LB', 'RB', 'REGION']);
        ood.each({
            // add resizer to ood.Dom plugin
            addResizer: function (properties, onUpdate, onChange) {
                var target = ood([this.get(0)]);
                properties = properties || {};
                ood.merge(properties, {
                    _attached: true
                });

                var r = new ood.UI.Resizer(properties)._attachTo(target, target);

                //set event
                if (onUpdate) r.onUpdate(onUpdate);
                if (onChange) r.onChange(onChange);
                return r;
            },
            removeResizer: function () {
                var s = this.id();
                ood.arr.each(ood.UI.Resizer._cache, function (o) {
                    if (o && o.$resizeId == s)
                        o.boxing().destroy(true);
                });
                return this;
            },
            $getResizer: function () {
                var s = this.id(), b;
                ood.arr.each(ood.UI.Resizer._cache, function (o) {
                    if (o && o.$resizeId == s) {
                        b = o;
                        return false;
                    }
                });
                return b && b.boxing();
            }
        }, function (o, i) {
            ood.Dom.plugIn(i, o);
        });

        //for ood.UI.Widget
        ood.each({
            _resizer: function (key, args) {
                return this.each(function (o) {
                    var target = o.getSubNode('BORDER'),
                        d = o.properties;
                    if (target.$getResizer()) return;
                    args = args || {};
                    var update = function (pro, target, size, cssPos) {
                        var profile = arguments.callee.profile,
                            node = profile.getRoot(),
                            instance = profile.boxing(),
                            prop = profile.properties,
                            svg = profile.box['ood.svg'],
                            t;
                        if (size) {
                            var w = null, h = null, l = null, t = null;
                            if (t = size.width) {
                                node.widthBy(t);
                                prop.width = w = profile.$forceu(svg ? instance.getWidth() : node.width());
                            }
                            if (t = size.height) {
                                node.heightBy(t);
                                prop.height = h = profile.$forceu(svg ? instance.getHeight() : node.height());
                            }
                            ood.UI.$tryResize(profile, w, h, true);

                            // for no _onresize widget only
                            if (!profile.box._onresize && profile.onResize && (w !== null || h !== null))
                                instance.onResize(profile, w, h);
                        }
                        if (cssPos) {
                            if ((t = cssPos.left) && !(prop.left == 'auto' && Math.round(parseFloat(prop.right)) >= 0)) {
                                node.leftBy(t);
                                prop.left = l = profile.$forceu(svg ? instance.getLeft() : node.left());
                            }
                            if ((t = cssPos.top) && !(prop.top == 'auto' && Math.round(parseFloat(prop.bottom)) >= 0)) {
                                node.topBy(t);
                                prop.top = t = profile.$forceu(svg ? instance.getTop() : node.top());
                            }
                            if (profile.onMove && (l !== null || t !== null))
                                instance.onMove(profile, l, t, null, null);
                        }
                        return false;
                    };
                    update.profile = o;

                    o.$resizer = target.addResizer(args, update);

                    o.$resizer.get(0).$parentUIProfile = o;

                    // hide resizer
                    if (d.visibility == 'hidden') {
                        o.$resizer.hide();
                    }
                });
            },
            _unResizer: function () {
                return this.each(function (o) {
                    var target = o.getSubNode('BORDER');
                    if (!target.$getResizer()) return;
                    target.removeResizer();
                    delete o.$resizer;
                });
            }
        }, function (o, i) {
            ood.UI.Widget.plugIn(i, o);
        });
        ood.UI.Widget.setDataModel({
            resizer: {
                ini: false,
                action: function (v) {
                    var b = this.boxing();
                    if (v) {
                        var t = this.properties,
                            arg = {};
                        ood.each('minHeight,minWidth,maxHeight,maxWidth'.split(','), function (i) {
                            if (i in t) arg[i] = t[i];
                        });

                        if (t.resizerProp && !ood.isEmpty(t.resizerProp)) {
                            ood.merge(arg, t.resizerProp, 'all');
                        }
                        if (t.tagVar.resizerProp) {
                            ood.merge(arg, t.tagVar.resizerProp, 'all');
                        }
                        b._resizer(v, arg);
                        if (this.$inDesign) {
                            try {
                                this.$resizer.get(0).$inDesign = 1;
                            } catch (e) {

                            }

                        }
                    } else
                        b._unResizer();
                }
            },
            resizerProp: {
                ini: {}
            }
        });
    },
    Static: {
        Templates: {
            tagName: 'div',
            className: '{_disabled}',
            style: '{_style};'
        },
        Appearances: {
            KEY: {
                position: 'absolute',
                margin: '0 -1px -1px 0',
                visibility: 'visible',
                background: (ood.browser.ie && !ood.browser.newie) ? ('url(' + ood.ini.img_bg + ')') : '',
                'z-index': 60,
                cursor: 'move',
                'border': '1px solid var(--ood-resizer-border)',
                'background-color': 'var(--ood-resizer-bg)'
            },
            "KEY.readonly, KEY.disabled": {
                background: "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 400 400'><rect x='0' y='0' width='400' height='400' stroke='var(--ood-resizer-disabled-stroke)' fill='var(--ood-resizer-disabled-fill)' opacity='0.3' stroke-width='1'></rect><path d='M400 0 L0 400 ' stroke='var(--ood-resizer-disabled-stroke)' stroke-width='1'/><path d='M0 0 L400 400 ' stroke='var(--ood-resizer-disabled-stroke)' stroke-width='1'/></svg>\")",
                'background-repeat': 'no-repeat',
                'background-position': 'center center',
                'background-size': '100% 100%, auto'
            },
            "KEY.readonly.active, KEY.disabled.active": {
                background: "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 400 400'><rect x='0' y='0' width='400' height='400' stroke='var(--ood-resizer-disabled-stroke)' fill='var(--ood-resizer-disabled-fill-active)' opacity='0.3' stroke-width='1'></rect><path d='M400 0 L0 400 ' stroke='var(--ood-resizer-disabled-stroke)' stroke-width='1'/><path d='M0 0 L400 400 ' stroke='var(--ood-resizer-disabled-stroke)' stroke-width='1'/></svg>\")"
            },
            "KEY.readonly div, KEY.disabled div": {
                display: 'none'
            },
            "KEY.readonly CONF1, KEY.readonly CONF2": {
                $order: 10,
                opacity: 1,
                display: 'block'
            },
            MOVE: {
                position: 'absolute',
                display: 'block',
                'z-index': 100,
                visibility: 'visible'
            },
            'CONF1, CONF2, ROTATE': {
                position: 'absolute',
                display: 'block',
                'z-index': 100,
                visibility: 'visible',
                cursor: 'pointer'
            },
            ROTATE: {
                $order: 1,
                cursor: 'crosshair'
            },
            HANDLER: {
                $order: 0,
                position: 'absolute',
                display: 'block',
                border: 'solid 1px',
                'z-index': 100,
                visibility: 'visible'
            },
            T: {
                $order: 1,
                left: '50%',
                cursor: 'n-resize'
            },
            RT: {
                $order: 1,
                cursor: 'ne-resize',
                'z-index': 110
            },
            R: {
                $order: 1,
                top: '50%',
                cursor: 'e-resize'
            },
            RB: {
                $order: 1,
                cursor: 'se-resize',
                'z-index': 110
            },
            B: {
                $order: 1,
                left: '50%',
                cursor: 's-resize'
            },
            LB: {
                $order: 1,
                cursor: 'sw-resize',
                'z-index': 110
            },
            L: {
                $order: 1,
                top: '50%',
                cursor: 'w-resize'
            },
            LT: {
                $order: 1,
                cursor: 'nw-resize',
                'z-index': 110
            },
            //must after HANDLER
            HIDDEN: {
                $order: 10,
                'background-color': 'transparent',
                'border-width': 0
            }
        },
        Behaviors: {
            beforeMousedown: function (profile, e, src) {
                if (profile.properties.readonly || profile.properties.disabled) return false;
                profile.box._onMousedown(profile, e, src, "move");
            },
            onDragbegin: function (profile, e, src) {
                if (profile.properties.readonly || profile.properties.disabled) return false;
                profile.box._onDragbegin(profile, e, src, "move");
            },
            onDrag: function (profile, e, src) {
                profile.box._onDrag(profile, e, src, "move");
            },
            onDragstop: function (profile, e, src) {
                profile.box._onDragstop(profile, e, src, "move");
            },
            onDblclick: function (profile, e, src) {
                if (profile.onDblclick) profile.boxing().onDblclick(profile, e, src);
            },
            CONF1: {
                onMouseover: function (profile, e, src) {
                    if (profile.properties.disabled) return false;
                    if (profile.onConfig)
                        return profile.boxing().onConfig(profile, e, src, 'left', 'mouseover');
                    return false;
                },
                onMousedown: function (profile, e, src) {
                    if (profile.properties.disabled) return false;
                    if (profile.onConfig)
                        return profile.boxing().onConfig(profile, e, src, 'left', 'mousedown');
                    return false;
                },
                onClick: function (profile, e, src) {
                    if (profile.properties.disabled) return false;
                    if (profile.onConfig)
                        return profile.boxing().onConfig(profile, e, src, 'left', 'click');
                    return false;
                }
            },
            CONF2: {
                onMouseover: function (profile, e, src) {
                    if (profile.properties.disabled) return false;
                    if (profile.onConfig)
                        return profile.boxing().onConfig(profile, e, src, 'right', 'mouseover');
                    return false;
                },
                onMousedown: function (profile, e, src) {
                    if (profile.properties.disabled) return false;
                    if (profile.onConfig)
                        return profile.boxing().onConfig(profile, e, src, 'right', 'mousedown');
                    return false;
                },
                onClick: function (profile, e, src) {
                    if (profile.properties.disabled) return false;
                    if (profile.onConfig)
                        return profile.boxing().onConfig(profile, e, src, 'right', 'click');
                    return false;
                }
            },
            ROTATE: {
                beforeMousedown: function (profile, e, src) {
                    profile.box._onMousedown(profile, e, src, "rotate");
                    return false;
                },
                onDragbegin: function (profile, e, src) {
                    profile.box._onDragbegin(profile, e, src, "rotate");
                },
                onDrag: function (profile, e, src) {
                    profile.box._onDrag(profile, e, src, "rotate");
                },
                onDragstop: function (profile, e, src) {
                    profile.box._onDragstop(profile, e, src, "rotate");
                }
            },
            LT: {
                beforeMousedown: function (profile, e, src) {
                    profile.box._onMousedown(profile, e, src, 'nw');
                    return false;
                },
                onDragbegin: function (profile, e, src) {
                    profile.box._onDragbegin(profile, e, src, 'nw');
                },
                onDrag: function (profile, e, src) {
                    profile.box._onDrag(profile, e, src, 'nw');
                },
                onDragstop: function (profile, e, src) {
                    profile.box._onDragstop(profile, e, src, 'nw');
                }
            },
            RT: {
                beforeMousedown: function (profile, e, src) {
                    profile.box._onMousedown(profile, e, src, 'ne');
                    return false;
                },
                onDragbegin: function (profile, e, src) {
                    profile.box._onDragbegin(profile, e, src, 'ne');
                },
                onDrag: function (profile, e, src) {
                    profile.box._onDrag(profile, e, src, 'ne');
                },
                onDragstop: function (profile, e, src) {
                    profile.box._onDragstop(profile, e, src, 'ne');
                }
            },
            LB: {
                beforeMousedown: function (profile, e, src) {
                    profile.box._onMousedown(profile, e, src, 'sw');
                    return false;
                },
                onDragbegin: function (profile, e, src) {
                    profile.box._onDragbegin(profile, e, src, 'sw');
                },
                onDrag: function (profile, e, src) {
                    profile.box._onDrag(profile, e, src, 'sw');
                },
                onDragstop: function (profile, e, src) {
                    profile.box._onDragstop(profile, e, src, 'sw');
                }
            },
            RB: {
                beforeMousedown: function (profile, e, src) {
                    profile.box._onMousedown(profile, e, src, 'se');
                    return false;
                },
                onDragbegin: function (profile, e, src) {
                    profile.box._onDragbegin(profile, e, src, 'se');
                },
                onDrag: function (profile, e, src) {
                    profile.box._onDrag(profile, e, src, 'se');
                },
                onDragstop: function (profile, e, src) {
                    profile.box._onDragstop(profile, e, src, 'se');
                }
            },
            L: {
                beforeMousedown: function (profile, e, src) {
                    profile.box._onMousedown(profile, e, src, 'w');
                    return false;
                },
                onDragbegin: function (profile, e, src) {
                    profile.box._onDragbegin(profile, e, src, 'w');
                },
                onDrag: function (profile, e, src) {
                    profile.box._onDrag(profile, e, src, 'w');
                },
                onDragstop: function (profile, e, src) {
                    profile.box._onDragstop(profile, e, src, 'w');
                }
            },
            T: {
                beforeMousedown: function (profile, e, src) {
                    profile.box._onMousedown(profile, e, src, 'n');
                    return false;
                },
                onDragbegin: function (profile, e, src) {
                    profile.box._onDragbegin(profile, e, src, 'n');
                },
                onDrag: function (profile, e, src) {
                    profile.box._onDrag(profile, e, src, 'n');
                },
                onDragstop: function (profile, e, src) {
                    profile.box._onDragstop(profile, e, src, 'n');
                }
            },
            R: {
                beforeMousedown: function (profile, e, src) {
                    profile.box._onMousedown(profile, e, src, 'e');
                    return false;
                },
                onDragbegin: function (profile, e, src) {
                    profile.box._onDragbegin(profile, e, src, 'e');
                },
                onDrag: function (profile, e, src) {
                    profile.box._onDrag(profile, e, src, 'e');
                },
                onDragstop: function (profile, e, src) {
                    profile.box._onDragstop(profile, e, src, 'e');
                }
            },
            B: {
                beforeMousedown: function (profile, e, src) {
                    profile.box._onMousedown(profile, e, src, 's');
                    return false;
                },
                onDragbegin: function (profile, e, src) {
                    profile.box._onDragbegin(profile, e, src, 's');
                },
                onDrag: function (profile, e, src) {
                    profile.box._onDrag(profile, e, src, 's');
                },
                onDragstop: function (profile, e, src) {
                    profile.box._onDragstop(profile, e, src, 's');
                }
            }
        },
        DataModel: {
            _attached: false,

            forceVisible: {
                ini: false,
                caption: ood.getResText("DataModel.forceVisible") || ""
            },
            forceMovable: {
                ini: '',
                caption: ood.getResText("DataModel.forceMovable") || ""
            },

            singleDir: {
                ini: false,
                caption: ood.getResText("DataModel.singleDir") || ""
            },
            vertical: {
                ini: true,
                caption: ood.getResText("DataModel.vertical") || ""
            },
            horizontal: {
                ini: true,
                caption: ood.getResText("DataModel.horizontal") || ""
            },

            minHeight: {
                ini: 12,
                caption: ood.getResText("DataModel.minHeight") || ""
            },
            minWidth: {
                ini: 12,
                caption: ood.getResText("DataModel.minWidth") || ""
            },
            maxHeight: {
                ini: 5000,
                caption: ood.getResText("DataModel.maxHeight") || ""
            },
            maxWidth: {
                ini: 5000,
                caption: ood.getResText("DataModel.maxWidth") || ""
            },

            handlerSize: {
                ini: ood.browser.contentBox ? 8 : 12,
                caption: ood.getResText("DataModel.handleSize") || ""
            },
            handlerOffset: {
                ini: ood.browser.contentBox ? 1 : 0,
                caption: ood.getResText("DataModel.handlerOffset") || ""
            },
            readonly: {
                ini: false,
                caption: ood.getResText("DataModel.readonly") || "",
                action: function (v) {
                    if (v) this.getRoot().addClass("readonly");
                    else this.getRoot().removeClass("readonly");
                }
            },
            disabled: {
                ini: false,
                caption: ood.getResText("DataModel.disabled") || "",
                action: function (v) {
                    if (v) this.getRoot().addClass("disabled");
                    else this.getRoot().removeClass("disabled");
                }
            },
            leftConfigBtn: {
                ini: false,
                caption: ood.getResText("DataModel.leftConfigBtn") || "",
                action: function (v) {
                    this.getSubNode('CONF1').css('display', v ? '' : 'none');
                }
            },
            rightConfigBtn: {
                ini: false,
                caption: ood.getResText("DataModel.rightConfigBtn") || "",
                action: function (v) {
                    this.getSubNode('CONF2').css('display', v ? '' : 'none');
                }
            },
            rotatable: {
                ini: false,
                caption: ood.getResText("DataModel.rotatable") || "",
                action: function (v) {
                    if (v && ood.browser.ie && ood.browser.ver <= 8)
                        v = false;
                    this.getSubNode('ROTATE').css('display', v ? '' : 'none');
                }
            },
//>>

            left: {
                ini: 100,
                caption: ood.getResText("DataModel.left") || ""
            },
            top: {
                ini: 100,
                caption: ood.getResText("DataModel.top") || ""
            },
            height: {
                ini: 100,
                caption: ""
            },
            width: {
                ini: 100,
                caption: ""
            },
            position: {
                ini: 'absolute',
                caption: ""
            },
            display: {
                ini: 'block',
                caption: ""
            }
        },
        EventHandlers: {
            onDblclick: function (profile, e, src) {
            },
            onUpdate: function (profile, target, size, cssPos, rotate) {
            },
            onChange: function (profile, proxy) {
            },
            onConfig: function (profile, e, src, pos, type) {
            }
        },
        _dynamicTemplate: function (profile) {
            var pro = profile.properties, size, pos, temp,
                hash = profile._exhash =
                    "$" +
                    '_attached:' + pro._attached + ';' +
                    'forceVisible:' + pro.forceVisible + ';' +
                    'singleDir:' + pro.singleDir + ';' +
                    'vertical:' + pro.vertical + ';' +
                    'horizontal:' + pro.horizontal + ';' +
                    'forceMovable:' + pro.forceMovable + ';'
            ;

            var map = arguments.callee.map || (arguments.callee.map = {
                //move icon size 13*13
                MOVE: {
                    tagName: 'div',
                    className: 'oodfont',
                    $fonticon: 'ood-icon-dragmove',
                    style: 'font-size: 1.5em;top:50%;left:50%;margin-left:-0.5em;margin-top:-0.5em;'
                },
                CONF1: {
                    tagName: 'div',
                    className: 'oodfont',
                    $fonticon: 'ood-icon-star',
                    style: 'font-size: 1.5em;top:-1.125em;left:-1.125em;{_leftCofigBtn};'
                },
                CONF2: {
                    tagName: 'div',
                    className: 'oodfont',
                    $fonticon: 'ood-uicmd-opt',
                    style: 'font-size: 1.5em;top:-1.125em;left:auto;right:-1.125em;{_rightCofigBtn};'
                },
                ROTATE: {
                    tagName: 'div',
                    className: 'oodfont',
                    $fonticon: 'ood-icon-circle',
                    style: 'font-size: 1.5em;top:-1.25em;left:50%;margin-left:-0.5em;{_rotateBtn};'
                },
                T: {
                    tagName: 'div',
                    style: 'top:-{_extend};margin-left:-{_extend};width:{_handlerSize};height:{_handlerSize};'
                },
                RT: {
                    tagName: 'div',
                    style: 'top:-{_extend};right:-{_extend};width:{_handlerSize};height:{_handlerSize};'
                },
                R: {
                    tagName: 'div',
                    style: 'right:-{_extend};margin-top:-{_extend};width:{_handlerSize};height:{_handlerSize};'
                },
                RB: {
                    tagName: 'div',
                    style: 'bottom:-{_extend};right:-{_extend};width:{_handlerSize};height:{_handlerSize};'
                },
                B: {
                    tagName: 'div',
                    style: 'bottom:-{_extend};margin-left:-{_extend};width:{_handlerSize};height:{_handlerSize};'
                },
                LB: {
                    tagName: 'div',
                    style: 'bottom:-{_extend};left:-{_extend};width:{_handlerSize};height:{_handlerSize};'
                },
                L: {
                    tagName: 'div',
                    style: 'left:-{_extend};margin-top:-{_extend};width:{_handlerSize};height:{_handlerSize};'
                },
                LT: {
                    tagName: 'div',
                    style: 'left:-{_extend};top:-{_extend};width:{_handlerSize};height:{_handlerSize};'
                },
                cover: {
                    T: {tagName: 'div', style: 'width:100%;left:0em;top:-{_extend};height:{_handlerSize};'},
                    RT: {
                        tagName: 'div',
                        style: 'top:-{_extend};right:-{_extend};width:{_handlerSize};height:{_handlerSize};'
                    },
                    R: {tagName: 'div', style: 'height:100%;top:0em;right:-{_extend};width:{_handlerSize};'},
                    RB: {
                        tagName: 'div',
                        style: 'right:-{_extend};bottom:-{_extend};width:{_handlerSize};height:{_handlerSize};'
                    },
                    B: {tagName: 'div', style: 'width:100%;left:0em;bottom:-{_extend};height:{_handlerSize};'},
                    LB: {
                        tagName: 'div',
                        style: 'left:-{_extend};bottom:-{_extend};width:{_handlerSize};height:{_handlerSize};'
                    },
                    L: {tagName: 'div', style: 'height:100%;top:0em;left:-{_extend};width:{_handlerSize};'},
                    LT: {
                        tagName: 'div',
                        style: 'top:-{_extend};left:-{_extend};width:{_handlerSize};height:{_handlerSize};'
                    }
                }
            });

            /* dynamic template set here
                template._id is main id, which can input by create arg
                template._did is sub id, which must be built on fly, and cached
            */
            var template = profile.box.getTemplate(hash);
            // set template dynamic
            if (!template) {
                var t, n;
                template = ood.clone(profile.box.getTemplate());

                // cover or not?
                t = pro._cover ? map.cover : map;
                // can move?
                if (pro._move) template.MOVE = map.MOVE;

                template.CONF1 = map.CONF1;
                template.CONF2 = map.CONF2;
                template.ROTATE = map.ROTATE;

                // change height only
                if (pro.vertical) {
                    if (!pro.singleDir)
                        template.T = t.T;
                    template.B = t.B;
                }
                // change width only
                if (pro.horizontal) {
                    if (!pro.singleDir)
                        template.L = t.L;
                    template.R = t.R;
                    // change height and width
                    if (pro.vertical) {
                        if (!pro.singleDir) {
                            template.LB = t.LB;
                            template.RT = t.RT;
                            template.LT = t.LT;
                        }
                        template.RB = t.RB;
                    }
                }

                n = profile.getClass('KEY', '-handler') + " ";
                if (t = template.T) t.className = n;
                if (t = template.RT) t.className = n;
                if (t = template.R) t.className = n;
                if (t = template.RB) t.className = n;
                if (t = template.B) t.className = n;
                if (t = template.LB) t.className = n;
                if (t = template.L) t.className = n;
                if (t = template.LT) t.className = n;

                // if hidden
                if (!pro._visible) {
                    n = profile.getClass('KEY', '-hidden') + " ";
                    if (t = template.T) t.className += n;
                    if (t = template.RT) t.className += n;
                    if (t = template.R) t.className += n;
                    if (t = template.RB) t.className += n;
                    if (t = template.B) t.className += n;
                    if (t = template.LB) t.className += n;
                    if (t = template.L) t.className += n;
                    if (t = template.LT) t.className += n;

                }
                // set template
                profile.box.setTemplate(template, hash);
            }
            profile.template = template;
        },
        _prepareData: function (profile) {
            var t = profile.properties;
            //default is true
            t._visible = true;
            t._cover = false;
            t._move = true;
            // for _attached type
            if (t._attached) {
                t._visible = false;
                t._cover = true;
                t._move = false;

                t.position = 'static';
                if (ood.browser.ie67) t.display = 'inline';
                t.left = t.top = t.width = t.height = 0;
            }
            if (t.forceVisible) {
                t._visible = true;
                t._cover = false;
            }
            if (typeof t.forceMovable == "boolean")
                t._move = t.forceMovable;

            t.extend = (parseFloat(t.handlerSize) || 0) / 2 + (parseFloat(t.handlerOffset) || 0);
            t._handlerSize = profile.$em(t.handlerSize) + 'em';
            t._extend = profile.$em(t.extend) + 'em';

            t._leftCofigBtn = t.leftConfigBtn ? '' : 'display:none';
            t._rightCofigBtn = t.rightConfigBtn ? '' : 'display:none';

            var r = t.rotatable;
            if (r && ood.browser.ie && ood.browser.ver <= 8)
                r = false;
            t._rotateBtn = r ? '' : 'display:none';
            t._disabled = t.disabled ? "disabled" : "";
            return arguments.callee.upper.call(this, profile);
        },
        RenderTrigger: function () {
            var self = this;
            ood.setNodeData(self.renderId, 'zIndexIgnore', 1);
            self.box._tryCursors(self);
        },
        _onUpdate: function (profile, target, size, cssPos, rotate) {
            if (target) {
                if (size) target.widthBy(size.width, true).heightBy(size.height, true);
                if (cssPos) {
                    var t = target.get(0).style;
                    if (t.left == 'auto' && (Math.round(parseFloat(t.right)) >= 0)) {
                    } else
                        target.leftBy(cssPos.left)
                    if (t.top == 'auto' && (Math.round(parseFloat(t.bottom)) >= 0)) {
                    } else
                        target.topBy(cssPos.top);
                }
                if (ood.isDefined(rotate)) {
                    target.rotate(rotate);
                }
            }
        },
        //
        _switchAxis: function (axis, angle, dir4) {
            var a = (angle + 360) % 360,
                axisArray = ["n", "ne", "e", "se", "s", "sw", "w", "nw"],
                // 0 .. 7
                octant = Math.round(a / 45),
                oindex = ood.arr.indexOf(axisArray, axis),
                index = oindex + octant,
                naxis = axisArray[index % 8];
            if (dir4 && index % 2 == 1) {
                if (a < octant * 45) {
                    naxis = axisArray[(index - 1) % 8];
                } else {
                    naxis = axisArray[(index + 1) % 8];
                }
            }
            return naxis;
        },
        _tryCursors: function (profile) {
            var a = (profile.getRoot().rotate() + 360) % 360,
                f = this._switchAxis,
                hash = {T: "n", RT: "ne", R: "e", RB: "se", B: "s", LB: "sw", L: "w", LT: "nw"}, n;
            ood.each(hash, function (k, i) {
                if ((n = profile.getSubNode(i)).get(0)) {
                    n.css('cursor', f(k, a) + "-resize");
                }
            });
        },
        _getDDParas: function (angle, axis, switched) {
            switch (axis) {
                case "move":
                    return {move: true};
                case "rotate":
                    return {rotate: true};
                case "nw":
                    return {left: true, top: true};
                case "ne":
                    return {right: true, top: true};
                case "sw":
                    return {left: true, bottom: true};
                case "se":
                    return {right: true, bottom: true};
                case "w":
                    return {left: true};
                case "n":
                    return {top: true};
                case "e":
                    return {right: true};
                case "s":
                    return {bottom: true};
            }
        },
        _onMousedown: function (profile, e, src, axis) {
            if (profile.$inDesign) return;
            if (profile.properties.disabled) return false;

            var ddparas = this._getDDParas(0, axis);
            if (ood.Event.getBtn(e) != "left") return;
            var puip = profile.$parentUIProfile;
            if (puip && puip['ood.UIProfile'] && puip.beforeResizerDrag && false === ood.tryF(puip.beforeResizerDrag, [puip, profile, ddparas], puip.boxing()))
                return;

            var pos = ood.Event.getPos(e);
            ood.use(src).startDrag(e, {
                dragDefer: 2,
                targetReposition: false,
                dragType: 'blank',
                dragCursor: true,
                targetLeft: pos.left,
                targetTop: pos.top
            });
        },
        _onDragbegin: function (profile, e, src, axis) {
            var prop = profile.properties,
                rotatable = prop.rotatable,
                //set target to specific target
                //or, set target to resizer
                o = profile.properties._attached ? profile._target : ood([profile.renderId]),
                w = o.width(),
                h = o.height(),
                pos = o.offset(),
                rotate;
            if (rotatable) {
                rotate = o.rotate();
                if (o.get(0).getBoundingClientRect) {
                    var rect = o.get(0).getBoundingClientRect();
                    profile.o_center = {
                        x: (rect.right + rect.left) / 2,
                        y: (rect.bottom + rect.top) / 2
                    };
                } else {
                    profile.o_center = {
                        x: pos.left + w / 2,
                        y: pos.top + w / 2
                    };
                }
            }

            if (profile.properties._attached) {
                //custom proxy
                profile.proxy = ood.Dom.getEmptyDiv();
                profile.proxy
                    .html(' ', false)
                    .css({border: '1px dashed', visibility: 'visible', position: 'absolute'})
                    .offset(pos)
                    .width(w)
                    .height(h)
                    .css('zIndex', ood.Dom.TOP_ZINDEX + 20);
                if (rotate)
                    profile.proxy.rotate(rotate);
            } else
            //set proxy to itself
                profile.proxy = o;


            //get current w h from target
            profile.o_w2 = profile.o_w = w;
            profile.o_h2 = profile.o_h = h;
            //get pos for target and proxy
            profile.o_pos = profile.proxy.cssPos();
            profile.o_size = {width: w, height: h};
            profile.o_rotate = rotate;
            if (profile.regions) {
                profile.o_regions = [];
                profile.regions.each(function (n) {
                    profile.o_regions.push(ood(n).cssSize());
                });
            }

            profile.$onDrag = true;
        },
        _onDrag: function (profile, e, src, axis) {
            var args = this._getDDParas(profile.o_rotate, axis);

            //get dragdop off set
            profile.oos = profile.oos || {};
            var dd = ood.DragDrop.getProfile(),
                t = profile.properties,
                elemAngle = profile.o_rotate,
                cs = profile.o_size,
                sp = profile.o_pos,
                os = dd.offset,
                dx = os.x,
                dy = os.y,
                x, y, w, h, rotate,
                data = {};

            // no move
            if (dx === 0 && dy === 0) return;
            // for rotate
            if (elemAngle && !(args.move || args.rotate)) {
                var adjustAngle = function (a) {
                        return (a + 360) % 360;
                    },
                    distance = Math.pow(Math.pow(dx, 2) + Math.pow(dy, 2), .5),
                    mouseAngle = adjustAngle(Math.atan2(dx, -dy) * 180 / Math.PI),
                    offAngle = elemAngle + 90 - mouseAngle,
                    flagX = (adjustAngle(mouseAngle - elemAngle) < 180) ? 1 : -1,
                    flagY = (adjustAngle(mouseAngle - elemAngle) < 90 || adjustAngle(mouseAngle - elemAngle) > 270) ? -1 : 1;

                dx = distance * Math.abs(Math.cos(offAngle * Math.PI / 180)) * flagX;
                dy = distance * Math.abs(Math.sin(offAngle * Math.PI / 180)) * flagY;
            }
            // no data
            if (dx == profile.oos.width && dy == profile.oos.height) return;
            profile.oos = {width: dx, height: dy};

            // pos and size
            if (args.left) {
                // width of proxy
                w = profile.o_w - dx;
                // left of proxy
                x = sp.left + dx;
                if (w < t.minWidth) {
                    w = t.minWidth;
                    x = profile.o_w + sp.left - w;
                } else if (w > t.maxWidth) {
                    w = t.maxWidth;
                    x = profile.o_w + sp.left - w;
                }
                ood.merge(data, {width: w, left: x});
            } else if (args.right) {
                w = profile.o_w + dx;
                if (w < t.minWidth) w = t.minWidth;
                else if (w > t.maxWidth) w = t.maxWidth;
                ood.merge(data, {width: w});
            }
            if (args.top) {
                h = profile.o_h - dy;
                y = sp.top + dy;
                if (h < t.minHeight) {
                    h = t.minHeight;
                    y = profile.o_h + sp.top - h;
                } else if (h > t.maxHeight) {
                    h = t.maxHeight;
                    y = profile.o_h + sp.top - h;
                }
                ood.merge(data, {height: h, top: y});
            } else if (args.bottom) {
                h = profile.o_h + dy;
                if (h < t.minHeight) h = t.minHeight;
                else if (h > t.maxHeight) h = t.maxHeight;
                ood.merge(data, {height: h});
            }

            if (elemAngle && !(args.move || args.rotate)) {
                delete data.left;
                delete data.top;

                var xRate = Math.abs(Math.cos(elemAngle * Math.PI / 180)),
                    yRate = Math.abs(Math.sin(elemAngle * Math.PI / 180)),
                    // old bbox
                    oldBBoxCX = sp.left + cs.width / 2,
                    oldBBoxCY = sp.top + cs.height / 2,
                    oldBboxW = cs.width * xRate + cs.height * yRate,
                    oldBboxH = cs.width * yRate + cs.height * xRate,
                    oldBboxL = oldBBoxCX - oldBboxW / 2,
                    oldBboxT = oldBBoxCY - oldBboxH / 2,

                    // new bbox
                    newBboxCX = (data.left || sp.left) + (data.width || cs.width) / 2,
                    newBboxCY = (data.top || sp.top) + (data.height || cs.height) / 2,
                    newBboxW = (data.width || cs.width) * xRate + (data.height || cs.height) * yRate,
                    newBboxH = (data.width || cs.width) * yRate + (data.height || cs.height) * xRate,
                    newBboxL = newBboxCX - newBboxW / 2,
                    newBboxT = newBboxCY - newBboxH / 2,
                    offW = (newBboxW - oldBboxW) / 2,
                    offH = (newBboxH - oldBboxH) / 2,
                    //two original points offset
                    offCX = newBboxCX - oldBBoxCX,
                    offCY = newBboxCY - oldBBoxCY;

                //Alignment by origin point
                data.left = sp.left - offCX;
                data.top = sp.top - offCY;

                // find the direction
                var naxis = this._switchAxis(axis, elemAngle, true);

                switch (naxis) {
                    case "e":
                        if (elemAngle < 90) {
                            data.top -= ((data.height || cs.height) * xRate - newBboxH / 2) - (cs.height * xRate - oldBboxH / 2);
                        } else if (elemAngle > 90 && (elemAngle < 180)) {
                            data.top -= ((data.width || cs.width) * yRate - newBboxH / 2) - (cs.width * yRate - oldBboxH / 2);
                        } else if (elemAngle > 180 && (elemAngle < 270)) {
                            data.top += ((data.width || cs.width) * yRate - newBboxH / 2) - (cs.width * yRate - oldBboxH / 2);
                        } else {
                            data.top += ((data.height || cs.height) * xRate - newBboxH / 2) - (cs.height * xRate - oldBboxH / 2);
                        }
                        data.left += offW;
                        break;
                    case "s":
                        if (elemAngle < 90) {
                            data.left -= ((data.height || cs.height) * yRate - newBboxW / 2) - (cs.height * yRate - oldBboxW / 2);
                        } else if (elemAngle > 90 && (elemAngle < 180)) {
                            data.left -= ((data.width || cs.width) * xRate - newBboxW / 2) - (cs.width * xRate - oldBboxW / 2);
                        } else if (elemAngle > 180 && (elemAngle < 270)) {
                            data.left += ((data.width || cs.width) * xRate - newBboxW / 2) - (cs.width * xRate - oldBboxW / 2);
                        } else {
                            data.left += ((data.height || cs.height) * yRate - newBboxW / 2) - (cs.height * yRate - oldBboxW / 2);
                        }
                        data.top += offH;
                        break;
                    case "w":
                        if (elemAngle < 90) {
                            data.top += ((data.height || cs.height) * xRate - newBboxH / 2) - (cs.height * xRate - oldBboxH / 2);
                        } else if (elemAngle > 90 && (elemAngle < 180)) {
                            data.top += ((data.width || cs.width) * yRate - newBboxH / 2) - (cs.width * yRate - oldBboxH / 2);
                        } else if (elemAngle > 180 && (elemAngle < 270)) {
                            data.top -= ((data.width || cs.width) * yRate - newBboxH / 2) - (cs.width * yRate - oldBboxH / 2);
                        } else {
                            data.top -= ((data.height || cs.height) * xRate - newBboxH / 2) - (cs.height * xRate - oldBboxH / 2);
                        }
                        data.left -= offW;
                        break;
                    case "n":
                        if (elemAngle < 90) {
                            data.left += ((data.height || cs.height) * yRate - newBboxW / 2) - (cs.height * yRate - oldBboxW / 2);
                        } else if (elemAngle > 90 && (elemAngle < 180)) {
                            data.left += ((data.width || cs.width) * xRate - newBboxW / 2) - (cs.width * xRate - oldBboxW / 2);
                        } else if (elemAngle > 180 && (elemAngle < 270)) {
                            data.left -= ((data.width || cs.width) * xRate - newBboxW / 2) - (cs.width * xRate - oldBboxW / 2);
                        } else {
                            data.left -= ((data.height || cs.height) * yRate - newBboxW / 2) - (cs.height * yRate - oldBboxW / 2);
                        }
                        data.top -= offH;
                        break;
                }
            }
            // for inner region
            if (args.left || args.right) {
                //resize inner region block
                if (profile.regions && "width" in data && data.width !== cs.width) {
                    var offw = data.width - cs.width;
                    profile.regions.each(function (n, i) {
                        ood(n).width(profile.o_regions[i].width + offw);
                    });
                }
            }

            if (args.top || args.bottom) {
                //resize inner region block
                if (profile.regions && "height" in data && data.height !== cs.height) {
                    var offh = data.height - cs.height;
                    profile.regions.each(function (n, i) {
                        ood(n).height(profile.o_regions[i].height + offh);
                    });
                }
            }

            if (args.move) {
                x = sp.left + dx;
                y = sp.top + dy;
                ood.merge(data, {top: y, left: x});
            }
            if (args.rotate) {
                rotate = (180 - Math.atan2(dd.x - profile.o_center.x, dd.y - profile.o_center.y) * 180 / Math.PI);
                if (rotate < 0) rotate += 360;
                ood.merge(data, {rotate: rotate});
            }

            if (!ood.isEmpty(data)) {
                ood.each(data, function (o, i) {
                    data[i] = Math.round(parseFloat(o)) + 'px';
                });
                profile.proxy.css(data);

                if (profile.onChange)
                    profile.boxing().onChange(profile, profile.proxy);
            }
        },
        _onDragstop: function (profile, e, src, axis) {
            var cssSize, cssPos,
                offsize, offpos,
                rotate,
                cs = profile.o_size,
                sp = profile.o_pos,
                o = profile.proxy,
                args = this._getDDParas(profile.o_rotate, axis);

            if (!args.move && !args.rotate) {
                cssSize = o.cssSize();
                offsize = {
                    width: cssSize.width - cs.width,
                    height: cssSize.height - cs.height
                };
                if (offsize.width === 0 && offsize.height === 0) offsize = null;
            }

            cssPos = o.cssPos();
            offpos = {
                left: cssPos.left - sp.left,
                top: cssPos.top - sp.top
            };
            if (offpos.left === 0 && offpos.top === 0) offpos = null;

            if (args.rotate)
                rotate = o.rotate();

            if (profile.onUpdate && false === profile.boxing().onUpdate(profile, profile._target, offsize, offpos, rotate)) {
            }
            else {
                profile.box._onUpdate(profile, profile._target, offsize, offpos, rotate);
            }

            if (profile.properties._attached) {
                if (ood.browser.ie6) profile._target.ieRemedy();
                profile.proxy.html('', false).css({
                    visibility: 'hidden',
                    border: 'none',
                    zIndex: '0',
                    width: '0',
                    height: '0',
                    rotate: 0
                });
            }
            //profile.boxing().active();
            profile.$onDrag = false;
            delete profile.o_rotate;

            profile.box._tryCursors(profile);
        }
    }
});ood.Class("ood.UI.Block", "ood.UI.Widget", {

    Instance: {

        iniProp: {
            dock: 'width',
            position: 'relative',
            left: 'auto',
            top: 'auto',
            width: 'auto',
            height: '18em',
            toggleBtn: true,
            closeBtn: true,
            refreshBtn: true

        },

        /**
         * 
         * @param {string} [theme] ('light''dark')
         */
        toggleTheme: function (theme) {
            var root = this.getRoot();
            var oldTheme = root.attr('data-theme') || 'light';
            var newTheme;

            if (theme) {
                newTheme = theme;
                root.attr('data-theme', newTheme);
            } else {
                newTheme = oldTheme === 'dark' ? 'high-contrast' :
                    oldTheme === 'high-contrast' ? 'light' : 'dark';
                root.attr('data-theme', newTheme);
            }

            // 
            this.emit('themechange', {
                oldTheme: oldTheme,
                newTheme: newTheme
            });
            return this;
        },

        /**
         * 
         * @param {string} theme ('light''dark')
         */
        setTheme: function (theme) {
            return this.toggleTheme(theme);
        },

        /**
         * 
         * @param {string} color 
         */
        setHighContrastColor: function (color) {
            this.getRoot().css('--ood-hc-color', color);
            return this;
        },


        setChildren: function (childrens, prf) {
            var host = this, items = [], ctx = host.getModule().getCtxComponents();
            this.removeChildren(true, true, true);
            ood.each(childrens, function (o) {
                if (o && o.alias) {
                    if (o.alias == 'PAGECTX') {
                        ctx.boxing().removeChildren(true, true, true);
                        host.getModule().addCtxComponents(o.children);
                    } else {
                        items.push(o);
                    }
                }
            });
            ood.addChild({children: items}, host, host.getModule(), host.getModule());
        },
        getAllFormValues: function (isAll) {
            var a = this.getChildren(),
                elems = ood.absValue.pack(a),
                formValue = {},
                profile = this.get(0);
            ood.arr.each(profile.children, function (o) {
                var oo = o[0].boxing(), name = oo.getProperties().name || o[0].alias;
                if (oo.Class['ood.UI.Tabs']) {
                    // formValue[name] = oo.getAllFormValues();
                    ood.merge(formValue, oo.getAllFormValues(isAll), 'all')
                } else if (oo.Class['ood.UI.Block'] || oo.Class["ood.UI.Panel"] || oo.Class["ood.UI.Layout"]) {
                    ood.merge(formValue, oo.getAllFormValues(isAll), 'all')
                } else if (oo.getFormValues) {
                    ood.merge(formValue, oo.getFormValues(), 'all')
                } else if (oo.getUIValue) {
                    formValue[name] = oo.getUIValue();
                } else if (oo.getValue) {
                    formValue[name] = oo.getValue();
                }
            });

            return formValue;
        }
    },


    Initialize: function () {
        var self = this,
            t = self.getTemplate();
        // 
        if (!t) {
            t = {};
        }
        // classNameFRAMEBORDER
        if (!t.className) t.className = '';
        if (!t.FRAME) t.FRAME = {};
        if (!t.FRAME.BORDER) t.FRAME.BORDER = {};

        //modify
        t.className += ' {_sidebarStatus}';
        ood.merge(t.FRAME.BORDER, {
            className: 'ood-uiw-border {clsBorderType1}',
            SIDEBAR: {
                tagName: 'div',
                className: 'ood-uisb ood-uibar {_sidebar}',
                SBCAP: {
                    className: 'ood-uisbcap ood-title-node',
                    text: '{sideBarCaption}'
                },
                SBBTN: {
                    $order: 1,
                    className: 'ood-uisbbtn oodfont',
                    $fonticon: '{_fi_btn}'
                }
            },
            PANEL: {
                tagName: 'div',
                className: 'ood-uibar ood-uicontainer {clsBorderType2}',
                style: '{_panelstyle};{background};{_overflow};',
                text: '{html}' + ood.UI.$childTag
            }
        }, 'all');


        //set back
        self.setTemplate(t);

        //get default Appearance
        t = self.getAppearance();
        //modify
        ood.merge(t, {
            PANEL: {
                position: 'relative',
                overflow: 'auto',
                'background-color': 'var(--ood-bg-primary)',
                'border-radius': 'var(--ood-border-radius-lg)',
                'box-shadow': '0 1px 3px rgba(0,0,0,0.1)'
              //  'padding': '1em'
            },
            SBCAP: {
                'text-overflow': 'ellipsis',
                'white-space': 'nowrap',
                overflow: 'hidden',
                'font-family': 'var(--ood-font-family)',
                'font-size': '1em',
                'font-weight': '500',
                'color': 'var(--ood-text-primary)'
            },

            SBBTN: {
                'z-index': 2,
                margin: '0.5em',
                'font-size': '1.25em',
                'color': 'var(--ood-icon-color)',
                'transition': 'all 0.2s ease',
                'cursor': 'pointer',
                'role': 'button',
                'aria-label': '{sideBarCaption}',
                'aria-expanded': '{sideBarStatus === "expand" ? "true" : "false"}'
            },
            'SBBTN:hover': {
                'color': 'var(--ood-icon-hover)'
            },
            'SBBTN:focus': {
                'outline': '2px solid var(--ood-icon-hover)',
                'outline-offset': '2px'
            }
        });
        //set back
        self.setAppearance(t);
    },
    Static: {
        Behaviors: {
            HoverEffected: {SBBTN: 'SBBTN', SBCAP: null},
            ClickEffected: {SBBTN: 'SBBTN'},
            DroppableKeys: ['PANEL'],
            PanelKeys: ['PANEL'],
            PANEL: {
                onClick: function (profile, e, src) {
                    var p = profile.properties;
                    if (p.disabled) return false;
                    if (profile.onClickPanel)
                        return profile.boxing().onClickPanel(profile, e, src);
                }
            },
            SBBTN: {
                onClick: function (profile, e, src) {
                    var p = profile.properties;
                    if (p.disabled) return false;
                    profile.boxing().setSideBarStatus(p.sideBarStatus == 'fold' ? 'expand' : 'fold');
                }
            },
            SIDEBAR: {
                onClick: function (profile, e, src) {
                    var p = profile.properties,
                        btn = profile.getSubNode('SBBTN');
                    if (p.disabled) return false;
                    if (ood.Event.getSrc(e).$xid != btn.xid()) {
                        if (p.sideBarStatus == 'fold') {
                            btn.onClick(true);
                        }
                    }
                }
            }
        },
        EventHandlers: {
            onClickPanel: function (profile, e, src) {
            },

            onFlagClick: function (profile, item, e, src) {
            },
            touchstart: function (profile, item, e, src) {
            },
            touchmove: function (profile, item, e, src) {
            },
            touchend: function (profile, item, e, src) {
            },
            touchcancel: function (profile, item, e, src) {
            },

            swipe: function (profile, item, e, src) {
                // 
                var distance = ood.Event.getDistance(e);
                if (distance > 50) {
                    profile.boxing().toggleTheme();
                }
            },
            swipeleft: function (profile, item, e, src) {
                if (profile.properties.sideBarType === 'right') {
                    profile.boxing().setSideBarStatus('fold');
                }
            },
            swiperight: function (profile, item, e, src) {
                if (profile.properties.sideBarType === 'left') {
                    profile.boxing().setSideBarStatus('fold');
                }
            },
            swipeup: function (profile, item, e, src) {
                if (profile.properties.sideBarType === 'bottom') {
                    profile.boxing().setSideBarStatus('fold');
                }
            },
            swipedown: function (profile, item, e, src) {
                if (profile.properties.sideBarType === 'top') {
                    profile.boxing().setSideBarStatus('fold');
                }
            },


            press: function (profile, item, e, src) {
            },
            pressup: function (profile, item, e, src) {
            },


            pan: function (profile, item, e, src) {
            },
            panstart: function (profile, item, e, src) {
            },
            panmove: function (profile, item, e, src) {
            },
            panend: function (profile, item, e, src) {
            },
            pancancel: function (profile, item, e, src) {
            },

            panleft: function (profile, item, e, src) {
            },
            panright: function (profile, item, e, src) {
            },
            panup: function (profile, item, e, src) {
            },
            pandown: function (profile, item, e, src) {
            },


            pinch: function (profile, item, e, src) {
            },
            pinchstart: function (profile, item, e, src) {
            },
            pinchmove: function (profile, item, e, src) {
            },
            pinchend: function (profile, item, e, src) {
            },
            pinchcancel: function (profile, item, e, src) {
            },

            pinchin: function (profile, item, e, src) {
            },
            pinchout: function (profile, item, e, src) {
            },


            rotate: function (profile, item, e, src) {
            },
            rotatestart: function (profile, item, e, src) {
            },
            rotatemove: function (profile, item, e, src) {
            },
            rotateend: function (profile, item, e, src) {
            },
            rotatecancel: function (profile, item, e, src) {
            }
        },
        DataModel: {
            //delete those properties
            disabled: null,
            tips: null,

            comboType: {
                ini: "Block",
            },
            rotate: null,
            iframeAutoLoad: {
                ini: "",
                action: function () {
                    ood.UI.Div._applyAutoLoad(this);
                }
            },
            ajaxAutoLoad: {
                ini: "",
                action: function () {
                    ood.UI.Div._applyAutoLoad(this);
                }
            },
            selectable: true,
            html: {
                html: 1,
                action: function (v, ov, force) {
                    this.getSubNode('PANEL').html(ood.adjustRes(v, 0, 1), null, null, force);
                }
            },
            borderType: {
                ini: 'outset',
                listbox: ['none', 'flat', 'inset', 'outset', 'groove', 'ridge'],
                action: function (v) {
                    var ns = this,
                        p = ns.properties;
                    ns.box._borderType(ns, v, p.sideBarStatus, p.sideBarType.split('-'), true);
                }
            },

            // for side bar
            sideBarCaption: {
                ini: '',
                action: function (v) {
                    this.getSubNode("SBCAP").html(v);
                }
            },
            sideBarType: {
                ini: 'none',
                listbox: ['none', 'left', 'right', 'top', 'bottom', 'left-top', 'left-bottom', 'right-top', 'right-bottom', 'top-left', 'top-right', 'bottom-left', 'bottom-right'],
                action: function (v) {
                    var ns = this,
                        prop = ns.properties;
                    ns.box._adjustSideBar(ns, prop.sideBarStatus, v);

                    if (prop.dock != 'none') ns.boxing().adjustDock(true);
                    else ns.adjustSize();
                }
            },
            sideBarStatus: {
                ini: 'expand',
                listbox: ['expand', 'fold'],
                action: function (v) {
                    var ns = this, prop = ns.properties;
                    ns.getRoot().tagClass('-fold', v != 'expand');

                    ns.box._adjustSideBar(ns, v, prop.sideBarType);

                    // use sync way
                    ood.UI.$doResize(ns, prop.width, prop.height, true);
                    ns.boxing().adjustDock(true);
                }
            },
            sideBarSize: {
                ini: '2em',
                action: function (v) {
                    var ns = this,
                        prop = ns.properties;
                    if (prop.dock == 'none')
                        ns.adjustSize();
                    else
                        ns.boxing().adjustDock(true);
                }
            },

            background: {
                format: 'color',
                ini: '',
                action: function (v) {
                    this.getSubNode('PANEL').css('background', v);
                }
            },
            width: {
                $spaceunit: 1,
                ini: 'auto'
            },
            height: {
                $spaceunit: 1,
                ini: 'auto'
            }
        },
        Appearances: {
            KEY: {
                'line-height': 'normal'
            },
            'KEY-fold PANEL': {
                display: 'none'
            },
            'KEY-fold SIDEBAR': {
                cursor: 'pointer',
                'background-color': 'var(--ood-bg-disabled)'
            }
        },
        RenderTrigger: function () {
            // only div
            var ns = this;
            if (ns.box.KEY == "ood.UI.Block")
                if (ns.properties.iframeAutoLoad || ns.properties.ajaxAutoLoad)
                    ood.UI.Div._applyAutoLoad(this);
        },
        _sbicon: function (profile, sideBarStatus, type, ui) {
            var target = sideBarStatus == 'fold'
                ? type == 'left' ? 'left' : type == 'right' ? 'right' : type == 'top' ? 'up' : 'down'
                : type == 'left' ? 'right' : type == 'right' ? 'left' : type == 'top' ? 'down' : 'up';

            return ui ? profile.getSubNode('SBBTN').replaceClass(/(ood-icon-double)[\w]+/g, '$1' + target) : 'ood-icon-double' + target;
        },
        _borderType: function (profile, borderType, sideBarStatus, type, adjust) {
            type = sideBarStatus == 'expand' ? type[0] : (type[1] || type[0]);
            var ns = profile,
                v = borderType,
                n1 = ns.getSubNode('BORDER'), n2 = ns.getSubNode('PANEL'),
                reg = /^ood-uiborder-/,
                b = 'ood-uiborder-',
                r = b + 'radius',
                i = b + 'inset',
                o = b + 'outset',
                f = b + 'flat',
                ibr = type == 'left' ? r + '-tr ' + r + '-br' : type == 'top' ? r + '-bl ' + r + '-br' : type == 'right' ? r + '-tl ' + r + '-bl' : type == 'bottom' ? r + '-tl ' + r + '-tr' : r,
                flat = f + ' ' + r,
                ins = i + ' ' + r,
                outs = o + ' ' + r,
                ins2 = i + ' ' + ibr,
                outs2 = o + ' ' + ibr,
                root = ns.getRoot();
            n1.removeClass(reg);
            n2.removeClass(reg);
            switch (v) {
                case 'flat':
                    n1.addClass(flat);
                    n2.addClass(ibr);
                    break;
                case 'inset':
                    n1.addClass(ins);
                    n2.addClass(ibr);
                    break;
                case 'outset':
                    n1.addClass(outs);
                    n2.addClass(ibr);
                    break;
                case 'groove':
                    n1.addClass(ins);
                    n2.addClass(outs2);
                    break;
                case 'ridge':
                    n1.addClass(outs);
                    n2.addClass(ins2);
                    break;
            }

            //force to resize
            ns.box._setB(ns);

            if (adjust)
                ns.adjustSize();
        },
        _adjustSideBar: function (prf, sideBarStatus, sideBarType) {
            var ns = prf,
                prop = ns.properties,
                reg = /^ood-uisb-/,
                arr = sideBarType.split('-'),
                node = ns.getSubNode('SIDEBAR');
            node.removeClass(reg).addClass('ood-uisb-' + (sideBarStatus == 'expand' ? arr[0] : (arr[1] || arr[0])));
            ns.box._sbicon(ns, sideBarStatus, arr[1] || arr[0], true);
            ns.box._borderType(ns, prop.borderType, sideBarStatus, arr, false);
        },
        _setB: function (profile) {
            var p = profile.properties,
                type = p.borderType,
                nd = profile.getSubNode("BORDER"),
                w = nd._borderW('left');
            p.$hborder = p.$vborder = p.$iborder = 0;

            if (type == 'flat' || type == 'inset' || type == 'outset') {
                p.$hborder = p.$vborder = w;
                p.$iborder = 0;
            }
            else if (type == 'groove' || type == 'ridge') {
                p.$hborder = p.$vborder = p.$iborder = w;
            }
        },
        LayoutTrigger: function () {
            var prop = this.properties,
                m = prop.sideBarStatus,
                v = prop.borderType;
            if (v != 'none') this.boxing().setBorderType(v, true);
            if (m == 'fold') this.boxing().setSideBarStatus('fold', true);
        },
        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile),
                a = data.sideBarType.split('-'),
                b = data.sideBarStatus;
            data.background = data.background ? 'background:' + data.background : '';
            if (ood.isStr(data.overflow))
                data._overflow = data.overflow.indexOf(':') != -1 ? (data.overflow) : (data.overflow ? ("overflow:" + data.overflow) : "");

            data._sidebar = 'ood-uisb-' + (b == 'expand' ? a[0] : (a[1] || a[0]));
            data._sidebarStatus = b == 'fold' ? profile.getClass('KEY', '-fold') : '';
            data._fi_btn = profile.box._sbicon(profile, b, a[1] || a[0]);

            return data;
        },

        _onresize: function (profile, width, height) {
            var size = arguments.callee.upper.apply(this, arguments),
                root = profile.getRoot(),
                border = profile.getSubNode('BORDER'),
                panel = profile.getSubNode('PANEL'),
                sidebar = profile.getSubNode('SIDEBAR'),
                sbcap = profile.getSubNode('SBCAP'),
                prop = profile.properties,
                sbs = prop.sideBarStatus,
                sbtype = prop.sideBarType.split('-'),
                cb1 = border.contentBox(),
                bv = (prop.$vborder || 0) * 2,
                bh = (prop.$hborder || 0) * 2,

                cb2 = panel.contentBox(),
                b2 = (prop.$iborder || 0) * 2,
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },

                fzrate = profile.getEmSize() / root._getEmSize(),
                panelfz = panel._getEmSize(fzrate),

                // caculate by px
                ww = width ? profile.$px(size.width) : size.width,
                hh = height ? profile.$px(size.height) : size.height,
                sbsize = profile.$px(prop.sideBarSize),
                sbsize2 = adjustunit(sbsize);

            sbtype = sbs == 'expand' ? sbtype[0] : (sbtype[1] || sbtype[0]);

            size.left = size.top = 0;
            if (sbtype && sbtype != 'none') {
                sbcap.css('line-height', adjustunit(sbsize - (!cb1 ? 0 : bh)));
                if (sbtype == 'left' || sbtype == 'right') {
                    sidebar.width(sbsize2);
                    if (height && 'auto' !== height)
                        sidebar.height(adjustunit(hh - (cb1 ? 0 : bv)));
                } else {
                    sidebar.height(sbsize2);
                    sidebar.width(adjustunit(ww - (cb1 ? 0 : bh)));
                }

                if (sbs == 'fold') {
                    if (sbtype == 'left' || sbtype == 'right') {
                        root.width(adjustunit(sbsize + bh));
                        border.width(adjustunit(sbsize + (cb1 ? 0 : bh)));
                    } else {
                        root.height(adjustunit(sbsize + bv));
                        border.height(adjustunit(sbsize + (cb1 ? 0 : bv)));
                    }
                    return;
                } else {
                    if (sbtype == 'left' || sbtype == 'right') {
                        root.width(adjustunit(width));
                        border.width(adjustunit(ww));
                    } else {
                        root.height(adjustunit(height));
                        border.height(adjustunit(hh));
                    }
                    switch (sbtype) {
                        case 'left':
                            ww -= sbsize;
                            size.left = sbsize;
                            break;
                        case 'right':
                            ww -= sbsize;
                            break;
                        case 'top':
                            hh -= sbsize;
                            size.top = sbsize;
                            break;
                        case 'bottom':
                            hh -= sbsize;
                            break;
                    }
                }
            }
            if (size.width) size.width = adjustunit(ww - (cb1 ? 0 : bh) - (!cb2 ? 0 : b2), panelfz);
            if (size.height && 'auto' !== size.height)
                size.height = adjustunit(hh - (cb1 ? 0 : bv) - (!cb2 ? 0 : b2), panelfz);
            panel.cssRegion(size, true);

            // if (size.width) {
            //     ood.UI._adjustConW(profile, panel, size.width);
            // }
        },


        // _onresize: function (profile, width, height) {
        //     var size = arguments.callee.upper.apply(this, arguments),
        //         root = profile.getRoot(),
        //         border = profile.getSubNode('BORDER'),
        //         panel = profile.getSubNode('PANEL'),
        //         sidebar = profile.getSubNode('SIDEBAR'),
        //         sbcap = profile.getSubNode('SBCAP'),
        //         prop = profile.properties,
        //         sbs = prop.sideBarStatus,
        //         sbtype = prop.sideBarType.split('-'),
        //         cb1 = border.contentBox(),
        //         bv = (prop.$vborder || 0) * 2,
        //         bh = (prop.$hborder || 0) * 2,
        //
        //         cb2 = panel.contentBox(),
        //         b2 = (prop.$iborder || 0) * 1,
        //         us = ood.$us(profile),
        //         adjustunit = function (v, emRate) {
        //             return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
        //         },
        //
        //         fzrate = profile.getEmSize() / root._getEmSize(),
        //         panelfz = panel._getEmSize(fzrate),
        //
        //         // caculate by px
        //         ww = width ? profile.$px(size.width) : size.width,
        //         hh = height ? profile.$px(size.height) : size.height,
        //         sbsize = profile.$px(prop.sideBarSize),
        //         sbsize2 = adjustunit(sbsize);
        //
        //     sbtype = sbs == 'expand' ? sbtype[0] : (sbtype[1] || sbtype[0]);
        //
        //     size.left = size.top = 0;
        //     if (sbtype && sbtype != 'none') {
        //         sbcap.css('line-height', adjustunit(sbsize - (!cb1 ? 0 : bh)));
        //         if (sbtype == 'left' || sbtype == 'right') {
        //             sidebar.width(sbsize2);
        //             if (height && 'auto' !== height)
        //                 sidebar.height(adjustunit(hh - (cb1 ? 0 : bv)));
        //         } else {
        //             sidebar.height(sbsize2);
        //             sidebar.width(adjustunit(ww - (cb1 ? 0 : bh)));
        //         }
        //
        //         if (sbs == 'fold') {
        //             if (sbtype == 'left' || sbtype == 'right') {
        //                 root.width(adjustunit(sbsize + bh));
        //                 border.width(adjustunit(sbsize + (cb1 ? 0 : bh)));
        //             } else {
        //                 root.height(adjustunit(sbsize + bv));
        //                 border.height(adjustunit(sbsize + (cb1 ? 0 : bv)));
        //             }
        //             return;
        //         } else {
        //             if (sbtype == 'left' || sbtype == 'right') {
        //                 root.width(adjustunit(width));
        //                 border.width(adjustunit(ww));
        //             } else {
        //                 root.height(adjustunit(height));
        //                 border.height(adjustunit(hh));
        //             }
        //             switch (sbtype) {
        //                 case 'left':
        //                     ww -= sbsize;
        //                     size.left = sbsize;
        //                     break;
        //                 case 'right':
        //                     ww -= sbsize;
        //                     break;
        //                 case 'top':
        //                     hh -= sbsize;
        //                     size.top = sbsize;
        //                     break;
        //                 case 'bottom':
        //                     hh -= sbsize;
        //                     break;
        //             }
        //         }
        //     }
        //
        //     if (size.width && 'auto' !=size.width) size.width = adjustunit(ww - (cb1 ? 0 : bh) - (!cb2 ? 0 : b2), panelfz);
        //     if (size.height && 'auto' !== size.height)
        //         size.height = adjustunit(hh - (cb1 ? 0 : bv) - (!cb2 ? 0 : b2), panelfz);
        //     panel.cssRegion(size, true);
        //
        //     if (size.width) {
        //         ood.UI._adjustConW(profile, panel, size.width);
        //     }
        // },
        _showTips: function (profile, node, pos) {
            var p = profile.properties;
            if (p.disableTips) return;
            if (profile.onShowTips)
                return profile.boxing().onShowTips(profile, node, pos);

            if (!ood.Tips) return;
            if (p.sideBarType == 'none') return;

            var id = node.id, ks = profile.keys;
            if (p.sideBarStatus == "fold" && (id.indexOf(ks.SBCAP) === 0 || id.indexOf(ks.SBBTN) === 0)) {
                ood.Tips.show(pos, {tips: ood.wrapRes('$inline.Expand')});
                return false;
            } else if (p.sideBarStatus == "expand" && id.indexOf(ks.SBBTN) === 0) {
                ood.Tips.show(pos, {tips: ood.wrapRes('$inline.Fold')});
                return false;
            }
        }
    }
});

ood.Class("ood.UI.Label", "ood.UI", {
    iniProp: {
        caption:  ""
    },
    Initialize: function () {
        // compitable
        ood.UI.SLabel = ood.UI.Label;
        var key = "ood.UI.SLabel";
        ood.absBox.$type[key.replace("ood.UI.", "")] = ood.absBox.$type[key] = key;
    },
    Instance: {
        fireClickEvent: function () {
            this.getRoot().onClick();
            return this;
        },
        // calculate the formula, and apply to the control
        _applyExcelFormula: function (cellsMap) {
            var profile = this.get(0), prop = profile.properties, f, value;
            if (f = prop.excelCellFormula) {
                value = ood.ExcelFormula.calculate(f, cellsMap);
                if (ood.isSet(value)) {
                    if (profile.beforeApplyExcelFormula && false === profile.beforeApplyExcelFormula(profile, prop.excelCellFormula, value)) {
                    } else {
                        this.setCaption(value, true);
                        if (profile.afterApplyExcelFormula) profile.afterApplyExcelFormula(profile, prop.excelCellFormula, value);
                    }
                }
            }
        },
        
        // 
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot(),
                    caption = profile.getSubNode('CAPTION'),
                    icon = profile.getSubNode('ICON');

                if (theme === 'dark') {
                    // 
                    root.addClass('label-dark');
                    caption.css({
                        'color': 'var(--ood-text-muted)'
                    });
                    icon.css({
                        'color': '#cccccc'
                    });
                } else {
                    // 
                    root.removeClass('label-dark');
                    caption.css({
                        'color': ''
                    });
                    icon.css({
                        'color': ''
                    });
                }
                
                // 
                localStorage.setItem('label-theme', theme);
            });
        },
        
        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('label-theme') || 'light';
        },

        LabelTrigger: function() {
            var profile = this.get(0);
            var prop = profile.properties

            // 
            // 
            if (prop.theme) {
                this.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('label-theme');
                if (savedTheme) {
                    this.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                this.adjustLayout();
            }

            // 
            this.enhanceAccessibility();
        },
        
        // 
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        
        // 
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    caption = profile.getSubNode('CAPTION'),
                    icon = profile.getSubNode('ICON'),
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('label-mobile');
                    
                    // 
                    caption.css({
                        'font-size': '0.9em'
                    });
                    if (icon && !icon.isEmpty()) {
                        icon.css({
                            'font-size': '1.1em'
                        });
                    }
                } else {
                    root.removeClass('label-mobile');
                    
                    // 
                    caption.css({
                        'font-size': ''
                    });
                    if (icon && !icon.isEmpty()) {
                        icon.css({
                            'font-size': ''
                        });
                    }
                }

                // 
                if (width < 480) {
                    root.addClass('label-tiny');
                    
                    // 
                    caption.css({
                        'font-size': '0.8em'
                    });
                } else {
                    root.removeClass('label-tiny');
                }
            });
        },
        
        // 
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    caption = profile.getSubNode('CAPTION'),
                    icon = profile.getSubNode('ICON'),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'text',
                    'aria-label': properties.caption || ''
                });
                
                // ARIA
                if (icon && !icon.isEmpty()) {
                    icon.attr({
                        'aria-hidden': 'true' // 
                    });
                }

                // 
                if (properties.clock) {
                    root.attr({
                        'role': 'timer',
                        'aria-label': '',
                        'aria-live': 'polite'
                    });
                }
            });
        }
    },
    Static: {
        Templates: {
            tagName: "label",
            className: '{_className}',
            style: '{_hAlign};{_style}',
            VALIGN: {
                $order: 0,
                style: '{_vAlign}'
            },
            ICON: {
                $order: 1,
                className: 'oodcon {imageClass} {picClass}',
                style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{_fc}{imageDisplay}{iconStyle}',
                text: '{iconFontCode}',
                'color': 'var(--ood-text-muted)'
            },
            CAPTION: {
                $order: 2,
                text: '{caption}',
                style: '{_fc}{_fw}{_fs}{_ff}',
                'font-size': 'var(--ood-font-size-md)',
                'color': 'var(--ood-text)'
            }
        },
        Appearances: {
            VALIGN: {
                'font-size': 0,
                width: 0,
                display: 'inline-block',
                height: '100%'
            },
            
            // 
            'label-dark ICON': {
                'color': 'var(--ood-dark-text-muted) !important'
            },
            'label-dark CAPTION': {
                'color': 'var(--ood-dark-text) !important'
            },
            
            // 
            'label-mobile CAPTION': {
                'font-size': 'var(--ood-font-size-sm)'
            },
            'label-mobile ICON': {
                'font-size': '1.1em !important'
            },
            
            // 
            'label-tiny CAPTION': {
                'font-size': 'var(--ood-font-size-xs)'
            }
        },
        DataModel: {
            // 
            theme: {
                ini: 'light',
                caption: ood.getResText("DataModel.theme") || "",
                listbox: ['light', 'dark'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                caption: ood.getResText("DataModel.responsive") || "",
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            selectable: {
                ini: true,
                caption: ood.getResText("DataModel.selectable") || ""
            },
            expression: {
                ini: '',
                caption: ood.getResText("DataModel.expression") || "",
                action: function () {
                }
            },
            caption: {
                ini: null,
                caption: ood.getResText("DataModel.title") || "",
                action: function (v) {
                    var prf = this;
                    if (!prf.properties.clock) {
                        v = (ood.isSet(v) ? v : "") + "";
                        prf.getSubNode("CAPTION").html(ood.adjustRes(v, true));
                    }
                }
            },
            clock: {
                ini: '',
                caption: ood.getResText("DataModel.clock") || "",
                combobox: ['hh : mm : ss', 'hh - mm : ss'],
                action: function (v) {
                    var prf = this, timer;
                    if (v && !prf._timer) {
                        timer = prf._timer = new ood.Timer();
                        var f = timer.get(0).$onTime = function () {
                            if (!prf.destroyed)
                                prf.getSubNode("CAPTION").html(ood.Date.format(new Date, prf.properties.clock));
                        };
                        f();
                    } else if (!v && prf._timer) {
                        prf._timer.destroy();
                        prf._timer = null;
                        prf.boxing().setCaption(prf.properties.caption, true);
                    }
                }
            },
            image: {
                format: 'image',
                caption: ood.getResText("DataModel.image") || "",
                action: function (v) {
                    ood.UI.$iconAction(this);
                }
            },
            imagePos: {
                ini: '',
                caption: ood.getResText("DataModel.imagePosition") || "",
                action: function (value) {
                    this.getSubNode('ICON').css('backgroundPosition', value || 'center');
                }
            },
            imageBgSize: {
                ini: '',
                caption: ood.getResText("DataModel.imageBgSize") || "",
                action: function (value) {
                    this.getSubNode('ICON').css('backgroundSize', value || '');
                }
            },
            imageClass: {
                ini: '',
                caption: ood.getResText("DataModel.imageClass") || "",
                action: function (v, ov) {
                    ood.UI.$iconAction(this, 'ICON', ov);
                }
            },
            iconFontCode: {
                ini: '',
                caption: ood.getResText("DataModel.iconFontCode") || "",
                action: function (v) {
                    ood.UI.$iconAction(this);
                }
            },
            iconFontColor: {
                ini: '',
                type: "color",
                caption: ood.getResText("DataModel.iconFontColor") || "",
                action: function (value) {
                    this.getRoot().css('color', value);
                }
            },
            hAlign: {
                ini: 'right',
                caption: ood.getResText("DataModel.hAlign") || "",
                listbox: ['left', 'center', 'right'],
                action: function (v) {
                    this.getRoot().css('textAlign', v || '');
                }
            },
            vAlign: {
                ini: 'top',
                caption: ood.getResText("DataModel.vAlign") || "",
                listbox: ['top', 'middle', 'bottom'],
                action: function (v) {
                    this.getSubNode('VALIGN').css('verticalAlign', v || '');
                }
            },
            fontColor: {
                caption: ood.getResText("DataModel.fontColor") || "",
                value: ood.UI.Button.$DataModel.fontColor
            },
            fontSize: {
                caption: ood.getResText("DataModel.fontSize") || "",
                value: ood.UI.Button.$DataModel.fontSize
            },
            fontWeight: {
                caption: ood.getResText("DataModel.fontWeight") || "",
                value: ood.UI.Button.$DataModel.fontWeight
            },
            fontFamily: {
                caption: ood.getResText("DataModel.fontFamily") || "",
                value: ood.UI.Button.$DataModel.fontFamily
            },
            excelCellFormula: {
                ini: "",
                caption: ood.getResText("DataModel.excelCellFormula") || "Excel",
                action: function (v) {
                    var prf = this, m,
                        prop = prf.properties;
                    if (v && ood.ExcelFormula.validate(v)) {
                        if (prf.host && (m = prf.host['ood.Module'])) {
                            m.applyExcelFormula(prf);
                        }
                    }
                }
            }
        },
        Behaviors: {
            HoverEffected: {KEY: 'KEY', ICON: 'ICON'},
            onClick: function (profile, e, src) {
                var p = profile.properties;
                if (p.disabled) return false;
                if (profile.onClick)
                    return profile.boxing().onClick(profile, e, src);
            }
        },
        EventHandlers: {
            onClick: function (profile, e, src) {
            },
            beforeApplyExcelFormula: function (profile, excelCellFormula, value) {
            },
            afterApplyExcelFormula: function (profile, excelCellFormula, value) {
            }
        },
        RenderTrigger: function () {
            var prf = this, t;
            (prf.$beforeDestroy = (prf.$beforeDestroy || {}))["timerClear"] = function () {
                if (prf._timer) {
                    prf._timer.destroy();
                    delete prf._timer;
                }
            };
            if (t = prf.properties.clock) {
                prf.boxing().setClock(t, true);
            }
            
            // 
            var self = this;
            ood.asyRun(function(){
                self.boxing().LabelTrigger();
            });
        },
        

        _prepareData: function (profile, data) {
            data = arguments.callee.upper.call(this, profile, data);
            var v;
            if (data.caption) data.caption = ood.adjustVar(data.caption);
            if (data.clock) data.caption = '';
            if (v = data.iconFontColor) data._ic = 'color:var(--' + v + ');';
            if (v = data.fontSize) data._fs = 'font-size:' + v + ';';
            if (v = data.fontWeight) data._fw = 'font-weight:' + v + ';';
            if (v = data.fontColor) data._fc = 'color:var(--' + v + ');';
            if (v = data.fontFamily) data._ff = 'font-family:' + v + ';';
            data._hAlign = 'text-align:' + (data.hAlign || '');
            data._vAlign = 'vertical-align:' + (data.vAlign || '');
            return data;
        }
    }
});

ood.Class("ood.UI.ProgressBar", ["ood.UI.Widget","ood.absValue"] ,{
    Instance:{
        _setCtrlValue:function(value){
            return this.each(function(profile){
                var type=profile.properties.type,
                    inn=profile.getSubNode('FILL');
               if(type=="horizontal"){
                    inn.width(value+"%");
                }else{
                    inn.top((100-value)+"%").height(value+"%");
                }
                profile.getSubNode('CAP').text(profile.properties.captionTpl.replace(/\{value\}|\*/g,value));
            });
        },
        
        // Set theme
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();

                // Clear all theme classes
                root.removeClass('progressbar-dark progressbar-light progressbar-hc');
                
                // Apply theme class
                root.addClass('progressbar-' + theme);
                
                // Save theme settings
                localStorage.setItem('progressbar-theme', theme);
            });
        },
        
        // Get current theme
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('progressbar-theme') || 'light';
        },
        
        // Toggle dark mode
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        
        // Responsive layout adjustment
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    prop = profile.properties;

                // Adjust layout for small screens
                if (width < 768) {
                    root.addClass('progressbar-mobile');
                } else {
                    root.removeClass('progressbar-mobile');
                }

                // Special handling for extra small screens
                if (width < 480) {
                    root.addClass('progressbar-tiny');
                } else {
                    root.removeClass('progressbar-tiny');
                }
            });
        },
        
        // Enhance accessibility support
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    fill = profile.getSubNode('FILL'),
                    cap = profile.getSubNode('CAP'),
                    properties = profile.properties,
                    currentValue = properties.$UIvalue || properties.value || 0;

                // Add ARIA attributes to progress bar
                root.attr({
                    'role': 'progressbar',
                    'aria-valuemin': '0',
                    'aria-valuemax': '100',
                    'aria-valuenow': currentValue,
                    'aria-label': ood.getRes('UI.progressbar.label') || 'Progress indicator',
                    'aria-describedby': properties.tips ? profile.serialId + '_tips' : null,
                    'aria-live': 'polite',
                    'aria-atomic': 'true'
                });
                
                // Add ARIA attributes to fill area
                if (fill && !fill.isEmpty()) {
                    fill.attr({
                        'aria-hidden': 'true' // Hide decorative element
                    });
                }

                // Add ARIA attributes to text
                if (cap && !cap.isEmpty()) {
                    cap.attr({
                        'aria-hidden': 'true' // Text is already reflected in aria-valuenow
                    });
                }
            });
        }
    },
    Initialize:function(){
        var self=this,
            t = self.getTemplate();
        //modify
        ood.merge(t.FRAME.BORDER,{
            className:"ood-uiborder-flat ood-uiborder-radius ood-uibase",
            FILL:{
                tagName:'div',
                style:'{fillBG}',
                className:'ood-uibar',
                text:'{html}'+ood.UI.$childTag
            },
            INN:{
                $order:2,
                tagName:'div',
                CAP:{
                    tagName:'div'
                }
            }
        },'all');
        //set back
        self.setTemplate(t);

        //get default Appearance
        t = self.getAppearance();
        //modify
        ood.merge(t,{
            BORDER:{
                overflow:'hidden',
                'background-color': 'var(--ood-progressbar-track-bg)',
                'border': 'var(--ood-progressbar-track-border)',
                'height': 'var(--ood-progressbar-height)',
                'border-radius': 'var(--ood-progressbar-border-radius)'
            },
            INN:{
                display:'table',
                position:'absolute',
                left:0,
                top:0,
                width:'100%',
                height:'100%'
            },
            CAP:{
                'text-align':'center',
                'color': 'var(--progressbar-text)'
            },
            FILL:{
                border:'none',
                position:'relative',
                width:0,
                height:0,
                left:0,
                top:0,
                'background': 'var(--ood-progressbar-fill-bg)',
                'transition': 'width 0.3s ease, height 0.3s ease'
            }
        });
        //set back
        self.setAppearance(t);
    },
    Static:{
        DataModel:{
            // Modern properties
            theme: {
                ini: 'light',
                listbox: ['light', 'dark', 'high-contrast'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            value:0,
            width:{
                $spaceunit:1,
                ini:'25em'
            },
            height:{
                $spaceunit:1,
                ini:'1.5em'
            },
            captionTpl:{
                ini:'* %',
                action:function(){
                    this.boxing()._setCtrlValue(this.properties.$UIvalue);
                }
            },
            type:{
                listbox:['vertical', 'horizontal'],
                ini:'horizontal',
                action:function(v){
                    var w=this.properties.width,h=this.properties.height;
                    this.properties.height=w;this.properties.width=h;
                    this.boxing().refresh();
                }
            },
            fillBG:{
                ini:'',
                format:'color',
                action:function(v){
                    this.getSubNode('FILL').css('background',v);
                }
            },
            $hborder:1,
            $vborder:1
        },
        LayoutTrigger:function(){
            var v=this.properties,nd=this.getSubNode("BORDER");
            v.$hborder=v.$vborder=nd._borderW('left');
            
            // Modern feature initialization
            var self = this;
            ood.asyRun(function(){
                self.boxing().ProgressBarTrigger();
            });
        },
        
        ProgressBarTrigger: function() {
            var prop = this.properties,
                boxing = this.boxing();
            
            // Initialize modern features
            // Initialize theme
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // Restore theme from local storage
                var savedTheme = localStorage.getItem('progressbar-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // Initialize responsive design
            if (prop.responsive !== false) {
                boxing.adjustLayout();
            }
            
            // Initialize accessibility
            boxing.enhanceAccessibility();
        },
        _prepareData:function(profile){
            var data=arguments.callee.upper.call(this, profile);
            data.fillBG = data.fillBG?'background:'+data.fillBG:'';
            return data;
        },
        _ensureValue:function(profile,value){
            return Math.max(0, Math.min(100, ((/^\s*\=/.test(value||"")) ? ood.ExcelFormula.calculate(value||"") : parseInt(value,10)) || 0));
        },
        _onresize:function(profile,width,height){
            var size = arguments.callee.upper.apply(this,arguments),v,
                p=profile.properties,
                us = ood.$us(profile),
                adjustunit = function(v,emRate){return profile.$forceu(v, us>0?'em':'px', emRate)},
                root = profile.getRoot(),
                inn = profile.getSubNode('INN'),
                cap = profile.getSubNode('CAP'),
                fill = profile.getSubNode('FILL'),
                
                fzrate=profile.getEmSize()/root._getEmSize(),
                innfz=inn._getEmSize(fzrate),
                capfz=cap._getEmSize(fzrate),
                fillfz=fill._getEmSize(fzrate);
                
            // caculate by px
            if(size.width && size.width!='auto')size.width=profile.$px(size.width);
            if(size.height && size.height!='auto')size.height=profile.$px(size.height);

            if(p.type=="horizontal"){
                if(size.height){
                    v=adjustunit(size.height, innfz);
                    inn.css({'line-height':v});
                    
                    v=adjustunit(size.height, fillfz);
                    fill.css({height:v,'line-height':v});
                    
                    v=adjustunit(size.height, capfz);
                    cap.css({height:v,'line-height':v});
                }
            }else{
                if(size.width){
                    //inn.css({width:adjustunit(size.width, innfz)});                   
                    fill.css({width:adjustunit(size.width, fillfz)});
                    cap.css({width:adjustunit(size.width, capfz)});
                }
                if(size.height){
                    inn.css({'line-height':adjustunit(size.height, innfz)});
                    fill.css({'line-height':adjustunit(size.height, fillfz)});
                    cap.css({'line-height':adjustunit(size.height, capfz)});
                }
            }
        }
    }
});ood.Class("ood.UI.Slider", ["ood.UI","ood.absValue"],{
    Instance:{
        iniProp: {
            labelSize: '6em', height: '4em', labelPos: 'top', caption: '$RAD.widgets.slider', labelHAlign: 'left',
            isRange: false
        },
        _setCtrlValue:function(value){
            return this.each(function(profile){
                var p=profile.properties,
                    steps=p.steps,
                    fun=function(k){return profile.getSubNode(k)},
                    a=fun('IND1'),
                    b=fun('IND2'),
                    c=fun('BG'),
                    v=p.type=='vertical',
                    arr = profile.box._v2a(profile,value),
                    ori = v?'top':'left',
                    orj = v?'height':'width',
                    label, cap=ood.adjustRes(p.labelCaption,true)||"";
                if(p.isRange){
                    a[ori](arr[0]+'%');
                    b[ori](arr[1]+'%');
                    c[ori](arr[0]+'%')[orj]((arr[1]-arr[0])+'%');
                    label = (p.numberTpl+"")
                        .replace(/[*12]/g,function(a){
                            return a=='1'?ood.formatNumeric(arr[0],p.precision||0,null,null,true):
                            a=='2'? ood.formatNumeric(arr[1],p.precision||0,null,null,true)
                            : cap;
                        });
                }else{
                    a[ori](arr[0]+'%');
                    c[orj](arr[0]+'%');
                    label = (p.numberTpl+"")
                        .replace(/1[^2]*2/, '1' )
                        .replace('1', ood.formatNumeric(arr[0],p.precision||0,null,null,true) );
                    if(label.indexOf('*')!=-1)
                        label=label.replace('*', cap);
                    else label += cap;
                }
                if(p.labelPos!='none'&&parseFloat(p.labelSize)){
                    profile.getSubNode('LABEL').html(label );
                }
            });
        },
        _setDirtyMark:function(){
            return arguments.callee.upper.apply(this,['BOX']);
        },
        
        // Set theme
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();

                // Clear all theme classes
                root.removeClass('slider-dark slider-light slider-hc');
                
                // Apply theme class
                root.addClass('slider-' + theme);
                
                // Save theme settings
                localStorage.setItem('slider-theme', theme);
            });
        },
        
        // Get current theme
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('slider-theme') || 'light';
        },
        
        // Toggle dark mode
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        
        // Responsive layout adjustment
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    prop = profile.properties;

                // Adjust layout for small screens
                if (width < 768) {
                    root.addClass('slider-mobile');
                    
                    // Increase touch area for mobile
                    var inds = profile.getSubNode('IND1');
                    inds.css({
                        'width': '1.2em',
                        'height': '1.2em'
                    });
                    
                    if (prop.isRange) {
                        var ind2 = profile.getSubNode('IND2');
                        if (ind2 && !ind2.isEmpty()) {
                            ind2.css({
                                'width': '1.2em',
                                'height': '1.2em'
                            });
                        }
                    }
                } else {
                    root.removeClass('slider-mobile');
                    
                    // Restore desktop styles
                    var inds = profile.getSubNode('IND1');
                    inds.css({
                        'width': '',
                        'height': ''
                    });
                    
                    if (prop.isRange) {
                        var ind2 = profile.getSubNode('IND2');
                        if (ind2 && !ind2.isEmpty()) {
                            ind2.css({
                                'width': '',
                                'height': ''
                            });
                        }
                    }
                }

                // Special handling for extra small screens
                if (width < 480) {
                    root.addClass('slider-tiny');
                    
                    // Further increase touch area
                    var inds = profile.getSubNode('IND1');
                    inds.css({
                        'width': '1.4em',
                        'height': '1.4em'
                    });
                } else {
                    root.removeClass('slider-tiny');
                }
            });
        },
        
        // Enhance accessibility support
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    ind1 = profile.getSubNode('IND1'),
                    ind2 = profile.getSubNode('IND2'),
                    label = profile.getSubNode('LABEL'),
                    properties = profile.properties,
                    currentValue = properties.$UIvalue || properties.value || properties.min || 0;

                // Add ARIA attributes to slider
                root.attr({
                    'role': 'slider',
                    'aria-label': ood.getRes('UI.slider.label') || 'Slider control',
                    'aria-orientation': properties.type === 'vertical' ? 'vertical' : 'horizontal',
                    'aria-valuetext': properties.isRange ? 
                        ood.formatNumeric(Array.isArray(currentValue) ? currentValue[0] : currentValue, properties.precision || 0) + 
                        ' to ' + 
                        ood.formatNumeric(Array.isArray(currentValue) ? currentValue[1] : currentValue, properties.precision || 0) :
                        ood.formatNumeric(currentValue, properties.precision || 0),
                    'aria-valuemin': properties.min || 0,
                    'aria-valuemax': properties.max || 100,
                    'aria-valuenow': Array.isArray(currentValue) ? currentValue[0] : currentValue
                });
                
                // Add ARIA attributes to main slider
                if (ind1 && !ind1.isEmpty()) {
                    ind1.attr({
                        'role': 'slider',
                        'aria-valuemin': properties.min || 0,
                        'aria-valuemax': properties.max || 100,
                        'aria-valuenow': Array.isArray(currentValue) ? currentValue[0] : currentValue,
                        'aria-label': properties.isRange ? ood.getRes('UI.slider.rangeStart') : ood.getRes('UI.slider.value'),
                        'aria-orientation': properties.type === 'vertical' ? 'vertical' : 'horizontal'
                    });
                }
                
                // Add ARIA attributes to second slider (range)
                if (properties.isRange && ind2 && !ind2.isEmpty()) {
                    ind2.attr({
                        'role': 'slider',
                        'aria-valuemin': properties.min || 0,
                        'aria-valuemax': properties.max || 100,
                        'aria-valuenow': Array.isArray(currentValue) ? currentValue[1] : currentValue,
                        'aria-label': ood.getRes('UI.slider.rangeEnd'),
                        'aria-orientation': properties.type === 'vertical' ? 'vertical' : 'horizontal'
                    });
                }

                // Add attributes to label
                if (label && !label.isEmpty() && properties.labelPos !== 'none') {
                    label.attr({
                        'aria-live': 'polite'
                    });
                }
            });
        }
    },
    Static:{
        Templates:{
            style:'{_style}',
            className:'{_className} ood-ui-ellipsis {_cls}',
            LABEL:{
                className:'{_required}',
                style:'{labelShow};width:{_labelSize};{labelHAlign}',
                text:'{labelCaption}'
            },
            BOX:{
                tagName:'div',
                RULER:{
                    $order:1,
                    tagName:'div',
                    className:'ood-uiborder-flat ood-uibase ood-uiborder-radius',
                    BG:{
                        tagName:'div',
                        className:'ood-uibar ood-uiborder-radius'
                    }
                },
                IND:{
                    $order:2,
                    IND1:{
                        tagName:'span',
                        className:'ood-uibar ood-uigradient ood-ui-btn ood-uiborder-circle oodcon ood-icon-placeholder',
                        style:'{_showD}',
                        tabindex:'{tabindex}'
                    },
                    IND2:{
                        tagName:'span',
                        className:'ood-uibar ood-uigradient ood-ui-btn ood-uiborder-circle oodcon ood-icon-placeholder',
                        style:'{_showD2}',
                        tabindex:'{tabindex}'
                    }
                },
                DECREASE:{
                    style:'{_showDes}',
                    className:'oodfont',
                    $fonticon:'{_fi_decls}',
                    tabindex:'{tabindex}'
                },
                INCREASE:{
                    style:'{_showIns}',
                    className:'oodfont',
                    $fonticon:'{_fi_incls}',
                    tabindex:'{tabindex}'
                }
            }
        },
        // Upgrade Appearances section
        Appearances: {
        'RULER': {
        'background-color': 'var(--ood-slider-track-bg)',
        'border-radius': 'var(--ood-slider-border-radius)',
        'border': 'var(--ood-slider-track-border)',
        'height': 'var(--ood-slider-height)',
        transition: 'background-color 0.3s ease'
        },
        'BG': {
        'background': 'var(--ood-slider-fill-bg)',
        'border-radius': 'var(--ood-slider-border-radius)'
        },
        'IND1, IND2': {
        'border-radius': '50%',
        'box-shadow': 'var(--ood-slider-thumb-shadow)',
        'background': 'var(--ood-slider-thumb-bg)',
        'border': 'var(--ood-slider-thumb-border)',
        'width': 'var(--ood-slider-thumb-size)',
        'height': 'var(--ood-slider-thumb-size)',
        transition: 'all 0.2s ease'
        },
        'IND1:hover, IND2:hover': {
        'transform': 'scale(1.1)',
        'box-shadow': 'var(--ood-slider-thumb-hover-shadow)',
        'background': 'var(--ood-slider-thumb-hover)'
        }
        },
        Behaviors:{
            HoverEffected:{IND1:'IND1',IND2:'IND2',DECREASE:'DECREASE',INCREASE:'INCREASE'},
            ClickEffected:{IND1:'IND1',IND2:'IND2',DECREASE:'DECREASE',INCREASE:'INCREASE'},
            IND:{
                onClick:function(profile, e, src){
                    var p=profile.properties;
                    if(p.disabled || p.readonly)return false;
                    var p1=ood.use(src).offset(),
                        p2=ood.Event.getPos(e),
                        arr=profile.box._v2a(profile,profile.properties.$UIvalue),
                        i1,i2,
                        type=p.type=='vertical',
                        k1=type?'top':'left',
                        k2=type?'top':'left',
                        k3=type?'height':'width',
                        cur=p2[k1]-p1[k1],
                        v=(cur/ood.use(src)[k3]())*100;
                    if(!p.isRange)
                        arr[0]=v;
                    else{
                        i1=profile.getSubNode('IND1')[k2](),
                        i2=profile.getSubNode('IND2')[k2]();
                        if(Math.abs(i1-cur)<Math.abs(i2-cur))
                            arr[0]=v;
                        else arr[1]=v;
                    }
                    profile.boxing().setUIValue(profile.box._adjustValue(profile,arr),null,null,'click');
                }
            },
            IND1:{
                onKeydown:function(profile, e, src){
                    var p=profile.properties;
                    if(p.disabled || p.readonly)return;
                    var type=p.type=='vertical',
                        key=ood.Event.getKey(e).key;
                    if(key==(type?'up':'left'))
                        profile.box._auto(profile, false);
                    if(key==(type?'down':'right'))
                        profile.box._auto(profile, true);
                },
                onKeyout:function(profile){
                    ood.Thread.abort(profile.$xid+':auto');
                },
                onKeyup:function(profile){
                    ood.Thread.abort(profile.$xid+':auto');
                },
                beforeMousedown:function(profile, e, src){
                    if(ood.Event.getBtn(e)!="left")return;
                    var p=profile.properties;
                    if(p.disabled || p.readonly)return;
                    var type=p.type=='vertical',
                        k2=type?'top':'left',
                        k3=type?'height':'width',
                        box=profile.box;
                    ood.use(src).startDrag(e,{
                        widthIncrement:p.steps?profile._size/p.steps:null,
                        dragType:'none',
                        targetReposition:true,
                        horizontalOnly:type?true:null,
                        verticalOnly:type?null:true,
                        maxLeftOffset: ood.use(src)[k2](),
                        maxRightOffset: ood.use(src).parent()[k3]()-ood.use(src)[k2](),
                        dragCursor:'default'
                    });

                    ood.use(src).css('zIndex',10).focus(true);
                    profile.getSubNode('IND2').css('zIndex',5);
                },
                beforeDragbegin:function(profile, e, src){
                    var type=profile.properties.type=='vertical';
                    ood(src)[type?'top':'left'](profile.__x=profile.$px(ood.use(src)[type?'top':'left']()));
                },
                onDrag:function(profile, e, src){
                    var offset=ood.DragDrop.getProfile().offset,
                        type=profile.properties.type=='vertical',
                        arr=profile.box._v2a(profile,profile.properties.$UIvalue);
                    arr[0]=((profile.__x+offset[type?'y':'x'])/ood.use(src).parent()[type?'height':'width']())*100;
                    profile.boxing().setUIValue(profile.box._adjustValue(profile,arr),null,null,'drag');
                },
                onDragstop:function(profile, e, src){
                    ood(src).onMouseout(true,{$force:true}).onMouseup(true);
                },
                onClick:function(){return false}
            },
            IND2:{
                onKeydown:function(profile, e, src){
                    var p=profile.properties;
                    if(p.disabled || p.readonly)return;
                    var type=p.type=='vertical',
                        key=ood.Event.getKey(e).key;
                    if(key==(type?'up':'left'))
                        profile.box._auto(profile, false);
                    if(key==(type?'down':'right'))
                        profile.box._auto(profile, true);
                },
                onKeyout:function(profile){
                    ood.Thread.abort(profile.$xid+':auto');
                },
                onKeyup:function(profile){
                    ood.Thread.abort(profile.$xid+':auto');
                },
                beforeMousedown:function(profile, e, src){
                    if(ood.Event.getBtn(e)!="left")return;
                    var p=profile.properties;
                    if(p.disabled || p.readonly)return;
                    var type=p.type=='vertical',
                        k2=type?'top':'left',
                        k3=type?'height':'width',
                        box=profile.box;
                    ood.use(src).startDrag(e,{
                        widthIncrement:p.steps?profile._size/p.steps:null,
                        dragType:'none',
                        targetReposition:true,
                        horizontalOnly:type?true:null,
                        verticalOnly:type?null:true,
                        maxLeftOffset: ood.use(src)[k2](),
                        maxRightOffset: ood.use(src).parent()[k3]()-ood.use(src)[k2](),
                        dragCursor:'default'
                    });

                    ood.use(src).css('zIndex',10).focus(true);
                    profile.getSubNode('IND1').css('zIndex',5);
                },
                beforeDragbegin:function(profile, e, src){
                    var type=profile.properties.type=='vertical';
                    ood(src)[type?'top':'left'](profile.__x=profile.$px(ood.use(src)[type?'top':'left']()));
                },
                onDrag:function(profile, e, src){
                    var offset=ood.DragDrop.getProfile().offset,
                        type=profile.properties.type=='vertical',
                        arr=profile.box._v2a(profile,profile.properties.$UIvalue);
                    arr[1]=((profile.__x+offset[type?'y':'x'])/ood.use(src).parent()[type?'height':'width']())*100;
                    profile.boxing().setUIValue(profile.box._adjustValue(profile,arr),null,null,'drag2');
                },
                onDragstop:function(profile, e, src){
                    ood(src).onMouseout(true,{$force:true}).onMouseup(true);
                },
                onClick:function(){return false}
            },
            DECREASE:{
                onMousedown:function(profile){
                    if(profile.properties.disabled || profile.properties.readonly)return;
                    profile.box._auto(profile, false);
                },
                onMouseout:function(profile){
                    if(profile.properties.disabled || profile.properties.readonly)return;
                    ood.Thread.abort(profile.$xid+':auto');
                },
                onMouseup:function(profile){
                    if(profile.properties.disabled || profile.properties.readonly)return;
                    ood.Thread.abort(profile.$xid+':auto');
                }
            },
            INCREASE:{
                onMousedown:function(profile){
                    if(profile.properties.disabled || profile.properties.readonly)return;
                    profile.box._auto(profile, true);
                },
                onMouseout:function(profile){
                    if(profile.properties.disabled || profile.properties.readonly)return;
                    ood.Thread.abort(profile.$xid+':auto');
                },
                onMouseup:function(profile){
                    if(profile.properties.disabled || profile.properties.readonly)return;
                    ood.Thread.abort(profile.$xid+':auto');
                }
            },
            LABEL:{
                onClick:function(profile, e, src){
                    if(profile.properties.disabled)return false;
                    if(profile.onLabelClick)
                        profile.boxing().onLabelClick(profile, e, src);
                },
                onDblClick:function(profile, e, src){
                    if(profile.properties.disabled)return false;
                    if(profile.onLabelDblClick)
                        profile.boxing().onLabelDblClick(profile, e, src);
                },
                onMousedown:function(profile, e, src){
                    if(ood.Event.getBtn(e)!='left')return;
                    if(profile.properties.disabled)return false;
                     if(profile.onLabelActive)
                        profile.boxing().onLabelActive(profile, e, src);
                }
            }
        },
        DataModel:{
            // Modern properties
            theme: {
                ini: 'light',
                listbox: ['light', 'dark'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            position:'absolute',
            expression:{
                ini:'',
                action:function () {
                }
            },
            width:{
                $spaceunit:1,
                ini:'15em'
            },
            height:{
                $spaceunit:1,
                ini:'4em'
            },
            precision:0,
            numberTpl:'* - 1% ~ 2%',
            steps:0,
            value:'0:0',
            type:{
                listbox:['vertical', 'horizontal'],
                ini:'horizontal',
                action:function(v){
                    this.boxing().refresh();
                }
            },
            isRange:{
                ini:true,
                action:function(v){
                    this.boxing().refresh();
                }
            },
            showIncreaseHandle:{
                ini:true,
                action:function(v){
                    this.adjustSize();
                }
            },
            showDecreaseHandle:{
                ini:true,
                action:function(v){
                    this.adjustSize();
                }
            },
            // label
            labelSize:{
                $spaceunit:2,
                ini:0,
                action: function(v){
                    this.getSubNode('LABEL').css({display:v?'':'none'});
                    ood.UI.$doResize(this,this.properties.width,this.properties.height,true);
                }
            },
            labelPos:{
                ini:"left",
                listbox:['none','left','top', 'right', 'bottom'],
                action: function(v){
                    ood.UI.$doResize(this,this.properties.width,this.properties.height,true);
                }                
            },
            labelGap:{
                $spaceunit:2,
                ini:4,
                action: function(v){
                    ood.UI.$doResize(this,this.properties.width,this.properties.height,true);
                }
            },
            labelCaption:{
                ini:"",
                action: function(v){
                     var p=this.properties;
                     if(p.labelPos!='none'&& parseFloat(p.labelSize))
                        this.getSubNode('LABEL').html(ood.adjustRes((ood.isSet(v)?v:"")+"", true));
                }
            },
            labelHAlign:{
                ini:'right',
                listbox:['','left','center','right'],
                action: function(v){
                    this.getSubNode('LABEL').css({
                        'textAlign': v||'',
                        'justifyContent':v=='right'?'flex-end':v=='center'?'center':v=='left'?'flex-start':''
                    });
                }
            },
            labelVAlign:{
                ini:'top',
                listbox:['','top','middle','bottom'],
                action: function(v){
                    this.getSubNode('LABEL').css('align-items',v=='bottom'?'flex-end':v=='middle'?'center':v=='top'?'flex-start':'');
                }
            }
        },
        EventHandlers:{
            onLabelClick:function(profile, e, src){},
            onLabelDblClick:function(profile, e, src){},
            onLabelActive:function(profile, e, src){}
        },
        
        RenderTrigger: function() {
            // Modern feature initialization
            var self = this;
            ood.asyRun(function(){
                self.boxing().SliderTrigger();
            });
        },
        
        SliderTrigger: function() {
            var profile = this.get(0);
            var prop = profile.properties;
            var boxing = this;

            // Initialize theme
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // Restore theme from local storage
                var savedTheme = localStorage.getItem('slider-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // Initialize responsive design
            if (prop.responsive !== false) {
                boxing.adjustLayout();
            }

            // Initialize accessibility
            boxing.enhanceAccessibility();
        },
        _prepareData:function(profile){
            var d=arguments.callee.upper.call(this, profile),
                N='display:none',t,v;
            d._showDes=d.showDecreaseHandle?'':N,
            d._showIns=d.showIncreaseHandle?'':N,
            d._showD2=d.isRange?'':N;
            d._cls=profile.getClass('KEY',d.type=='vertical'?'-v':'-h');
            d._labelHAlign = 'text-align:'+(v=d.labelHAlign||'')+';justify-content:'+(v=='right'?'flex-end':v=='center'?'center':v=='left'?'flex-start':'');
            d._labelVAlign = 'align-items:'+((v=d.labelVAlign)=='bottom'?'flex-end':v=='middle'?'center':v=='top'?'flex-start':'');
            d.labelShow=d.labelPos!='none'&&d.labelSize&&d.labelSize!='auto'?"":"display:none";
            d._labelSize=d.labelSize?'':0+profile.$picku();

            // adjustRes for labelCaption
            if(d.labelPos!='none'&& d.labelSize && d.labelCaption)
                d.labelCaption=ood.adjustRes(d.labelCaption,true);

            d._fi_decls = 'ood-icon-single'+(d.type=='vertical'?'up':'left');
            d._fi_incls = 'ood-icon-single'+(d.type=='vertical'?'down':'right');
            return d;
        },
        _adjustValue:function(profile,value){
            var p = profile.properties,
                b=[];
            b[0]=parseFloat(value[0])||0;
            b[1]=parseFloat(value[1])||0;
            if(p.steps){
                value=100/p.steps;
                b[0]=Math.ceil(b[0]/value);
                if(p.isRange)
                    b[1]=Math.ceil(b[1]/value);
            }
            return p.isRange?b.join(':'):(b[0]+'');
        },
        _ensureValue:function(profile, value){
            var p = profile.properties,
                a = String(value).split(':'),
                min=0,
                max=p.steps?p.steps:100,
                b=[],
                f1=function(a){return parseFloat(a)||0},
                f2=function(a){return Math.min(max, Math.max(min,a))};
            b[0]= f1(a[0]);
            if(p.isRange){
                b[1]= f1(a[1]);
                if(b[0]>b[1]){
                    a=b[1];
                    b[1]=b[0];
                    b[0]=a;
                }
            }
            b[0]= f2(b[0]);
            if(p.isRange)
                b[1]= f2(b[1]);
            return p.isRange?b.join(':'):(b[0]+'');
        },
        _v2a:function(profile,v){
            var steps=profile.properties.steps,t;
            v = typeof v == 'string'? v.split(':') : v;
            v[0]=parseFloat(v[0])||0;v[1]=parseFloat(v[1])||0;
            if(steps)v[0]=v[0]*100/steps;
            if(steps)v[1]=v[1]*100/steps;
            if(v[0]>v[1]){
                t=v[0];
                v[1]=v[0];
                v[0]=t;
            }
            return v;
        },
        _auto:function(profile, flag){
            var id=profile.$xid+':auto';
            if(ood.Thread.isAlive(id))return;
            var p=profile.properties,t,
                //%
                off=(p.steps?100/p.steps:1)*(flag?1:-1),
                task={delay:300},
                arr=profile.box._v2a(profile,p.$UIvalue),
                fun=function(){
                    arr[0] += off;
                    if(p.isRange)
                        arr[1] += off;
                    profile.boxing().setUIValue(profile.box._adjustValue(profile,arr),null,null,'auto');
                    task.delay *=0.8;
                };
            task.task=fun;
            ood.Thread(id,[task],500,null,fun,null,true).start();
        },
        _onresize:function(profile, width, height){
            var prop=profile.properties,
                type=prop.type,
                f=function(k){return profile.getSubNode(k)},
                root = f('KEY'),
                ruler = f('RULER'),
                ind = f('IND'),
                indb = f('IND1'),
                offset = profile.$px('.75em'),
                box = f('BOX'),
                label = f('LABEL'),
                cmd1 = f('INCREASE'),
                cmd2 = f('DECREASE'),
                cb=ood.browser.contentBox,
                us = ood.$us(profile),
                adjustunit = function(v,emRate){return profile.$forceu(v, us>0?'em':'px', emRate)},

                fzrate=profile.getEmSize()/root._getEmSize(),
                labelfz=label._getEmSize(fzrate),
                rulerfz = ruler._getEmSize(fzrate),
                indfz = ind._getEmSize(fzrate),

                label = profile.getSubNode('LABEL'),
                labelPos=prop.labelPos,
                labelSize=(labelPos=='none'||!labelPos)?0:profile.$px(prop.labelSize,labelfz)||0,
                labelGap=(labelPos=='none'||!labelPos)?0:profile.$px(prop.labelGap)||0,
                ll, tt, ww, hh;

            // calculate by px
            if(width && width!='auto')width=profile.$px(width);
            if(height && height!='auto')height=profile.$px(height);

            box.cssPos({
                left : adjustunit(ll = labelPos=='left'?labelSize:0),
                top : adjustunit(tt = labelPos=='top'?labelSize:0)
            });
            cmd2.css('display',prop.showDecreaseHandle?'':'none');
            cmd1.css('display',prop.showIncreaseHandle?'':'none');

            if(type=='vertical'){
                box.cssSize({
                    width : '',
                    height : adjustunit(hh = height===null?null:Math.max(0,(height - ((labelPos=='top'||labelPos=='bottom')?labelSize:0))))
                });
                var w=profile.$px('1em'),
                    w1=prop.showIncreaseHandle?w:0,
                    w2=prop.showDecreaseHandle?w:0,
                    w3=ood.browser.contentBox?indb._borderH('top'):0;
                if(hh){
                    ruler.top(adjustunit(w1+offset,rulerfz))
                        .height(adjustunit(hh-w1-w2-2*offset,rulerfz));
                    ind.top(adjustunit(w1+offset-w3,indfz))
                        .height(adjustunit(hh-w1-w2-2*offset,indfz));
                }

            if(labelSize)
                label.cssRegion({
                    left: adjustunit(width===null?null:Math.max(0,labelPos=='right'?(box.width()+labelGap):0),labelfz),
                    top:  adjustunit(height===null?null:Math.max(0,labelPos=='bottom'?(height-labelSize+labelGap):0),labelfz), 
                    width: '',
                    height: adjustunit(height===null?null:Math.max(0,((labelPos=='top'||labelPos=='bottom')?(labelSize-labelGap):height)),labelfz)
                });
            }else{
                box.cssSize({
                    width : adjustunit(ww = width===null?null:Math.max(0,(width - ((labelPos=='left'||labelPos=='right')?labelSize:0)))),
                    height : ''
                });
                var w=profile.$px('1em'),
                    w1=prop.showDecreaseHandle?w:0,
                    w2=prop.showIncreaseHandle?w:0,
                    w3=!cb?0:indb._borderW('left');
                if(ww){
                    ruler.left(adjustunit(w1+offset, rulerfz))
                        .width(adjustunit(ww-w1-w2-2*offset,rulerfz));
                    ind.left(adjustunit(w1+offset-w3, indfz))
                        .width(adjustunit(ww-w1-w2-2*offset,indfz));
                }

            if(labelSize)
                label.cssRegion({
                    left: adjustunit(width===null?null:Math.max(0,labelPos=='right'?(width-labelSize+labelGap):0),labelfz),
                    top:  adjustunit(height===null?null:Math.max(0,labelPos=='bottom'?(box.height()+labelGap):0),labelfz), 
                    width: adjustunit(width===null?null:Math.max(0,((labelPos=='left'||labelPos=='right')?(labelSize-labelGap):width)),labelfz),
                    height: adjustunit(height===null?null:Math.max(0,((labelPos=='top'||labelPos=='bottom')?(labelSize-labelGap):height)),labelfz)
                });

            }
        }
    }
});ood.Class("ood.UI.Input", ["ood.UI.Widget", "ood.absValue"], {
    Instance: {
        iniProp: {width: '18em', labelSize: '6em', caption: ""},
        // 
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot(),
                    frame = profile.getSubNode('FRAME'),
                    border = profile.getSubNode('BORDER'),
                    box = profile.getSubNode('BOX'),
                    wrap = profile.getSubNode('WRAP'),
                    input = profile.getSubNode('INPUT'),
                    label = profile.getSubNode('LABEL'),
                    error = profile.getSubNode('ERROR');

                // 
                root.addClass('input-themed');
                if (theme === 'dark') {
                    root.addClass('input-dark');
                    
                    // CSS
                    frame && !frame.isEmpty() && frame.css({
                        'background-color': 'var(--input-dark-bg)',
                        'border-color': 'var(--input-dark-border)'
                    });
                    border && !border.isEmpty() && border.css({
                        'background-color': 'var(--input-dark-bg)',
                        'border-color': 'var(--input-dark-border)'
                    });
                    box && !box.isEmpty() && box.css({
                        'background-color': 'var(--input-dark-bg-input)',
                        'border-color': 'var(--input-dark-border)'
                    });
                    wrap && !wrap.isEmpty() && wrap.css({
                        'background-color': 'var(--input-dark-bg-input)',
                        'border-color': 'var(--input-dark-border)'
                    });
                    input.css({
                        'background-color': 'var(--input-dark-bg-input)',
                        'border-color': 'var(--input-dark-border)',
                        'color': 'var(--input-dark-text)',
                        'caret-color': 'var(--input-dark-text)'
                    });
                    label && !label.isEmpty() && label.css({
                        'color': 'var(--input-dark-text)'
                    });
                    error && !error.isEmpty() && error.css({
                        'color': 'var(--input-dark-error)'
                    });
                } else if (theme === 'high-contrast') {
                    // 
                    root.addClass('input-hc');
                    
                    // 
                    if (frame && !frame.isEmpty()) {
                        frame.css({
                            'background-color': 'var(--hc-bg)',
                            'border-color': 'var(--hc-border)',
                            'border-width': '2px'
                        });
                    }
                    if (border && !border.isEmpty()) {
                        border.css({
                            'background-color': 'var(--hc-bg)',
                            'border-color': 'var(--hc-border)',
                            'border-width': '2px'
                        });
                    }
                    
                    // 
                    if (box && !box.isEmpty()) {
                        box.css({
                            'background-color': 'var(--hc-bg-input)',
                            'border-color': 'var(--hc-border)',
                            'border-width': '2px'
                        });
                    }
                    if (wrap && !wrap.isEmpty()) {
                        wrap.css({
                            'background-color': 'var(--hc-bg-input)',
                            'border-color': 'var(--hc-border)',
                            'border-width': '2px'
                        });
                    }
                    
                    // 
                    input.css({
                        'background-color': 'var(--hc-bg-input)',
                        'border-color': 'var(--hc-border)',
                        'border-width': '2px',
                        'color': 'var(--hc-text)',
                        'caret-color': 'var(--hc-primary)'
                    });
                    
                    // 
                    if (label && !label.isEmpty()) {
                        label.css({
                            'color': 'var(--hc-text)',
                            'font-weight': 'bold'
                        });
                    }
                    
                    // 
                    if (error && !error.isEmpty()) {
                        error.css({
                            'color': 'var(--hc-error)',
                            'font-weight': 'bold'
                        });
                    }
                } else {
                    // 
                    root.removeClass('input-dark input-hc');
                    
                    // CSS
                    frame && !frame.isEmpty() && frame.css({
                        'background-color': 'var(--input-bg)',
                        'border-color': 'var(--input-border)'
                    });
                    border && !border.isEmpty() && border.css({
                        'background-color': 'var(--input-bg)',
                        'border-color': 'var(--input-border)'
                    });
                    box && !box.isEmpty() && box.css({
                        'background-color': 'var(--input-bg-input)',
                        'border-color': 'var(--input-border)'
                    });
                    wrap && !wrap.isEmpty() && wrap.css({
                        'background-color': 'var(--input-bg-input)',
                        'border-color': 'var(--input-border)'
                    });
                    input.css({
                        'background-color': 'var(--input-bg-input)',
                        'border-color': 'var(--input-border)',
                        'color': 'var(--input-text)',
                        'caret-color': 'var(--input-primary)'
                    });
                    label && !label.isEmpty() && label.css({
                        'color': 'var(--input-text)'
                    });
                    error && !error.isEmpty() && error.css({
                        'color': 'var(--input-error)'
                    });
                }
                
                // 
                localStorage.setItem('input-theme', theme);
            });
        },
        
        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('input-theme') || 'light';
        },
        
        // 
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        _setTB: function (type) {
            var profile = this.get(0), p = profile.properties, o, t;
            if (!profile.host || !p.tipsBinder) return;
            var ot = profile.tips;
            t = profile.tips = profile.tips || p.tips || '';
            o = ood.getObject(p.tipsBinder) || ((o = profile.host[p.tipsBinder]) && o.get(0));
            if (o && (o.key == 'ood.UI.Span' || o.key == 'ood.UI.Div' || o.key == 'ood.UI.Label')) {
                if (o.renderId) {
                    //use innerHTML, not setHtml
                    o.getRootNode().innerHTML = t.charAt(0) == '$' ? ood.wrapRes(t) : t;
                    o.getRoot().css('color', type == 1 ? 'var(--text-muted)' : type == 2 ? 'var(--error-color)' : 'var(--text-primary)');
                }
            }
            if (ot !== profile.tips && ood.Tips && ood.Tips.getTips()) ood.Tips.setTips(profile.tips);
        },
        activate: function (select) {
            var profile = this.get(0);
            if (profile && profile.renderId) {
                var node = profile.getSubNode('INPUT').get(0);
                if (node) {
                    try {
                        node.focus();
                        if (select || (!ood.browser.fakeTouch && ood.browser.deviceType != 'touchOnly')) {
                            try {
                                if (node.tagName.toLowerCase() == "input" || !/[\n\r]/.test(node.value)) node.select();
                                else ood(node).caret(0, 0);
                            } catch (e) {
                            }
                        }
                    } catch (e) {
                    }
                    delete profile._justFocus;
                }
            }
            return this;
        },
        getAutoexpandHeight: function () {
            var prf = this.get(0), prop = prf.properties;
            return (prop.multiLines && parseFloat(prf._autoexpand || prop.autoexpand)) ? (prf.$autoExpandH || prf.$px(prf._autoexpand || prop.autoexpand)) : null;
        },
        _setCtrlValue: function (value) {
            if (ood.isNull(value) || !ood.isDefined(value)) value = '';
            return this.each(function (profile) {
                if (profile.$Mask && !value) {
                    value = profile.$Mask;
                }
                profile.$_inner = 1;
                profile.getSubNode('INPUT').attr('value', value + "");

                profile.box._checkAutoexpand(profile);

                delete profile.$_inner;
            });
        },
        _getCtrlValue: function () {
            var node = this.getSubNode('INPUT'),
                v = (node && !node.isEmpty()) ? this.getSubNode('INPUT').attr('value') : "";
            if (v.indexOf("\r") != -1) v = v.replace(/(\r\n|\r)/g, "\n");
            if (this.get(0).$Mask && this.get(0).$Mask == v) {
                v = "";
            }
            return v;
        },
        _setDirtyMark: function () {
            return this.each(function (profile) {
                var properties = profile.properties,
                    o = profile.getSubNode('INPUT'),
                    cls = profile.box,
                    box = profile.boxing(),
                    d = ood.UI.$css_tag_dirty,
                    v = ood.UI.$css_tag_invalid,
                    flag = properties.value !== properties.$UIvalue;
                var ot = profile.tips;
                if (profile._inValid == 2) {
                    //display tips
                    profile.tips = properties.tipsErr || properties.tips;
                } else {
                    if (profile._inValid == 1)
                        profile.tips = properties.tips;
                    else {
                        profile.tips = properties.tipsOK || properties.tips;
                    }
                }
                if (ot !== profile.tips && ood.Tips && ood.Tips.getTips()) ood.Tips.setTips(profile.tips);

                if (profile._dirtyFlag !== flag) {
                    if (properties.dirtyMark && properties.showDirtyMark) {
                        if (profile.beforeDirtyMark && false === box.beforeDirtyMark(profile, flag)) {
                        }
                        else {
                            if (profile._dirtyFlag = flag) o.addClass(d);
                            else o.removeClass(d);
                        }
                    }
                    profile._dirtyFlag = flag
                }

                //format statux
                if (profile.beforeFormatMark && false === box.beforeFormatMark(profile, profile._inValid == 2)) {
                }
                else {
                    var err = profile.getSubNode('ERROR');
                    if (profile._inValid == 2) {
                        o.addClass(v);
                        err.css('display', 'block');
                    } else {
                        o.removeClass(v);
                        err.css('display', 'none');
                    }
                }
                box._setTB(profile._inValid);
            });
        },


        getSelectedItem: function (returnArr) {
            var upper = arguments.callee.upper,
                v = upper.apply(this, ood.toArr(arguments));
            upper = null;
            return this._adjustV(v);
        },


        getUIValue: function () {
            var upper = arguments.callee.upper,
                v = upper.apply(this, ood.toArr(arguments));
            upper = null;
            return v;
        },
        // notify the modification to fake excel ( in module )
        notifyExcel: function (refreshAll) {
            return this.each(function (prf) {
                var prop = prf.properties, ID = 'triggerExcelFormulas:';
                if (prop.excelCellId) {
                    if (prf.host && prf.host['ood.Module']) {
                        ID = ID + prf.host.xid;
                        if (refreshAll === false) {
                            if (!ood.resetRun.exists(ID))
                                if (prf && prf.host) prf.host.triggerExcelFormulas(prf);
                        } else
                            ood.resetRun(ID, function () {
                                if (prf && prf.host) prf.host.triggerExcelFormulas(null);
                            });
                    }
                }
            });
        },
        // get control's fake cexcel cell value
        getExcelCellValue: function () {
            var profile = this.get(0), prop = profile.properties, value, v2;
            if (prop.excelCellId) {
                value = this.getUIValue();
                if (ood.isSet(v2 = (profile.onGetExcelCellValue && profile.onGetExcelCellValue(profile, prop.excelCellId, value))))
                    value = v2;
            }
            return value;
        },
        // calculate the formula, and apply to the control
        _applyExcelFormula: function (cellsMap) {
            var profile = this.get(0), prop = profile.properties, f, value;
            if (f = prop.excelCellFormula) {
                value = ood.ExcelFormula.calculate(f, cellsMap);
                if (ood.isSet(value)) {
                    if (profile.beforeApplyExcelFormula && false === profile.beforeApplyExcelFormula(profile, prop.excelCellFormula, value)) {
                    } else {
                        this.setUIValue(value, true, null, 'formula');
                        if (profile.afterApplyExcelFormula) profile.afterApplyExcelFormula(profile, prop.excelCellFormula, value);
                    }
                }
            }
        }
    },
    Initialize: function () {
        //modify default template fro shell
        var t = this.getTemplate();
        ood.merge(t.FRAME.BORDER, {
            style: '',
            LABEL: {
                className: '{_required} ui-ellipsis',
                style: '{labelShow};width:{_labelSize};{_labelHAlign};{_labelVAlign};',
                text: '{labelCaption}'
            },
            BOX: {
                className: 'ui-input ui-shadow-input uiborder-flat uiborder-radius uibase',
                style: ' {_hiddenBorder}',
                WRAP: {
                    tagName: 'div',
                    INPUT: {
                        $order: 10,
                        className: 'ui-ellipsis {_inputcls}',
                        tagName: 'input',
                        type: '{_inputtype}',
                        maxlength: '{maxlength}',
                        tabindex: '{tabindex}',
                        placeholder: "{placeholder}",
                        style: '{_css};{hAlign}'
                    }
                }
            }
        }, 'all');
        t.FRAME.ERROR = {
            className: 'oodfont',
            $fonticon: 'icon-error'
        };
        this.setTemplate(t)
    },
    Static: {
        _syncResize: true,
        _maskMap: {
            '~': '[+-]',
            '1': '[0-9]',
            'a': '[A-Za-z]',
            'u': '[A-Z]',
            'l': '[a-z]',
            '*': '[A-Za-z0-9]'
        },
        _maskSpace: '_',
        Appearances: {
            KEY: {
                position: 'relative'
            },
            BORDER: {},
            WRAP: {
                left: 0,
                //for firefox bug: cursor not show
                position: 'absolute',
                overflow: (ood.browser.gek && ood.browser.ver < 3) ? 'auto' : 'visible'
            },
            BOX: {
                left: 0,
                top: 0,
                position: 'absolute',
                overflow: 'hidden',
                'z-index': 10
            },
            '.required-field BOX': {
                'border-color': 'var(--error-color)'
            },
            LABEL: {
                $order: 100,
                'z-index': 1,
                top: 0,
                left: 0,
                display: ood.browser.isWebKit ? '-webkit-flex' : 'flex',
                position: 'absolute',
                //don't change it in custom class or style
                'padding-top': '4px',
                'padding-bottom': '4px'
            },
            INPUT: {
                $order: 100,
                'padding': 'var(--spacing-sm)',
                'background-color': 'var(--bg-input)',
                'border': '1px solid var(--border-light)',
                'border-radius': 'var(--radius-sm)',
                'margin': 0,
                'text-align': 'left',
                'position': 'relative',
                'z-index': 10,
                'width': '100%',
                'transition': 'all 0.2s ease',
                'box-sizing': 'border-box',
                'font-family': 'var(--font-family)',
                'font-size': 'var(--font-size)',
                'color': 'var(--text-input)  !important',
                '&:focus': {
                    'border-color': 'var(--border-color)',
                    'box-shadow': '0 0 0 2px var(--bg-tertiary)'
                },
                
                '&:disabled': {
                    'background-color': 'var(--text-muted)',
                    'cursor': 'not-allowed'
                },
                
                '&.ui-invalid': {
                    'border-color': 'var(--error-color)'
                }
            },
            "KEY textarea.autoexpand": {
                overflow: 'hidden',
                $order: 2
            },
            "KEY textarea": {
                'white-space': 'normal',
                'overflow-x': 'hidden',
                'overflow-y': 'auto'
            },
            ERROR: {
                position: 'absolute',
                right: 'var(--spacing-sm)',
                top: 'var(--spacing-sm)',
                display: 'none',
                'z-index': 20,
                'color': 'var(--error-color)',
                'font-size': 'var(--font-size-sm)'
            },

            '.required-field BOX': {
                'border-color': 'var(--error-color)'
            },

            "KEY textarea": {
                'min-height': '5em',
                'resize': 'vertical',
                'white-space': 'pre-wrap'
            }
        },
        Behaviors: {
            HoverEffected: {BOX: ['BOX']},
            NavKeys: {INPUT: 1},
            LABEL: {
                onClick: function (profile, e, src) {
                    if (profile.properties.disabled) return false;
                    if (profile.onLabelClick)
                        profile.boxing().onLabelClick(profile, e, src);
                },
                onDblClick: function (profile, e, src) {
                    if (profile.properties.disabled) return false;
                    if (profile.onLabelDblClick)
                        profile.boxing().onLabelDblClick(profile, e, src);
                },
                onMousedown: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != 'left') return;
                    if (profile.properties.disabled) return false;
                    if (profile.onLabelActive)
                        profile.boxing().onLabelActive(profile, e, src);
                }
            },
            INPUT: {
                onChange: function (profile, e, src) {
                    if (profile.$_onedit || profile.$_inner || profile.destroyed || !profile.box) return;
                    var p = profile.properties, b = profile.box,
                        o = profile._inValid,
                        instance = profile.boxing(),
                        value = ood.use(src).get(0).value;

                    if (profile.$Mask && profile.$Mask == value) {
                        value = "";
                    }

                    // trigger events
                    instance.setUIValue(value, null, null, 'onchange');
                    // input/textarea is special, ctrl value will be set before the $UIvalue
                    if (p.$UIvalue !== value) instance._setCtrlValue(p.$UIvalue);
                    if (o !== profile._inValid) if (profile.renderId) instance._setDirtyMark();

                    b._asyCheck(profile);
                },



                //if properties.mask exists, onHotKeyxxx wont be tigger any more
                onKeydown: function (profile, e, src) {
                    var p = profile.properties, b = profile.box,
                        m = p.multiLines,
                        evt = ood.Event,
                        k = evt.getKey(e);
                    if (p.disabled || p.readonly) return;

                    if (parseInt(p.autoexpand))
                        b._checkAutoexpand(profile);

                    //fire onchange first
                    if (k.key == 'enter' && (!m || k.altKey))
                        ood.use(src).onChange();

                    b._asyCheck(profile);

                    if (p.mask) {
                        if (k.key.length > 1) profile.$ignore = true;
                        else delete profile.$ignore;
                        switch (k.key) {
                            case 'backspace':
                                b._changeMask(profile, ood.use(src).get(0), '', false);
                                return false;
                            case 'delete':
                                b._changeMask(profile, ood.use(src).get(0), '');
                                return false;
                        }
                    }
                },
                onKeypress: function (profile, e, src) {
                    var p = profile.properties,
                        b = profile.box,
                        cls = profile.box,
                        map = cls._maskMap,
                        k = ood.Event.getKey(e), t,
                        caret = ood.use(src).caret();

                    if (profile.beforeKeypress && false === profile.boxing().beforeKeypress(profile, caret, k, e, src))
                        return false;
                    t = profile.CF.beforeKeypress || profile.$beforeKeypress;
                    if (t && false === t(profile, caret, k, e, src))
                        return false;

                    b._asyCheck(profile);

                    if (p.mask) {
                        if (profile.$ignore) {
                            delete profile.$ignore;
                            return true;
                        }
                        if (k.ctrlKey || k.altKey) return true;

                        cls._changeMask(profile, ood.use(src).get(0), k.key, true);
                        return false;
                    }
                },
                onKeyup: function (profile, e, src) {
                    var p = profile.properties, b = profile.box;
                    // must be key up event
                    if (ood.Event.getKey(e).key == 'esc') {
                        profile.boxing()._setCtrlValue(p.$UIvalue);
                        if (profile.onCancel)
                            profile.boxing().onCancel(profile);
                    }

                    if (p.dynCheck) {
                        var value = ood.use(src).get(0).value;
                        profile.box._checkValid(profile, value);
                        profile.boxing()._setDirtyMark();
                    }
                    b._asyCheck(profile);
                },
                onMousedown: function (profile, e, src) {
                    profile._mousedownmark = 1;
                    ood.asyRun(function () {
                        if (profile) delete profile._mousedownmark;
                    });
                },
                onMouseup: function (profile, e, src) {
                    if (profile.properties.selectOnFocus && profile._justFocus) {
                        var node = ood.use(src).get(0);
                        if (!node.readOnly && node.select) {
                            profile.$mouseupDelayFun = ood.asyRun(function () {
                                delete profile.$mouseupDelayFun;
                                if (!ood.browser.fakeTouch && ood.browser.deviceType != 'touchOnly') {
                                    if (node.tagName.toLowerCase() == "input" || !/[\n\r]/.test(node.value)) node.select();
                                }
                            })
                        }
                        delete profile._justFocus;
                    }
                    if (profile._activedonmousedown) {
                        delete profile._activedonmousedown;
                        var node = ood.use(src).get(0);
                        if (node.tagName.toLowerCase() == "input" || !/[\n\r]/.test(node.value)) node.select();
                    }
                },
                onFocus: function (profile, e, src) {
                    if (profile.$ignoreFocus) return false;
                    if (profile.beforeFocus && false === profile.boxing().beforeFocus(profile)) {
                        profile.$ignoreBlur = 1;
                        ood(src).blur();
                        delete profile.$ignoreBlur;
                        return false;
                    }
                    var p = profile.properties, b = profile.box;
                    if (p.disabled || p.readonly) return false;
                    if (profile.onFocus) profile.boxing().onFocus(profile);
                    profile.getSubNode('BOX').tagClass('-focus');

                    var node = ood.use(src).get(0);

                    //if no value, add mask
                    if (p.mask) {
                        var value = node.value;
                        if (!value) {
                            profile.$focusDelayFun = ood.asyRun(function () {
                                // destroyed
                                if (!profile.box) return;
                                delete profile.$focusDelayFun;
                                profile.$_inner = true;
                                node.value = profile.$Mask;
                                delete profile.$_inner;
                                b._setCaret(profile, node);
                            });
                        }
                    }
                    if (p.selectOnFocus && !node.readOnly && node.select) {
                        if (ood.browser.kde) {
                            profile.$focusDelayFun2 = ood.asyRun(function () {
                                delete profile.$focusDelayFun2;
                                if (!ood.browser.fakeTouch && ood.browser.deviceType != 'touchOnly') {
                                    if (node.tagName.toLowerCase() == "input" || !/[\n\r]/.test(node.value)) node.select();
                                }
                            });
                        } else {
                            if (!ood.browser.fakeTouch && ood.browser.deviceType != 'touchOnly') {
                                if (node.tagName.toLowerCase() == "input" || !/[\n\r]/.test(node.value)) node.select();
                            }
                        }
                        // if focus was triggerred by mousedown, try to stop mouseup's caret
                        if (profile._mousedownmark) profile._justFocus = 1;
                    }
                    //show tips color
                    profile.boxing()._setTB(3);

                    b._asyCheck(profile);
                },
                onBlur: function (profile, e, src) {
                    if (profile.$ignoreBlur) return false;
                    ood.resetRun(profile.$xid + ":asycheck");
                    if (profile.$focusDelayFun) ood.clearTimeout(profile.$focusDelayFun);
                    if (profile.$focusDelayFun2) ood.clearTimeout(profile.$focusDelayFun2);
                    if (profile.$focusDelayFun2) ood.clearTimeout(profile.$mouseupDelayFun);

                    var p = profile.properties, b = profile.box;
                    if (p.disabled || p.readonly) return false;
                    if (profile.onBlur) profile.boxing().onBlur(profile);

                    // allow destory control inonBlur event
                    if (profile.destroyed) return false;

                    profile.getSubNode('BOX').tagClass('-focus', false);
                    var value = ood.use(src).get(0).value;
                    if (profile.$Mask && profile.$Mask == value) {
                        value = "";
                    }
                    //onblur check it
                    if (p.$UIvalue == value)
                        profile.box._checkValid(profile, value);

                    profile.boxing()._setDirtyMark();
                    b._asyCheck(profile, false);
                }
            }
        },
        DataModel: {
            selectable: {
                ini: true,
                caption: ood.getResText("DataModel.selectable") || ""
            },
            expression: {
                ini: '',
                action: function () {
                },
                caption: ood.getResText("DataModel.expression") || ""
            },
            tipsErr: {
                ini: '',
                caption: ood.getResText("DataModel.errorTips") || ""
            },
            tipsOK: {
                ini: '',
                caption: ood.getResText("DataModel.successTips") || ""
            },

            dynCheck: {
                ini: false,
                caption: ood.getResText("DataModel.dynamicCheck") || ""
            },
            selectOnFocus: {
                ini: true,
                caption: ood.getResText("DataModel.selectOnFocus") || ""
            },
            placeholder: {
                ini: '',
                action: function (value) {
                    this.getSubNode('INPUT').attr('placeholder', value);
                },
                caption: ood.getResText("DataModel.placeholder") || ""
            },
            // label
            labelSize: {
                $spaceunit: 2,
                ini: '4',
                action: function (v) {
                    this.getSubNode('LABEL').css({display: v ? '' : 'none'});
                    ood.UI.$doResize(this, this.properties.width, this.properties.height, true);
                },
                caption: ood.getResText("DataModel.labelSize") || ""
            },
            labelPos: {
                ini: "left",
                listbox: ['none', 'left', 'top', 'right', 'bottom'],
                action: function (v) {
                    ood.UI.$doResize(this, this.properties.width, this.properties.height, true);
                },
                caption: ood.getResText("DataModel.labelPosition") || ""
            },
            labelGap: {
                $spaceunit: 2,
                ini: '4',
                action: function (v) {
                    ood.UI.$doResize(this, this.properties.width, this.properties.height, true);
                },
                caption: ood.getResText("DataModel.labelGap") || ""
            },
            labelCaption: {
                ini: "",
                action: function (v) {
                    v = (ood.isSet(v) ? v : "") + "";
                    this.getSubNode('LABEL').html(ood.adjustRes(v, true));
                },
                caption: ood.getResText("DataModel.labelCaption") || ""
            },
            labelHAlign: {
                ini: 'right',
                listbox: ['', 'left', 'center', 'right'],
                action: function (v) {
                    this.getSubNode('LABEL').css({
                        'textAlign': v || '',
                        'justifyContent': v == 'right' ? 'flex-end' : v == 'center' ? 'center' : v == 'left' ? 'flex-start' : ''
                    });
                },
                caption: ood.getResText("DataModel.labelHAlign") || ""
            },
            labelVAlign: {
                ini: 'top',
                listbox: ['', 'top', 'middle', 'bottom'],
                action: function (v) {
                    this.getSubNode('LABEL').css('align-items', v == 'bottom' ? 'flex-end' : v == 'middle' ? 'center' : v == 'top' ? 'flex-start' : '');
                },
                caption: ood.getResText("DataModel.labelVAlign") || ""
            },
            valueFormat: {
                helpinput: [


                    {caption:'phone',id:"^1[3456789]\\d{9}$"},
                    {caption:'numpassword',id:"^\\d{6}$"},
                    {caption: 'required', id: "[^.*]"},
                    {caption: 'email', id: "^[\\w\\.=-]+@[\\w\\.-]+\\.[\\w\\.-]{2,4}$"},
                    {caption: 'charOnly', id: "^[a-zA-Z]*$"},
                    {caption: 'words', id: "^[\\w ]*$"},
                    {caption: 'size', id: "^(([1-9]\d*\.\d+)|([1-9]\d*)|(\.\d\d*))\s*(px|em)?$"},
                    {caption: 'integer', id: "^-?\\d\\d*$"},
                    {caption: 'positiveInteger', id: "^\\d\\d*$"},
                    {caption: 'number', id: "^-?(\\d\\d*\\.\\d*$)|(^-?\\d\\d*$)|(^-?\\.\\d\\d*$)"},
                    {caption: 'filepath', id: "([\\/]?[\\w_]+)+\\.\\w{1,9}$"},
                    {
                        caption: 'URL',
                        id: "^(http|https|ftp)\\:\\/\\/[\\w\\-\\_\\.]+[\\w\\-\\_](:[\\w]*)?\\/?([\\w\\-\\._\\?\\,\\'\\/\\\\\\+&amp;%\\$#\\=~])*$"
                    },
                    {caption: 'color', id: "^\\#[0-9A-Fa-f]{6}$"},
                    {caption: "HH:MM", id: "^\(\([0-1][0-9]\)|\([2][0-3])\)\:\([0-5][0-9]\)$"},
                    {caption: "HH:MM:SS", id: "^\(\([0-1][0-9]\)|\([2][0-3])\)\:\([0-5][0-9]\)\\:\([0-5][0-9]\)$"},
                    {caption: "YYYY-MM-DD", id: "^\([0-9]{4}\)\\-\(\([0][0-9]\)|\([1][0-2]\)\)\\-\([0-3][0-9]\)$"},
                    {
                        caption: "DD/MM/YYYY",
                        id: "^\(\([0-2][0-9]\)|\([3][0-1]\)\)\/\(\([0][0-9]\)|\([1][0-2]\)\)\/\([0-9]{4}\)$"
                    }
                ]
            },
            mask: {
                action: function (value) {
                    var ns = this,
                        b = ns.box;
                    if (value) {
                        ns.$MaskFormat = function (ns, v) {
                            var m = ns._maskMap, a = [], r = /[A-Za-z0-9]/;
                            ood.arr.each(v.split(''), function (o, i) {
                                a.push(m[o] || (r.test(o) ? "" : "\\") + o)
                            });
                            return '^' + a.join('') + '$';
                        }(b, value);
                        ns.$Mask = function (ns, v) {
                            var m = ns._maskMap, a = [], s = ns._maskSpace;
                            ood.arr.each(v.split(''), function (o, i) {
                                a.push(m[o] ? s : o);
                            });
                            return a.join('');
                        }(b, value);
                        var uiv = ns.properties.$UIvalue;
                        uiv = ood.isSet(uiv) ? (uiv + "") : "";
                        //visibility mask string
                        ns.boxing()._setCtrlValue(uiv + ns.$Mask.slice(uiv.length));
                    } else {
                        delete ns.$MaskFormat;
                        delete ns.$Mask;
                    }
                }
            },
            value: '',
            width: {
                $spaceunit: 1,
                ini: '10em',
                caption: ood.getResText("DataModel.width") || ""
            },
            height: {
                $spaceunit: 1,
                ini: '1.5em',
                caption: ood.getResText("DataModel.height") || ""
            },
            hAlign: {
                ini: '',
                listbox: ['', 'left', 'center', 'right'],
                action: function (v) {
                    this.getSubNode("INPUT").css('textAlign', v);
                },
                caption: ood.getResText("DataModel.hAlign") || ""
            },
            disabled: {
                ini: false,
                action: function (v) {
                    this.box._handleInput(this, "ui-disabled", v);
                },
                caption: ood.getResText("DataModel.disabled") || ""
            },

            hiddenBorder:{
                ini: false,
                action: function (v) {
                    var o = this.getSubNode('BOX');
                    if (v)
                        o.css('border', '');
                    else
                        o.css('border', '0px');

                },
                caption: ood.getResText("DataModel.hiddenBorder") || ""
            },

            readonly: {
                ini: false,
                action: function (v) {
                    this.box._handleInput(this, "ui-readonly", v);
                },
                caption: ood.getResText("DataModel.readonly") || ""
            },
            texttype: {
                ini: 'text',
                listbox: ['text', 'password'],
                set: function (value) {
                    var pro = this;
                    pro.properties.texttype = value;
                    if (pro.renderId)
                        pro.boxing().refresh(true);
                },
                caption: ood.getResText("DataModel.texttype") || ""
            },
            maxlength: {
                ini: -1,
                action: function (value) {
                    this.getSubNode('INPUT').attr('maxlength', value);
                },
                caption: ood.getResText("DataModel.maxlength") || ""
            },



            multiLines: {
                ini: false,
                action: function (value) {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.multiLines") || ""
            },
            autoexpand: {
                $spaceunit: 1,
                ini: "",
                action: function (v) {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.autoexpand") || ""
            },
            tipsBinder: {
                ini: '',
                set: function (value) {
                    if (value['ood.UIProfile'])
                        value = value.$xid;
                    if (value['ood.UI'] && (value = value.get(0)))
                        value = value.$xid;
                    this.properties.tipsBinder = value + '';
                },
                caption: ood.getResText("DataModel.tipsBinder") || ""
            },
            excelCellId: {
                ini: "",
                action: function () {
                    this.boxing().notifyExcel(false);
                },
                caption: ood.getResText("DataModel.excelCellId") || "ExcelID"
            },
            excelCellFormula: {
                ini: "",
                action: function (v) {
                    var prf = this, m,
                        prop = prf.properties;
                    if (v && ood.ExcelFormula.validate(v)) {
                        if (prf.host && (m = prf.host['ood.Module'])) {
                            m.applyExcelFormula(prf);
                        }
                    }
                },
                caption: ood.getResText("DataModel.excelCellFormula") || "Excel"
            }
        },
        EventHandlers: {
            beforeFocus: function (profile) {
            },
            onFocus: function (profile) {
            },
            onBlur: function (profile) {
            },
            onCancel: function (profile) {
            },
            beforeFormatCheck: function (profile, value) {
            },
            beforeFormatMark: function (profile, formatErr) {
            },
            beforeKeypress: function (profile, caret, keyboard, e, src) {
            },

            onLabelClick: function (profile, e, src) {
            },
            onLabelDblClick: function (profile, e, src) {
            },
            onLabelActive: function (profile, e, src) {
            },

            onGetExcelCellValue: function (profile, excelCellId, dftValue) {
            },
            beforeApplyExcelFormula: function (profile, excelCellFormula, value) {
            },
            afterApplyExcelFormula: function (profile, excelCellFormula, value) {
            },

            onAutoexpand: function (profile, height, offset) {
            }
        },
        _checkAutoexpand: function (profile) {
            var prop = profile.properties, autoe = profile._autoexpand || prop.autoexpand;
            if (profile.renderId && parseFloat(autoe)) {
                ood.resetRun(profile.key + ":" + profile.$xid + ":autoexpand", function () {
                    if (profile.renderId && !profile.destroyed) {
                        var root = profile.getRoot(),
                            min = profile.$px(autoe),
                            t = profile.getSubNode('INPUT'),
                            rh = root.height(),
                            th1, th2, oth, offset;
                        //get offset
                        {
                            oth = t.get(0).style.height;
                            th1 = t.height();
                            ph = t._paddingH();
                            th2 = t.scrollHeight();
                            min -= rh - th1;
                            t.height(min + "px");
                            min = Math.max(min, t.scrollHeight() - ph);
                            offset = parseInt(min - th1, 10);
                            t.get(0).style.height = oth;
                        }
                        if (offset) {
                            var toH = profile.$autoExpandH = rh + offset;
                            if (!(profile.$beforeAutoexpand && false === profile.$beforeAutoexpand(profile, toH, offset))) {
                                profile.boxing().setHeight(toH);
                                if (profile.$onAutoexpand)
                                    toH = profile.$onAutoexpand(profile, toH, offset);
                                if (profile.onAutoexpand) profile.boxing().onAutoexpand(profile, toH, offset);
                            }
                        }
                    }
                });
            }
        },
        _handleInput: function (prf, cls, v) {
            var i = prf.getSubNode('INPUT');
            if (("" + i.get(0).type).toLowerCase() != 'button') {
                if (!v && (prf.properties.disabled || prf.properties.readonly))
                    v = true;
                prf.getRoot()[v ? 'addClass' : 'removeClass'](cls);
                i.attr('readonly', v);
            }
        },
        _prepareData: function (profile) {
            var data = {}, prop = profile.properties, t, v;

            if (prop.height == 'auto') {
                data.height = '1.83em';
            }
            data._inputcls = parseFloat(profile._autoexpand || prop.autoexpand) ? 'autoexpand' : '';

            var d = arguments.callee.upper.call(this, profile, data);

            d._inputtype = d.texttype || '';
            if (d.maxlength < 0) d.maxlength = "";

            if (ood.browser.kde)
                d._css = 'resize:none;';

            d.hAlign = (v = d.hAlign) ? ("text-align:" + v) : "";

            d._hiddenBorder=prop.hiddenBorder ? "border:0px" : "";
            data._labelHAlign = 'text-align:' + (v = data.labelHAlign || '') + ';justify-content:' + (v == 'right' ? 'flex-end' : v == 'center' ? 'center' : v == 'left' ? 'flex-start' : '');
            data._labelVAlign = 'align-items:' + ((v = data.labelVAlign) == 'bottom' ? 'flex-end' : v == 'middle' ? 'center' : v == 'top' ? 'flex-start' : '');

            d.labelShow = d.labelPos != 'none' && d.labelSize && d.labelSize != 'auto' ? "" : "display:none";
            d._labelSize = d.labelSize ? '' : 0 + profile.$picku();

            // adjustRes for labelCaption
            if (v = d.labelCaption)
                d.labelCaption = ood.adjustRes(v, true);

            return d;
        },
        _dynamicTemplate: function (profile) {
            var prop = profile.properties, t,
                hash = profile._exhash = "$" + 'multiLines:' + prop.multiLines,
                template = profile.box.getTemplate(hash);

            prop.$UIvalue = prop.value;

            // set template dynamic
            if (!template) {
                template = ood.clone(profile.box.getTemplate());
                if (prop.multiLines) {
                    t = template.FRAME.BORDER.BOX.WRAP.INPUT;
                    t.tagName = 'textarea';
                    delete t.type;
                }

                // set template
                profile.box.setTemplate(template, hash);
            }
            profile.template = template;
        },
        _ensureValue: function (profile, value) {
            // ensure return string
            return "" + (ood.isSet(value) ? value : "");
        },
        RenderTrigger: function () {
            var ns = this, p = ns.properties;
            ood.asyRun(function () {
                if (ns.box)
                    ns.boxing()._setTB(1);
            });
            ns.getSubNode('WRAP').$firfox2();
            if (p.readonly)
                ns.boxing().setReadonly(true, true);
            if (p.tipsBinder)
                ns.boxing().setTipsBinder(p.tipsBinder, true);
            if (p.excelCellId)
                ns.boxing().notifyExcel();
            //add event for cut/paste text
            var ie = ood.browser.ie,
                src = ns.getSubNode('INPUT').get(0),
                b = ns.box,
                f = function (o) {
                    if (ie && ('propertyName' in o) && o.propertyName != 'value') return;
                    b._asyCheck(ns, false);
                };
            if (ie && src.attachEvent) {
                src.attachEvent("onpropertychange", f);
                src.attachEvent("ondrop", f);
                ns.$ondestory = function () {
                    var src = this.getSubNode('INPUT').get(0);
                    if (src) {
                        src.detachEvent("onpropertychange", f);
                        src.detachEvent("ondrop", f);
                    }
                    src = f = null;
                }
            } else {
                src.addEventListener("input", f, false);
                src.addEventListener("drop", f, false);
                //Firefox earlier than version 3.5
                if (ood.browser.gek)
                    src.addEventListener("dragdrop", f, false);

                ns.$ondestory = function () {
                    var src = this.getSubNode('INPUT').get(0);
                    if (src) {
                        src.removeEventListener("input", f, false);
                        src.removeEventListener("drop", f, false);
                        if (ood.browser.gek)
                            src.removeEventListener("dragdrop", f, false);
                    }
                    src = f = null;
                }
            }
            src = null;

        },
        LayoutTrigger: function () {
            var p = this.properties;
            if (p.mask) this.boxing().setMask(p.mask, true);
        },
        //v=value.substr(0,caret);
        //i=v.lastIndexOf(ms);

        _changeMask: function (profile, src, v, dir, resetCaret) {
            if (false !== resetCaret) {
                var ns = this,
                    p = profile.properties,
                    map = ns._maskMap,
                    ms = ns._maskSpace,
                    maskTxt = p.mask,
                    maskStr = profile.$Mask,
                    input = ood(src),
                    caret = input.caret();
                //for backspace
                if (dir === false && caret[0] == caret[1] && caret[0] > 0)
                    input.caret(caret[0] - 1, caret[0]);

                //for delete
                if (dir === undefined && caret[0] == caret[1])
                    input.caret(caret[0], caret[0] + 1);

                //for caret is from a fix char, nav to the next 'input allow' char
                if (dir === true) {
                    if (maskStr.charAt(caret[0]) != ms) {
                        var from = caret[0] + maskStr.substr(caret[0], maskStr.length).indexOf(ms);
                        input.caret(from, Math.max(caret[1], from))
                    }
                }

                var caret = input.caret(),
                    value = src.value,
                    cc = p.mask.charAt(caret[0]),
                    reg = ns._maskMap[cc],
                    i, t;

                if (reg && v && v.length == 1) {
                    if (cc == 'l')
                        v = v.toLowerCase();
                    else if (cc == 'u')
                        v = v.toUpperCase();
                }

                if (reg && new RegExp('^' + reg + '$').test(v) || v == '') {
                    t = value;
                    //if select some text
                    if (caret[0] != caret[1])
                        t = t.substr(0, caret[0]) + maskStr.substr(caret[0], caret[1] - caret[0]) + t.substr(caret[1], t.length - caret[1]);
                    //if any char input
                    if (v)
                        t = t.substr(0, caret[0]) + v + t.substr(caret[0] + 1, t.length - caret[0] - 1);

                    //get corret string according to maskTxt
                    var a = [];
                    ood.arr.each(maskTxt.split(''), function (o, i) {
                        a.push(map[o] ? (((new RegExp('^' + map[o] + '$')).test(t.charAt(i))) ? t.charAt(i) : maskStr.charAt(i)) : maskStr.charAt(i))
                    });

                    //if input visible char
                    if (dir === true) {
                        v = maskStr.substr(caret[0] + 1, value.length - caret[0] - 1);
                        i = v.indexOf(ms);
                        i = caret[0] + (i == -1 ? 0 : i) + 1;
                    } else
                        i = caret[0];
                    //in opera, delete/backspace cant be stopbubbled
                    //add a dummy maskSpace
                    if (ood.browser.opr) {
                        //delete
                        if (dir === undefined)
                            ood.arr.insertAny(a, ms, i);
                        //backspace
                        if (dir === false)
                            ood.arr.insertAny(a, ms, i++);
                    }
                    value = a.join('');
                    src.value = value;
                    // maybe cant fire _setCtrlValue
                    profile.boxing().setUIValue(value == maskStr ? "" : value, null, null, 'mask');
                    ns._setCaret(profile, src, i);
                }
            } else {
                var ns = this,
                    p = profile.properties,
                    map = ns._maskMap,
                    maskTxt = p.mask,
                    maskStr = profile.$Mask,
                    t = src.value,
                    a = [];
                //get corret string according to maskTxt
                ood.arr.each(maskTxt.split(''), function (o, i) {
                    a.push((new RegExp('^' + (map[o] ? map[o] : '\\' + o) + '$').test(t.charAt(i))) ? t.charAt(i) : maskStr.charAt(i))
                });
                value = a.join('');
                src.value = value;
                // maybe cant fire _setCtrlValue
                profile.boxing().setUIValue(value == maskStr ? "" : value, null, null, 'mask');
            }

        },
        _setCaret: function (profile, src, pos) {
            if (profile.properties.mask) {
                if (typeof pos != 'number')
                    pos = src.value.indexOf(this._maskSpace);
                ood(src).caret(pos, pos);
            }
        },
        // for checking html <input>
        _checkValid2: function (profile) {
            if (!profile.renderId) return true;
            return this._checkValid(profile, profile.getSubNode('INPUT').get(0).value);
        },
        //check valid manually
        _checkValid: function (profile, value) {
            var p = profile.properties,
                vf1 = (p.mask && profile.$MaskFormat),
                vf2 = p.valueFormat || profile.$valueFormat;

            if (profile.boxing()._toEditor) value = profile.boxing()._toEditor(value);

            var input = profile.getSubNode("INPUT"),
                src = input.get(0);
            if (src && profile.properties.required) {
                v = src.value;
                if (profile.keys['LABEL']) {
                    var node = profile.getSubNode('LABEL');
                    if (!v) node.addClass('required');
                    else node.removeClass('required');
                }
                if (!v) profile.getRoot().addClass('required-field');
                else profile.getRoot().removeClass('required-field');
            }


            if ((profile.beforeFormatCheck && (profile.boxing().beforeFormatCheck(profile, value) === false)) ||
                // if inputs, check mask valid, or don't
                (((value && value.length) && profile.$Mask !== value) && (vf1 && typeof vf1 == 'string' && !(new RegExp(vf1)).test((value === 0 ? '0' : value) || ''))) ||
                (vf2 && typeof vf2 == 'string' && !(new RegExp(vf2)).test((value === 0 ? '0' : value) || ''))
            ) {
                profile._inValid = 2;
                return false;
            }
            {
                profile._inValid = 3;
                return true;
            }
        },
        _asyCheck: function (profile, resetCaret) {
            if (profile.destroyed) return;
            if (!profile.properties.dynCheck && !profile.properties.mask) return;

            ood.resetRun(profile.$xid + ":asycheck", function () {
                if (!profile.renderId) return;

                var input = profile.getSubNode("INPUT"),
                    src = input.get(0);
                if (!src) return;

                if (profile.properties.required) {
                    v = src.value;
                    if (profile.keys['LABEL']) {
                        var node = profile.getSubNode('LABEL');
                        if (!v) node.addClass('required');
                        else node.removeClass('required');
                    }
                    if (!v) profile.getRoot().addClass('required-field');
                    else profile.getRoot().removeClass('required-field');
                }

                //for mask
                if (profile.properties.mask) {
                    if (src.value.length != profile.$Mask.length)
                        profile.box._changeMask(profile, src, '', true, resetCaret);
                }

                //for onchange event
                if (profile.properties.dynCheck) {
                    var v = src.value;
                    if (profile.$Mask && profile.$Mask == v) {
                        v = "";
                    }
                    // dont trigger _setContrlValue
                    profile.boxing().setUIValue(v, false, true, 'asycheck');
                }
            });
        },
        _onresize: function (profile, width, height) {
            if (profile._$ignoreonsize) return;

            var prop = profile.properties,
                // if any node use other font-size which does not equal to node, use 'px' 
                f = function (k) {
                    if (!k) return null;
                    k = profile.getSubNode(k);
                    return k;
                },
                root = f('KEY'),
                v1 = f('INPUT'),
                box = f('BOX'),
                label = f('LABEL'),

                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },

                fzrate = profile.getEmSize() / root._getEmSize(),
                v1fz = v1._getEmSize(fzrate),
                labelfz = label._getEmSize(fzrate),

                $hborder, $vborder,

                clsname = 'node input-input',
                cb = ood.browser.contentBox,
                paddingH = !cb ? 0 : Math.round(v1._paddingH() / 2) * 2,
                paddingW = !cb ? 0 : Math.round(v1._paddingW() / 2) * 2,
                autoH,
                boxB = box._borderW();

            $hborder = $vborder = !cb ? 0 : boxB / 2;

            // calculate by px
            if (height) height = (autoH = height == 'auto') ? profile.$em2px(!cb ? 1.6666667 : 1, null, true) + paddingH + boxB : profile.$isEm(height) ? profile.$em2px(height, null, true) : height;
            if (width) width = profile.$isEm(width) ? profile.$em2px(width, null, true) : width;

            // for auto height
            if (autoH) {
                profile._$ignoreonsize = 1;
                root.height(adjustunit(height));
                delete profile._$ignoreonsize;
            }

            var labelPos = prop.labelPos,
                labelSize = (labelPos == 'none' || !labelPos) ? 0 : profile.$px(prop.labelSize, labelfz) || 0,
                labelGap = (labelPos == 'none' || !labelPos) ? 0 : profile.$px(prop.labelGap) || 0,

                ww = width,
                hh = height,
                left = Math.max(0, (prop.$b_lw || 0) - $hborder),
                top = Math.max(0, (prop.$b_tw || 0) - $vborder);
            if (null !== ww) {
                ww -= Math.max($hborder * 2, (prop.$b_lw || 0) + (prop.$b_rw || 0));
                /*for ie6 bug*/
                /*for example, if single number, 100% width will add 1*/
                /*for example, if single number, attached shadow will overlap*/
                if (ood.browser.ie6) ww = (Math.round(parseFloat(ww / 2))) * 2;
            }
            if (null !== hh) {
                hh -= Math.max($vborder * 2, (prop.$b_lw || 0) + (prop.$b_rw || 0));

                if (ood.browser.ie6) hh = (Math.round(parseFloat(hh / 2))) * 2;
                /*for ie6 bug*/
                if (ood.browser.ie6 && null === width) box.ieRemedy();
            }
            var iL = left + (labelPos == 'left' ? labelSize : 0),
                iT = top + (labelPos == 'top' ? labelSize : 0),
                iW = ww === null ? null : Math.max(0, ww - ((labelPos == 'left' || labelPos == 'right') ? labelSize : 0)),
                iH = hh === null ? null : Math.max(0, hh - ((labelPos == 'top' || labelPos == 'bottom') ? labelSize : 0)),
                iH2 = hh === null ? null : Math.max(0, height - ((labelPos == 'top' || labelPos == 'bottom') ? labelSize : 0));

            if (null !== iW && iW - paddingW > 0)
                v1.width(adjustunit(Math.max(0, iW - paddingW), v1fz));
            if (null !== iH && iH - paddingH > 0)
                v1.height(adjustunit(Math.max(0, iH - paddingH), v1fz));

            box.cssRegion({
                left: adjustunit(iL),
                top: adjustunit(iT),
                width: adjustunit(iW),
                height: adjustunit(iH)
            });

            if (labelSize)
                label.cssRegion({
                    left: adjustunit(ww === null ? null : labelPos == 'right' ? (ww - labelSize + labelGap + $hborder * 2) : 0, labelfz),
                    top: adjustunit(height === null ? null : labelPos == 'bottom' ? (height - labelSize + labelGap) : 0, labelfz),
                    width: adjustunit(ww === null ? null : Math.max(0, ((labelPos == 'left' || labelPos == 'right') ? (labelSize - labelGap) : ww)), labelfz),
                    height: adjustunit(height === null ? null : Math.max(0, ((labelPos == 'top' || labelPos == 'bottom') ? (labelSize - labelGap) : height) - paddingH), labelfz)
                });

            iL += (iW || 0) + $hborder * 2;

            /*for ie6 bug*/
            if ((profile.$resizer) && ood.browser.ie) {
                box.ieRemedy();
            }
        }
    }
});
ood.Class("ood.UI.CheckBox", ["ood.UI","ood.absValue"],{

    Initialize:function(){

        // compitable
        ood.UI.SCheckBox = ood.UI.CheckBox;
        var key="ood.UI.SCheckBox";
        ood.absBox.$type[key.replace("ood.UI.","")]=ood.absBox.$type[key]=key;
    },
    Instance:{
        iniProp: {
            caption: 'ri ri-checkbox-line',
            value: true
        },
        fireClickEvent:function(){
            this.getRoot().onClick();
            return this;
        },
        activate:function(){
            this.getSubNode('FOCUS').focus(true);
            return this;
        },
        _setCtrlValue:function(value){
            return this.each(function(profile){
               profile.getSubNode('MARK').tagClass('-checked', !!value);
            });
        },
        //update UI face
        _setDirtyMark:function(){
            return arguments.callee.upper.apply(this,['CAPTION']);
        },
        notifyExcel:ood.UI.Input.prototype.notifyExcel,
        // get control's fake cexcel cell value
        getExcelCellValue:ood.UI.Input.prototype.getExcelCellValue,
        
        // 
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();
                root.attr('data-theme', theme);
                
                // 
                localStorage.setItem('checkbox-theme', theme);
            });
        },
        
        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('checkbox-theme') || 'light';
        },



        CheckBoxTrigger: function() {
            var profile = this.get(0);
            var prop = profile.properties,
                boxing = this;

            // 
            // 
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('checkbox-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                boxing.adjustLayout();
            }

            // 
            boxing.enhanceAccessibility();
        },

        // 
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        
        // 
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width;

                // 
                if (width < 768) {
                    root.addClass('checkbox-mobile');
                } else {
                    root.removeClass('checkbox-mobile');
                }

                // 
                if (width < 480) {
                    root.addClass('checkbox-tiny');
                } else {
                    root.removeClass('checkbox-tiny');
                }
            });
        },
        
        // 
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var focus = profile.getSubNode('FOCUS'),
                    mark = profile.getSubNode('MARK'),
                    caption = profile.getSubNode('CAPTION'),
                    properties = profile.properties;

                // ARIA
                focus.attr({
                    'role': 'checkbox',
                    'aria-checked': properties.value ? 'true' : 'false',
                    'aria-label': properties.caption || ood.getRes('UI.checkbox.default'),
                    'aria-describedby': properties.tips ? profile.serialId + '_tips' : null,
                    'aria-disabled': properties.disabled ? 'true' : 'false',
                    'aria-live': 'polite'
                });
                
                // ARIA
                mark.attr({
                    'aria-hidden': 'true' // 
                });

                // 
                if (caption && !caption.isEmpty()) {
                    caption.attr({
                        'id': profile.serialId + '_label'
                    });
                    focus.attr('aria-labelledby', profile.serialId + '_label');
                }

                // 
                focus.on('keydown', function(e) {
                    var key = e.keyCode;
                    // 
                    if (key === 32) {
                        e.preventDefault();
                        profile.getRoot().onClick();
                    }
                });
            });
        }
    },
    Static:{
        Templates:{
            className:'{_className} ',
            style:'{_style} {_hAlign}',
            VALIGN:{
                $order:0,
                style:'{_vAlign}'
            },
            FOCUS:{
                tabindex: '{tabindex}',
                MARK:{
                    $order:0,
                    className:'{_iconPosCls} oodfont',
                    $fonticon:'ood-uicmd-check'
                },
                ICON:{
                    $order:1,
                    className:'oodcon {imageClass}  {picClass}',
                    style:'{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{imageDisplay}{iconStyle}',
                    text:'{iconFontCode}' 
                },
                CAPTION:{
                    $order:2,
                    text:'{caption}'
                }
            }
        },
        Appearances:{
            KEY:{
                className: 'ood-checkbox'
            },
            MARK:{
                className: 'ood-checkbox-mark'
            },
            VALIGN: {
                className: 'ood-checkbox-valign'
            },
            FOCUS:{
                className: 'ood-checkbox-focus'
            },
            CAPTION:{
                className: 'ood-checkbox-caption'
            },
            
            // 
            'checkbox-mobile MARK': {
                className: 'checkbox-mobile .ood-checkbox-mark'
            },
            'checkbox-mobile CAPTION': {
                className: 'checkbox-mobile .ood-checkbox-caption'
            },
            'checkbox-tiny ICON': {
                className: 'checkbox-tiny .ood-checkbox-icon'
            },
            'checkbox-tiny CAPTION': {
                className: 'checkbox-tiny .ood-checkbox-caption'
            }
        },
        Behaviors:{
            HoverEffected:{KEY:'MARK',ICON:'ICON'},
            ClickEffected:{KEY:'MARK'},
            NavKeys:{FOCUS:1},
            onClick:function(profile, e, src){
                var p=profile.properties,b=profile.boxing();
                if(p.disabled)return false;
                if(p.readonly)return false;
                b.setUIValue(!p.$UIvalue,null,null,'click');
                if(profile.onChecked)b.onChecked(profile, e, p.$UIvalue);
                profile.getSubNode('FOCUS').focus(true);
            },
            FOCUS:{
                onKeydown:function(profile, e, src){
                    var key = ood.Event.getKey(e).key;
                    if(key ==' ' || key=='enter'){
                        profile.getRoot().onClick(true);
                        return false;
                    }
                }
            }
        },
        DataModel:{
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark', 'high-contrast'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            value:false,
            expression:{
                ini:'',
                action:function () {
                }
            },
            hAlign:{
                ini:'left',
                listbox:['left','center','right'],
                action: function(v){
                    this.getRoot().css('textAlign',v);
                }
            },
            vAlign:{
                ini:'top',
                listbox:['top','middle','bottom'],
                action: function(v){
                    this.getSubNode('VALIGN').css('verticalAlign', v||'');
                }
            },
            iconPos:{
                ini:'left',
                listbox:['left','right'],
                action:function(v){
                    this.getSubNode("MARK").removeClass('ood-float-left ood-float-right').addClass('ood-float-'+v);
                }
            },
            image:{
                format:'image',
                action: function(v){
                    ood.UI.$iconAction(this);
                }
            },
            imagePos:{
                action: function(value){
                    this.getSubNode('ICON').css('backgroundPosition', value||'center');
                }
            },
            imageBgSize:{
                action: function(value){
                    this.getSubNode('ICON').css('backgroundSize', value||'');
                }
            },
            imageClass: {
                ini:'',
                action:function(v,ov){
                    ood.UI.$iconAction(this, 'ICON', ov);
                }
            },
            iconFontCode:{
                action:function(v){
                    ood.UI.$iconAction(this);
                }
            },
            caption:{
                ini:undefined,
                action: function(v){
                    v=(ood.isSet(v)?v:"")+"";
                    this.getSubNode('CAPTION').html(ood.adjustRes(v,true));
                }
            },
            excelCellId:{
                ini:"",
                action:function(){
                    this.boxing().notifyExcel(false);
                }
            }
        },
        EventHandlers:{
            onChecked:function(profile, e, value){},
            onGetExcelCellValue:function(profile, excelCellId, dftValue){}
        },
        RenderTrigger:function(){
            var ns=this,p=ns.properties;
            if(p.excelCellId)
                ns.boxing().notifyExcel();
                
            // 
            var self = this;
            ood.asyRun(function(){
                self.boxing().CheckBoxTrigger();
            });
        },

        _prepareData:function(profile){
            var data=arguments.callee.upper.call(this, profile);
            data._hAlign = 'text-align:'+data.hAlign+';';
            data._vAlign = 'vertical-align:'+(data.vAlign||'');
            data._iconPosCls = 'ood-float-'+data.iconPos;
            return data;
        },
        _ensureValue:function(profile, value){
            return value==="0"?false:!!value;
        }
    }
});
ood.Class("ood.UI.HiddenInput", ["ood.UI.Widget","ood.absValue"] ,{
    Instance:{
        activate:function(){
            return this;
        }

    },


    Static:{
      //  $initRootHidden:true,
        Templates:{
            className:'ood-display-none',
            style:'display:none',
            tagName:'input',
            type:'hidden'
        },
        DataModel:{
            expression:null,
            locked:null,
            required:null,
            dataBinder:null,
            dataField:null,
            display:null,
            visibility:null,
            position:null,
            left:null,
            top:null,
            right:null,
            bottom:null,
            width:null,
            height:null,
            rotate:null,
            showEffects:null,
            hideEffects:null,
            activeAnim:null,
            tabindex:null,
            zIndex:null,
            defaultFocus:null,
            hoverPop:null,
            hoverPopType:null,
            disabled:null,
            readonly:null,
            disableClickEffect:null,
            disableHoverEffect:null,
            dock:null,
            dockOrder:null,
            dockMargin:null,
            dockMinW:null,
            dockMinH:null,
            dockMaxW:null,
            dockMaxH:null,
            dockFloat:null,
            dockIgnore:null,
            dirtyMark:null,
            showDirtyMark:null,
            selectable:null,
            autoTips:null,
            tips:null,
            disableTips:null,
            renderer:null,
            className:null
        },
        EventHandlers:{
            beforeDirtyMark:null,
            onContextmenu:null,
            onDock:null,
            onLayout:null,
            onMove:null,
            onRender:null,
            onResize:null,
            onShowTips:null,
            beforeAppend:null,
            afterAppend:null,
            beforeRender:null,
            afterRender:null,
            beforeRemove:null,
            afterRemove:null,
            onHotKeydown:null,
            onHotKeypress:null,
            onHotKeyup:null
        },
        setUIValue:function(value, force, triggerEventOnly, tag){
            var upper=arguments.callee.upper,
                v = upper.apply(this,ood.toArr(arguments));
        },
        getUIValue:function(){
            var upper=arguments.callee.upper,
                v = upper.apply(this,ood.toArr(arguments));
            upper=null;
            return v;
        },
        _ensureValue:function(profile, value){
            // ensure return string
            return ""+(ood.isSet(value)?value:"");
        }
    }
});ood.Class("ood.UI.RichEditor", ["ood.UI", "ood.absValue"], {
    Initialize: function () {
        this.addTemplateKeys(['TOOLBARBTN']);
    },
    Instance: {
        iniProp: {
            labelSize: '2em', height: '26em', labelPos: 'top', caption: '$RAD.widgets.richText', labelHAlign: 'left'
        },
        activate: function () {
            this.getEditorWin().focus();
            return this;
        },
        getEditorWin: function () {
            return this.get(0).$win;
        },
        getEditorDoc: function () {
            return this.get(0).$doc;
        },
        getEditorBody: function () {
            var doc = this.get(0).$doc;
            return doc && (doc.body || doc.documentElement);
        },
        _setCtrlValue: function (value) {
            if (!ood.isSet(value)) value = '';
            return this.each(function (profile) {
                var sp = window['/'];
                if (sp && sp.indexOf(':/') != -1)
                    value = value.replace(/{\/}/g, sp);
                var html = profile.$useOriginalText ? value : ood.adjustRes(value, 0, 1);
                if (!profile.$inDesign) {
                    var doc = profile.$doc, body = doc && (doc.body || doc.documentElement);
                    if (body) {
                        body.innerHTML = html;
                        return;
                    }
                }
                profile.getSubNode("EDITOR").html(html);
            });
        },
        _getCtrlValue: function () {
            var profile = this.get(0);
            if (!profile.$inDesign) {
                var doc = profile.$doc,
                    body = doc && (doc.body || doc.documentElement);
                if (body) {
                    var v = body.innerHTML;
                    if (this.getTextType() == 'text') {
                        v = body.innerText;
                    }
                    ;
                    sp = window['/'];
                    if (sp && sp.indexOf(':/') != -1)
                        v = v.replace(new RegExp(sp, 'g'), '{/}');
                    return v;
                } else
                    return '';
            } else {
                return profile.getSubNode("EDITOR").text();
            }
        },
        
        // 
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot(),
                    toolbar = profile.getSubNode('TOOLBAR'),
                    editor = profile.getSubNode('EDITOR'),
                    toolbarBtns = profile.getSubNode('TOOLBARBTN', true);

                if (theme === 'dark') {
                    // 
                    root.addClass('richeditor-dark');
                    
                    // 
                    if (toolbar && !toolbar.isEmpty()) {
                        toolbar.css({
                            'background': 'var(--ood-dark-gradient)',
                            'border-color': 'var(--ood-dark-border)',
                            'color': 'var(--ood-dark-text)'
                        });
                    }
                    
                    // 
                    editor.css({
                        'background-color': 'var(--ood-dark-bg)',
                        'border-color': 'var(--ood-dark-border)',
                        'color': 'var(--ood-dark-text)'
                    });
                    
                    // 
                    if (toolbarBtns && toolbarBtns.length > 0) {
                        toolbarBtns.css({
                            'background-color': 'var(--ood-dark-bg-secondary)',
                            'border-color': 'var(--ood-dark-border)',
                            'color': 'var(--ood-dark-text)'
                        });
                    }
                    
                    // iframe
                    var editorDoc = profile.$doc;
                    if (editorDoc && editorDoc.body) {
                        ood(editorDoc.body).css({
                            'background-color': 'var(--ood-dark-bg)',
                            'color': 'var(--ood-dark-text)',
                            'font-family': '"Segoe UI", Tahoma, Arial, sans-serif'
                        });
                    }
                } else {
                    // 
                    root.removeClass('richeditor-dark');
                    
                    // 
                    if (toolbar && !toolbar.isEmpty()) {
                        toolbar.css({
                            'background': '',
                            'border-color': '',
                            'color': ''
                        });
                    }
                    
                    editor.css({
                        'background-color': '',
                        'border-color': '',
                        'color': ''
                    });
                    
                    if (toolbarBtns && toolbarBtns.length > 0) {
                        toolbarBtns.css({
                            'background-color': '',
                            'border-color': '',
                            'color': ''
                        });
                    }
                    
                    // iframe
                    var editorDoc = profile.$doc;
                    if (editorDoc && editorDoc.body) {
                        ood(editorDoc.body).css({
                            'background-color': '',
                            'color': '',
                            'font-family': ''
                        });
                    }
                }
                
                // 
                localStorage.setItem('richeditor-theme', theme);
            });
        },


        RichEditorTrigger: function() {
            var profile = this.get(0);
            var prop = profile.properties;
            var boxing = this;

            // 
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('richeditor-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                boxing.adjustLayout();
            }

            // 
            boxing.enhanceAccessibility();
        },

        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('richeditor-theme') || 'light';
        },
        
        // 
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        
        // 
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    toolbar = profile.getSubNode('TOOLBAR'),
                    editor = profile.getSubNode('EDITOR'),
                    toolbarBtns = profile.getSubNode('TOOLBARBTN', true),
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('richeditor-mobile');
                    
                    // 
                    if (toolbarBtns && toolbarBtns.length > 0) {
                        toolbarBtns.css({
                            'min-width': '2.2em',
                            'min-height': '2.2em',
                            'font-size': '0.9em'
                        });
                    }
                    
                    // 
                    editor.css({
                        'min-height': '8em',
                        'font-size': '1em'
                    });
                } else {
                    root.removeClass('richeditor-mobile');
                    
                    // 
                    if (toolbarBtns && toolbarBtns.length > 0) {
                        toolbarBtns.css({
                            'min-width': '',
                            'min-height': '',
                            'font-size': ''
                        });
                    }
                    
                    editor.css({
                        'min-height': '',
                        'font-size': ''
                    });
                }

                // 
                if (width < 480) {
                    root.addClass('richeditor-tiny');
                    
                    // 
                    if (toolbarBtns && toolbarBtns.length > 0) {
                        toolbarBtns.each(function(btn) {
                            var btnId = ood(btn).id();
                            if (btnId && (btnId.indexOf('fontname') > -1 || btnId.indexOf('fontsize') > -1)) {
                                ood(btn).css('display', 'none');
                            }
                        });
                    }
                } else {
                    root.removeClass('richeditor-tiny');
                    
                    // 
                    if (toolbarBtns && toolbarBtns.length > 0) {
                        toolbarBtns.css('display', '');
                    }
                }
            });
        },
        
        // 
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    toolbar = profile.getSubNode('TOOLBAR'),
                    editor = profile.getSubNode('EDITOR'),
                    toolbarBtns = profile.getSubNode('TOOLBARBTN', true),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'application',
                    'aria-label': ''
                });
                
                // ARIA
                if (toolbar && !toolbar.isEmpty()) {
                    toolbar.attr({
                        'role': 'toolbar',
                        'aria-label': ''
                    });
                }
                
                // ARIA
                editor.attr({
                    'role': 'textbox',
                    'aria-multiline': 'true',
                    'aria-label': ''
                });
                
                // ARIA
                if (toolbarBtns && toolbarBtns.length > 0) {
                    toolbarBtns.each(function(btn) {
                        var btnElement = ood(btn),
                            btnId = btnElement.id(),
                            btnTitle = btnElement.attr('title') || '';
                        
                        btnElement.attr({
                            'role': 'button',
                            'aria-label': btnTitle,
                            'tabindex': properties.disabled ? '-1' : '0'
                        });
                    });
                }
                
                // iframe
                var editorDoc = profile.$doc;
                if (editorDoc && editorDoc.body) {
                    ood(editorDoc.body).attr({
                        'role': 'textbox',
                        'aria-multiline': 'true',
                        'aria-label': ''
                    });
                }
            });
        }
    },
    Static: {
        DIRYMARKICON: "DIRTYMARK",
        Templates: {
            tagName: 'div',
            style: '{_style}',
            className: '{_className} ood-ui-selectable',
            LABEL: {
                className: '{_required} ood-ui-ellipsis',
                style: '{labelShow};width:{_labelSize};{_labelHAlign};{_labelVAlign}',
                text: '{labelCaption}'
            },
            BOX: {
                EDITOR: {
                    tagName: 'div',

                    className: 'ood-uiborder-flat ood-uiborder-radius ood-uibase'
                },
                DIRTYMARK: {},
                POOL: {}
            }
        },
        DataModel: {
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            expression: {
                ini: '',
                action: function () {
                }
            },
            selectable: true,

            value: {
                ini: '',
                html: 1
            },
            width: {
                $spaceunit: 1,
                ini: '32em'
            },
            height: {
                $spaceunit: 1,
                ini: '25em'
            },
            frameTemplate: {
                ini: '<html style="-webkit-overflow-scrolling: touch;padding:0;margin:0.25em;">' +
                '<head>' +
                '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />' +
                '<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\">' +
                '<style type="text/css">' +
                'body{height: 100%;-webkit-overflow-scrolling: touch;border:0;padding:0;margin:.0;cursor:text;color:var(--ood-text-primary);font-family:arial,helvetica,clean,sans-serif;font-style:normal;font-weight:normal;font-size:12px;line-height:1.22}' +
                'div, p{margin:0;padding:0;} ' +
                'body, p, div{word-wrap: break-word;} ' +
                'img, input, textarea{cursor:default;}' +
                '</style>' +
                '</head>' +
                '<body scroll="auto" spellcheck="false"></body>' +
                '</html>',
                action: function () {
                    this.boxing().refresh();
                }
            },
            frameStyle: "",
            cmdList: {
                ini: 'font1;font2;align;list;font4;font3;insert;clear;html',
                action: function (v) {
                    var ns = this;
                    if (!ns.properties.disabled && !ns.properties.readonly)
                        ns.box._iniToolBar(ns);
                }
            },
            cmdFilter: {
                ini: ''
            },
            enableBar: {
                ini: false,
                action: function (disabled) {
                    var ns = this;
                    this.cmdList = "";
                    this.labelPos = 'none';
                    if (!ns.properties.disabled && !ns.properties.readonly) {
                        ns.box._iniToolBar(ns);
                    }
                    ood.UI.$doResize(this, this.properties.width, this.properties.height, true);
                }
            },
            disabled: {
                ini: false,
                action: function (disabled) {
                    var disabled = this.properties.disabled || this.properties.readonly,
                        doc = this.$doc;
                    if (doc) {
                        if (doc.body.contentEditable != undefined && ood.browser.ie)
                            doc.body.contentEditable = disabled ? "false" : "true";
                        else
                            doc.designMode = disabled ? "off" : "on";
                        this.box._iniToolBar(this, !disabled);
                    }
                }
            },
            readonly: {
                ini: false,
                action: function (v) {
                    this.boxing().setDisabled(v);
                }
            },
            textType: {
                ini: "html",
                listbox: ['text', 'html'],
                action: function (v) {

                }
            },
            // label
            labelSize: {
                $spaceunit: 2,
                ini: 0,
                action: function (v) {
                    this.getSubNode('LABEL').css({display: v && v != 'auto' ? '' : 'none'});
                    ood.UI.$doResize(this, this.properties.width, this.properties.height, true);
                }
            },
            labelPos: {
                ini: "left",
                listbox: ['none', 'left', 'top', 'right', 'bottom'],
                action: function (v) {
                    ood.UI.$doResize(this, this.properties.width, this.properties.height, true);
                }
            },
            labelGap: {
                $spaceunit: 2,
                ini: 4,
                action: function (v) {
                    ood.UI.$doResize(this, this.properties.width, this.properties.height, true);
                }
            },
            labelCaption: {
                ini: "",
                action: function (v) {
                    v = (ood.isSet(v) ? v : "") + "";
                    this.getSubNode('LABEL').html(ood.adjustRes(v, true));
                }
            },
            labelHAlign: {
                ini: 'right',
                listbox: ['', 'left', 'center', 'right'],
                action: function (v) {
                    this.getSubNode('LABEL').css({
                        'textAlign': v || '',
                        'justifyContent': v == 'right' ? 'flex-end' : v == 'center' ? 'center' : v == 'left' ? 'flex-start' : ''
                    });
                }
            },
            labelVAlign: {
                ini: 'top',
                listbox: ['', 'top', 'middle', 'bottom'],
                action: function (v) {
                    this.getSubNode('LABEL').css('align-items', v == 'bottom' ? 'flex-end' : v == 'middle' ? 'center' : v == 'top' ? 'flex-start' : '');
                }
            }
        },
        Appearances: {
            KEY: {
                overflow: "hidden"
            },
            BOX: {
                left: 0,
                top: 0,
                width: '100%',
                position: 'absolute',
                overflow: 'hidden'
            },
            POOL: {
                position: 'absolute',
                display: 'none'
            },
            DIRTYMARK: {
                position: 'absolute',
                width: "1em",
                height: "1em"
            },
            TOOLBARBTN: {},
            LABEL: {
                'z-index': 1,
                top: 0,
                left: 0,
                display: ood.browser.isWebKit ? '-webkit-flex' : 'flex',
                position: 'absolute',
                'padding-top': '.5em'
            },
            EDITOR: {
                'background-color': 'var(--bg-input) !important',
                'color': 'var(--text-input)  !important',
                position: 'absolute',
                display: 'block',
                left: 0,
                top: 0,
                width: '100%',
                height: '100%',
                padding: 0,
                margin: 0,
                'z-index': '10'
            }
        },
        Behaviors: {
            LABEL: {
                onClick: function (profile, e, src) {
                    if (profile.properties.disabled) return false;
                    if (profile.onLabelClick)
                        profile.boxing().onLabelClick(profile, e, src);
                },
                onDblClick: function (profile, e, src) {
                    if (profile.properties.disabled) return false;
                    if (profile.onLabelDblClick)
                        profile.boxing().onLabelDblClick(profile, e, src);
                },
                onMousedown: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != 'left') return;
                    if (profile.properties.disabled) return false;
                    if (profile.onLabelActive)
                        profile.boxing().onLabelActive(profile, e, src);
                }
            }
        },
        EventHandlers: {
            onInnerEvent: function (profile, type, node, e) {
            },
            onUpdateToolbar: function (profile, etype, doc) {
            },
            onReady: function (profile) {
            },

            onLabelClick: function (profile, e, src) {
            },
            onLabelDblClick: function (profile, e, src) {
            },
            onLabelActive: function (profile, e, src) {
            }
        },
        $cmds: {
            //font style
            font1: [
                {
                    id: 'bold',
                    command: 'Bold',
                    statusButton: true,
                    imageClass: 'oodfont ood-icon-bold',
                    _fi_: 'ood-icon-bold'
                },
                {
                    id: 'italic',
                    command: 'Italic',
                    statusButton: true,
                    imageClass: 'oodfont ood-icon-italic',
                    _fi_: 'ood-icon-italic'
                },
                {
                    id: 'underline',
                    command: 'Underline',
                    statusButton: true,
                    imageClass: 'oodfont ood-icon-underline',
                    _fi_: 'ood-icon-underline'
                },
                {
                    id: 'strikethrough',
                    command: 'strikeThrough',
                    statusButton: true,
                    imageClass: 'oodfont ood-icon-strikethrough',
                    _fi_: 'ood-icon-strikethrough'
                }
            ],
            font2: [
                {
                    id: 'subscript',
                    command: 'subscript',
                    statusButton: true,
                    imageClass: "oodfont ood-icon-sub",
                    _fi_: 'ood-icon-sub'
                },
                {
                    id: 'superscript',
                    command: 'superscript',
                    statusButton: true,
                    imageClass: "oodfont ood-icon-super",
                    _fi_: 'ood-icon-super'
                }
            ],
            font3: [
                {
                    id: 'forecolor',
                    command: 'custom',
                    imageClass: "oodfont ood-icon-forecolor",
                    _fi_: 'ood-icon-forecolor'
                },
                {id: 'bgcolor', command: 'custom', imageClass: "oodfont ood-icon-bgcolor", _fi_: 'ood-icon-bgcolor'}
            ],
            font4: [
                {id: 'fontsize', command: 'custom', caption: '$editor.fontsize', dropButton: true},
                {id: 'fontname', command: 'custom', caption: '$editor.fontname', dropButton: true},
                {id: 'formatblock', command: 'custom', caption: '$editor.formatblock', dropButton: true}
            ],
            align: [
                {
                    id: 'left',
                    command: 'justifyleft',
                    imageClass: "oodfont ood-icon-alignleft",
                    _fi_: 'ood-icon-alignleft'
                },
                {
                    id: 'center',
                    command: 'justifycenter',
                    imageClass: "oodfont ood-icon-aligncenter",
                    _fi_: 'ood-icon-aligncenter'
                },
                {
                    id: 'right',
                    command: 'justifyright',
                    imageClass: "oodfont ood-icon-alignright",
                    _fi_: 'ood-icon-alignright'
                },
                {
                    id: 'justify',
                    command: 'justifyfull',
                    imageClass: "oodfont ood-icon-alignjustify",
                    _fi_: 'ood-icon-alignjustify'
                }
            ],
            list: [
                {id: 'indent', command: 'indent', imageClass: "oodfont ood-icon-indent", _fi_: 'ood-icon-indent'},
                {id: 'outdent', command: 'outdent', imageClass: "oodfont ood-icon-outdent", _fi_: 'ood-icon-outdent'},
                {
                    id: 'ol',
                    command: 'insertorderedlist',
                    imageClass: "oodfont ood-icon-number",
                    _fi_: 'ood-icon-number'
                },
                {
                    id: 'ul',
                    command: 'insertunorderedlist',
                    imageClass: "oodfont ood-icon-bullet",
                    _fi_: 'ood-icon-bullet'
                }
            ],
            insert: [
                {
                    id: 'hr',
                    command: 'insertHorizontalRule',
                    imageClass: "oodfont ood-icon-inserthr",
                    _fi_: 'ood-icon-inserthr'
                },
                {
                    id: 'insertimage',
                    command: 'custom',
                    imageClass: "oodfont ood-icon-picture",
                    _fi_: 'ood-icon-picture'
                },
                {id: 'createlink', command: 'custom', imageClass: "oodfont ood-icon-link", _fi_: 'ood-icon-link'},
                {id: 'unlink', command: 'unlink', imageClass: "oodfont ood-icon-breaklink", _fi_: 'ood-icon-breaklink'}
            ],
            clear: [
                {
                    id: 'removeformat',
                    command: 'removeformat',
                    imageClass: "oodfont ood-icon-formatclear",
                    _fi_: 'ood-icon-formatclear'
                }
            ],
            html: [
                {id: 'html', command: 'custom', imageClass: "oodfont ood-icon-html", _fi_: 'ood-icon-html'}
            ]
        },
        _prepareData: function (profile) {
            var d = arguments.callee.upper.call(this, profile), t, v;
            d._labelHAlign = 'text-align:' + (v = d.labelHAlign || '') + ';justify-content:' + (v == 'right' ? 'flex-end' : v == 'center' ? 'center' : v == 'left' ? 'flex-start' : '');
            d._labelVAlign = 'align-items:' + ((v = d.labelVAlign) == 'bottom' ? 'flex-end' : v == 'middle' ? 'center' : v == 'top' ? 'flex-start' : '');
            d.labelShow = d.labelPos != 'none' && d.labelSize && d.labelSize != 'auto' ? "" : "display:none";
            d._labelSize = d.labelSize ? '' : 0 + profile.$picku();
            // adjustRes for labelCaption
            if (!d.enableBar) {
                this.cmdList = "";
                this.labelPos = 'none';
            }
            if (d.textType && d.textType=='text') {
                this.cmdList = "";
                this.labelPos = 'none';
            }



            if (d.labelCaption)
                d.labelCaption = ood.adjustRes(d.labelCaption, true);
            return d;
        },
        _updateToolbar: function (domId, clear, etype) {
            var profile = ood.$cache.profileMap[domId], toolbar;
            if (!profile) return;

            if (profile.properties.disabled || profile.properties.readonly) return;

            if (profile && (toolbar = profile.$toolbar)) {
                var doc = profile.$doc,
                    bold = clear ? false : doc.queryCommandState('bold'),
                    italic = clear ? false : doc.queryCommandState('italic'),
                    underline = clear ? false : doc.queryCommandState('underline'),
                    strikethrough = clear ? false : doc.queryCommandState('strikethrough'),
                    subscript = clear ? false : doc.queryCommandState('subscript'),
                    superscript = clear ? false : doc.queryCommandState('superscript'),

                    tb = toolbar.boxing();

                tb.updateItem('bold', {value: bold})
                tb.updateItem('italic', {value: italic})
                tb.updateItem('underline', {value: underline})
                tb.updateItem('strikethrough', {value: strikethrough})
                tb.updateItem('subscript', {value: subscript})
                tb.updateItem('superscript', {value: superscript})

                if (profile.onUpdateToolbar) {
                    profile.boxing().onUpdateToolbar(profile, etype, doc);
                }
                doc = null;
            }
        },
        RenderTrigger: function () {
            var self = this;

            if (!self.properties.disabled && !self.properties.readonly)
                self.box._iniToolBar(self);

            if (!self.$inDesign) {
                var div = self.getSubNode('EDITOR').get(0),
                    domId = self.$domId,
                    htmlTpl = self.properties.frameTemplate,
                    style = self.properties.frameStyle,
                    id = div.id;
                if (style) {
                    htmlTpl = htmlTpl.replace(/<\s*\/\s*head\s*>/, "<style>" + (style || "") + "</style></head>");
                }
                // rendered already
                if (!self.$once) {
                    self.$once = true;
                    try {
                        var iframe = self.$ifr = document.createElement("IFRAME");
                    } catch (e) {
                        var iframe = self.$ifr = document.createElement("<iframe name='" + id + "' id='" + id + "'></iframe>");
                    }
                    //_updateToolbar event
                    var kprf = this,
                        eventOutput = self._eventOutput = function (e) {
                            if (kprf && (kprf.properties.disabled || kprf.properties.readonly)) return;
                            if (kprf.onInnerEvent)
                                return kprf.boxing().onInnerEvent(kprf, e.type, ood.Event.getSrc(e), e);
                        },
                        event = self._event = function (e) {
                            if (kprf && (kprf.properties.disabled || kprf.properties.readonly)) return;
                            var etype = e.type;
                            if (etype !== "mouseover" && etype !== "mouseout") {
                                ood.resetRun('RichEditor:' + domId, function () {
                                    // destroyed
                                    if (!kprf.box) return;
                                    ood.UI.RichEditor._updateToolbar(domId, false, etype)
                                }, 100);
                                if (etype == 'mousedown') {
                                    if (ood.browser.applewebkit && e.target.tagName == "IMG") {
                                        var sel = self.$win.getSelection(), range = self.$doc.createRange();
                                        range.selectNode(e.target);
                                        sel.removeAllRanges();
                                        sel.addRange(range);
                                    }

                                    //for BlurTrigger
                                    ood.doc.onMousedown(true);
                                }
                            }
                            if (kprf.onInnerEvent)
                                return kprf.boxing().onInnerEvent(kprf, etype, ood.Event.getSrc(e), e);
                        },
                        event2 = self._event2 = function (e) {
                            if (kprf && (kprf.properties.disabled || kprf.properties.readonly)) return;
                            if (kprf.onInnerEvent) {
                                var etype = e.type;
                                ood.resetRun(kprf.$xid + ":frmInnerAsyEvent", function () {
                                    if (kprf && !kprf.destroyed)
                                        kprf.boxing().onInnerEvent(kprf, etype, ood.Event.getSrc(e), e);
                                });
                            }
                        },
                        _focus = function (e) {
                            if (!kprf) return;
                            if (kprf.properties.disabled || kprf.properties.readonly) return;
                            kprf.box._onchange(kprf);
                        },
                        _blur = function (e) {
                            if (!kprf) return;
                            if (kprf.properties.disabled || kprf.properties.readonly) return;

                            ood.resetRun('RichEditor:' + domId, function () {
                                // destroyed
                                if (!kprf.box) return;
                                ood.UI.RichEditor._updateToolbar(domId, true, 'blur')
                            }, 100);

                            if (kprf._onchangethread) {
                                clearInterval(kprf._onchangethread);
                                kprf._onchangethread = null;
                                // check again
                                if (kprf && kprf.box)
                                    kprf.box._checkc(kprf);
                            }

                            var v = kprf.boxing()._getCtrlValue();
                            // here: dont trigger setCtrlValue
                            kprf.boxing().setUIValue(v, null, true, 'blur');
                        },
                        gekfix = function (e) {
                            // to fix firefox appendChid's bug: refresh iframe's document
                            if (kprf) {
                                var ins = kprf.boxing();
                                ood.asyRun(function () {
                                    // destroyed
                                    if (!kprf.box) return;
                                    ins.refresh();
                                });
                            }
                        },
                        doc, win,
                        checkF = function () {
                            ood.setTimeout(function () {
                                // removed from DOM already
                                if (!frames[id]) return;
                                // not ready
                                if (!frames[id].document) return;

                                if (self.$win != frames[id].window) {
                                    win = self.$win = frames[id].window;

                                    doc = self.$doc = win.document;

                                    doc.open();
                                    doc.write(htmlTpl);
                                    doc.close();

                                    //if(ood.browser.isTouch && (ood.browser.isAndroid||||ood.browser.isBB)){
                                    //    ood(doc.body).$touchscroll('xy');
                                    //}

                                    try {
                                        doc.execCommand("styleWithCSS", 0, false)
                                    } catch (e) {
                                        try {
                                            doc.execCommand("useCSS", 0, true)
                                        } catch (e) {
                                        }
                                    }

                                    var disabled = self.properties.disabled || self.properties.readonly;

                                    if (doc.body.contentEditable != undefined && ood.browser.ie)
                                        doc.body.contentEditable = disabled ? "false" : "true";
                                    else
                                        doc.designMode = disabled ? "off" : "on";

                                    // ensure toolbar disable
                                    if (disabled) {
                                        self.box._iniToolBar(self, false);
                                    }

                                    win._gekfix = gekfix;

                                    if (ood.browser.ie && doc.attachEvent) {
                                    //    doc.attachEvent("unload", gekfix);

                                        if (!disabled) {
                                            doc.attachEvent("onmousedown", event);
                                            doc.attachEvent("ondblclick", event);
                                            doc.attachEvent("onclick", event);
                                            doc.attachEvent("oncontextmenu", eventOutput);
                                            doc.attachEvent("onkeyup", event);
                                            doc.attachEvent("onkeydown", event);

                                            doc.attachEvent("onmouseover", event);
                                            doc.attachEvent("onmouseout", event);
                                            doc.attachEvent("onmousemove", event2);

                                            win.attachEvent("onfocus", _focus);
                                            win.attachEvent("onblur", _blur);
                                            (self.$beforeDestroy = (self.$beforeDestroy || {}))["ifmClearMem"] = function () {
                                                var win = this.$win,
                                                    doc = this.$doc,
                                                    event = this._event,
                                                    event2 = this._event2;
                                                if (this._onchangethread) {
                                                    clearInterval(this._onchangethread);
                                                    this._onchangethread = null;
                                                }

                                                // crack for ie7/8 eat focus
                                                // error raise in ie6
                                                try {
                                                    var status = doc.designMode;
                                                    doc.designMode = "off";
                                                    doc.designMode = "on";
                                                    doc.designMode = status;
                                                } catch (e) {
                                                }

                                                win._gekfix = undefined;


                                                if (!this.properties.disabled && !this.properties.readonly) {
                                                    doc.detachEvent("onmousedown", event);
                                                    doc.detachEvent("ondblclick", event);
                                                    doc.detachEvent("onclick", event);
                                                    doc.detachEvent("oncontextmenu", eventOutput);
                                                    doc.detachEvent("onkeyup", event);
                                                    doc.detachEvent("onkeydown", event);

                                                    doc.detachEvent("onmouseover", event);
                                                    doc.detachEvent("onmouseout", event);
                                                    doc.detachEvent("onmousemove", event2);

                                                    win.detachEvent("onfocus", _focus);
                                                    win.detachEvent("onblur", _blur);
                                                }
                                                win = doc = event = event2 = null;
                                            };
                                        }
                                    } else {
                                        var prf = self;
                                        // for opera
                                        if (ood.browser.opr || !win.addEventListener) {
                                            prf.$repeatT = ood.Thread.repeat(function () {
                                                if (!frames[id])
                                                    return false;
                                                else {
                                                    if (!prf.$win.document || !prf.$win.document.defaultView)
                                                        prf.boxing().refresh();
                                                }
                                            }, 99);
                                        }
                                        //else
                                          //  win.addEventListener("unload", gekfix, false);

                                        if (!disabled) {
                                            doc.addEventListener("mousedown", event, false);
                                            doc.addEventListener("dblclick", event, false);
                                            doc.addEventListener("click", event, false);
                                            doc.addEventListener("contextmenu", eventOutput, false);
                                            doc.addEventListener("keyup", event, false);

                                            doc.addEventListener("mouseover", event, false);
                                            doc.addEventListener("mouseout", event, false);
                                            doc.addEventListener("mousemove", event2, false);

                                            if (ood.browser.gek || !win.addEventListener) {
                                                doc.addEventListener("focus", _focus, false);
                                                doc.addEventListener("blur", _blur, false);
                                                doc.addEventListener("keypress", event, false);
                                            } else {
                                                win.addEventListener("focus", _focus, false);
                                                win.addEventListener("blur", _blur, false);
                                                doc.addEventListener("keydown", event, false);
                                            }
                                        }

                                        //don't ues $ondestory, opera will set doc to null
                                        (self.$beforeDestroy = (self.$beforeDestroy || {}))["ifmClearMem"] = function () {
                                            var win = this.$win,
                                                doc = this.$doc,
                                                ifr = this.$ifr,
                                                event = this._event,
                                                event2 = this._event2;
                                            // for opera
                                            if (ood.browser.opr)
                                                if (prf.$repeatT) prf.$repeatT.abort();

                                            if (ifr.detachEvent) {
                                                ifr.detachEvent('onload', checkF);
                                            } else {
                                                ifr.onload = null;
                                            }

                                            win._gekfix = undefined;

                                            //for firefox
                                            delete frames[this.$frameId];

                                            if (!this.properties.disabled && !this.properties.readonly && doc.removeEventListener) {
                                                doc.removeEventListener("mousedown", event, false);
                                                doc.removeEventListener("dblclick", event, false);
                                                doc.removeEventListener("click", event, false);
                                                doc.removeEventListener("contextmenu", eventOutput, false);
                                                doc.removeEventListener("keyup", event, false);

                                                doc.removeEventListener("mouseover", event, false);
                                                doc.removeEventListener("mouseout", event, false);
                                                doc.removeEventListener("mousemove", event2, false);

                                                if (ood.browser.gek || !win.removeEventListener) {
                                                    doc.removeEventListener("focus", _focus, false);
                                                    doc.removeEventListener("blur", _blur, false);
                                                    doc.removeEventListener("keypress", event, false);
                                                } else {
                                                    win.removeEventListener("focus", _focus, false);
                                                    win.removeEventListener("blur", _blur, false);
                                                    doc.removeEventListener("keydown", event, false);
                                                }
                                            }
                                            prf = gekfix = event = event2 = win = doc = null;
                                        };
                                    }

                                    self.boxing()._setCtrlValue(self.properties.$UIvalue || "");

                                    iframe.style.visibility = '';
                                    iframe.style.overflow = 'auto';

                                    if (self.onReady) self.boxing().onReady(self);
                                }
                            });
                        };
                    self.$frameId = id;
                    iframe.id = iframe.name = id;
                    iframe.className = div.className;
                    iframe.src = "about:blank";
                    iframe.frameBorder = 0;
                    iframe.border = 0;
                    iframe.scrolling = 'yes';
                    iframe.marginWidth = 0;
                    iframe.marginHeight = 0;
                    iframe.tabIndex = -1;
                    iframe.allowTransparency = "allowtransparency";
                    iframe.style.visibility = 'hidden';

                    //replace the original one
                    ood.$cache.domPurgeData[iframe.$xid = div.$xid].element = iframe;
                    div.parentNode.replaceChild(iframe, div);

                    if (iframe.attachEvent) {
                        iframe.attachEvent('onload', checkF);
                    } else {
                        iframe.onload = checkF;
                    }
                }
            } else {
                self.boxing()._setCtrlValue(self.properties.value || "");
            }
            
            // 
            ood.asyRun(function(){
                self.boxing().RichEditorTrigger();
            });
        },
        

        _checkc: function (profile) {
            if (profile && profile.$doc) {
                var doc = profile.$doc, body = doc && (doc.body || doc.documentElement);
                if (!profile.__oldv)
                    profile.__oldv = body.innerHTML;
                if (body.innerHTML != profile.__oldv) {
                    var ov = profile.__oldv;
                    profile.__oldv = body.innerHTML;
                    profile.boxing().onChange(profile, ov, body.innerHTML);
                }
            }
        },
        _onchange: function (profile) {
            if (profile.onChange) {
                if (profile._onchangethread) {
                    clearInterval(profile._onchangethread);
                    profile._onchangethread = null;
                }
                profile._onchangethread = setInterval(function () {
                    if (profile && profile.box)
                        profile.box._checkc(profile);
                }, 500);
            }
        },
        _clearPool: function (profile) {
            profile.getSubNode('POOL').empty();
            profile.$colorPicker = profile.$fontsizeList = profile.$fontnameList = profile.$formatblockList = profile.$htmlEditor = null;
        },
        _iniToolBar: function (profile, flag) {
            var self = profile,
                pro = self.properties,
                cmdFilter = (pro.cmdFilter || '').split(/[\s,;]+/),
                tbH;
            if (self.$toolbar) {
                self.$toolbar.boxing().destroy(true);
                delete self._$tb;
                delete self.$toolbar;
            }

            if (flag !== false) {
                var t, v, o, items = [],
                    imageClass = self.getClass('TOOLBARBTN'),
                    arr = pro.cmdList.split(/[\s,;]+/),
                    h = {};
                ood.arr.each(arr, function (i) {
                    //filter
                    if ((o = self.box.$cmds[i]) && !h[i]) {
                        h[i] = 1;
                        ood.filter(o, function (v) {
                            if (ood.arr.indexOf(cmdFilter, v.id) !== -1) return false;
                            if (v.imagePos)
                                v.imageClass = imageClass;
                            v.tips = ood.wrapRes('editor.' + v.id);
                        });
                        items.push({id: i, sub: o});
                    }
                });

                //compose
                t = new ood.UI.ToolBar({
                    selectable: false,
                    handler: false,
                    items: items,
                    disabled: pro.disabled || pro.readonly
                });
                t.setCustomStyle('ITEMS', 'border:none');
                self.getSubNode('BOX').prepend(t);
                t.render(true);
                // keep toolbar's height number here
                profile.$_tbH = tbH = t.getRoot().offsetHeight();
                if (ood.browser.ie)
                    t.getSubNode('BOX').query('*').attr('unselectable', 'on');

                t = self._$tb = t.get(0);

                t.onClick = self.box._toolbarclick;
                v = self._$composed = {};
                v[t.$xid] = t;
                self.$toolbar = t;
                t.$hostage = self;
            }
            profile.adjustSize(true);
            return tbH;
        },
        _toolbarclick: function (profile, item, group, e, src) {
            var editor = profile.$hostage;
            if (!editor.$doc) return;

            var pro = editor.properties, first;
            editor.$win.focus();

            if (item.command == 'custom') {
                var cmd = item.id,
                    o, _clear, node,
                    items, items2;

                //get the pop control
                switch (cmd) {
                    case 'forecolor':
                    case 'bgcolor':
                        if (!editor.$colorPicker) {
                            first = true;
                            editor.$colorPicker = (new ood.UI.ColorPicker({
                                selectable: false,
                                barDisplay: false
                            })).render(true);
                        }
                        o = editor.$colorPicker;
                        break;
                    case 'fontsize':
                    case 'fontname':
                    case 'formatblock':
                        //if lang was changed, clear the pool first
                        if (editor.$lang != ood.getLang())
                            editor.box._clearPool(editor);
                        editor.$lang = ood.getLang();

                        //font size
                        if (cmd == 'fontsize') {
                            if (!editor.$fontsizeList) {
                                items = ood.getRes('editor.fontsizeList');
                                items = items.split(';');
                                items2 = [];
                                var t;
                                ood.arr.each(items, function (o) {
                                    o = o.split(',');
                                    t = o[0] == '...' ? '1' : o[0];
                                    items2.push({
                                        id: o[0],
                                        caption: '<font size="' + o[0] + '" ' + ood.$IEUNSELECTABLE() + '>' + o[1] + '</font>'
                                    });
                                });
                                first = true;
                                editor.$fontsizeList = (new ood.UI.List({
                                    selectable: false,
                                    height: 'auto',
                                    items: items2,
                                    width: 150
                                })).render(true);
                            }
                            o = editor.$fontsizeList;
                            //font family
                        } else if (cmd == 'fontname') {
                            if (!editor.$fontnameList) {
                                items = ood.getRes('editor.fontnameList');
                                items = items.split(';');
                                items2 = [];
                                var t;
                                ood.arr.each(items, function (o) {
                                    t = o == '...' ? '' : o;
                                    items2.push({
                                        id: o,
                                        caption: '<span style="font-family:' + o + '" ' + ood.$IEUNSELECTABLE() + '>' + o + '</span>'
                                    });
                                });
                                first = true;
                                editor.$fontnameList = (new ood.UI.List({
                                    selectable: false,
                                    height: 'auto',
                                    items: items2
                                })).render(true);
                            }
                            o = editor.$fontnameList;
                            //font format
                        } else if (cmd == 'formatblock') {
                            if (!editor.$formatblockList) {
                                items = ood.getRes('editor.formatblockList');
                                items = items.split(';');
                                items2 = [];
                                var t;
                                ood.arr.each(items, function (o) {
                                    o = o.split(',');
                                    t = o[0] == '...' ? 'span' : o[0];
                                    items2.push({
                                        id: o[0],
                                        caption: '<' + t + ' style="display:inline;padding:0;margin:0" ' + ood.$IEUNSELECTABLE() + '>' + o[1] + '</' + t + '>'
                                    });
                                });
                                first = true;
                                editor.$formatblockList = (new ood.UI.List({
                                    selectable: false,
                                    height: 'auto',
                                    items: items2
                                })).render(true);
                            }
                            o = editor.$formatblockList;
                        }
                        break;
                    case 'html':
                        if (!editor.$htmlEditor) {
                            first = true;
                            editor.$htmlEditor = new ood.UI.Input({
                                multiLines: true,
                                width: 400,
                                height: 300,
                                resizer: true
                            });
                        }
                        o = editor.$htmlEditor;
                        break;
                }
                //pop the control and set clear funciton
                if (o) {
                    var sid = profile.key + ":" + editor.$xid;
                    _clear = function () {
                        o.beforeUIValueSet(null);
                        editor.getSubNode('POOL').append(o.getRoot());
                        node.setBlurTrigger(sid);
                        ood.Event.keyboardHook('esc', 0, 0, 0, sid);
                        ood.asyRun(function () {
                            // destroyed
                            if (!editor || !editor.$win) return;
                            editor.$win.focus()
                        });
                    };

                    o.setValue('', true, 'clear');
                    node = o.reBoxing();

                    if (editor.$htmlEditor == o) {
                        var root = editor.getRoot(), ifr = editor.getSubNode("EDITOR");
                        o.setLeft(ifr.left()).setTop(ifr.top()).setWidth(ifr.offsetWidth()).setHeight(ifr.offsetHeight());
                        o.setZIndex(10);
                        editor.getSubNode('BOX').append(node);
                    } else {
                        node.popToTop(src);
                    }

                    if (first && ood.browser.ie)
                        o.getSubNode('BOX').query('*').attr('unselectable', 'on');

                    ood.tryF(o.activate, [], o);

                    //for on blur disappear
                    node.setBlurTrigger(sid, function () {
                        //force to trigger beforeUIValueSet event
                        if (o == editor.$htmlEditor)
                            var v = o._getCtrlValue();
                        // here: dont trigger setCtrlValue
                        o.setUIValue(v, null, true, 'blur');
                        _clear();
                    });
                    //for esc
                    ood.Event.keyboardHook('esc', 0, 0, 0, function () {
                        _clear();
                    }, sid, null, null, profile.domId);
                }
                //set beforeUIValueSet function
                switch (cmd) {
                    case 'forecolor':
                    case 'bgcolor':
                        o.beforeUIValueSet(function (p, o, v) {
                            _clear();
                            var doc = editor.$doc;
                            if (cmd == 'bgcolor' && ood.browser.gek) {
                                doc.execCommand('useCSS', 0, false);
                                doc.execCommand('hilitecolor', false, '#' + v);
                                doc.execCommand('useCSS', 0, true);
                            } else {
                                if (cmd == 'bgcolor')
                                    cmd = ood.browser.opr ? 'hilitecolor' : 'backcolor';
                                doc.execCommand(cmd, false, ood.browser.kde ? ('#' + v) : v);
                            }
                            doc = null;
                            return false;
                        });
                        break;
                    case 'fontsize':
                    case 'fontname':
                    case 'formatblock':
                        o.beforeUIValueSet(function (p, o, v) {
                            _clear();
                            //store range for IE
                            if (ood.browser.ie && (v == '...' || cmd == 'formatblock')) {
                                var selection = editor.$doc.selection,
                                    range = selection ? selection.createRange() : null;
                                if (range && range.parentElement().ownerDocument != editor.$doc)
                                    range = selection = null;
                            }
                            var f = function (cmd, v) {
                                var doc = editor.$doc;

                                //for formatblock in IE
                                //reset range for IE
                                if (range) {
                                    editor.$win.focus();
                                    if (cmd == 'formatblock' && v) {
                                        var p = range.parentElement(), html;
                                        if (p.ownerDocument == doc) {
                                            if (/^\s*</.test(range.htmlText)) {
                                                //affect the first block only
                                                range.collapse(true);
                                                p = range.parentElement();
                                                if (p.tagName == 'BODY') {
                                                    html = p.innerHTML;
                                                    p.innerHTML = "<" + v + ">" + html + "</" + v + ">"
                                                } else {
                                                    html = p.outerHTML;
                                                    html = html.replace(/\<[\w]+/, '<' + v).replace(/[\w]+\>$/, v + '>');
                                                    p.outerHTML = html;
                                                }
                                            } else {
                                                range.pasteHTML("<" + v + ">" + range.htmlText + "</" + v + ">")
                                            }
                                        }
                                        p = null;
                                    }
                                    range.select();
                                    selection = range = null;
                                }

                                doc.execCommand(cmd, false, v);
                                doc = null;
                            };
                            if (v == '...') {
                                var str = ood.getRes('editor.' + cmd);
                                ood.UI.Dialog.prompt(str, str, "", function (v) {
                                    if (v) {
                                        f(cmd, v);
                                    }
                                }, function () {
                                    //reset range for IE
                                    if (ood.browser.ie) {
                                        if (range) {
                                            editor.$win.focus();
                                            range.select();
                                        }
                                        selection = range = null
                                    }
                                });
                            } else
                                f(cmd, v);
                        });
                        break;
                    case 'insertimage':
                    case 'createlink':
                        var str = ood.getRes('editor.' + cmd),
                            str2 = ood.getRes('editor.' + cmd + '2');
                        //store range for IE
                        if (ood.browser.ie) {
                            var selection = editor.$doc.selection,
                                range = selection ? selection.createRange() : null;
                            if (range && range.parentElement().ownerDocument != editor.$doc)
                                range = selection = null;
                        }
                        ood.UI.Dialog.prompt(str, str2, "http:/" + '/', function (v) {
                            //reset range for IE
                            if (ood.browser.ie) {
                                if (range) {
                                    editor.$win.focus();
                                    range.select();
                                }
                                selection = range = null
                            }
                            if (v) {
                                var doc = editor.$doc;
                                doc.execCommand(cmd, false, ood.adjustRes(v, 0, 1));
                                doc = null;
                            }
                        }, function () {
                            //reset range for IE
                            if (ood.browser.ie) {
                                if (range) {
                                    editor.$win.focus();
                                    range.select();
                                }
                                selection = range = null
                            }
                        });
                        break;
                    case 'html':
                        var v = editor.boxing().getUIValue();
                        if (ood.Coder) v = ood.Coder.formatText(v, 'html');
                        o.setValue(v, true, 'editor');
                        o.beforeUIValueSet(function (p, o, v) {
                            _clear();
                            // here: trigger setCtrlValue
                            editor.boxing().setUIValue(v, null, null, 'html');
                        });
                        break;
                }
            } else {
                editor.$doc.execCommand(item.command, false, item.commandArgs || null);

                if (item.id == 'removeformat')
                    ood.UI.RichEditor._updateToolbar(editor.$domId, true, 'none')
                editor.$win.focus();
            }
        },
        _ensureValue: function (profile, value) {
            var p = ood.$getGhostDiv();
            p.innerHTML = (ood.isSet(value) ? value : '') + "";
            value = p.innerHTML;
            p.innerHTML = "";
            return value;
        },
        _onresize: function (profile, width, height) {
            if (width || height) {
                if (!height)
                    height = profile.properties.height;

                var prop = profile.properties,
                    root = profile.getRoot(),
                    box = profile.getSubNode('BOX'),
                    label = profile.getSubNode('LABEL'),

                    us = ood.$us(profile),
                    adjustunit = function (v, emRate) {
                        return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                    },

                    fzrate = profile.getEmSize() / root._getEmSize(),
                    labelfz = label._getEmSize(fzrate),

                    labelPos = prop.labelPos,
                    labelSize = (labelPos == 'none' || !labelPos) ? 0 : profile.$px(prop.labelSize, labelfz) || 0,
                    labelGap = (labelPos == 'none' || !labelPos) ? 0 : profile.$px(prop.labelGap) || 0,
                    ll, tt, ww, hh;

                // caculate by px
                if (width && width != 'auto') width = profile.$px(width);
                if (height && height != 'auto') height = profile.$px(height);

                box.cssRegion({
                    left: adjustunit(ll = labelPos == 'left' ? labelSize : 0),
                    top: adjustunit(tt = labelPos == 'top' ? labelSize : 0),
                    width: adjustunit(ww = width === null ? null : Math.max(0, (width - ((labelPos == 'left' || labelPos == 'right') ? labelSize : 0)))),
                    height: adjustunit(hh = height === null ? null : Math.max(0, (height - ((labelPos == 'top' || labelPos == 'bottom') ? labelSize : 0))))
                });
                if (labelSize) {
                    label.cssRegion({
                        left: adjustunit(width === null ? null : Math.max(0, labelPos == 'right' ? (width - labelSize + labelGap) : 0), labelfz),
                        top: adjustunit(height === null ? null : Math.max(0, labelPos == 'bottom' ? (height - labelSize + labelGap) : 0), labelfz),
                        width: adjustunit(width === null ? null : Math.max(0, ((labelPos == 'left' || labelPos == 'right') ? (labelSize - labelGap) : width)), labelfz),
                        height: adjustunit(height === null ? null : Math.max(0, ((labelPos == 'top' || labelPos == 'bottom') ? (labelSize - labelGap) : height)), labelfz)
                    });
                }
                ood.asyRun(function () {
                    if (!profile.renderId) return;

                    // calculate toolbar's height
                    var itb = profile._$tb,
                        size = {},
                        _top = 0,
                        tbh;
                    if (itb) {
                        // here, do resize first
                        itb.getRoot().width(adjustunit(ww, itb.getRoot()));
                        tbh = itb.getRoot().offsetHeight(true);
                        if (tbh)
                            profile.$_tbH = tbh;
                        else
                            tbh = profile.$_tbH;
                    }
                    _top = (itb ? (tbh - 1) : 0);

                    size.height = hh - _top - 2;
                    if (ww) size.width = ww - 2;

                    if (size.width < 0) size.width = 0;
                    if (size.height < 0) size.height = 0;

                    if (ww || hh) {
                        if (profile && profile.renderId) {
                            // non-sence for setting fontSize for EDITOR or MARK
                            size.width = adjustunit(size.width);
                            size.height = adjustunit(size.height);

                            profile.getSubNode('EDITOR').top(adjustunit(_top)).cssSize(size, true);
                            profile.getSubNode('DIRTYMARK').left(0 + profile.$picku()).top(adjustunit(_top + 1));
                        }
                    }
                }, 100/*greater than 16*/);
            }
        }
    }
});

ood.Class("ood.UI.ComboInput", "ood.UI.Input", {

    /*Instance*/
    Instance: {
        iniProp: {width: '18em', labelSize: '6em', caption: '$RAD.widgets.inputField', items: [
                {id: 'option1', caption: '1', value: '1'},
                {id: 'option2', caption: '2', value: '2'},
                {id: 'option3', caption: '3', value: '3'},
                {id: 'option4', caption: '4', value: '4', disabled: true}
            ]},
        // 
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot(),
                    frame = profile.getSubNode('FRAME'),
                    border = profile.getSubNode('BORDER'),
                    box = profile.getSubNode('BOX'),
                    wrap = profile.getSubNode('WRAP'),
                    input = profile.getSubNode('INPUT'),
                    label = profile.getSubNode('LABEL'),
                    arrow = profile.getSubNode('ARROW'),
                    error = profile.getSubNode('ERROR');

                // 
                root.addClass('combo-input-themed');
                
                // 
                frame.addClass('combo-input-frame');
                border.addClass('combo-input-border');
                box.addClass('combo-input-box');
                wrap.addClass('combo-input-wrap');
                input.addClass('combo-input-field');
                label.addClass('combo-input-label');
                arrow.addClass('combo-input-arrow');
                error.addClass('combo-input-error');

                // 
                root.attr('data-theme', theme);
                
                // 
                localStorage.setItem('combo-input-theme', theme);
            });
        },
        
        // 
        getTheme: function() {
            return this.properties.theme;
        },

        
        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('combo-input-theme') || 'light';
        },
        
        // 
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        _adjustV: function (v) {
            var profile = this.get(0), p = profile.properties;
            if (profile.$isNumber) {
                v = ('' + v).replace(/[^\d.-]/g, '');
                v = ood.isNumb(parseFloat(v)) ? ood.toFixedNumber(v, p.precision) : null;
            } else if (profile.properties.type == 'date' || profile.properties.type == 'datetime') {
                v = ood.isDate(v) ? v : ood.isFinite(v) ? new Date(parseInt(v, 10)) : null;


                if (v && ood.isDate(v)) {
                    v = v.getTime();
                }

            } else if (typeof v == "string" && v.indexOf("\r") != -1) {
                v = v.replace(/(\r\n|\r)/g, "\n");
            }
            return v;
        },
        getValue: function () {
            var upper = arguments.callee.upper,
                v = upper.apply(this, ood.toArr(arguments));
            upper = null;
            return this._adjustV(v);
        },

        getAllSelectedValues: function (key) {
            var items = getSelectedItem(true);
            var selectValues = [];
            if (key) {
                ood.each(items, function (item) {
                        selectValues.push(item[k])
                    }
                )
            } else {
                selectValues = items;
            }
            return selectValues;
        },

        getSelectedItem: function (returnArr) {
            var upper = arguments.callee.upper,
                v = upper.apply(this, ood.toArr(arguments));
            upper = null;
            return this._adjustV(v);
        },

        getUICationValue: function (returnArr) {
            var upper = arguments.callee.upper,
                v = upper.apply(this, ood.toArr(arguments));
            upper = null;
            return this._adjustV(v);
        },

        getUIValue: function () {
            var upper = arguments.callee.upper,
                v = upper.apply(this, ood.toArr(arguments));
            upper = null;
            return this._adjustV(v);
        },

        setCaptionValue: function (value) {
            var upper = arguments.callee.upper,
                v = upper.apply(this, ood.toArr(arguments));
            upper = null;

        },

        getCaptionValue: function () {
            var upper = arguments.callee.upper,
                v = upper.apply(this, ood.toArr(arguments));
            upper = null;
            return v;
        },

        _getCtrlValue: function () {
            return this.get(0).properties.$UIvalue;
            //return this._fromEditor(this.getSubNode('INPUT').attr('value'));
        },
        _setCtrlValue: function (value) {
            var ns = this, me = arguments.callee, r1 = me._r1 || (me._r1 = /\</),
                r2 = me._r2 || (me._r2 = /\<\/?[^>]+\>/g);
            return this.each(function (profile) {
                if (!profile.$typeOK) profile.box._iniType(profile);
                var o = profile.getSubNode('INPUT'), type = profile.properties.type;

                value = profile.$_onedit
                    // for enter/esc key, show editMode value
                    ? ns._toEditor(value)
                    : ns.getShowValue(value);

                if (type !== 'none' && type !== 'input' && type !== 'password' && !profile.properties.multiLines && typeof value == 'string' && r1.test(value)) value = value.replace(r2, '');

                if (profile.$Mask && !value) {
                    value = profile.$Mask;
                }
                profile.$_inner = 1;
                o.attr('value', value || '');
                delete profile.$_inner;
                if (type == 'color') {
                    var clr = ood.UI.ColorPicker.getTextColor(value);
                    o.css({backgroundColor: value, color: clr});

                    if (profile.properties.showMode == 'compact')
                        profile.getRoot().query('button').css('color', clr);
                }
            })
        },
        _compareValue: function (v1, v2) {
            var profile = this.get(0), t;
            if (t = profile.CF.compareValue || profile.$compareValue)
                return t(profile, v1, v2);

            return v1 === v2;
        },
        getShowValue: function (value) {
            var profile = this.get(0),
                pro = profile.properties, v, t;
            if (!ood.isDefined(value))
                value = pro.$UIvalue;

            if (!profile.$typeOK) profile.box._iniType(profile);

            // try to give default caption
            if (t = profile.CF.getShowValue || profile.$getShowValue)
                v = t(profile, value);
            else {
                //get from items
                if ('listbox' == pro.type) {
                    var list = (pro.listKey) ? ood.UI.getCachedData(pro.listKey) : pro.items;
                    if (list && (t = ood.arr.subIndexOf(list, 'id', value)) != -1) {
                        v = list[t].caption + "";
                        if (v && v.length > 0) v = ood.adjustRes(v);
                    } else
                        v = null;
                } else
                    v = profile.$showValue;
            }
            if (!ood.isSet(v) && (profile.$inputReadonly || pro.inputReadonly))
                v = ood.isSet(pro.caption) ? pro.caption : null;
            return "" + (ood.isSet(v) ? v : ood.isSet(value) ? value : "");
        },
        _toEditor: function (value) {
            var profile = this.get(0),
                pro = profile.properties, t;
            if (t = profile.CF.toEditor || profile.$toEditor)
                return t(profile, value);
            return value;
        },
        _fromEditor: function (value) {
            var profile = this.get(0),
                pro = profile.properties, t;

            if (t = profile.CF.fromEditor || profile.$fromEditor)
                return t(profile, value);
            return value;
        },
        setPopWnd: function (drop) {
            if (this.isDestroyed()) return;
            var profile = this.get(0);
            profile.$poplink = drop ? drop['ood.Module'] ? drop.getRoot(true) : drop['ood.UI'] ? drop.get(0) : drop : null;
            (profile.$poplink.$beforeDestroy = (profile.$poplink.$beforeDestroy || {}))["$poplink_to"] = function () {
                delete profile.$poplink;
            };
            (profile.$beforeDestroy = (profile.$beforeDestroy || {}))["$poplink"] = function () {
                if (profile.$poplink) {
                    ood.filter(profile.box.$drop, function (o) {
                        return o !== profile.$poplink;
                    });
                    profile.$poplink.boxing().destroy();
                    profile.$poplink = null;
                }
            };
        },
        _cache: function (type, focus) {
            if (this.isDestroyed()) return;
            var profile = this.get(0);

            var drop = profile.$poplink, cached = profile.properties.cachePopWnd;
            if (drop) {
                if (!cached) {
                    if (!drop.destroyed)
                        drop.boxing().destroy(true);
                    delete profile.$poplink;
                    if (focus)
                        profile.boxing().activate();
                } else {
                    if (!profile.__tryToHide) {
                        profile.__tryToHide = ood.asyRun(function () {
                            // destroyed
                            if (!profile.box) return;
                            delete profile.__tryToHide;

                            if (!drop.destroyed) {
                                if (ood.browser.opr)
                                    drop.getRoot().css('display', 'none');
                                if (drop.boxing()._clearMouseOver) drop.boxing()._clearMouseOver();
                                profile.getSubNode('POOL').append(drop.getRoot());
                            }
                            if (focus)
                                profile.boxing().activate();
                        });
                    }
                }
            }
            delete profile.$poplink;

            if (profile.afterPopHide)
                this.afterPopHide(profile, drop, type);
            return cached;
        },
        clearPopCache: function () {
            var profile = this.get(0);
            if (profile.renderId)
                profile.getSubNode('POOL').empty();
            delete profile.$poplink;
            return this;
        },
        setUploadObj: function (input) {
            var profile = this.get(0),
                prop = profile.properties,
                c = ood(input).get(0);
            if (c.tagName && c.tagName.toLowerCase() == 'input' && c.type == 'file') {
                if (profile.renderId && prop.type == 'file') {
                    var o = profile.getSubNode('FILE').get(0);

                    ood.setNodeData(c.$xid = o.$xid, 'element', c);
                    c.id = o.id;
                    c.onclick = o.onclick;
                    c.onchange = o.onchange;
                    o.$xid = null;
                    o.id = o.onclick = o.onchange = null;
                    //a special node, must delete if from cache here:
                    delete profile.$_domid[profile.keys['FILE']];
                    ood([o]).addPrev(c).remove(false);
                    this.setUIValue(c.value || "", null, null, 'setfile');
                }
            }
            return this;
        },
        //for upload ,special must get the original node
        getUploadObj: function () {
            var profile = this.get(0), prop = profile.properties;
            if (profile.renderId && prop.type == 'file') {
                var o = profile.getSubNode('FILE').get(0);
                if (!o.value)
                    return null;

                var c = o.cloneNode(false);
                c.value = "";
                //inner replace
                ood.setNodeData(c.$xid = o.$xid, 'element', c);
                c.onclick = o.onclick;
                c.onchange = o.onchange;

                //remove those
                //if(ood.browser.ie)
                //    o.removeAttribute('$xid');
                //else
                //    delete o.$xid;
                //**: "removeAttribute" doesn't work in IE9+
                o.$xid = null;

                o.id = o.onclick = o.onchange = null;

                //a special node, must delete if from cache here:
                delete profile.$_domid[profile.keys['FILE']];
                ood([o]).addPrev(c).remove(false);
                c = null;

                this.setUIValue(this.getValue(), null, null, 'getfile');

                return o;
            }
        },
        popFileSelector: function (accept, multiple) {
            var profile = this.get(0), prop = profile.properties;
            if (profile.renderId && prop.type == 'file') {
                var input = profile.getSubNode('FILE'), fileInput = input.get(0);
                input.attr("accept", accept || prop.fileAccept || null);
                input.attr("multiple", multiple || prop.fileMultiple ? "multiple" : null);

                // for IE11
                if (ood.browser.ie11) {
                    var label = document.createElement("div");
                    fileInput.appendChild(label);
                    label.click();
                    fileInput.removeChild(label);
                } else {
                    fileInput.click();
                }
            }
        },

        ComboInputTrigger: function() {
            var profile = this.get(0);
            var prop = profile.properties

            // 
            // 
            if (prop.theme) {
                this.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('comboinput-theme');
                if (savedTheme) {
                    this.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                this.adjustLayout();
            }

            // 
            this.enhanceAccessibility();
        },

        // 
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    input = profile.getSubNode('INPUT'),
                    button = profile.getSubNode('BUTTON'),
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('comboinput-mobile');
                    
                    // 
                    input.css({
                        'padding': '0.6em 0.5em',
                        'font-size': '16px' // iOS
                    });
                    if (button && !button.isEmpty()) {
                        button.css({
                            'min-width': '2.5em',
                            'padding': '0.6em'
                        });
                    }
                } else {
                    root.removeClass('comboinput-mobile');
                    
                    // 
                    input.css({
                        'padding': '',
                        'font-size': ''
                    });
                    if (button && !button.isEmpty()) {
                        button.css({
                            'min-width': '',
                            'padding': ''
                        });
                    }
                }

                // 
                if (width < 480) {
                    root.addClass('comboinput-tiny');
                    
                    // 
                    var dropList = profile.getSubNode('DROPLIST');
                    if (dropList && !dropList.isEmpty()) {
                        dropList.css({
                            'max-height': '60vh'
                        });
                    }
                } else {
                    root.removeClass('comboinput-tiny');
                }
            });
        },
        
        // 
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var input = profile.getSubNode('INPUT'),
                    button = profile.getSubNode('BUTTON'),
                    dropList = profile.getSubNode('DROPLIST'),
                    properties = profile.properties;

                // ARIA
                if (input && !input.isEmpty()) {
                    input.attr({
                        'role': properties.type === 'combobox' ? 'combobox' : 'textbox',
                        'aria-label': properties.tips || properties.labelText || '',
                        'aria-describedby': properties.tips ? profile.serialId + '_tips' : null,
                        'aria-expanded': 'false'
                    });
                    
                    if (properties.type === 'combobox' || properties.type === 'listbox') {
                        input.attr({
                            'aria-autocomplete': 'list',
                            'aria-haspopup': 'listbox'
                        });
                    }
                }
                
                // ARIA
                if (button && !button.isEmpty()) {
                    button.attr({
                        'role': 'button',
                        'aria-label': '',
                        'tabindex': '0',
                        'aria-expanded': 'false'
                    });
                }

                // ARIA
                if (dropList && !dropList.isEmpty()) {
                    dropList.attr({
                        'role': 'listbox',
                        'aria-label': ''
                    });
                }
            });
        },
        resetValue: function (value) {
            this.each(function (p) {
                if (p.properties.type == 'file')
                    p.getSubNode('FILE').attr('value', '');
            });
            var upper = arguments.callee.upper,
                rtn = upper.apply(this, ood.toArr(arguments));
            upper = null;
            return rtn;
        },
        _drop: function (e, src, baseNode, ignoreEvent) {
            return this.each(function (profile) {
                var pro = profile.properties, type = pro.type, cacheDrop = pro.cachePopWnd;
                if (pro.disabled || pro.readonly) return;

                //open already
                if (profile.$poplink) return;
                var o, v, drop,
                    box = profile.boxing(),
                    main = profile.getSubNode('BOX'),
                    btn = profile.getSubNode('RBTN'),
                    pos = main.offset();
                pos.top += main.offsetHeight();

                //special cmd type: getter, 'cmdbox' and 'popbox'
                if ((!ignoreEvent && profile.beforeComboPop && false === box.beforeComboPop(profile, pos, e, src)))
                    return;

                // for standard drop
                if (type == 'combobox' || type == 'listbox' || type == 'helpinput'
                    || type == 'date'
                    || type == 'time'
                    || type == 'datetime'
                    || type == 'color') {

                    if (profile.__tryToHide) {
                        ood.clearTimeout(profile.__tryToHide);
                        delete profile.__tryToHide;
                    }

                    //get cache key
                    var cachekey;
                    if (cacheDrop) {
                        switch (type) {
                            case 'time':
                            case 'date':
                            case 'datetime':
                            case 'color':
                                cachekey = type;
                                break;
                            default:
                                if (pro.listKey)
                                //function no cache
                                    if (typeof ood.get(ood.$cache, ['UIDATA', pro.listKey]) == 'function')
                                        drop = cachekey = null;
                                    else
                                        cachekey = "!" + pro.listKey;
                                else
                                    cachekey = "$" + profile.$xid;
                        }
                        //get from global cache
                        if (cachekey) {
                            //filter first
                            ood.filter(profile.box.$drop, function (o) {
                                return !!o.renderId;
                            });
                            drop = profile.box.$drop[cachekey];
                        }
                    }

                    //cache pop
                    if (!drop) {
                        switch (type) {
                            case 'combobox':
                            case 'listbox':
                            case 'helpinput':
                                o = ood.create('List');
                                o.setHost(profile).setDirtyMark(false).setItems(ood.copy(pro.items)).setListKey(pro.listKey || '');
                                if (pro.dropListWidth) o.setWidth(pro.dropListWidth);
                                else o.setWidth(profile.$forceu(main.offsetWidth() + btn.offsetWidth()));

                                o.setHeight(pro.dropListHeight || 'auto');

                                o.afterClick(function () {
                                    if (!this.destroyed)
                                        this.boxing()._cache('', true);
                                    else
                                        o.destroy(true);
                                    return false;
                                });
                                o.beforeUIValueSet(function (p, ovalue, value) {
                                    var b2 = this.boxing();
                                    if (type == 'combobox') {
                                        var item = p.queryItems(p.properties.items, function (o) {
                                            return o.id == value
                                        }, false, true);
                                        if (item.length)
                                            value = item[0].caption;
                                    }
                                    //update value
                                    b2.setUIValue(value, null, null, 'pick');

                                    //cache pop
                                    return b2._cache('', true);
                                });
                                break;
                            case 'time':
                                o = ood.create('TimePicker');
                                o.setHost(profile);
                                o.beforeClose(function () {
                                    if (!this.destroyed)
                                        this.boxing()._cache('', true);
                                    return false
                                });
                                o.beforeUIValueSet(function (p, o, v) {
                                    var b2 = this.boxing();
                                    //update value
                                    b2.setUIValue(v, null, null, 'pick');
                                    return b2._cache('', true);
                                });
                                break;
                            case 'date':
                            case 'datetime':
                                o = ood.create('DatePicker');

                                if (type == 'datetime')
                                    o.setTimeInput(true);

                                o.setHost(profile);
                                o.beforeClose(function () {
                                    if (!this.destroyed)
                                        this.boxing()._cache('', true);
                                    else
                                        o.destroy(true);
                                    return false
                                });
                                o.beforeUIValueSet(function (p, o, v) {
                                    var b2 = this.boxing();
                                    //update value
                                    b2.setUIValue(String(v.getTime()), null, null, 'pick');
                                    return b2._cache('', true);
                                });

                                break;
                            case 'color':
                                o = ood.create('ColorPicker');
                                o.setHost(profile);
                                o.beforeClose(function () {
                                    if (!this.destroyed)
                                        this.boxing()._cache('', true);
                                    else
                                        o.destroy(true);
                                    return false
                                });
                                o.beforeUIValueSet(function (p, o, v) {
                                    var b2 = this.boxing();
                                    //update value
                                    b2.setUIValue((v == 'transparent' ? '' : '#') + v, null, null, 'pick');
                                    return b2._cache('', true);
                                });
                                break;
                        }
                        if (ood.isHash(pro.popCtrlProp) && !ood.isEmpty(pro.popCtrlProp))
                            o.setProperties(pro.popCtrlProp);
                        if (ood.isHash(pro.popCtrlEvents) && !ood.isEmpty(pro.popCtrlEvents))
                            o.setEvents(pro.popCtrlEvents);

                        drop = o.get(0);

                        //set to global cache
                        if (cachekey)
                            profile.box.$drop[cachekey] = drop;

                        o.render();
                    }

                    o = drop.boxing();
                    o.setHost(profile);

                    //set pop
                    switch (type) {
                        case 'combobox':
                        case 'listbox':
                        case 'helpinput':
                        case 'time':
                            o.setValue(profile.properties.$UIvalue, true, 'pop');
                            break;
                        case 'date':
                        case 'datetime':
                            var t = drop.properties;
                            if (t = profile.properties.$UIvalue)
                                o.setValue(new Date(parseInt(t, 10)), true, 'pop');
                            break;
                        case 'color':
                            o.setValue(profile.properties.$UIvalue.replace('#', ''), true, 'pop');
                            break;
                    }

                    profile.boxing().setPopWnd(o);

                    if (!ignoreEvent && profile.beforePopShow && false === box.beforePopShow(profile, drop, profile.properties.items))
                        return;
                    //pop
                    var node = o.reBoxing(), pid = pro.parentID || ood.ini.$rootContainer;
                    node.popToTop(baseNode || profile.getSubNode('BOX'), null,
                        pid ? ood.get(profile, ["host", pid]) ? profile.host[pid].getContainer() : ood(pid) : null);

                    ood.tryF(o.activate, [], o);

                    //for on blur disappear
                    var sid = profile.key + ":" + profile.$xid;
                    node.setBlurTrigger(sid, function () {
                        box._cache('blur');
                        ood.Event.keyboardHook('esc', 0, 0, 0, sid);
                    });

                    //for esc
                    ood.Event.keyboardHook('esc', 0, 0, 0, function () {
                        profile.$escclosedrop = 1;
                        ood.asyRun(function () {
                            delete profile.$escclosedrop;
                        });

                        box.activate();
                        box._cache('esc', true);

                        //unhook
                        ood.Event.keyboardHook('esc', 0, 0, 0, sid);
                        return false;
                    }, sid, null, null, profile.domId);
                } else if (type == 'file') {
                    profile.boxing().popFileSelector();
                }

                if (!ignoreEvent && profile.afterPopShow)
                    box.afterPopShow(profile, drop);
            });
        },
        expand: function (node, ignoreEvent, e) {
            var profile = this.get(0);
            if (profile.renderId)
                profile.boxing()._drop(e, node, node, ignoreEvent);
        },
        collapse: function () {
            var profile = this.get(0);
            if (profile.renderId && profile.$poplink)
                profile.boxing()._cache('call');
        },
        getPopWnd: function () {
            var profile = this.get(0);
            if (profile && profile.$poplink)
                return profile.$poplink.boxing();
        }
    },
    /*Initialize*/
    Initialize: function () {
        var ns = this;
        ns.addTemplateKeys(['ICONB', 'ICON', 'UNIT', 'FILE', 'LMID', 'RMID', 'LBTN', 'RBTN', 'SPINBTN', 'R1', 'R1B', 'R2', 'R2B']);
        //modify default template for shell
        var t = ns.getTemplate();
        ood.merge(t.FRAME.BORDER, {
            LBTN: {},
            RBTN: {},
            SPINBTN: {R1: {}, R2: {}},
            CMD: {
                $order: 50,
                tagName: 'button',
                className: 'ood-ui-unselectable ood-uiborder-radius-tr ood-uiborder-radius-br ood-uiborder-noradius-l ood-nofocus ood-ui-btn ood-uibar ood-uigradient',
                style: "{_cmdDisplay}",
                SMID: {
                    className: "oodfont",
                    $fonticon: '{_fi_commandCls}'
                }
            }
        }, 'all');
        var box = t.FRAME.BORDER.BOX;
        box.className = 'ood-ui-input ood-ui-shadow-input ood-uiborder-flat ood-uibase {_radius_input} ';
        box.ICONB = {
            tagName: 'button',
            className: 'ood-ui-unselectable ood-nofocus ood-ui-clear',
            tabindex: '-1',
            ICON: {
                className: 'oodfont {imageClass}  {picClass}',
                //for cover oodcon
                style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{imageDisplay}{iconStyle}',
                text: '{iconFontCode}'
            }
        };
        box.UNIT = {
            tagName: 'button',
            tabindex: '-1',
            className: 'ood-ui-unselectable ood-nofocus',
            text: '{unit}'
        };

        t.FRAME.POOL = {};
        t.className += ' {typecls}';

        ns.setTemplate(t);
        ns._adjustItems = ood.absList._adjustItems;

        var a = ns.prototype, b = ood.absList.prototype;
        a.getItems = b.getItems;
        a.getItemByItemId = b.getItemByItemId;
    },
    Static: {
        _beforeResetValue: function (profile) {
            profile.properties.caption = undefined;
        },
        _iniType: function (profile) {
            var pro = profile.properties, type = pro.type, c = profile.box;
            delete profile.$beforeKeypress;
            delete profile.$inputReadonly;
            delete profile.$isNumber;
            delete profile.$compareValue;
            delete profile.$getShowValue;
            delete profile.$toEditor;
            delete profile.$fromEditor;
            delete profile.$typeOK;

            if (type == 'listbox' || type == 'file' || type == 'cmdbox' || type == 'button' || type == 'dropbutton')
                profile.$inputReadonly = true;

            if (type == 'file')
                profile.$oodFileCtrl = true;

            if (type != 'listbox' && type != 'combobox' && type != 'helpinput')
                pro.items = [];

            if (type == 'time') {
                var keymap = {a: 1, c: 1, v: 1, x: 1};
                ood.merge(profile, {
                    $beforeKeypress: function (p, c, k) {
                        return k.key.length != 1 || /[-0-9:]/.test(k.key) || (k.ctrlKey && !!keymap[k.key]);
                    },
                    $getShowValue: function (p, v) {
                        return v ? ood.UI.TimePicker._ensureValue(p, v) : '';
                    },
                    $fromEditor: function (p, v) {
                        if (v) {
                            v = ood.UI.TimePicker._ensureValue(p, v);
                            if (v == '00:00') v = p.properties.$UIvalue;
                        }
                        return v;
                    }
                }, 'all');
            } else if (type == 'date' || type == 'datetime') {
                var date = ood.Date;
                var keymap = {a: 1, c: 1, v: 1, x: 1};
                ood.merge(profile, {
                    $beforeKeypress: function (p, c, k) {
                        return k.key.length != 1 || /[0-9:/\-_ ]/.test(k.key) || (k.ctrlKey && !!keymap[k.key]);
                    },
                    $compareValue: function (p, a, b) {
                        return (!a && !b) || (String(a) == String(b))
                    },
                    $getShowValue: function (p, v) {
                        if (p.properties.dateEditorTpl)
                            return v ? date.format(v, p.properties.dateEditorTpl) : '';
                        else
                            return v ? date.getText(new Date(parseInt(v, 10)), p.properties.type == 'datetime' ? 'ymdhn' : 'ymd') : '';
                    },
                    $toEditor: function (p, v) {
                        if (!v) return "";

                        v = new Date(parseInt(v, 10) || 0);
                        if (p.properties.dateEditorTpl)
                            return date.format(v, p.properties.dateEditorTpl);
                        else {
                            var m = (date.get(v, 'm') + 1) + '', d = date.get(v, 'd') + '', h = date.get(v, 'h') + '',
                                n = date.get(v, 'n') + '';
                            return date.get(v, 'y') + '-' + (m.length == 1 ? '0' : '') + m + '-' + (d.length == 1 ? '0' : '') + d

                                + (p.properties.type == 'datetime' ? (" " + (h.length == 1 ? '0' : '') + h + ":" + (n.length == 1 ? '0' : '') + n) : "");
                        }
                    },
                    $fromEditor: function (p, v) {
                        if (v) {
                            if (p.properties.dateEditorTpl)
                                v = date.parse(v, p.properties.dateEditorTpl);
                            else
                                v = ood.Date.parse(v);
                            // set to old UIvalue
                            if (!v) {
                                v = p.properties.$UIvalue;
                                if (ood.isFinite(v)) v = new Date(parseInt(v, 10));
                            }
                            if (v) {
                                if (p.properties.type != 'datetime')
                                    v = date.getTimSpanStart(v, 'd', 1);
                                // min/max year
                                if (v.getFullYear() < p.properties.min)
                                    v.setTime(p.properties.min);
                                if (v.getFullYear() > p.properties.max)
                                    v.setTime(p.properties.max);
                            }
                        }
                        return v ? String(v.getTime()) : '';
                    }
                }, 'all');
            } else if (type == 'currency') {
                profile.$isNumber = 1;
                var keymap = {a: 1, c: 1, v: 1, x: 1};
                ood.merge(profile, {
                    $beforeKeypress: function (p, c, k) {
                        return k.key.length != 1 || /[-0-9,. ]/.test(k.key) || (k.ctrlKey && !!keymap[k.key]);
                    },
                    $compareValue: function (p, a, b) {
                        return ((a === '' && b !== '') || (b === '' && a !== '')) ? false : p.box._number(p, a) == p.box._number(p, b)
                    },
                    $getShowValue: function (p, v) {
                        var pp = p.properties;
                        if (ood.isSet(v) && v !== "") {
                            v = ood.formatNumeric(p.box._number(p, v), pp.precision, pp.groupingSeparator, pp.decimalSeparator, pp.forceFillZero, pp.trimTailZero);
                            if (p.properties.currencyTpl)
                                v = p.properties.currencyTpl.replace("*", v);
                        } else
                            v = "";
                        return v;
                    },
                    $toEditor: function (p, v) {
                        var pp = p.properties;
                        return (ood.isSet(v) && v !== "") ? ood.formatNumeric(p.box._number(p, v), pp.precision, pp.groupingSeparator, pp.decimalSeparator, pp.forceFillZero, pp.trimTailZero) : "";
                    },
                    $fromEditor: function (p, v) {
                        return (ood.isSet(v) && v !== "") ? p.box._number(p, v) : "";
                    }
                }, 'all');
            } else if (type == 'number' || type == 'spin' || type == 'counter') {
                profile.$isNumber = 1;
                var keymap = {a: 1, c: 1, v: 1, x: 1};
                ood.merge(profile, {
                    $beforeKeypress: function (p, c, k) {
                        return k.key.length != 1 || /[-0-9. ]/.test(k.key) || (k.ctrlKey && !!keymap[k.key]);
                    },
                    $compareValue: function (p, a, b) {
                        return ((a === '' && b !== '') || (b === '' && a !== '')) ? false : p.box._number(p, a) == p.box._number(p, b)
                    },
                    $getShowValue: function (p, v) {
                        var pp = p.properties;
                        v = (ood.isSet(v) && v !== "") ? ood.formatNumeric(p.box._number(p, v), pp.precision, pp.groupingSeparator, pp.decimalSeparator, pp.forceFillZero, pp.trimTailZero) : "";
                        if (v != "" && p.properties.numberTpl)
                            v = p.properties.numberTpl.replace("*", v);
                        return v;
                    },
                    $toEditor: function (p, v) {
                        var pp = p.properties;
                        return (ood.isSet(v) && v !== "") ? ood.formatNumeric(p.box._number(p, v), pp.precision, pp.groupingSeparator, pp.decimalSeparator, pp.forceFillZero, pp.trimTailZero) : "";
                    },
                    $fromEditor: function (p, v) {
                        return (ood.isSet(v) && v !== "") ? p.box._number(p, v) : "";
                    }
                }, 'all');
            }

            if (pro.value)
                pro.$UIvalue = pro.value = c._ensureValue(profile, pro.value);

            profile.$typeOK = true;
        },
        $drop: {},
        Appearances: {
            POOL: {
                position: 'absolute',
                left: 0,
                top: 0,
                width: 0,
                height: 0,
                display: 'none',
                visibility: 'hidden'
            },
            FILE: {
                visibility: 'hidden',
                'z-index': 30,
                border: 0,
                width: '100%',
                height: '100%',
                position: 'absolute',
                padding: 0,
                top: 0,
                right: 0,
                cursor: 'pointer',
                overflow: 'hidden'
            },
            'KEY-type-number INPUT, KEY-type-spin INPUT, KEY-type-counter INPUT, KEY-type-currency INPUT': {
                $order: 4,
                'text-align': 'right'
            },
            'KEY-type-counter INPUT': {
                $order: 4,
                'text-align': 'center'
            },
            'KEY-type-file INPUT, KEY-type-button INPUT, KEY-type-dropbutton INPUT, KEY-type-cmdbox INPUT, KEY-type-listbox INPUT': {
                $order: 4,
                cursor: 'pointer',
                'text-align': 'left',
                'white-space': 'normal',
                overflow: 'hidden'
            },
            'KEY-type-button INPUT, KEY-type-dropbutton INPUT': {
                $order: 5,
                'text-align': 'center'
            },
            'LBTN,RBTN,SPINBTN,CMD': {
                display: 'block',
                'z-index': 20,
                cursor: 'pointer',
                padding: 0,
                position: 'absolute',
                width: '1.5em',

                // for IE8
                overflow: 'visible'
            },
            'ICONB, UNIT': {
                'z-index': 20,
                cursor: 'pointer',
                position: 'absolute',
                padding: 0,
                margin: 0,
                border: 0,
                background: 'none',
                height: '100%',
                padding: '0 2px',

                // for IE67
                display: ood.$inlineBlock,
                zoom: ood.browser.ie67 ? 1 : null,
                width: (ood.browser.ie && ood.browser.ver <= 7) ? 'auto' : null,
                'overflow': (ood.browser.ie && ood.browser.ver <= 7) ? 'visible' : null
            },
            ICONB: {
                left: 0,
                top: 0
            },
            ICON: {
                // for right size in onresize
                'color': 'var(--text-input)  !important',
                width: '1em'
            },
            UNIT: {
                top: 0,
                right: 0
            },
            CMD: {
                $order: 2,
                'z-index': 22,
                padding: 0
            },
            'R1,R2': {
                $order: 1,
                display: 'block',
                cursor: 'pointer',
                padding: 0,
                position: 'absolute',
                height: '50%',
                width: '1.5em',

                // for IE8
                overflow: 'visible'
            },

            INPUT: {
                $order: 100,
                'padding-left': '1em',
                'background-color': 'var(--bg-input) !important',
                'color': 'var(--text-input)  !important'
            },

            R1: {
                top: 0
            },
            R2: {
                bottom: 0
            },
            'R1B,R2B': {
                cursor: 'pointer',
                position: 'absolute',
                left: 0,
                top: '50%',
                height: '6px',
                'margin-top': '-2px',
                padding: 0,
                'z-index': 2
            },
            'SMID,LMID,RMID': {
                $order: 2,
                cursor: 'pointer',
                padding: 0,
                left: 0
            }
        },

        _objectProp: {popCtrlProp: 1, popCtrlEvents: 1},
        Behaviors: {
            HoverEffected: {BOX: 'BOX', ICON: 'ICON', ICONB: 'ICONB'},
            ClickEffected: {BOX: 'BOX'},
            ICONB: {
                onClick: function (profile, e, src) {
                    var prop = profile.properties;
                    if (prop.disabled || prop.readonly) return;
                    if (profile.onClickIcon) profile.boxing().onClickIcon(profile, src);
                }
            },
            UNIT: {
                onClick: function (profile, e, src) {
                    var prop = profile.properties;
                    if (prop.disabled || prop.readonly) return;
                    if (!prop.units) return;
                    var o = ood.create('List', {
                        dirtyMark: false,
                        items: prop.units.split(/[,;\:]/),
                        width: 'auto',
                        height: 'auto',
                        value: prop.unit
                    });
                    o.afterClick(function () {
                        o.destroy(true);
                        return false;
                    });
                    o.beforeUIValueSet(function (p, o, v) {
                        profile.boxing().setUnit(ood.str.trim(v));
                    });
                    o.render();
                    //pop
                    var node = o.reBoxing(), pid = prop.parentID || ood.ini.$rootContainer;
                    node.popToTop(src, null,
                        pid ? ood.get(profile, ["host", pid]) ? profile.host[pid].getContainer() : ood(pid) : null);
                    ood.tryF(o.activate, [], o);
                    var sid = profile.key + ":unit:" + profile.$xid;
                    node.setBlurTrigger(sid, function () {
                        o.destroy();
                        ood.Event.keyboardHook('esc', 0, 0, 0, sid);
                    });
                    ood.Event.keyboardHook('esc', 0, 0, 0, function () {
                        o.destroy();
                        ood.Event.keyboardHook('esc', 0, 0, 0, sid);
                        return false;
                    }, sid, null, null, profile.domId);
                }
            },
            FILE: {
                onClick: function (profile, e, src) {
                    var prop = profile.properties;
                    if (prop.disabled || prop.readonly) return;
                    if (profile.onFileDlgOpen) profile.boxing().onFileDlgOpen(profile, src);
                },
                onChange: function (profile, e, src) {
                    var prop = profile.properties,
                        input = ood.use(src).get(0),
                        value = input.value + '';
                    if (prop.type == 'file') {
                        var arr = [];
                        for (var i = 0, f = input.files, l = f.length; i < l; i++) arr.push(f[i].name);
                        value = arr.length ? '"' + arr.join('", "') + '"' : '';
                    }
                    profile.boxing().setUIValue(value, null, null, 'onchange');
                }
            },
            LBTN: {
                onMousedown: function (profile) {
                    var prop = profile.properties;
                    if (prop.disabled || prop.readonly) return;
                    profile.box._spin(profile, false);
                },
                onMouseout: function (profile) {
                    ood.Thread.abort(profile.$xid + ':spin');
                },
                onMouseup: function (profile) {
                    ood.Thread.abort(profile.$xid + ':spin');
                }
            },
            RBTN: {
                onMousedown: function (profile) {
                    var prop = profile.properties, type = prop.type;
                    if (type != 'counter') return;

                    if (prop.disabled || prop.readonly) return;
                    profile.box._spin(profile, true);
                },
                onMouseout: function (profile) {
                    if (profile.properties.type != 'counter') return;
                    ood.Thread.abort(profile.$xid + ':spin');
                },
                onMouseup: function (profile) {
                    if (profile.properties.type != 'counter') return;
                    ood.Thread.abort(profile.$xid + ':spin');
                },
                onClick: function (profile, e, src) {
                    var prop = profile.properties, type = prop.type;
                    if (type == 'counter') return;

                    if (type == 'popbox' || type == 'cmdbox' || type == 'listbox' || type == 'getter' || type == 'dropbutton') {
                        if (profile.onClick && false === profile.boxing().onClick(profile, e, src, 'right', prop.$UIvalue))
                            return;
                    }
                    if (type == 'file') {
                        profile.boxing().popFileSelector();
                        return;
                    }

                    if (prop.disabled || prop.readonly) return;
                    profile.boxing()._drop(e, src);
                    return false;
                }
            },
            CMD: {
                onClick: function (profile, e, src) {
                    var prop = profile.properties;
                    if (prop.disabled || prop.readonly) return;
                    if (profile.onCommand && false === profile.boxing().onCommand(profile, src, prop.commandBtn))
                        return;
                    if (prop.commandBtn == 'delete' || prop.commandBtn == 'remove')
                        profile.boxing().setUIValue('', true, null, 'cmd');
                }
            },
            BOX: {
                onClick: function (profile, e, src) {
                    var prop = profile.properties;
                    if (prop.type == 'cmdbox' || prop.type == 'button' || prop.type == 'dropbutton') {
                        if (profile.onClick)
                            profile.boxing().onClick(profile, e, src, 'left', prop.$UIvalue);
                        //DOM node's readOnly
                    } else if (prop.inputReadonly || profile.$inputReadonly) {
                        if (prop.disabled || prop.readonly) return;
                        profile.boxing()._drop(e, src);
                    }
                }
            },
            INPUT: {
                onClick: function (profile, e, src) {
                    // for grid cell editor 'enter' bug: trigger list pop again
                    if (profile.onClick) {
                        var prop = profile.properties;
                        profile.boxing().onClick(profile, e, src, 'left', prop.$UIvalue);
                    }

                    if (e.$cell) {
                        e = ood.Event.getPos(e);
                        if (e.left === 0 && e.top === 0) return false;
                    }
                },
                onChange: function (profile, e, src) {
                    if (profile.$_onedit || profile.$_inner || profile.destroyed || !profile.box) return;
                    var o = profile._inValid,
                        p = profile.properties, b = profile.box,
                        instance = profile.boxing(),
                        v = instance._fromEditor(ood.use(src).get(0).value),
                        uiv = p.$UIvalue;
                    if (!instance._compareValue(uiv, v)) {
                        //give a invalid value in edit mode
                        if (v === null)
                            instance._setCtrlValue(uiv);
                        else {
                            // trigger events
                            instance.setUIValue(v, null, null, 'onchange');
                            // input/textarea is special, ctrl value will be set before the $UIvalue
                            if (p.$UIvalue !== v) instance._setCtrlValue(p.$UIvalue);
                            if (o !== profile._inValid) if (profile.renderId) instance._setDirtyMark();
                        }
                    }
                    b._asyCheck(profile);
                },
                onKeyup: function (profile, e, src) {
                    var p = profile.properties, b = profile.box,
                        key = ood.Event.getKey(e);
                    if (p.disabled || p.readonly) return false;
                    if (profile.$inputReadonly || p.inputReadonly) return;

                    // must be key up event
                    if (key.key == 'esc') {
                        if (profile.$escclosedrop) {
                            return;
                        }

                        profile.boxing()._setCtrlValue(p.$UIvalue);
                        if (profile.onCancel)
                            profile.boxing().onCancel(profile);
                    }

                    if (p.dynCheck) {
                        var value = ood.use(src).get(0).value;
                        profile.box._checkValid(profile, value);
                        profile.boxing()._setDirtyMark();
                    }
                    b._asyCheck(profile);

                    if (key.key == 'down' || key.key == 'up') {
                        if (p.type == 'spin' || p.type == 'counter') {
                            ood.Thread.abort(profile.$xid + ':spin');
                            return false;
                        }
                    }
                },
                onMousedown: function (profile, e, src) {
                    profile._mousedownmark = 1;
                    ood.asyRun(function () {
                        if (profile) delete profile._mousedownmark;
                    });
                },
                onMouseup: function (profile, e, src) {
                    if (profile.properties.selectOnFocus && profile._stopmouseupcaret) {
                        var node = ood.use(src).get(0);
                        if (!node.readOnly && node.select) {
                            profile.$mouseupDelayFun = ood.asyRun(function () {
                                delete profile.$mouseupDelayFun;
                                if (node.tagName.toLowerCase() == "input" || !/[\n\r]/.test(node.value)) node.select();
                            })
                        }
                        delete profile._stopmouseupcaret;
                    }
                },
                onFocus: function (profile, e, src) {
                    if (profile.$ignoreFocus) return false;
                    if (profile.beforeFocus && false === profile.boxing().beforeFocus(profile)) {
                        profile.$ignoreBlur = 1;
                        ood(src).blur();
                        delete profile.$ignoreBlur;
                        return false;
                    }
                    var p = profile.properties, b = profile.box;
                    if (p.disabled || p.readonly) return false;
                    if (profile.onFocus) profile.boxing().onFocus(profile);
                    if (profile.$inputReadonly || p.inputReadonly) return;
                    profile.getSubNode('BORDER').tagClass('-focus');

                    var instance = profile.boxing(),
                        uiv = p.$UIvalue,
                        v = instance._toEditor(uiv),
                        node = ood.use(src).get(0),
                        nodev = node.value;

                    // if _toEditor adjust value, ensure node value
                    if (uiv !== v && nodev !== v) {
                        profile.$_onedit = true;
                        node.value = v;
                        delete profile.$_onedit;
                    }

                    //if no value, add mask
                    if (p.mask) {
                        var value = node.value;
                        if (!value) {
                            profile.$focusDelayFun = ood.asyRun(function () {
                                // destroyed
                                if (!profile.box) return;
                                delete profile.$focusDelayFun;
                                profile.$_onedit = true;
                                profile.boxing()._setCtrlValue(value = profile.$Mask);
                                delete profile.$_onedit;
                                b._setCaret(profile, node);
                            });
                        }
                    }
                    if (p.selectOnFocus && !node.readOnly && node.select) {
                        if (ood.browser.kde) {
                            profile.$focusDelayFun2 = ood.asyRun(function () {
                                delete profile.$focusDelayFun2;
                                if (node.tagName.toLowerCase() == "input" || !/[\n\r]/.test(node.value)) node.select();
                            });
                        } else {
                            if (node.tagName.toLowerCase() == "input" || !/[\n\r]/.test(node.value)) node.select();
                        }
                        // if focus was triggerred by mousedown, try to stop mouseup's caret
                        if (profile._mousedownmark) profile._stopmouseupcaret = 1;
                    }
                    //show tips color
                    profile.boxing()._setTB(3);

                    b._asyCheck(profile);
                },
                onBlur: function (profile, e, src) {
                    if (profile.$ignoreBlur) return false;
                    ood.resetRun(profile.$xid + ":asycheck");
                    if (profile.$focusDelayFun) ood.clearTimeout(profile.$focusDelayFun);
                    if (profile.$focusDelayFun2) ood.clearTimeout(profile.$focusDelayFun2);
                    if (profile.$focusDelayFun2) ood.clearTimeout(profile.$mouseupDelayFun);

                    var p = profile.properties;
                    if (p.disabled || p.readonly) return false;
                    if (profile.onBlur) profile.boxing().onBlur(profile);
                    if (profile.$inputReadonly || p.inputReadonly) return;

                    var b = profile.box,
                        instance = profile.boxing(),
                        uiv = p.$UIvalue,
                        v = ood.use(src).get(0).value;

                    if (profile.$Mask && profile.$Mask == v) {
                        v = "";
                        uiv = profile.$Mask;
                    }
                    v = instance._fromEditor(v);

                    profile.getSubNode('BORDER').tagClass('-focus', false);

                    //onblur check it
                    if (instance._compareValue(p.$UIvalue, v)) {
                        profile.box._checkValid(profile, v);
                        instance._setCtrlValue(uiv);
                    }
                    instance._setDirtyMark();
                    b._asyCheck(profile, false);
                },
                onKeydown: function (profile, e, src) {
                    var p = profile.properties;
                    if (p.disabled || p.readonly) return;
                    var b = profile.box,
                        m = p.multiLines,
                        evt = ood.Event,
                        k = evt.getKey(e);

                    //fire onchange first
                    if (k.key == 'enter' && (!m || k.altKey) && !p.inputReadonly && !profile.$inputReadonly) {
                        profile.$_onedit = true;
                        profile.boxing().setUIValue(profile.boxing()._fromEditor(ood.use(src).get(0).value), true, null, 'enter');
                        profile.$_onedit = false;
                    }

                    b._asyCheck(profile);

                    if (p.mask) {
                        if (k.key.length > 1) profile.$ignore = true;
                        else delete profile.$ignore;
                        switch (k.key) {
                            case 'backspace':
                                b._changeMask(profile, ood.use(src).get(0), '', false);
                                return false;
                            case 'delete':
                                b._changeMask(profile, ood.use(src).get(0), '');
                                return false;
                        }
                    }

                    if (k.key == 'down' || k.key == 'up') {
                        if (p.type == 'spin' || p.type == 'counter') {
                            if (!k.ctrlKey) {
                                profile.box._spin(profile, k.key == 'up');
                                return false;
                            }
                        } else if (k.ctrlKey && p.type != 'none' && p.type != 'input' && p.type != 'password') {
                            profile.boxing()._drop(e, src);
                            return false;
                        }
                    }
                },
                onDblclick: function (profile, e, src) {
                    profile.getSubNode('RBTN').onClick(true);
                }
            },
            R1: {
                onMousedown: function (profile) {
                    var prop = profile.properties;
                    if (prop.disabled || prop.readonly) return;
                    profile.box._spin(profile, true);
                },
                onMouseout: function (profile) {
                    ood.Thread.abort(profile.$xid + ':spin');
                },
                onMouseup: function (profile) {
                    ood.Thread.abort(profile.$xid + ':spin');
                }
            },
            R2: {
                onMousedown: function (profile) {
                    var prop = profile.properties;
                    if (prop.disabled || prop.readonly) return;
                    profile.box._spin(profile, false);
                },
                onMouseout: function (profile) {
                    ood.Thread.abort(profile.$xid + ':spin');
                },
                onMouseup: function (profile) {
                    ood.Thread.abort(profile.$xid + ':spin');
                }
            }
        },
        EventHandlers: {
            onFileDlgOpen: function (profile, src) {
            },
            onCommand: function (profile, src, type) {
            },
            beforeComboPop: function (profile, pos, e, src) {
            },
            beforePopShow: function (profile, popCtl, items) {
            },
            afterPopShow: function (profile, popCtl) {
            },
            afterPopHide: function (profile, popCtl, type) {
            },
            onClick: function (profile, e, src, btn, value) {
            },
            onClickIcon: function (profile, src) {
            },
            beforeUnitUpdated: function (prfole, unit) {
            },
            afterUnitUpdated: function (prfole, unit) {
            }
        },
        DataModel: {
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark'],
                caption: ood.getResText("DataModel.theme") || "",
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                caption: ood.getResText("DataModel.responsive") || "",
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            cachePopWnd: {
                ini: true,
                caption: ood.getResText("DataModel.cachePopWnd") || ""
            },
            bindClass: {
                ini: "",
                caption: ood.getResText("DataModel.bindClass") || ""
            },
            expression: {
                ini: '',
                caption: ood.getResText("DataModel.expression") || "",
                action: function () {
                }
            },

            // allowed: yyyy,mm,dd,y,m,d
            // yyyy-mm-dd
            // yyyy/mm/dd

            filter: {
                ini: "",
                caption: ood.getResText("DataModel.filter") || ""
            },
            itemsExpression: {
                ini: "",
                caption: ood.getResText("DataModel.itemsExpression") || ""
            },
            dateEditorTpl: {
                ini: "",
                caption: ood.getResText("DataModel.dateEditorTpl") || ""
            },
            groupingSeparator: {
                ini: ",",
                caption: ood.getResText("DataModel.groupingSeparator") || ""
            },
            decimalSeparator: {
                ini: ".",
                caption: ood.getResText("DataModel.decimalSeparator") || ""
            },
            forceFillZero: {
                ini: true,
                caption: ood.getResText("DataModel.forceFillZero") || ""
            },
            trimTailZero: {
                ini: false,
                caption: ood.getResText("DataModel.trimTailZero") || ""
            },
            parentID: {
                ini: "",
                caption: ood.getResText("DataModel.parentID") || "ID"
            },
            enumClass: {
                ini: "",
                caption: ood.getResText("DataModel.enumClass") || ""
            },
            popCtrlProp: {
                ini: {},
                caption: ood.getResText("DataModel.popCtrlProp") || ""
            },
            popCtrlEvents: {
                ini: {},
                caption: ood.getResText("DataModel.popCtrlEvents") || ""
            },
            image: {
                format: 'image',
                caption: ood.getResText("DataModel.image") || "",
                action: function () {
                    ood.UI.$iconAction(this);
                    this.boxing().reLayout(true);
                }
            },
            imagePos: {
                caption: ood.getResText("DataModel.imagePos") || "",
                action: function (value) {
                    this.getSubNode('ICON').css('backgroundPosition', value || 'center');
                }
            },
            imageBgSize: {
                caption: ood.getResText("DataModel.imageBgSize") || "",
                action: function (value) {
                    this.getSubNode('ICON').css('backgroundSize', value || '');
                }
            },
            imageClass: {
                ini: '',
                caption: ood.getResText("DataModel.imageClass") || "",
                action: function (v, ov) {
                    ood.UI.$iconAction(this, 'ICON', ov);
                    this.boxing().reLayout(true);
                }
            },
            iconFontCode: {
                caption: ood.getResText("DataModel.iconFontCode") || "",
                action: function (v) {
                    ood.UI.$iconAction(this);
                    this.boxing().reLayout(true);
                }
            },
            dropImageClass: {
                caption: ood.getResText("DataModel.dropImageClass") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            unit: {
                ini: "",
                caption: ood.getResText("DataModel.unit") || "",
                set: function (v) {
                    var ns = this;
                    if (ns.beforeUnitUpdated && false === ns.boxing().beforeUnitUpdated(ns, v))
                        return;
                    ns.properties.unit = v;
                    if (ns.renderId) {
                        ns.getSubNode('UNIT').html(v);
                        ns.boxing().reLayout(true);
                    }
                    if (ns.afterUnitUpdated) ns.boxing().afterUnitUpdated(ns, v);
                }
            },
            units: {
                ini: '',
                caption: ood.getResText("DataModel.units") || ""
            },
            numberTpl: {
                ini: "",
                caption: ood.getResText("DataModel.numberTpl") || "",
                action: function () {
                    this.boxing().setUIValue(this.properties.$UIvalue, true, null, 'tpl');
                }
            },
            currencyTpl: {
                ini: "$ *",
                caption: ood.getResText("DataModel.currencyTpl") || "",
                action: function () {
                    this.boxing().setUIValue(this.properties.$UIvalue, true, null, 'tpl');
                }
            },
            listKey: {
                caption: ood.getResText("DataModel.listKey") || "",
                set: function (value) {
                    var t = ood.UI.getCachedData(value),
                        o = this;
                    o.boxing().setItems(t ? ood.clone(t) : o.properties.items);
                    o.properties.listKey = value;
                }
            },
            dropListWidth: {
                ini: 0,
                caption: ood.getResText("DataModel.dropWidth") || ""
            },
            dropListHeight: {
                ini: 0,
                caption: ood.getResText("DataModel.dropHeight") || ""
            },
            items: {
                ini: [],
                caption: ood.getResText("DataModel.items") || "",
                set: function (value) {
                    var o = this;
                    value = o.properties.items = o.box._adjustItems(value);
                    if (o.renderId) {
                        //clear those
                        o.SubSerialIdMapItem = {};
                        o.ItemIdMapSubSerialId = {};
                        o.box._prepareItems(o, value);

                        // if popped
                        if (o.$poplink && o.$poplink.box)
                            o.$poplink.boxing().setItems(value);
                        else
                            o.boxing().clearPopCache();
                    }
                }
            },
            type: {
                ini: 'combobox',
                listbox: ood.toArr('none,input,password,combobox,listbox,file,getter,helpinput,button,dropbutton,cmdbox,popbox,date,time,datetime,color,spin,counter,currency,number'),
                caption: ood.getResText("DataModel.type") || "",
                set: function (value) {
                    var pro = this;
                    pro.properties.type = value;
                    if (pro.renderId)
                        pro.boxing().refresh(true);
                }
            },
            showMode: {
                ini: 'normal',
                listbox: ['', 'normal', 'compact', 'transparent'],
                caption: ood.getResText("DataModel.displayMode") || "",
                action: function () {
                    this.boxing().refresh()
                }
            },
            // for number&currency
            precision: {
                ini: 2,
                caption: ood.getResText("DataModel.precision") || ""
            },
            increment: {
                ini: 0.01,
                caption: ood.getResText("DataModel.increment") || ""
            },
            min: {
                ini: -Math.pow(10, 15),
                caption: ood.getResText("DataModel.minValue") || ""
            },
            // big number for date
            max: {
                ini: Math.pow(10, 15),
                caption: ood.getResText("DataModel.maxValue") || ""
            },
            commandBtn: {
                ini: "none",
                combobox: ood.toArr("none,save,delete,add,remove,pop,select,search,function"),
                caption: ood.getResText("DataModel.cmdButtons") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            disabled: {
                ini: false,
                caption: ood.getResText("DataModel.disabled") || "",
                action: function (v) {
                    this.box._handleInput(this, "ood-ui-disabled", v);
                }
            },
            inputReadonly: {
                ini: false,
                caption: ood.getResText("DataModel.inputReadonly") || "",
                action: function (v) {
                    this.box._handleInput(this, "ood-ui-inputreadonly", v);
                }
            },
            readonly: {
                ini: false,
                caption: ood.getResText("DataModel.readonly") || "",
                action: function (v) {
                    this.box._handleInput(this, "ood-ui-readonly", v);
                }
            },
            // caption is for readonly comboinput(listbox/cmdbox are readonly)
            caption: {
                ini: null,
                caption: ood.getResText("DataModel.title") || "",
                set: function (v) {
                    var p = this.properties;
                    p.caption = v;

                    if (ood.isSet(v)) {
                        v = v + "";
                        p.caption = ood.adjustRes(v, false);
                    }
                    if (this.renderId) {
                        if (this.$inputReadonly || p.inputReadonly) {
                            this.getSubNode('INPUT').attr("value", this.boxing().getShowValue());
                        }
                    }
                },
                get: function () {
                    return this.boxing().getShowValue();
                }
            },
            fileAccept: {
                ini: "",
                caption: ood.getResText("DataModel.accept") || ""
            },
            fileMultiple: {
                ini: false,
                caption: ood.getResText("DataModel.multiple") || ""
        }
        },
        RenderTrigger: function () {
            var self = this,
                instance = self.boxing(),
                p = self.properties;
            self.box._iniType(self);

            if (p.readonly)
                instance.setReadonly(true, true);
            else if (p.inputReadonly){
                instance.setInputReadonly(true, true);
            }

                
            // 
            ood.asyRun(function(){
                if (self.boxing() && self.boxing().ComboInputTrigger){
                    self.boxing().ComboInputTrigger();
                }
            });

        },
        

        _spin: function (profile, flag) {
            if (profile.$inDesign) return;

            var id = profile.$xid + ':spin';
            if (ood.Thread.isAlive(id)) return;
            var prop = profile.properties,
                increment = Math.max(prop.increment, Math.pow(10, -prop.precision)),
                off = increment * (flag ? 1 : -1),
                task = {delay: 300},
                fun = function () {
                    if (profile.destroyed) return false;
                    var v = ((+prop.$UIvalue) || 0) + off;
                    v = (ood.isSet(v) && v !== "") ? ood.formatNumeric(profile.box._number(profile, v), prop.precision, prop.groupingSeparator, prop.decimalSeparator, prop.forceFillZero, prop.trimTailZero) : "";
                    profile.boxing().setUIValue(v, null, null, 'spin');
                    task.delay *= 0.9;
                };
            task.task = fun;
            ood.Thread(id, [task], 500, null, fun, null, true).start();
        },
        _dynamicTemplate: function (profile) {
            var properties = profile.properties,
                type = properties.type,
                multiLines = properties.multiLines,
                fileAccept = properties.fileAccept,
                fileMultiple = properties.fileMultiple,
                showMode = properties.showMode,
                hash = profile._exhash = "$" +
                    'multiLines:' + multiLines + ';' +
                    'type:' + type + ';' +
                    'mode:' + showMode + ';',
                template = profile.box.getTemplate(hash),
                adj = function (s) {
                    return (!showMode || showMode == 'normal') ? s : 'ood-ui-clear ' + s.replace(/\b(ood-ui-btn|ood-uibar|ood-uigradient|ood-uibase)\b/g, '');
                }

            properties.$UIvalue = properties.value;

            // set template dynamic
            if (!template) {
                template = ood.clone(profile.box.getTemplate());
                var t = template.FRAME.BORDER,
                    ip = t.BOX.WRAP.INPUT;

                delete t.LBTN;
                delete t.RBTN;
                delete t.SPINBTN;

                ip.tagName = 'input';
                ip.type = 'text';
                switch (type) {
                    case "none":
                    case "input":
                    case "number":
                    case "currency":
                        break;
                    case 'button':
                        ip.type = 'button';
                        break;
                    case 'password':
                        ip.type = 'password';
                        break;
                    // spin has spin buttons
                    case 'spin':
                        t.SPINBTN = {
                            $order: 20,
                            className: 'ood-ui-unselectable',
                            style: "{rDisplay}",
                            R1: {
                                tagName: 'button',
                                className: adj('ood-ui-btn ood-uibar ood-uigradient ood-nofocus {_radius_dropt}'),
                                R1B: {
                                    className: 'oodfont',
                                    $fonticon: 'ood-icon-smallup'
                                }
                            },
                            R2: {
                                tagName: 'button',
                                className: adj('ood-ui-btn ood-uibar ood-uigradient ood-nofocus {_radius_dropb}'),
                                R2B: {
                                    className: 'oodfont',
                                    $fonticon: 'ood-icon-smalldown'
                                }
                            }
                        };
                        break;
                    // following have RBTN button
                    case 'counter':
                        t.LBTN = {
                            $order: 1,
                            tagName: 'button',
                            className: adj('ood-ui-unselectable ood-ui-btn ood-uibar ood-uigradient ood-nofocus {_radius_dropl}'),
                            style: "{_btnlDisplay}",
                            LMID: {
                                className: 'oodfont',
                                $fonticon: '{_fi_btnlClass}',
                                style: '{_btnlStyle}'
                            }
                        };
                        break;
                    case 'file':
                        t.FILE = {
                            $order: 20,
                            className: 'ood-ui-unselectable  {_radius_dropr}',
                            tagName: 'input',
                            type: 'file',
                            accept: fileAccept || null,
                            multiple: fileMultiple ? "multiple" : null,
                            hidefocus: ood.browser.ie ? "hidefocus" : null,
                            size: '1'
                        };
                    case 'listbox':
                    case 'cmdbox':
                    case 'dropbutton':
                        t.className += ' ood-ui-noshadow';
                        ip.type = 'button';
                }
                if (type != 'none' && type != 'input' && type != 'password' && type != 'button' && type != 'spin' && type != 'currency' && type != 'number') {
                    t.RBTN = {
                        $order: 20,
                        tagName: 'button',
                        className: adj('ood-ui-unselectable ood-ui-btn ood-uibar ood-uigradient ood-nofocus {_radius_dropr}'),
                        style: "{_btnrDisplay}",
                        RMID: {
                            className: 'oodfont',
                            $fonticon: '{_fi_btnrClass}'
                        }
                    };
                }
                if (type == 'button' || type == 'dropbutton') {
                    t.BOX.className += ' ood-uigradient';
                }

                if (multiLines) {
                    switch (type) {
                        case 'none':
                        case 'input':
                        case 'getter':
                        case 'helpinput':
                        case 'popbox':
                        case 'number':
                        case 'combobox':
                            ip.tagName = 'textarea';
                            ip.className = '';
                            delete ip.type;
                    }
                }
                if (showMode && showMode != 'normal') {
                    if (showMode == 'transparent') t.BOX.className = '{_radius_input} ';
                    t.CMD.className = adj(t.CMD.className);
                }
                // set template
                profile.box.setTemplate(template, hash);
            }
            profile.template = template;
        },
        _handleInput: function (prf, cls, v) {
            var i = prf.getSubNode('INPUT');
            if (("" + i.get(0).type).toLowerCase() != 'button') {
                if (!v && (prf.properties.disabled || prf.properties.readonly || prf.$inputReadonly))
                    v = true;
                prf.getRoot()[v ? 'addClass' : 'removeClass'](cls);
                i.attr('readonly', v);
            }
        },
        _prepareData: function (profile) {
            var data = {},
                NONE = 'display:none',
                prop = profile.properties,
                type = prop.type,
                showMode = prop.showMode,
                arr = profile.box.$DataModel.commandBtn.combobox;
            data = arguments.callee.upper.call(this, profile, data);

            var tt = type, a, b, c = tt == 'counter';
            tt = (tt == 'combobox' || tt == 'listbox' || tt == 'dropbutton') ? 'arrowdrop' : tt;

            data._fi_btnlClass = "ood-icon-singleleft";
            data._fi_btnrClass = tt == 'counter' ? 'ood-icon-singleright' : (data.dropImageClass || ('ood-uicmd-' + tt));

            data._type = "text";

            data._cmdDisplay = (a = (!data.commandBtn) || data.commandBtn == 'none') ? NONE : '';
            data._fi_commandCls = (ood.arr.indexOf(arr, data.commandBtn) != -1 ? "ood-uicmd-" : "") + data.commandBtn;

            data._btnrDisplay = (b = type == 'none' || type == 'input' || type == 'password' || type == 'currency' || type == 'number' || type == 'button') ? NONE : '';
            data.typecls = profile.getClass('KEY', '-type-' + data.type);
            if (!showMode || showMode == 'normal') {
                data._radius_dropl = 'ood-uiborder-radius-tl ood-uiborder-radius-bl ood-uiborder-noradius-r';
                // lbtn + rbtn + cmd ?
                data._radius_input = (a && b) ? 'ood-uiborder-radius' : c ? 'ood-uiborder-noradius' : 'ood-uiborder-radius-tl ood-uiborder-radius-bl ood-uiborder-noradius-r';
                // rtbn?
                data._radius_dropr = a ? 'ood-uiborder-radius-tr ood-uiborder-radius-br ood-uiborder-noradius-l' : 'ood-uiborder-noradius';

                data._radius_dropt = a ? 'ood-uiborder-radius-tr ood-uiborder-noradius-l ood-uiborder-noradius-b' : 'ood-uiborder-noradius';
                data._radius_dropb = a ? 'ood-uiborder-radius-br ood-uiborder-noradius-l ood-uiborder-noradius-t' : 'ood-uiborder-noradius';
            } else if (showMode == 'compact') {
                data._radius_input = 'ood-uiborder-radius';
            }
            return data;
        },
        _ensureValue: function (profile, value) {
            var me = arguments.callee, prop = profile.properties;
            //if value is empty
            if (!ood.isSet(value) || value === '') return '';
            if (profile.$Mask && profile.$Mask == value) {
                value = '';
            }
            switch (profile.properties.type) {
                case 'date':
                case 'datetime':
                    var d;
                    if (value) {
                        if (ood.isDate(value))
                            d = value;
                        else if (ood.isFinite(value))
                            d = new Date(parseInt(value, 10));
                        else
                            d = ood.Date.parse(value + "");
                    }
                    return d ? String(profile.properties.type == 'datetime' ? d.getTime() : ood.Date.getTimSpanStart(d, 'd', 1).getTime()) : "";
                case 'color':
                    var c = ood.UI.ColorPicker._ensureValue(null, value);
                    return (c == "transparent" ? '' : '#') + c;
                case 'time':
                    return ood.UI.TimePicker._ensureValue(null, value);
                case 'currency':
                case 'number':
                case 'spin':
                case 'counter':
                    return this._number(profile, value);
                default:
                    return typeof value == 'string' ? value : (value || value === 0) ? String(value) : '';
            }
        },
        _number: function (profile, value) {
            var prop = profile.properties;
            if (/^\s*\=/.test(value || "")) {
                value = ood.ExcelFormula.calculate(value || "") || "";
            }
            value = ood.toNumeric(value, prop.precision, prop.groupingSeparator, prop.decimalSeparator, prop.forceFillZero, prop.trimTailZero);
            if (ood.isSet(prop.max))
                value = value > prop.max ? prop.max : value;
            if (ood.isSet(prop.min))
                value = value < prop.min ? prop.min : value;
            return value;
        },
        _onresize: function (profile, width, height) {
            if (profile._$ignoreonsize) return;

            var prop = profile.properties,
                type = prop.type,
                cmp = prop.showMode == 'compact',
                // if any node use other font-size which does not equal to ood-node, use 'px'
                f = function (k) {
                    if (!k) return null;
                    k = profile.getSubNode(k);
                    return k;
                },
                root = f('KEY'),
                v1 = f('INPUT'),
                icb = f('ICONB'),
                ut = f('UNIT'),
                box = f('BOX'),
                label = f('LABEL'),
                cmdbtn = f(prop.commandBtn != 'none' ? 'CMD' : null),
                lbtn = f(type == 'counter' ? 'LBTN' : null),
                rbtn = f(type == 'spin' ? 'SPINBTN' : (type == 'none' || type == 'input' || type == 'password' || type == 'currency' || type == 'number' || type == 'button') ? null : 'RBTN'),
                // determine em
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },

                fzrate = profile.getEmSize() / root._getEmSize(),
                v1fz = v1._getEmSize(fzrate),
                labelfz = label._getEmSize(fzrate),

                isB = v1.get(0).type.toLowerCase() == 'button',
                $hborder, $vborder,

                clsname = 'ood-node ood-input-input',
                cb = ood.browser.contentBox,
                paddingH = !cb ? 0 : isB ? 0 : Math.round(v1._paddingH() / 2) * 2,
                paddingH2 = !cb ? 0 : Math.round(v1._paddingH() / 2) * 2,
                paddingW = 0,

                autoH, icbw, utw, btnw,
                pl = 0, pr = 0,
                boxB = box._borderW(),
                offset = boxB / 2;

            $hborder = $vborder = !cb ? 0 : offset;
            btnw = parseInt(profile.getEmSize() * 1.5, 10);

            // calculate by px
            if (height) height = (autoH = height == 'auto') ? profile.$em2px(!cb ? 1.6666667 : 1, null, true) + paddingH2 + boxB : profile.$isEm(height) ? profile.$em2px(height, null, true) : height;
            if (width) width = profile.$isEm(width) ? profile.$em2px(width, null, true) : width;

            // for auto height
            if (autoH) {
                profile._$ignoreonsize = 1;
                root.height(adjustunit(height));
                delete profile._$ignoreonsize;
            }

            var labelPos = prop.labelPos || 'left',
                // make it round to Integer
                labelSize = (labelPos == 'none' || !labelPos) ? 0 : profile.$px(prop.labelSize, labelfz, true) || 0,
                labelGap = (labelPos == 'none' || !labelPos) ? 0 : profile.$px(prop.labelGap, null, true) || 0,

                ww = width,
                hh = height,
                bwcmd = 0,
                lbw = 0,
                rbw = 0,
                left = Math.max(0, (prop.$b_lw || 0) - $hborder),
                top = Math.max(0, (prop.$b_tw || 0) - $vborder);
            if (null !== ww) {
                ww -= Math.max($hborder * 2, (prop.$b_lw || 0) + (prop.$b_rw || 0));
                lbw = lbtn ? btnw : 0;
                rbw = rbtn ? btnw : 0;
                bwcmd = cmdbtn ? btnw : 0;
//                bwcmd=(cmdbtn?cmdbtn.offsetWidth:0);
//                rbw=(rbtn?rbtn.offsetWidth:0);
                /*for ie6 bug*/
                /*for example, if single number, 100% width will add 1*/
                /*for example, if single number, attached shadow will overlap*/
                if (ood.browser.ie6) ww = (Math.round(ww / 2)) * 2;
            }
            if (null !== hh) {
                hh -= Math.max($vborder * 2, (prop.$b_lw || 0) + (prop.$b_rw || 0));

                if (ood.browser.ie6) hh = (Math.round(hh / 2)) * 2;
                /*for ie6 bug*/
                if (ood.browser.ie6 && null === width) box.ieRemedy();
            }
            var iL = ww === null ? null : left + (labelPos == 'left' ? labelSize : 0),
                iT = hh === null ? null : top + (labelPos == 'top' ? labelSize : 0),
                iW = ww === null ? null : Math.max(0, ww - ((labelPos == 'left' || labelPos == 'right') ? labelSize : 0)),
                iH = hh === null ? null : Math.max(0, hh - ((labelPos == 'top' || labelPos == 'bottom') ? labelSize : 0)),
                iH2 = hh === null ? null : Math.max(0, height - ((labelPos == 'top' || labelPos == 'bottom') ? labelSize : 0)),
                iR = labelPos == 'right' ? labelSize : 0;

            // label
            if (labelSize) {
                label.css('display', '');
                label.cssRegion({
                    left: adjustunit(ww === null ? null : labelPos == 'right' ? (ww - labelSize + labelGap + $hborder * 2) : 0, labelfz),
                    top: adjustunit(height === null ? null : labelPos == 'bottom' ? (height - labelSize + labelGap) : 0, labelfz),
                    width: adjustunit(ww === null ? null : Math.max(0, ((labelPos == 'left' || labelPos == 'right') ? (labelSize - labelGap) : ww)), labelfz),
                    height: adjustunit(height === null ? null : Math.max(0, ((labelPos == 'top' || labelPos == 'bottom') ? (labelSize - labelGap) : height) - paddingH), labelfz)
                });
            } else {
                label.css('display', 'none');
            }
            if (iW !== null) {
                if (cmp) {
                    pl += lbw;
                    pr += bwcmd + rbw;
                } else {
                    iW -= bwcmd + rbw + lbw;
                }
            }
            // left 1
            if (lbtn) {
                if (iH2 !== null)
                    lbtn.height(adjustunit(Math.max(0, iH2)));
                if (iW !== null)
                    lbtn.left(adjustunit(iL));
                lbtn.top(adjustunit(iT));
                if (!cmp) {
                    iL += lbw;
                }
                // for left offset 1px
                if (iW !== null) {
                    iL -= offset;
                    iW += offset;
                }
            }
            //left 2
            if (prop.image || prop.imageClass) {
                icb.setInlineBlock();
                if (icbw = icb.offsetWidth(true))
                    pl += icbw;
            }
            if (!icbw) icb.css('display', 'none');
            else if (cmp && lbw)
                icb.left(adjustunit(lbw, icb));

            // right 1
            if (bwcmd) {
                cmdbtn.top(adjustunit(iT));
                if (iH2 !== null)
                    cmdbtn.height(adjustunit(Math.max(0, iH2)));
                if (iW !== null) {
                    cmdbtn.css('right', adjustunit(iR));
                    iR += bwcmd - $hborder;

                    // for left offset 1px
                    iW += offset;
                }
            }

            // right 2
            if (rbw) {
                rbtn.top(adjustunit(iT));
                if (iH2 !== null)
                    rbtn.height(adjustunit(Math.max(0, iH2)));
                if (iW !== null) {
                    rbtn.css('right', adjustunit(iR));
                    // for left offset 1px
                    iW += offset;
                }
                if (iH2 !== null && prop.type == 'spin') {
                    if (iH2 / 2 - $vborder * 2 > 0) {
                        f('R1').height(adjustunit(iH2 / 2));
                        f('R2').height(adjustunit(iH2 / 2 + (Math.round(iH2) - Math.round(iH2 / 2) * 2)));
                    }
                }
            }
            // right 3
            if (prop.unit) {
                ut.setInlineBlock();
                if (utw = ut.offsetWidth(true))
                    pr += utw;
            }
            if (!utw) ut.css('display', 'none');
            else if (cmp && (rbw || bwcmd))
                ut.css('right', adjustunit(rbw + bwcmd, ut));

            // box
            box.cssRegion({
                left: iW ? adjustunit(iL) : null,
                top: iH ? adjustunit(iT) : null,
                width: iW ? adjustunit(iW) : null,
                height: iH ? adjustunit(iH) : null
            });

            // input last
            if (pl) v1.css('paddingLeft', adjustunit(pl, icb));
            if (pr) v1.css('paddingRight', adjustunit(pr, ut));

            // must recalculate here
            paddingW = !cb ? 0 : isB ? 0 : v1._paddingW();
            if (null !== iW && iW - paddingW > 0)
                v1.width(adjustunit(Math.max(0, iW - paddingW), v1fz));
            if (null !== iH && iH - paddingH > 0)
                v1.height(adjustunit(Math.max(0, iH - paddingH), v1fz));

            /*for ie6 bug*/
            if ((profile.$resizer) && ood.browser.ie) {
                box.ieRemedy();
            }
        }
    }
});ood.Class('ood.UI.ColorPicker', ['ood.UI',"ood.absValue"], {
    Instance:{
        activate:function(){
            this.getSubNode('TOGGLE').focus(true);
            return this;
        },
        _setCtrlValue:function(value,inner){
            return this.each(function(profile){
                if(!profile.renderId)return;
                var cls = profile.box,
                    p = profile.properties;
                if(value && value.toLowerCase()=='transparent')value='transparent';

                var hex = profile.$hex = cls._to3(value),
                    hexs = profile.$hex.join(''),
                    rgb = profile.$rgb = cls.hex2rgb(value),
                    hsv = profile.$hsv = cls.rgb2hsv(rgb),
                    f=function(s,v){profile.getSubNode(s).get(0).firstChild.nodeValue=String(v)},
                    ff=function(v){return parseInt(v*100,10)};
                if(value=='transparent'){
                    hex=profile.$hex = ['00','00','00'];
                    rgb=profile.$rgb = [0,0,0];
                    hsv=profile.$hsv = [0,0,0];
                };

                f('R',rgb[0]);
                f('G',rgb[1]);
                f('B',rgb[2]);
                f('H',hex[0]);
                f('E',hex[1]);
                f('X',hex[2]);

                //dont update hsv UI again, if hsv value is the newest
                if(profile.$hexinhsv != hexs){
                    f('HH',hsv[0]);
                    f('S',ff(hsv[1]));
                    f('V',ff(hsv[2]));
                    delete profile.$hexinhsv;
                }
                cls._setClrName(profile,value=='transparent'?value:hexs);
                cls._updateDftTip(profile);
                //dont update adv UI again, if adv value is the newest
                if(p.advance && profile.$hexinadv != hexs){
                    cls._updateMarks(profile, value, true, hsv[0]);
                    delete profile.$hexinadv;
                }
                //from setUIValue/setValue
                if(inner!=false)
                    profile.getSubNode('CAPTION').html((value=='transparent'?'':'#')+value,false);
           });
        },
        getColorName:function(){
            return this.get(0).$clrN||'';
        },
        
        // Set theme
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot(),
                    border = profile.getSubNode('BORDER'),
                    bar = profile.getSubNode('BAR'),
                    main = profile.getSubNode('MAIN'),
                    tail = profile.getSubNode('TAIL'),
                    simpleColors = root.query('.ood-span'),
                    inputs = root.query('.ood-ui-draggable'),
                    exam = profile.getSubNode('EXAM');

                // Apply theme variables
                root.addClass('colorpicker-themed');
                if (theme === 'dark') {
                    root.addClass('colorpicker-dark');
                    
                    // Border and background
                    border.css({
                        'background-color': 'var(--dark-bg)',
                        'border-color': 'var(--dark-border)',
                        'color': 'var(--dark-text)'
                    });
                    
                    // Top toolbar
                    bar.css({
                        'background': 'var(--dark-gradient)',
                        'border-color': 'var(--dark-border-secondary)'
                    });
                    
                    // Main area
                    main.css({
                        'background-color': 'var(--dark-bg-secondary)',
                        'border-color': 'var(--dark-border)'
                    });
                    
                    // Bottom area
                    tail.css({
                        'background-color': 'var(--dark-bg-secondary)',
                        'border-color': 'var(--dark-border)'
                    });
                    
                    // Input styles
                    inputs.css({
                        'background-color': 'var(--dark-bg-input)',
                        'border-color': 'var(--dark-border-secondary)',
                        'color': 'var(--dark-text)'
                    });
                    
                    // Preview area
                    if (exam && !exam.isEmpty()) {
                        exam.css({
                            'border-color': 'var(--dark-border-secondary)'
                        });
                    }
                } else {
                    // Light mode styles
                    root.removeClass('colorpicker-dark');
                    
                    // Restore default styles
                    border.css({
                        'background-color': 'var(--bg)',
                        'border-color': 'var(--border)',
                        'color': 'var(--text)'
                    });
                    
                    bar.css({
                        'background': 'var(--gradient)',
                        'border-color': 'var(--border-secondary)'
                    });
                    
                    main.css({
                        'background-color': 'var(--bg-secondary)',
                        'border-color': 'var(--border)'
                    });
                    
                    tail.css({
                        'background-color': 'var(--bg-secondary)',
                        'border-color': 'var(--border)'
                    });
                    
                    inputs.css({
                        'background-color': 'var(--bg-input)',
                        'border-color': 'var(--border-secondary)',
                        'color': 'var(--text)'
                    });
                    
                    if (exam && !exam.isEmpty()) {
                        exam.css({
                            'border-color': 'var(--border-secondary)'
                        });
                    }
                }
                
                // Save theme settings
                localStorage.setItem('colorpicker-theme', theme);
            });
        },



        ColorPickerTrigger: function() {
            var profile = this.get(0);
            var prop = profile.properties;
            var boxing = this;

            // Initialize theme
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // Restore theme from local storage
                var savedTheme = localStorage.getItem('colorpicker-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // Initialize responsive design
            if (prop.responsive !== false) {
                boxing.adjustLayout();
            }

            // Initialize accessibility
            boxing.enhanceAccessibility();
        },
        // Get current theme
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('colorpicker-theme') || 'light';
        },
        
        // Toggle dark mode
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        
        // Responsive layout adjustment
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    main = profile.getSubNode('MAIN'),
                    tail = profile.getSubNode('TAIL'),
                    inputs = root.query('.ood-ui-draggable'),
                    simpleColors = root.query('.ood-span'),
                    prop = profile.properties;

                // Adjust layout for small screens
                if (width < 768) {
                    root.addClass('colorpicker-mobile');
                    
                    // Adjust inputs for mobile
                    inputs.css({
                        'min-height': '2em',
                        'font-size': '0.9em',
                        'padding': '0.3em'
                    });
                    
                    // Adjust color blocks for mobile
                    simpleColors.css({
                        'width': '1.8em',
                        'height': '1.8em',
                        'margin': '0.1em'
                    });
                } else {
                    root.removeClass('colorpicker-mobile');
                    
                    // Restore desktop styles
                    inputs.css({
                        'min-height': '',
                        'font-size': '',
                        'padding': ''
                    });
                    
                    simpleColors.css({
                        'width': '',
                        'height': '',
                        'margin': ''
                    });
                }

                // Special handling for extra small screens
                if (width < 480) {
                    root.addClass('colorpicker-tiny');
                    
                    // Adjust layout to vertical
                    main.css({
                        'font-size': '0.8em'
                    });
                    
                    tail.css({
                        'font-size': '0.8em'
                    });
                } else {
                    root.removeClass('colorpicker-tiny');
                    
                    main.css({
                        'font-size': ''
                    });
                    
                    tail.css({
                        'font-size': ''
                    });
                }
            });
        },
        
        // Enhance accessibility support
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    bar = profile.getSubNode('BAR'),
                    main = profile.getSubNode('MAIN'),
                    tail = profile.getSubNode('TAIL'),
                    inputs = root.query('.ood-ui-draggable'),
                    simpleColors = root.query('.ood-span'),
                    exam = profile.getSubNode('EXAM'),
                    properties = profile.properties;

                // Add ARIA attributes to container
                root.attr({
                    'role': 'application',
                    'aria-label': ood.getRes('UI.colorpicker.label')
                });
                
                // Add ARIA attributes to toolbar
                if (bar && !bar.isEmpty()) {
                    bar.attr({
                        'role': 'toolbar',
                        'aria-label': ood.getRes('UI.colorpicker.toolbar')
                    });
                }
                
                // Add ARIA attributes to main area
                if (main && !main.isEmpty()) {
                    main.attr({
                        'role': 'group',
                        'aria-label': ood.getRes('UI.colorpicker.selection')
                    });
                }
                
                // Add ARIA attributes to inputs
                inputs.each(function(input) {
                    var inputElement = ood(input),
                        inputId = inputElement.id();
                    
                    var label = ood.getRes('UI.colorpicker.colorInput');
                    if (inputId && inputId.indexOf('-R:') > -1) {
                        label = ood.getRes('UI.colorpicker.redValue');
                    } else if (inputId && inputId.indexOf('-G:') > -1) {
                        label = ood.getRes('UI.colorpicker.greenValue');
                    } else if (inputId && inputId.indexOf('-B:') > -1) {
                        label = ood.getRes('UI.colorpicker.blueValue');
                    } else if (inputId && inputId.indexOf('-H:') > -1) {
                        label = ood.getRes('UI.colorpicker.hueValue');
                    } else if (inputId && inputId.indexOf('-S:') > -1) {
                        label = ood.getRes('UI.colorpicker.saturation');
                    } else if (inputId && inputId.indexOf('-V:') > -1) {
                        label = ood.getRes('UI.colorpicker.brightness');
                    }
                    
                    inputElement.attr({
                        'role': 'spinbutton',
                        'aria-label': label,
                        'tabindex': properties.disabled ? '-1' : '0'
                    });
                });
                
                // Add ARIA attributes to color blocks
                simpleColors.each(function(color) {
                    var colorElement = ood(color),
                        bgColor = colorElement.css('background-color') || '';
                    
                    colorElement.attr({
                        'role': 'button',
                        'aria-label': ood.getRes('UI.colorpicker.selectColor') + ' ' + bgColor,
                        'tabindex': properties.disabled ? '-1' : '0'
                    });
                });
                
                // Add ARIA attributes to preview area
                if (exam && !exam.isEmpty()) {
                    exam.attr({
                        'role': 'img',
                        'aria-label': ood.getRes('UI.colorpicker.colorPreview')
                    });
                }
            });
        }
    },
    Initialize:function(){
        var ns=this,
            id=ood.UI.$ID,
            cls=ood.UI.$CLS,
            tag=ood.UI.$tag_special,
            key=ns.KEY,
            list=ns._slist,
            l=list.length,
            i,data,
            arr=[],
            evs=ood.$IEUNSELECTABLE(),
            evs2='style="visibility:hidden;"',
            ddcls = 'ood-node ood-node-span ood-ui-draggable ood-uibase ood-uiborder-flat';

        ns.addTemplateKeys(['DD1', 'DD2', 'DD3','R','G','B','TXT','HH','S','V','H','E','X']);

        //simple list
        for(i=0;i<l;i++){
            arr.push('<span  '+'id="'+key+'-SC:'+id+':'+list[i]+'" style="background-color:#'+list[i]+'" '+evs+' class="ood-node ood-span oodcon ood-uiborder-flat ood-icon-placeholder">'+(ood.__iefix2&&ood.__iefix2['ood-icon-placeholder']||'')+'</span>');
            if((i+1)%17==0)arr.push('<br />');
        }
        //data
        data = '<div '+evs+'><span class="'+cls+'-txt"'+evs+'>R: </span><span '+'id="'+key+'-R:'+id+':" class="'+cls+'-dd2 '+ddcls+' '+tag+'DD2_CC'+tag+'" '+evs+'>R</span><span '+evs2+'>%</span><span class="'+cls+'-txt"'+evs+'>G: </span><span '+'id="'+key+'-G:'+id+':" class="'+cls+'-dd2 '+ddcls+'  '+tag+'DD2_CC'+tag+'" '+evs+'>G</span><span '+evs2+'>\xB0</span><span class="'+cls+'-txt"'+evs+'>B: </span><span '+'id="'+key+'-B:'+id+':" class="'+cls+'-dd2 '+ddcls+'  '+tag+'DD2_CC'+tag+'" '+evs+'>B</span></div>' +
                '<div '+evs+'><span class="'+cls+'-txt"'+evs+'>S: </span><span '+'id="'+key+'-S:'+id+':" class="'+cls+'-dd2 '+ddcls+'  '+tag+'DD2_CC'+tag+'"  '+evs+'>S</span><span '+evs+'>%</span><span class="'+cls+'-txt"'+evs+'>H: </span><span '+'id="'+key+'-HH:'+id+':" class="'+cls+'-dd2 '+ddcls+'  '+tag+'DD2_CC'+tag+'" '+evs+'>H</span><span '+evs+'>\xB0</span><span class="'+cls+'-txt"'+evs+'>V: </span><span '+'id="'+key+'-V:'+id+':" class="'+cls+'-dd2 '+ddcls+'  '+tag+'DD2_CC'+tag+'" '+evs+'>V</span><span '+evs+'>%</span></div>' +
               '<div '+evs+'><span class="'+cls+'-txt"'+evs+'>HEX: </span><span '+'id="'+key+'-H:'+id+':" class="'+cls+'-dd3 '+ddcls+'  '+tag+'DD3_CC'+tag+'" '+evs+'>H</span><span '+'id="'+key+'-E:'+id+':" class="'+cls+'-dd3 '+ddcls+'  '+tag+'DD3_CC'+tag+'" '+evs+''+evs+'>E</span><span '+'id="'+key+'-X:'+id+':" class="'+cls+'-dd3 '+ddcls+'  '+tag+'DD1_CC'+tag+'" '+evs+'>X</span></div>'
        ns.setTemplate({
            style:'{_style};height:auto;width:auto',
            tagName : 'div',
            //onselectstart:'return false',
            BORDER:{
                tagName : 'div',
                className: 'ood-uiborder-outset ood-uiborder-box ood-uiborder-radius-big',
                BAR:{
                    tagName:'div',
                    className:'{classBar}',
                    BARTDL:{
                        className:'ood-uibar-tdl ood-uibar ood-uiborder-radius-big-tl',
                        BARTDLT:{
                            className:'ood-uibar-tdlt'
                        }
                    },
                    BARTDM:{
                        $order:1,
                        className:'ood-uibar-tdm ood-uibar',
                        BARTDMT:{
                            className:'ood-uibar-tdmt'
                        }
                    },
                    BARTDR:{
                        $order:2,
                        className:'ood-uibar-tdr ood-uibar ood-uiborder-radius-big-tr',
                        BARTDRT:{
                            className:'ood-uibar-tdrt'
                        }
                    },
                    BARCMDL:{
                        $order:3,
                        tagName: 'div',
                        className:'ood-uibar-cmdl',
                        SPACE:{
                            className:'oodfont',
                            $fonticon:'ood-icon-placeholder'
                        }
                    },
                    BARCMDR:{
                        $order:4,
                        tagName: 'div',
                        className:'ood-uibar-cmdr',
                        CLOSE:{
                            className:'oodfont',
                            $fonticon:'ood-uicmd-close',
                            style:'{closeDisplay}'
                        }
                    },
                    TBARTDB:{
                        $order:5,
                        tagName: 'div',
                        className:'ood-uibar-tdb ood-uiborder-inset ood-uiborder-radius'
                    }
                },
                MAIN:{
                    $order:2,
                    tagName:'div',
                    className:'ood-uicon-main ood-uibar',
                    MAINI:{
                        tagName:'div',
                        className:'ood-uicon-maini ood-uibar',
                        CON:{
                            $order:1,
                            tagName:'div',
                            className:'ood-uiborder-inset ood-uiborder-radius',
                            SIMPLE:{
                                tagName:'div',
                                TOP:{
                                    $order:1,
                                    tagName:'div',
                                    DATA:{
                                        $order:0,
                                        tagName:'div',
                                        //onselectstart:'return false',
                                        text:data
                                    },
                                    EXAM:{
                                        $order:3,
                                        tagName:'div',
                                        className:'ood-uiborder-inset ood-uiborder-radius'
                                    }
                                },
                                LIST:{
                                   $order:2,
                                   tagName:'div',
                                   text: arr.join('')
                                }
                            },
                            ADV:{
                                $order:2,
                                style:'{advDispay}',
                                tagName:'div',
                                ADVWHEEL:{
                                    $order:0,
                                    tagName:'div'
                                },
                                ADVCLR:{
                                    $order:1,
                                    tagName:'div'
                                },
                                ADVMARK1:{
                                    $order:3,
                                    tagName:'div'
                                },
                                ADVMARK2:{
                                    $order:4,
                                    tagName:'div'
                                }
                            }
                        }
                    }
                },
                TAIL:{
                    $order:3,
                    tagName:'div',
                    className:'ood-uicon-main ood-uibar',
                    TAILI:{
                        tagName:'div',
                        className:'ood-uibar ood-uicon-maini',
                        TRANS:{
                            className:'oodcon',
                            $fonticon:'ood-icon-transparent',
                            tabindex: '{tabindex}',
                            title:"{_transparent}"
                        },
                        CAPTION:{
                            text : '{caption}'
                        },
                        SET:{
                            tagName:"button",
                            className:'ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius',
                            tabindex: '{tabindex}',
                            text:"{_set}"
                        },
                        TOGGLE:{
                            $order:2,
                            className:'oodfont',
                            $fonticon:'ood-icon-doubleright',
                            tabindex: '{tabindex}'
                        }
                    }
                },
                BBAR:{
                    $order:4,
                    tagName:'div',
                    className:'ood-uibar-bottom-s',
                    BBARTDL:{
                        className:'ood-uibar-tdl ood-uibar ood-uiborder-radius-big-bl'
                    },
                    BBARTDM:{
                        $order:1,
                        className:'ood-uibar-tdm ood-uibar'
                    },
                    BBARTDR:{
                        $order:2,
                        className:'ood-uibar-tdr ood-uibar ood-uiborder-radius-big-br'
                    }
                }
            }
        });
    },
    Static:{
        _radius:84,
        _square:100,
        _bigRadius:97,
        DataModel:{
            // Modern properties
            theme: {
                ini: 'light',
                listbox: ['light', 'dark'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            height:{
                ini:'auto',
                readonly:true
            },
            width:{
                ini:'auto',
                readonly:true
            },
            value:{
                ini:"FFFFFF",
                format:'color'
            },
            barDisplay : {
                ini:true,
                action:function(v){
                    if(v)
                        this.getSubNode('BAR').replaceClass('ood-uibar-top-s','ood-uibar-top');
                    else
                        this.getSubNode('BAR').replaceClass('ood-uibar-top','ood-uibar-top-s');
                }
            },
            closeBtn:{
                ini:true,
                action:function(v){
                    this.getSubNode('CLOSE').css('display',v?'':'none');
                }
            },
            advance:{
                ini:false,
                action:function(v){
                    var ns=this,
                        tg=ns.getSubNode('TOGGLE');
                    ns.getSubNode('ADV').css('display',v?'':'none');
                    ns.getSubNode('CON').css('padding-right',v?'205px':'0px');
                    if(ood.__iefix2){
                        tg.html(ood.__iefix2[v?'ood-icon-doubleleft':'ood-icon-doubleright']);
                    }else{
                        if(v) tg.removeClass('ood-icon-doubleright').addClass('ood-icon-doubleleft');
                        else tg.removeClass('ood-icon-doubleleft').addClass('ood-icon-doubleright');
                    }
                    if(v)
                        ns.box._updateMarks(ns,ns.properties.$UIvalue,true, ns.$hsv[0])
                }
            }
        },
        Appearances:{
            KEY:{
            },
            'TBART, BBART':{
                'border-spacing':0,
                'border-collapse':'separate'
            },
            MAINI:{
                'padding':'.5em .3333em .3333em 0'
            },
            CON:{
                padding:'.25em',
                position:'relative'
            },
            '.ood-uibar-top BARCMDL':{
                padding:".25em 0 0 0"
            },
            '.ood-uibar-top BARCMDR':{
                top:".3334em",
                right:".5em"
            },
            CMDL:{
                padding:".25em 0 .25em 0"
            },
            DATA:{
            },
            'DATA span':{
                'padding':'0 1px',
                'margin-left': '-1px',
                'margin-right':'1px',
                'width':'2em'
            },
            'DATA div':{
                'padding':'.5em 0'
            },
            CAPTION:{
                'vertical-align':ood.browser.ie6?'baseline':'middle',
                'font-size':'1em'
            },
            EXAM:{
                padding:'.125em',
                position:'absolute',
                width:'5.5em',
                height:'5.5em',
                top:'.25em',
                right:'.25em',
                'white-space':'normal',
                'text-align':'center'
            },
            'DD1, DD2, DD3':{
                'padding-right':'2px',
                cursor:'e-resize',
                'text-align':'center'
            },
            TOP:{
                position:'relative'
            },
            LIST :{
                position:'relative',
                overflow:'hidden',
                padding:'.25em',
                'white-space': 'nowrap',
                'line-height':'1em'
            },
            TAILI:{
                position:'relative',
                 padding:'.5em 0 0 0',
                'text-align':'center'
            },
            SIMPLE:{
                position:'relative'
            },
            ADV:{
                position:'absolute',
                right:'4px',
                bottom:'4px',
                width:'195px',
                height:'195px'
            },
            'ADV div':{
                cursor:'crosshair',
                position:'absolute'
            },
            ADVCLR:{
                background: ood.browser.ie6?null:"url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGUAAABlCAYAAABUfC3PAAAABGdBTUEAANbY1E9YMgAAABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjIyt5EXfQAATvhJREFUeF7t3AeUl+Wd8P3ZfXaTbHo1xsQSY2JMjLFHjS32rih2EVEUFEQFkSoCAgKiSG/Se++9997bAMPMML333v7v55qd8UyIKVvenOe85zXnuwzGxPX34Xdd9/0H8i8TJkyInH/++VH+iIT88cXX4Yu6P1f77zX4a77064Z/rf+emi/562vq/gbhm9p/v+77f/b1l/w19f+5L/vP/9mfa/jf2+Drs/+a8P9/7Z+r++OLv//Z//n6v+Csv75+Vl/2nz/736ufYfj7NZznf/7D/+efrJ97+PdvjVq7dm3tgFStSpWrTKUqVqHylatsZSpdKUpWguJ1WqcUrWM6rAPap93aoa3apA0Kf+OVWq7FWqh5mqUZmqKJGqcxGqmhGqRP1V991Us91E2d1UHv6h29qTfUQs3VTE30nJ5WYzXSI3pQ9+lu3aHbdLNu0vW6VlfpCl2uy3SpLtHFulDn6zydq3P0Q31f39W39E19XV/TV/Xv+jf9q/4liPTt2/fT/6+hdPEP1xClje+3qqmpaaHmaqYX9byeVmM10iN6UPfpbt2h23SzbtIfdK2u0hW6XJdVV1dfqkt0sS7U+TpPP6mqqjpHP9T39d3KyspvV1RUfLO8vPzrZWVlXystLf1qcXHxV/Ly8v4tMSHxX7dv2/4v/x717/+JsmbNmoj/khqFPypVrjKVqliFyleuspWpdKUoWQmK12mdUrSO6bAOaJ92a4e2apM2aK1WabmWaKHmabZ/iBmaqkkarzEaqWEarIH6WH3VWz30gbqoo9obQlu1USu11Kt6WS8azvN6Rk/qcT1qWA/pft1jaHfqdt2qPxrgDbpO15SUlFxpmL/Tb4uKin6tXxUWFv6ioKDg5/n5+Rca8s9yc3PPy87O/nFmZuaPMtIzfpiWmvb9pMSk78THxX/r1MlT3zhy+MjX9+3d9x9bNm/56vx58/+9z4d9/k/jRo3/Fcq/fvTRR/+J4h+iRtWqVLnKVKpiFSpfucpWptKVomQlKF6ndUrROqYjOqh9BrFHO7VNm7VR67RKK7REizRfszVTUzVJ4/W5RmmYBhviQH2sfuqtnuquruqk9wy3rd5Sa7U03Ff1sprqBQN+Vk/pCT1m2A/rAd1r4HfpT7rV0G829Bt0vcFfY/BX6grDv9zwL8vJyfkVgEsAXJyRkXFhelr6+ampqT9NSko6NyEh4RwQPzodc/oHx48d/+6hg4e+vXvX7m9u2rjpG6tXrv6P+XPnf23E0BFfaf1663+77ebb/g+U/wNlYNTq1asj/kFrVK3wR7nKVKpiFSpfucpWpn/odKUoWQmKV6xidELHdUQHtV97tFPbDGizNmqdVmmFlmqR5muOoc3UNE3WBI3VaMMbriH6TAPU3xD76EN11/vqZJgd1E5vG+qbel2v6RXDfUlN9JwhP63GhtxIjxr0gwZ9v+4x7DsM+/asrKxbsjIzbzL0P6Snp19r6Fcb+u9TUlIuT05K/o2j59Iz8Wd+afi/MPyfnzxx8oIT0SfOP3rk6HkHDxw810acs3PHzh9t3LDx+ytXrPzuwvkLvz1tyrRvjh0z9hsDBwz8+rvvvPu1h+9/+Cu/+dVv/h3Kv/Xp02dg1KpVqyIGUaNqVSr8UaZSFatQ+co1mGxlKkOpSlGizihWMTqh4zqigwa3X3u0U9u0RRu1TqsNcaWWarEWaI5mGeg0TdEEjdVoQx2hoRqkT/Sx4X6kXuqhbobcWR0N+V29ozaG3UotDftVNTPwpnre0J8x9Cf1uKE/5kf6Q+npGfenpaXd68i5y/D/ZPi3Gv4fHT83+pF/PYBr4mLjroo9HXtFzKmYywFcZgsudSRdAuFiCBft2rnrgq1btv7URpy3bu26c2Gcs2Degh/OmDbj++M+H/fdQQMHfbtvn77f6tyh8zdfavLS12+58ZavXfSzi74K5Su9e/f+LGrlypURw6lRtSpVrjKFP4pVqHyDylWOspShVKUoUWcUqxid0HFDPKJDOqC92qXt2qJNBrpeq7VSS7XYUBdormZpuqYY8ESN0xiNMOShGqxP9bFh91Vvw+6pbupi4B3V3tDb6i1Db63XDf5VvWz4TfWCH/nPAnjK8BunpqQ2AvBISnLKg46e+2zA3QlnEu6AcBuEm23BTRD+YBOuiz4effWxo8euBPE7EL/dv2//rx1Lv9qxfccl7omfb1i/4cJVK1f9bOmSpT9duGDhT2bPnP3jKZOm/GjMqDE/+OzTz77fq0ev73bp2OU7jq1vNX6s8TeuvfLar//0xz/9DyhfgzKoFsUQa1StSpWrTKUqVqEKDDJPOcpShlKVokSdUaxidMKAj+uoDumA9mqXtmuLYW/Seq3RSi3TYkNfqLmaremaYvATNc7gx2ikhhn8YH2qAYbfV731IYAP1BVAJ7UH0E5vAWit1yG8BuEVvQSiCYTnIDxtExrbhEYgHgHxEIj7HUf3wLgTxu0u51tsxE0wboBxHYxr3A9XHdh/4Iq9e/ZebjMu27Z126WbN23+pc24GMhFSxYvOd8l/rNZM2adN3ni5HM/H/35OUMGDflhvz79ftC1U9fvtXu73XdfffnVbz/8wMPf/P1vf/+Nn/zwJ1+H8h+9evUaFLVixYqIQdWoWpUqV5lKVazwR4Gh5SlHWcpQqlKUqDOKNcQYnVS0juqQDmivwe7SDm3VZm3QGkNepWVaooUGPU+zNUNTDXuSxutzAx+l4Rpi6AP1iaH3Ux/1MvjuBv++Oht8B71r+G/bgjcBvJGcnNwCQHMAzQC8COB5AM/qKQhPOJIeg/CwjXjARtwL4S5H0x3uh9sOHzp8s624yVb8Yc/uPdeCuNpj7O9txu/cF7+FcRmMX9mOS2zHxbbjwqmTp54/fuz4n40cPvK8Af0H/NhT1jnvd37/h++0eecHLV9t+b3nnn7uu3fdfte3L/vlZd8853vnfAPKN6AMjlq+fHnE0GpUrUqVq8zASlWiIhUoTznKUoZSDTFFiUpQnE7rpGFG66gO66D2Gepu7dBWbTbYDVqr1Ya7XEu1yHDna45mGvI0TdYEgx6r0QY9QkMN+zN9auAfG/hHfsT3NvAe6mboXQ29o9obfFtDf8vQW/uR/7rBv2bwrxj8SzagieE/bwueNvwnbUEjW/AogIcA3A/gXptwl6PpTy7rW23DzRBudFf8Yf269detXrX66hXLV/zeVvzOnfGbubPnXubeuNRR9UubcfGIYSMuclxd0O+jfufDOM92nPtGizd+/HLTl3/07FPP/tCW/OCm62/63sUXXPydH3z7B9+G8q0Pe344JGrZsmURg6xRtSpVrjKVGmaJilSgPOUoSxkGm6YUJSlBcTptyCcVrWM6rIOGvU+7tUPbDHyLNmqtga/WCi0z9EWab+hzNUvTDX6KJhr+OMMfY/gjNczwByUlJQ8EMMDw+6oPgJ76AML7EDpBeA9COwhvQ3gTwhsQWkBobguagXgRxAsgngHxFIgnHEmPuawftg0P2Ib73BN3u7TvcDTd7q64Ze2atTfBuAHG9bbi2kULFl01b86838+cPvNym/Ebm/FrIL8aNmTYJQM/GXixC/2inh/0vKB92/Y/a9Wy1XnNXmx27jNPPvPjJx594px777z3R+6TH1z40wu/971vfv+7UL7Ts2fPoVFLly6NGGaNqlWpcpUZZqhERSpQnnJkrlkZSlOqkpSgOEM+rVM6oWMGfVgHtV97DHyntmmLgW/UOq0x9BVapsVaYPjzDH6WZmgqgEkaD2CM4Y/ScMMfrM8ADADQTx9B+BBCdwjvQ+isDiDeBfEOiDYQWkFo6Th6FcTL7oWXQDQB8RyIp0E0thWNbMWjjqaHYNxvK+61FXfC+BOM22DcvHTx0ptg/MF7xnVzZs25xnZc5d64wpPV5Y6qy9wdl37y8Se/BHIJkItd6he91fqt890hP3NknffoQ4+e6zH43DtuveOcKy+/8kfnn3v+D777je9+H8r3evToMawWxUBrVK1KlYcMtUwlKlKB8pSjLAPOVJpSlaQEg45XrE7phI4Z+BEd0n7D3qOd2q6tBr9J6wx9jVY675cb/BItNPx5mm34MzTV8CdpPIDPNQrAcABD9BmETyD0V18IvSD0gNANQhfb0BFEexBtQbwFojWI10G8BqI5iGaOpxdBPG8rnrEVTzminnBEPQbjYZvxoLviPhh3w7jDZty+eOHiWx1Vf3RU3Wg7rrcd104cP/Fq23ElkCsGfzb4t0Au692z96VAfulSv8SWXPz6a69f2PSFpuc/2ejJnz1wzwPnuUt+4lH43Mt/ffk5Pz3npz/6zte/80MoP+jRvcfwqCVLlkQMtUbVqlSFgZarTCUqUoHyDDdH2cpU+CNVSYacoHjFOmZOGfYJHdcRAz9k4Pu118B3abu2GvomrTf0tVpl6Mu1xNAXar7mGP5Mg5+myYY/QWMNf7Thj9RQAIMADATwMYB+6g3hQwjdIXR1JHWG0AFCOwjvuCPagGhlI1pCeNVGvAziJRBNQDwH4mkQT4J4fM3qNY96v3ho+bLlD7gz7rUZd9uMO2zGbTBugfHHSRMm3egl8PpRI0ZdO3Tw0KvcH1f279v/d70/7H25O+Syju07Xuoe+dWbb7x5iXvkYsfWRY8++OgFQH528w03//T6q68/zyX/E09eP/72f3z7HCg/6t69+4ioxYsXRwy2RtWqVIXhlqtMJSpSgWHnGXKuspWpNANPVfhXouINO1YxOmngx3VUhw39gPZql8Hv0DZD36wNBr9Wq7TC8Jca/CItMPy5mmX40zUFwEQA4zQGwkgAwwAMAfAZgAHqbxM+gtBLPSB0g9AFQkfb0B5EWxBvgWjtaHodxGsgmrsrmnl6etER9YIj6llb8ZStaLxs6bLHlixa8giMh2DcD+MeGHd5G78Dxm2Oqlu8d9zkMr/BdlxvO65xXF31YY8Pr+z+fvcrOrzb4beesi5zj1zq2PrV8888f8njjz5+sS256LY/3nbBH675w/lX/e6qn/3y57/86Y+//+OffOtr3zoXyo8/+OCDkVGLFi2KGGiNqlWpCkMtV5lKVKQC5RtwrrKVqXSlGnSyEhVv2LGK0UkdN/SjOmzgB7RPuw1+p7YZ/GZt0DrDX62Vhr/M8BdrgeHP1WwAMwBM1SQI4yGM1SgAwzXUNgyC8Ilt+BhEXxC9QPSE8IFjqSuIziDesxHtQLzjnmgDohWIlrbiVVvxiq14yeNskxXLVjwH4xkYT/o45HEYjzmmHobx4PSp0+9zb9wzYdyEOx1Vf7Idt9mOm23HTR53b/io90fX9+ze8xobclWn9zpdCeR3Xg5/C+Q3Lz7/4q+feuKpXz3y4COX3P2nuy/+4x/++PNrfn/NRY6uC35x4S/O9zj8UyjnQTmvW7duo6I8U0cMt0bVqjTcCpWrTCUqUqEh5ytX2co07HSlKVmJBn5G4V8xhn5S0QZ+VId10ND3abfB79R2g9+ijVpv+GsMf6WWG/4SLQQwz/Dn2ICZmgZgMoAJGgthDIQREIZBGAxhoG0YAKIfiD4QPoTQ3Ua8D6KLjegIoj2ItiDeAtEaxOu2ooUjqrkjqpn7oqn74gUYz8J42mY09uL3OIxHYTwE4wFH1X2jR46+e/jQ4Xfajts9Xd3muLrZcXVTjw963ADkehtyDZCrbcjvX3vltSt8jHK5x9/fPPbwY7+2JZf+6ZY//dKW/MIFf/Glv7j0op+f//OLfvidH17wza9+83woP3v//fdHRy1YsCBiyDWqVqUBV6hcZSpRkQoNO1+5ylaWoacrTcmGnqQzijP40zqlaMM/piM6aPj7DX+Pdmk7gK3aBGA9gDVaBWG5lkBYBGG+5kCYCWE6hCkQJmociDEgRoIYDmIwiM9sxCcw+oP4CEQvG9EDRjf3RFcYnRxP78FoB+NtW9EGRqvlS5e3hPHa4kWLX/GD8yUX+Is243kYz3iiesq98YSjqpHH3Edsx0O2436Puvf67Ooux9UdQG7v06vPrT269bjZhX6jO+QGd8h17pBrgFzlHrnyhWdfuOLJx5+8/MF7H/zNPXfc8+tbb7r1Uo/Bv7ziN1dc4ui62OPwz72jXPSNr3zjQigXvN/1/TFRPgqIGGyNqlVlsBUqV5lKVKxCQ85XrnKUZdDpSlOKgSfpjOIN/LROGfgJHdMRgz+k/Qa/V7sMfoe2Gv4mg9+gtVoNYAWApQAWawGAuQBmAZihqRAmQRgP4XMIoyCMsBFDQQwCMRDCxzaiH4g+NuJDEN3dE++D6AyiI4j2tqItiLccUW8uWrjoDZvR0nvGqzbjZRgv2YwmMJ6D8QyMJ23HEzAesx2PeNR9yHbc/3G/j+9xf9ztM6w7Puj6we1Abn2v3Xs3t32r7U1AbvC2fr0NucY9cvXTjZ++qtHDjX4P5PLbb779t14WL3OX/Pq3l/72UkfXL8/70XmXfP9b378Yys+h/Lxrl66fR82bOy9iyDWqNuAqVahcZSox6GIVKl+5Bp6jLGUYeLpSlGToCYo39NOKMfQTOq6jhn9IBwx+r3Yb/k7D36bNhr/R8NdpDYCVhr9MSwAsBDAPwGwAMzUNwmQIEyGMswljIIyEMAzCYNvwGYhPbEN/EH0dTb1A9ATxAYiu7opOnqI6OKLeBfGOI6qNrWjt45A33BmvwWjuTbwZjKYwmtiMZx1VT8N4Esbj7o7H3B0Pezt/0HF1v8fde4Hc7ZPeOzzy3u7IutUdcrM75KZXXnrlRiDX25BrGz3S6BrvJFd7J/k9kN954rrclvzm15f8+rKf/+znv/bk9avvffN7v/z6v3/9Eii/6NK5y9iouXPmRgy4RtWqMuAKlatMJSo27ELlK085hp6lDKUbeoqSDD1B8Yo1+Bid1HEARw3/sA4A2KfdAHZqG4QtADZqPYQ1EFZBWK6lEBZBmA9hDoRZmg5iiibBGA/jcxCjQIwAMUSDbMSnMD6G0c8TVB8YH9qK7rbifRhdYHSE0R5GOxhvw3gTRiub0RLGa943XvFU9ZKnqhe9czzvqHrW3fH0pwM+bQzkcdvxaK+evR52fzzYrUu3+4HcY0PuAnKHDbndhtzqyLq5yXNNbvL4e4OnreuBXHf/3fdf64nrqhuuveH3LvgrXPC/c59c7uj6zbk/OPcyL46XQvkVlF917tx5XNTs2bMjBl2jakOuUoXKVaZSAy9WofINPE85yjLwDKUr1eCTlWDwZxSrGMM/qWjDP2b4h3XQ8PdpD4BdALZrC4BNADZoLYTVEFYAWOo4WgxggeZCmA1hho2YCmIyiAmOprE2YgyIkSCGgRgMYiCIAbaiv634CERvj7Q93RUfOKK6wugMowOMd2G0hfGWS/xNl/gbMFrAeNVR9bLteMl2NLEdz7s7nnV3PPVRrz6NPe428rj7qOPqYU9YD9qQ+99+8+17gdzdonmLO2zI7Z60bnOx3/LEY0/80TvJjUD+4L3kei+K11531XVX+0T4Sj+h9ftLLrrkigt+csHvPA7/FspvoFwG5dedOnUaHzVr1qyIIdeo2oCrVKFylanUsItVqALDzlOOsg08Q+lKNfhkJRr8GcUZ/GmdNPxoHTP8IzoIYL/h79UuAOFfWyFshrABwjqthrASwjIIiyEshDAPwhwIM23DNBBTQEwEMQ7E5yBGgRgOYiiIQS7tT0EMsBX9bEUfGB+6L7q7L7q5vLt4z+jkmHrPZrSD8Q6MNjBaw3jDO0cLj7nNXeQv246m7o4mtuN5x9UzjqunHFeNfWTSyIX+qJ8xfBjIg46s+4HcC+RuIHcC+ZNj67ZHHnjkFpf7ze6Sm9wlNzi6rr/6iquvsyXX2JKr3SdX+Xjl9568rvA2/zsol0P5bceOHSdGzZw5M2LINapWlSFXqFxlKjXsYhWpwMDzlKtsQ89UhqGnKlmJBn9GcYZ/WqcM/4SOG/4RHQKwH8Be7QawE8A2AFu0EcJ6CGsgrNJyEEtALAIxH8RcELMgTHdHTNUkEONBjHU8jXY8jbAVw0AMthWfwfjEVvS3FX1tRW9b0RNGdxjvw+gMoyOM9jDawXgbRhtHVStH1esu8ha2o7m7o5knq6aOqyaerp5zXD3juHrKI29jT1iNgDwG5GEgDwK5H8i9Pte62y+AuNM9cgeQ23zgeOudt915iy35o7vkRo/Bf/AGf52nrms9Cl/r45WrPXld6W3+9//xb/9xBZQrOnboOClqxvQZEQOvUbVhV6lC5SFDL1Wxigy9QHmGnqtsZRp8hlINPkVJBp+geMOP1SnDP6HjAI4COKwDAPYB2KOdELYD2ApgE4ANWgthNYQVEJbahsUgFkCYZyNmg5gJYpqNmAxiIohxtuJzEKNADAcxxFYMshUDbcUAGP0cUX0cUb1g9IDxgaeprjA6w+gAoz2MtjDedlS9CaOV7WhpO16zHa94GWzmuGrquGriuHrO/fGMJ6ynfLjY2HvI40Aec4c87DOth4Dc7wXxPiD3uEfuuu+u++4Acrstuc2W3Oox+I8u+JtsyQ1A/uCnf6+Hcp0nr2u8OF4N5SooV3Z4r8PkqOnTpkcMu0bVBl2lCpWHDLxUxSoy9ALlK9fgs5Vp8BlKM/gUJRl+guINP1YxAE4qGsBRAId1EMI+CHsA7AKwXVshbIKwAcI6CKu1EsRyEEtALLIN830yOxfELBDTQUwFMQnEBMfTWBCjbcVIWzEMxmBb8RmMT2B87PLu62mqt834EEZ3GN1gdIHRyb3xnqPqXUdVWxf5W7bjTdvRyna0tB2vOa5eAdLMcdXU/dHEhf5cm1ZtnvFzIk8BaQzkcRvyGJBHgDzkYn/AsXWfl8R7HVt3A7nTZ1x/csHf7i651dF1y68u/tUfgdx4wXkX3OjJ6wZPXtdDuQ7KtVCuea/9e1Oipk6dGjHoGlUbdJUqVB4y8FKVqMjQC5Rv6LnKUabBZyjN4FOUZPiJijf8OMOP0UkA0ToG4QiAg9oPYS+EXRB2aBuEzRA2QlgPYY1tWAViuY1YCmIxiAUg5oGYrRkwptmKySAm2opxMMbAGAVjuCNqqK0YBGMgjAE2oz+Mj2D0htETRncY78Po4qjqCOM9F3k72/GO7Xjrw+4ftu7erfsb3s5buD9eBfKK+6MZkKYu9BeAPOfF8BlH1lM2pLFH38e9izwG5BEfyT8M5AFbcr8393u9KN5z43U33uWCv/N3l/3udkfXbS74Wy8878Kb3Sc3Q7nJJX8DlBug/AHK9e3fbT81asqUKRHDrlG1qgy7oq5yAy9ViYoMvUD5yjX4HGUZfqbSDD9VyYafqDMA4nQawCkAJ3QMwlEAh3QAwj4IuyHs1HYQW0BsArEexFqX9WoQK0Asc08sBrHQRswHMcdWzAIxHcQUEJMcUeNtxVgYY2CMdEQNgzEExmfeNT6F8TGMfp6o+rjEe8HoAeMDR1VXR1Vn29HRdrS3He086r5jO9oAae24esNx1cL98ar74xUgzYA0BfICkOeAPOtt/Wkgjd0jTzz20GONHFuPukce9vnWQ0Du9xnXfT5SudcFf7ctudPR9ScX/O1AbvPSeKvH4Vug/NFHLDd97f987UYoN77b7t3pUZMnT44Yeo2qDbxKFSFDL1epSgy+SIUGn6885Rh+ljINP12pAJKVCOCM4iCcBnAKwAkdh3AUwGEAB7Qfwh4IuxxL223DVhCbIWzQOhBrbMNKEMtBLAWxyFYsgDEXxmwQM2zFVBiTHVETbcU4GJ87okbBGGEzhsEY7F1jIIxPYPSH0de90dtR9SGMHrajmw8Ru9qOzu6ODo6r9i7zdo6rt4G0cVy1AvIGkBZAXvXzIa8AaebIagqkCZDnvYs8C+Rpn2s9CeQJj7+NgDxqSx5xbD3k2HrAltzvgr/XY/A9tuQu98mdP/vxz/5kS273OHw7lFuh3ALlZih/bNeu3YyoSRMnRQy8RtWGXaWKkIGXq9TAS1SkQkPPV56h5yhLmYafbvhpSjb8JCUAiAcQqxgAJwFE6xiEwzbhIIT9NmEvgN0AdmqbbdgCYhOE9VoLYhWIFRCW2YjFIBaCmAdiDohZIKaDmGorJoGYYCvGeQMfA2KkzRjumBrimBoEY6DNGGAz+juqPrIZvWF8CKO7945uMLrC6ASjg6er9p6u2jmu3nFctXGht/aE9YaXwpbe1F8F8oo7pJkjqymQF4G8YEOedY88A+Qp90hjII/bkkaOrUeBPGxLHnLBP+gN/n5bcq/75B4X/F225E6fDt/pcfhPUG6HchuUW9u2bTszKvxWCIOuCRlylSpVoXIDL1OJgRerUAWGnqdcg89WpsGnK83wU5Rk+AmGH6/YpYuXxAA4ZQuiIRyDcATAIR2AsA/CbtuwE8J2CFshbLYNG0CsA7EGxEoIy7UExCLH0wIY80DMthUzQEyzFVNsxUQY423FWFsxGsZIGMNgDIExyGZ8ajMGwOgH4yMYvR1VPT1ZdXdUdYPRxd3R2XHVwXa0B9LOdrztuGoDpHXzZs3f8HPrLYG8BqS5I+tlIC950noRyAvukeeAPOtp62kgT9qSxh6BH/f2/pgL/lFH1yMu+IdsyQNeGO+Hcp8tucc7yj1Q7vKOcieUO6Dc0fadtrOjxo8fHzH4GgMPValSFQZfrjKDL1GxCg2/QHmGn6tsAFnKAJDmGEqxBckQEiGcgRAH4TSAUzoB4TiEoxAO6yCIfSD2gNgFYgeIbSC2gNhoI9aDWOueWA1iBYhltmIxjIW2Yj6MObZiJowZMKbCmGQzJsIYB+Nzx9RoGCNsxjCbMdgl/pl74xMfIH7sJbCf7ehjO3rZjp6Oqu62433HVRePu51sRwcg7YG09YT1tg15C0hrIG8AaQnkNSDNgbwMpJn3kaYu9iZAnve09SyQZ2zJU0Aa++DxCRd8I0fXY46uR2zJw+6TB90nD9iS+72j3Ocd5V6X/N1Q7oZy1ztvvzMnatzYcRGDrgkZdJUqVaFyAy9TiaEXq9DgC5Rv+LmGn23wWcow/HSlGn6y4SfqjOIgnAYQA+AkgGgdhXAYwiEI+yHshbAbwk4I2yFssRGbQGwAsQ7EGhArQSwHsdRWLAKxAMQ8ELNBzLQZ071nTIExyWZMgDEWxhgYo2AMhzEUxiD3xkAYn7jIP4bRz3b0sR29bEdP29HddnTzuNvFcdXJ/dHB/dHehd4OyDs+y3rLY++bQFoBed2nvi2AvPrQfQ+9AqSZe+Qlx9aLtuQFIM/bkmeBPG1LnvJp8JMu+Cf8MqJGPut6zJY84uh6+Eff/dFD3lEegvIAlPuh3Aflvrffentu1NjPP48YfE3I4KtUafAVBl+uMsMv9SO/2PCLVKB8ALkAspVl+JlKB5AKIFmJEBIUDyEWQgyEkxCidQzEERCHQBwAsQ/EHhA7QewAsRXEZhAbHU/rYawFscpWrICxzF2xGMZCGPNtxRwYs23FDJf3VBhTHFMT+3/UbzyMsTBGO6pGesQdDmOIo2qQo2qgx9wBtqM/jL7ujj62o5fLvIft6O6F8H3HVRcgnYB08PF7eyDtgLwD5C0gb9qQVj7Teh1IC/fIa0Ca+wT4ZSAvedpq6mmriRfFF1zuzzm2nrElTzu6nnJ0NfZu8oQtaeToegzKo1AegfIwkAe/+q9ffRDKA2+1eWt+1JjRYyIGX2PYoSpVGnqFyg29TKUqNvgiFRh+vsHnKUfZhp9p+OlKBZACIEkJAOIBxOk0hFMQTkA4DuEohMMQDkLYD2EvhF3aCWKbjdgCYhOIDSDW2Yo1IFaCWG4rloJYbCsW2Ip5MObAmAVjus2Y6s6YBGMCjPE243NH1WgYI2AMsx1DbMcg2zHQUTXAdvS3HX0dV31sRy/HVU/HVXfHVTcXeldPWJ08YXUA0h5IOyDvAHkbSBsgrYG84R5pCeQ1x9arjq1XPG297HJ/yeX+osu9iS153pY85+h61tH1tKPrSU9djR1dT7hPHvfk1cg7ymNQHoXyCJSH27zZZkHU6FGjI4ZdEzLwKlUadkVdZb4tNfgSQy9SofINP085hp9t+JnKMPw0pQBIApCoMxDiIJyGcEonQUSDOAbiCIRDEPbbhn0gdoPYCWG7toLYbCs2glgPYq2tWAVjha1YBmMJiEWOqPku77kwZsOYCWO6d40pNmOSzZgAY5x7YwyMUTBGwBhmO4bYjkEwPoUxwHb0tx19HVd9bEcvF3pPx1V3IN2AdPXhYmdv6h194vsekHeBtAXyNpA2QN50j7QC8jqQlo6t1xxbzd0lrzi2mgFp6mXxRVvSxFPXC14Yn/Mo/AyUp23JU1CedMk3hvIElMehNILSqE3rNgujRo0cFTH0mpCBV6nSwCvqKjP4UpUYfJEKDb5AeYafo2zDzzL8DKUBSFUygCQAZwDEKxZCDISTEKIhHINwBMIh23BA+yHsgbDLRuwAsQ3EFhCbQGywFetArLEVq0AstxVLYSx2RC2EMd9WzPU0NctmzIAxzZ0xBcYkGONhjIUxBsYoGCMcVcMcVUPcHYNgfApjgO3obzv6Oq4+clz1cqH3dKF398jbDUhXIF3cIR3dIR2AtAfSDsg7QN4C0saHja19tvWGY+t1IC0cW6/akuaOrZdtSTNb8tLF51/c1FNXE0fX8+6T54E865J/FsrTUJ6C8iSUJ6E0frP1m4ujRgwfETH0mpChV6nS0CvqKvNtqeGXGH6RCg2/QPmGn6scAFnKgJAOIFXJEJIgJECIVyyI0yBOgTgB4bhtOAriMIiDIPaD2AtiN4idILaD2GorNsPYaCvWw1gLYrWtWAljua1YAmORzVgAYx6MOTZjFowZMKa6Nya7NyZ6qhrvqBrrqBpjO0bZjuG2YyiQwe6Oz2zHp7ZjgOOqP5C+7o8+QHoB6QmkO5BuNuR9G9IFSCcgHYC09/Mj7YC0dY+8DaSNY+tNx1Yrx9YbtqSlu6SF95JXfRrc3Ja84uhq5uh6yZa86D5pAuUFKC9Aec47yrNQnoHyDJSnW7dqvSRq+LDhEUOvCRl6lSoNvSJk6OUqVYnBF6vQ8AuUb/i5hp+jLACZhp+uVAApAJKUCOEMhDgIpyHEQDgJIRrCMR2BcEgHIOyDsAfCLhuxA8R2EFtsxWYQG0CssxVrQKwCscIRtQzEYhCLbMYCd8ZcGHNsxkybMR3GNBiTYUyEMR7GWBhjYIyyHSNsxzDbMcR2DHJcDXRcfeK4+tj90c/98ZGfD+nts6wPvRj2sCEfeOx9H0hXIJ1tSEcg7wFp72JvB6StY+ttIG1syZtAWtmSNxxbLW1JCxf8ay745p66XoHysvukGZCmLvmmLvkXoTSB8jyU56E81+qNVsuihg4dGjH0mpChV6kyZPAVKjf8UpUYfrHhF6pA+QByAeQoC0CmMiCkQUiBkKxEEGdAxIOIhRBjG05CiNZxEEdBHNZBEPu1F8RuEDttxXYY22BssRUbYayHsRbGai99K4Esh7HUZiyGsRDGfJsxF8ZsGDMdVdMdVVMdVZMcVRNc5OOAjLUdo23HSNsx3HYMtR2DHVeDgHwK5BMgHwPpZ0M+8tFJbxvyoQ3pCaS7z7S62ZCuHn07+6ndTu6RDu6R9kDe9bTV1iPwO46tt9wlbWxJa1vSypa8YUtaOrpaOLpedXS96j55BcjLLvlmUF6C8hKUF6G8CKXJG6+/sTxqyOAhEQOvCRl2tSoNPFShckMvU4mhF6vI4AuVb/h5yjX8bMPPUgaANACpAJKVBCEBQLwjKQ7CaZ2CcMJGREM4ZiOOgDgE4gCIfRD22IhdIHaC2A5iK4jNnqI2glgPYi2I1TZjpSNqOYylNmMxjIUw5tuMuTBmwZgJY7rtmApjMowJtmO87RhrO8bYjlG2Y4TjahiMIY6rQY6rgZ6wPnn8kcc/tiH9bUhfG9IHSC8b0tOG9ADygQ1534Z0BdLZPdIJSAcg7YG8a0vaudzfcZe8DaQNkDdtSWtHVysor9uSlo6uFlBec3S9CqW5t/lXoLwMpRmUZq+3fH1l1OBBgyOGX2PwoWqDr6yrwvDLVWb4pSoGUKRCAAXKg5ALIVtZEDIgpCsVRAqIJAiJEM4oDkQsiBgQJ0FEgzgO4qiNOAzjIIz9MPaC2O3i3uWu2AFjG4wtMDbB2ABjHYw1MFbBWAFjmUt8ic1YBGMBjHmOqjkwZtmOGR5zpwGZYjsm2Y4JtmOc7RhrO8bYjlFARgAZZjuGABnk/hgI5BMfLg4A0h9IXxvSx4b0AvKhDenhYu/uHukGpKt7pItjq5Njq6M39/dsSXtb8q4taetl8W0ob9mSNp663nR0tYbyBpTX/RxKSygtXPItoLwKpTmU5lBegbIq6rOBn0UMvCZk4NWqNPBQhcoNvkylBl9s8EUqVIHh5ykXQA6ALACZSgeQBiAFQLISISRAiIcQCyEGwimdgHAcwlEbcQTEIRAHQOwDsRfEbvfFThjbQWx1RG2GsdERtR7GWhCrbcYqm7ECxjIYi2EsgrHAZsxzb8yBMct2zLAd02BMsR2TbMcE2zHOZT7W4+4Yx9UoICMcV8OADHVcDQbyGZBPvakPsCEfA+kH5CMgfYD0AtITSA8gH3ja6gakqy3pAqSTLekI5D13SXt3ybseg9vZkrbuk7dd8G85utq4T96E0hpKKyhvQHkdSMsQlBYtW7RcHTXw04ERQ68JGXy1qgy9UhWGXq4ylRp+ieEXqdDwCww/LwQgR9kAMgFkAEhTKoRkCEkAEmzCGQhxOg0iBsRJENGOpmMQjkI4DOEghP02Yh+IPSB2gdgBYhuILbZiM4yNtmI9jLUu8NUwVsFYYSuWtmrZegmMhTAW2Ix5NmMOjFkwZsCYZjum2o7JtmMijPEwxtqOMS700bZjpONquPtjqA8XhwAZBGSgI+sTIAOA9AfSD8hHQHq7R3oB6QmkB5APHFvdgHR1bHUB0tnR1clHKh1syXu2pL2j610obW3JO46ut90nbzm62rhP3oTSGkirEJQ3WrzWYm3UJwM+iRh6Tcjgq1Vl8JWqMPxylakUQImKARQCKFA+hDwAOcqGkAUhQ+kgUkGkQEiCkKgzIOJBxNqIGBtxCsYJGMdhHIVxBMQhHQCxX3th7IaxE8YOW7ENxhZbsUkbYKyDscZmrLIZKx1Ty4EstRmLbcZCIAuAzHNUzQEyC8YM2zHNdkwBMgnIRNsx3naMBfI5kNFARgIZDmQYkCFABgH5DMinQAYA6e9Jqx+QvkD6uEd6e/z9EEgPW9LdsfWBLXkfSFdb0sWWdLYlHW1JB0fXe7bkXVvyri1pB6UtlHegvA3lLSBtQlDebPFqi3VRAz4eEDHsmpCBV6vKwCvrKjf4MpUafInBF6vI4AuVb/h5ygWQAyBLmQDSAaQBSFEyhEQICRDOQIiDcBpCjI04CSHaRhyHcNQ9cRjEIRAHQOwDsQfEbluxE8R2EFtBbHaBb7IZG2CsA7HGZqyCsRLGcpf4UhiLYSyEscBRNQ/GHBizYMxwmU+3HVNtx2QvhBMdVxMcV+McV5+7P8a4P0b5LGsEkOFAhgIZDGQQkIFAPgUyAEh/IP2A9HWP9AHS25Z86BG4py3pcfH5P//AlnSzJe/bkq62pIunrs5QOkLpAOU9R1d7KO2hvOvDyHZA2uodKO+81vy1DVH9+/WPGHpNyOCrVWXwlXVVGH6ZSg2/xPCLVWT4hYafHwKQqxwAWQAyHUkZENIhpEJIgZCkRBBnQMSBiAURA+IUiBMgokEcczQd0WEQB7UfxF5H1B4Yu0DssBXbYWy1FZthbISxwTG1DsYaGKtgrISxHMZSGIthLHRULXCRz4Mxx3bMhjHDdky3HVNtx2TbMcl2TAAy3naMdX+MATIayEggwz32DgMyBMggIJ950hroYv8EyAAg/W1JPyAfObb6AOltS3q53Hvakh5AutuSD2xJN0fX+46uLlA625JOQDq6Tzr69cMdoLwHpH0IyruvNn91Y1S/vv0ihl4TMvhqVRl8ZV0VAMpVBqDE8ItVpEIIBRDylQchB0I2hCxlQEiHkAYhBUKyEkEkgIgHEQfiNIhTNuIkiBO24jiIo7biMIxDMA7Yin0w9sLYDWMnjB0wtsHYAmMTjI2OqfUw1ro3VgNZ5d5Y4ahaBmOp7VhsOxYCWWA75gGZ491jlu2YaTum246pQKYAmQRkApDxPlwc68XwcyCjb77hllFARgAZBmQokMFABrlHBgL5FMgnXhI/dmz1tyX9gHzk2OpjS3rbkl5QetqSHraku6eu7kC62ZL3bUlXIF1CUDpD6QSkYwhKh+avNN8U5X+gJWLoNYYeqlaVoVeGDL5C5SqzAaUqAVDsBa7I8AuUDyAPQK6yIWQByASQrjQIqRCSISRBSIRwBkIchFgIMRBOQTgBIdpGHANxFMRhEAdBHHBE7QOxF8RuR9QuGDtAbLMZW0BsArHRZqy3GWthrIGxCsZKGMthLIWxGMZC27HAdswDMhfIbBgzYcxwXE0DMhXIZNsxEcgE7yHjbMhYIGOAjAYyEshwIMOADHWxDwYyCMhnQAYC+cSWDPAI3N+W9APS113yEZA+tqS3Lenl6PoQSg8o3aF88K2vfVvf6gblfShdgXQJQenc/OXmW6L69O4T8aO9xsBrDLzaj/gqVRp8paFXqNzgy1Rq8CUqNvwiwy8IGX6e4ecqB0BWCEIGhHQIqRBSlAwiEUKC4kHEgTgNIgbESRAnQBwHcQzEEVtxGMRBEAdA7LMVe0DsshU7YWyHsc1WbIGxyTG1EcR6rYOxBsYqGCthLIex1HYsgbEIxgLbMR/IXJf5HBizYMx0XE0HMtV2THF/TAYyEcgET1njgIwFMgbIaCAjbchwIMOBDAUyBMggl/tntmSgLfnUlnxy/k/O/9iW9IfSz5b0Ped7P/4ISh9PXb2h9ILyIZCeISg9oHQH8kEISrdXmr2yLap3r94Rg48Yeo2qVWXwoUrDr1C5ygCUAihRsYogFAIoUD6EPAg5ygaRBSETQrrSbEQKiGQQSSASQJwBEQ8iFsRpEKdAnAQRbSuOwzgK4wiMQ7bioPbD2AtjD4xdNmMnjO0wtmoLjE3ujY0w1sNY66lqDZBVQFb6dVjL3R1L3R2LgSyyHQttx3wgc4HMcVzNAjITyHQg07ypTwEyGchEIBOAjAMyFsgYGzIayiggI9wjw4EMAzLUhgwGMgjIZ7ZkIJBP3SWfAPnYlvR3dPV3n/QD8hGQPu6T3kB6A+nlyetDL449v/IvX+kBpLaXm728Pcr/wkHE0COGXqNqA6+qq9LgK1Ru8GUqNfwSFRt+keEXqgBAvvIA5ALIBpClTAgZENIhpEJIgZCsRBAJIM6AiAMRCyIGxCkQJ0BE24pjII6COAziEIgDIPbbjL2OqN0gdjmmdoLYbjO2wdgCYxOMjT4iWW8z1jqq1sBYZTtWwlhhO5bZjiUwFnu6Wmg7FsCY57ia67iabTtmAZnpo5PpQKYCmeIpaxKQiUAmABkHZKwnrc+BjHGxjwIy0oaMgDLcsTXUxylDHFuDoQyyJZ9BGQjkU1vyCZQBUD6G0h9IP09dfaF8BOUjKH2g9AbSK/TySy/viOrZo2fEwCOGXaNqVRl6qNLQK1QeMvjSkOGXGH6xigy/0PDzQwBylQMhG0IWgAylQ0iDkAohGUIShEQlQIiHEAvhNIQYx9NJECdAHAdxDMRREIdtxUEYB0DstxV7YeyBscvT1E4Y22FssxlbYGxyTG2EsR7GOhhrYKy2HatsxwoYy23HUtuxGMYi27HQdswHMs92zHF/zAYyy5v6DCDTPfZOBTIFyGRH1kQgE4CMBzLWlnzuHhkDZDSQUZ62RgAZDmQYkKHukiFABgMZBOQzR9dAKJ9C+QTKACgDoHwMpT+UflD6AqmtWdNmu6LcHRFDjxh4japVZfChSlUYfqgcQJlKAZQYfrGKABSqAEI+gDzlQMiBkAUhUxkg0iCk2YYUEMlKhJEA4oziQMQqBsYpECcVDeI4iGO24giMwzAOwjhgK/bB2AtjD4xdMHbA2O6Y2gpkC4xNjqqNMDbAWAdjre1YDWOV7VgBZDmQpbZjCZBFtmMhkAVA5gGZC2QOkFlAZnrsnQ5kGpCpQKYAmQRkog2ZAGScLRkH5HPH1hjH1mggoxxbI4GMsCXDoQyDMtQFPwTKYI/Cgxxdn0EZCGUgkE/dJ59AGQDlYyC1vdT0pd1RH3T7IGLoEQOvUbWhV9VV6dtKw69QueGXGX6pSgy/WEUACgEUKB9AHoBc5UDIhpAFIEPpENJsRCqEZBuRBCERQoKNiIcQp1hbEQPiFIgTigZxHMRRW3EExmEYB2EcALHPfbEXxm4Yu2zGThjbYWyzHVtgbHZUbYKxwXasB7IWxmrH1SrbsRLICtuxDMhSx9ViIIscVwuAzAcyD8hcGzIbyCwgM4FMBzINyFQgk4FMBjLRPTIBynjH1jhbMhbK57ZkDJDR7pJRQEbakhFQhtuSYbZkKJQhQAaHoAyC8hmUz6AMBPJp6KUXX9ob5XejRgw8VGPg1aoy8PoqDb5C5QZfZvClKgkZfpHhhwoAFBh+vnIB5ADIVhaETAgZENKV9lKTZikgkiEkQUi0EWdAxEOIsxGxIGJAnAJxAkQ0iOMgjtqKIzAOews/6L44YCv2w9gLYw+IXTZjJ4wdNmMbjK0wNtuMTTA22oz1MNbBWANjNYxVMFbAWG47lsFYAmOx+2MRjAU2ZL77Yx6QuS712UBmAZnpyJoBZDqQqUCmXPjTiyYDmQRkIpAJQMbbknFAxtqSz4GMATLaloyCMgrKSFsyAshwR9cwKMOgDIUyBMpgILU1bdJ0X5TfjRqBEDH4GlUbfqgqZPiVqgBQrjIApSEIJQCKVQShEECB8iHkQchVDoRs25CpDBDpINJApIJIAZEMIvH5p59LgHEGRjyMWBinYcTAOAnjBIxoGMdgHIVxBMYhGAdhHICxD8ZeGHtsxi4gO2HssBnbgGy1GZuBbAKy0VG1Hsg6IGuBrIaxynasBLLCE9YyIEuBLAGyyIYsBLIAyHwg84DMATIbyCwgM90jM2zIdCDTHFtToUxxbE2CMtGWTIAy3paMgzIWyFggn2uMLRkNZRSUUUBGagSUEVCGQxkGZGjoxSYvHojq0qlLxMAjhl2j6pChV9VVafAVKjf8spDhl6oEQLHhF6kQQIHyAeQByAWQo2wIWRAyIWQoHUQahBQIyRCSICRCSIAQrzgIsToNIsYRdRLECUdUNIhjII46oo7AOAzjIIwDMPbbjL0w9sDYBWOX7dgBYzuMrTC2wNgMY6O7Y4PtWA9k3fVXXbcGxmobsspxtRLIciDLbMhSIEuALAayEMgCIPOBzAMy14bMATLbPTITyEwg04FMAzLVlkwBMsWWTIYyyZZMhDLBXTLeloyDMhbK51A+BzImBGS0RkEZCaS2F1948WBUp46dIoYeMfAaVYcMvaquSsOvMPhQucoMv9TwS1QcMvwiFaoAQL7yAOQqB0I2hCwImRAylAYiFUQKhGTbkAQhEcIZCPGKc1fEgjhtK2JgnIJxAkQ0iOMgjoI4YisOwzgI4wCI/SD22Yy9MHbD2OWo2gljO4xtMLbaji1ANtmOjTA2wFhvO9YCWQNjte1YBWSl+2MFkGVeDJcCWQJksXtkEZCFQBYAmedJay6QOUBmO7ZmA5kJZAaQ6UCmAZlqS6YCmWJDJkOZBGUSkAlAJji6xgMZFwIyNgTlcyBjQk2eb3I4yu+xixh8xMBrVB0y+KqQoVeqImQDylVm+KUhW1CiYghFAApVACEfQh6EXOVAyIaQpUwQGSDSQaSBSFUKhCQlOp4SbMUZEPEg4kDE2ooYGKdgnIRxAkY0jGMwjsI4YjMOAzkI5ACM/TD2wdhrO3YD2QVjJ4wdMLbZjq1AtgDZDGQTjA22Yz2QdUDW2o41QFYDWQlkBZDlMJbZkKVAlgBZDGSRDVng2FoAZT6QebZkLpDZjq3ZUGYBmQlkhi2ZDmRaCMpUWzIFymQok6FMAjIxBGRC6Cv/8tXxQMaFoByJ8tu5IoYdqjHsUPWLzzetMvBQpaGHKgy9XGUGHyo1/BIVG35RCECh4RcoH0AegFwAOcoGkKVMG5EBId02pEFIhZACIUmJIBJAnAERDyIORCyI0yBiQJwEcQJENIjjII7ZjCMwDsM4BOMgjAM2Yx+MvTD2wNgNYxeMnTC2w9hmO7YC2QJjM4yNtmMjkPUw1jmu1gJZYztWA1kFZKX7YwWQ5UCWAVkKY4kNWQxkEZCFQBYAmQ9kHpC5mgNkti2ZDWQWkJm2ZAaUGVCmA5mmqUBqAzLFxyuTbcokILW98NwLR6P8dq6I4UcMvqauasMPVRl+ZV0VAMoNP1QGoFQlAELFEIpUCKIAQr7yIORCyAmByLYNWSAyHE3pMNJBpIJIAZEMIkmJMBJgnIERDyMORiyM0zBOwTgJ4wSMaBjHYRyDcRTGYRiHYByEcQDGfhj7YOyBsRvGLhg7YeywHduBbAOyBchm27EJyEYgG4CsB7IOyFoga4CsBrIKyEpH1gogy4EsA7IUyBLH1mIoi4AsdGwtADLflswHMk9zgcwBMhtIaBaUmUBmhIBMBxKaBmUqlKlApoSef+7541Hvtn03YuARw66pq9q31YZeFTL0SlWo3ODLDb5MpSHDLzH8YhUZfmEIQIFNyFcehFwAOcqGkAUhE0KG0iGkQUiFkAIhWUkQEiEk6AyIeBBxIGJBnAYRA+LkbTfdegJEtCPqOIxjMI7COALjMIxDMA56qjoAZB+MvdoDYzeMXTB2wthhO7YD2QZkK4wtjqtNQDYB2QhkgyNrPZC1QNbYkDVAVgFZCWQFkBVAlgNZZkuWQlkCZDGQRbZkEZCFtmQBlPlQ5gOZB2Suo2sOkDmeuGaHgMwKQZkJZSaQGaHnn30+OspvUokYeMTAa+qq9m21oVeFDL5SFSHDLzf4spDhl6rE8Itre+ixIhUCKACQH4KQp1wIORCyIWQpE0QGhHTbkAYiVSkgkkEkgUgEkQDiDIh4EHGKtRWnYcTAOAXjJIxoGNEwjsE4CuMIjMMwDtmOgzAOwNivfTD2wtgDYzeMXTB22o4dQLYD2QZkC4zNMDbbkE1ANgJZb0PWA1kHZC2QNUBWA1kFZCWQlUBW2JLlQJYBWRqCsgTIYiCLtBDKQigLgMwPAZkXAjI3BGSOZgOp7blnnjsZ5TepRAw8YuA1dVX7ttrgq0IGX1nbw40qVA6g3BFUZvildZUAKDb8IsMvrKsAQj6APAC5IQg5ELJCEDIhZEBIVxqIVBApIJKVBCMRRAKIMyDiQcSBiAVxGkQMiFM6CeMEiGgQx0Ec01EYRxxVh2EcgnEQxgEY+2Hsg7EXxh4Yu2HsgrHTduwAsh3INiBbgWwBstmFvgnIRiAbgKwHsg7IOiBrgawBshrIKluyCspKICtsyHIgy0JAlgJZAmSJLVkMZFEIyMIQkAUhIPNDQOaFoJyK8vshIoYeMeyauqp9W+1HfajK4CtDBl+h8hCAMsMvDRl+SV3FEIoAFAIoqCsfQh6EXAg5ALJDELKUCSIDQjqENKWCSAGRDCIJRCKIRBBnFA8jDkQsiFhbcRpGDIxTIE5cc8XVJ0BEgzjumDoG4yiMIzAOwzgE46AOwNgPYx+MvTD2wNgNYxeMnTB2wNjuuNoGZCuQrUC2ANkMZBOQjUA2AFkPY10IyFoga4CsBrIqBGQlkJVAVgBZHoKyDMhSd8lSIEtghBaHgCwKAVkYevbpZ2Oi/H6IiKFHDLumrmrfVht8qMrgK0MGX1FXueGHygCUGn5JXcUAigCECiEUKB9CPoA85ULIgZAdgpAFIRNChtJBpIFIBZGiZBBJIJJAJIJI0BkY8TDiYMTCOG0rYmCcgnESxgkY0ToO5BiQoyCO2IzDMA7BOATjoA4A2Q9kH5C9QPYA2Q1kF5CdMHbC2KHtMLZpK5AtQLYA2WxDNgHZCGQDkA1A1juy1gFZG4KyBspqGKtCQFaGoKyAsgLKchihZe6TZUCWhoAsCUGJjXqz1ZsRQ48YeE1d1b6tzeCrQoZfafAVdZX7thxAWQhAqeGXqDgEoQhAYQhCAYB85UEI5YLIgZANISsEIhNChtJBpIFIBZECIRlCUghEohJgnIERDyMORiyM0zBiQJwCEToJ44TtiAZyHMgxIEeBHIFxGMYhGIdgHIRxAMZ+GPtg7LUde4DshrErZEN2AtkBZDuMbSEgW4FsAbL5R9/54WYgm4BshBHaAGQ9kHW2ZB2QtSEga0JAVgNZFQKyMgRlJZAVISDLQ8889UxcVOs3WkcMPWLQNXVV+7Y2Q68KGXylgYcqQgZfrrKQ4ZcafqjE8IvrKgJQCKAAQCgfQB6AUC6AHGVDyIKQBSFTGSDSIaQpFUIqhBQlg0gCkQgiAUQCiDMg4hUHIhbEaRAxIE6BOKkTME7AiIZxHMYxGEdhHIFxBMZhGId0EMgBIPuB7IexD8ZeGHtg7LYdu2Hs0k4gO4DsALLdhmwDshVIaAuQzUA2A9kEZGMIyAYY60O2ZD2UdUDWhoCsCUFZA2R1CMiqEJT4qFavt4oYesSwa+qqNuz6qnxdZfCVIYOvCBl8eV1lhl8aAlASAlCsIgihQggFAEL5EPIg5IYg5CgbRFYIRCaIDAjpENJCIFJBpCgZRhKMRBAJIRhnYMTDiIMRCyJ0GkYMjFMwTsIInQASDeQ4kGNAjsI4AuOIp6vDQA75efWDQA4AOQBkP5B9QPaGgOwBshvILiC7gOwEsiMEZDuQbSEgW0NAtgDZHAKyKQRkI4wN9QFZH4KyDkhtQNaGnn7y6YSo11u8HjHwiGGHakIGXt2gKl9XGXyloYcqQgZfXleZ4ZeGAJQYfqgYQFEIQKEKABQYfr7yAOQCyAWQo+wQhCxlgsiAkHHV5Vemg0gDkQohBUIKhGQlgUgEkQAhdAZEPIg4ELEQTodAxIA4BeIkiNAJGNEwjoM4ZjNCR2EcgXEExmEdAnIQxkEYB2Dsh7EPRmgvkD0wQruB7IKxy4bshLEjBGQ7jNA227E1BCS0BcjmEIxN9cHYGIKxoT4oiVEtX2sZMfCIQYdqQoZd3aAqX1cZemXI4CtCBl8eMviyukoNP1QCoNjwQ0UAQoUqAJEfgpAHIBdAKAdCNoBQFoRMCKGMKy77XTqMNBCpIEIpMJJBJINIUiKMBBgJIM4oHkYcjFgYodMwYmCcCgE5CeQEjGgY0TCO6xiMYzCOwjgCI3QYyCEgB0NADgDZDyO0D8beEJA9MEK7gYR2AdkZArIjBGR7CMi2EJCt9QHZEgKyub6nGj+VFOXXrkYMuzbDrgkZdnWDqnxdZfCVIUMPVRh8qNzgQ2UqDRl+Scjwiw2/KASgMASgAEB+XXkQQrkgciBkhyBkQQhlQsiAkA4hlAYhVSkgQskwkkCEEmEkwDgDIhQPIw5EHIhYnYYR45iKgXEKxEmdgHECRnQIyHEYx2AcDcE4AiN0GMghGIdsx0EYoQNA9sMI7QsB2Qtjj+NqD4zQbhi76gOyMwRkR31AtoeAbKsPSkqUXyYZMezaDLumPgOvrqvKt7UZemXI0CtCBl8eMviyukoNP1QSglCsIgihQgCFAAqUDyAfQF5duRByQiCylQUjC0SmMkBkQEiHkBaCkAohJQQiWUkgEkEkgkgIgTgDIl5xNiMORqxOwzgNIwbEqRCMkzoB5ASM6BCQ4zCOwTgK4yiMIyEYh0NADoVgHNQBIAeA7AdSG5B92gukNhh7QjB21+c+2QWkNiA763vyiSdTo/yKvIhB12bQNQ2qvu6q6+u6rsrwQ5WGX5uhV9RVbvDlhl4WMvjSukp8WwKgOAShSIUQQgUAQvkA8gCEcgGEciBkh0BkKRNEKANGBoh0pYFIBRFKgZECIllJMEKJMBJgJIA4o3gYoTggcTBidRrGaRgxIE6BCJ2EcQJGKBpI6DiQ4zCOhWAc1REYocMwaoNxSAdh1AbjQF37gdQGYl9de2F8EZA99UFJi/Ir8iKGHTHoUE19Bl7doCpfVxl+qDIEoCJk8OUhgw+VGXyoNGT4JXUVAwgVQQgVQigAEMoHEMoDkGv4oRwAoWwAoSwImSEIGUoHkQ4hTakQQikgUkAkKwlEKBFEIogEnYEQigcRF4IRG4JxGkYoBkboFIyTMEInYISiYYSOwzgWsiHHgByFEToSAnI4BORQCEbooA05CORAfVD21wdkX32NH2+cHuUXf0UMuTZDrmmYYVc3qMrXVQZfWZ/BV4QMvjxk6GX1GXxpyPBLQoZfXFcRgFBhCEQBhPwQhLwQhNwQhJwQhGwIWSEImSEIGSEQ6RDSQhBSIaSEICSHbERSCEYiiIQQiDMhGPEhGHEgQrEwTodgxIRgnArBOBkCcSIEI7o+GMdDMI6FYBytD8iREJTDQGqDcahhQA7WByUzyi/+ihhybQZc0zCDrq7PsKsaVOnrUIXB12bw5XWVGX5thl4aMviSkMEX11Vk+KHCEICCEID8EIS8EIRc5UCoDUK2skBkQcgMgcgIgUhXGohQKohQCowUEMkhEEkhEIkhGAkhGGcUD6M2GHEgYiGETtuK2mDEhGCcquskjNpgnAjBiK4PxvH6YByrD8jRhgE5Uh+UrKimLzaNGHxthlzTMMOurs/Aq86q0vcrDb8iZPihcsMPlYUAhEoNPlRi8KFigw8VhQy/sD4ABXXlQwjlQQjlggjlgMjxFJUNIgtCKBNCbRAyQiDSlQYilAoilAIilAwilAQilAiiNhgJMM6EYMSHYITiYIRiYYROg6gvBkboVAjIyRCM0In6gETXB+R4w4Acq++JRk9kR/nVExHDrc1waxpmyDWqrs+gqxpU6evaDL6iPsMvDxl+WX2GXxoy/JL6DL84ZPBFIYMPFRp8qMDwQ/mGH8oLAcitKwdCKBtCKAtCbRAylQGhNgjpSoNQG4TUEIQUCKFkCKGkEIjEEIiE+mCcCcGIDwGJqw9EbH0wTodAnHZcxdQH41R9ME6eHZAT9UHJifIT9RFDr82Aaxpm0DWqrs+wqxpm6JUNqvB1heGHykMAQmUhAKUhAKGSEITiEIRQEYRQIYBQQQhCfghAKA9AKPcnPwz9JAdAKDsEISsEIZQJIZQBIZQegpEWghFKBRFKARFKDsFICoEIJYZgJIRghM6EYITiQzBCcSEocUBi6wNyuj4gpxXTMCCn6gs/jR7lJ+ojBl2bodacneFWN8yAqxpm0JUNqvB1bYZeXp/Bl4UMvvSLfnJBCYDaDL+4PgBFIQCF9UEoCEHIDwEI5YUg5IYg5IQgZIcAZNUHITMEIaM+EOkhCGn1gUitD0RKfTCSQyCS6gORWB+IhBCMBBBnGgYjvmEw4s4OSGx9jz/2eF6UnxOOGPIXGWjN2Rlu9VlVGfIXGXRlgyp8XWHYofKGGXxZXaUG/0WGXxIy+OIGFQEIFRp+fQUAagOQXx+EvBCE3Pog5NSVDaI2CFl1ZYKoLwNEbRDSG5QGojYQqQ1KgVEbiGQQXwQjqUGJMP4sGAlnB+NMw6AURPnpx4iBf5Fh13xJ1Qb95/3kgioD/yLDrqzPwCvOqtz36ysDUBuA0gaVAKgNQnF9AIrqg1BYVwGE+vJB1JcHor5cELWByKkPRnZdWSDqy4TxRSAy6kqH8UUg0kB8EZDU+mCkNAxIcsNgJH1ZQBIb1ujRRgVRfqYrcuF5F9Rm8BGDrvF085ede361oX+RIVerqmEGXdkwA69omIGXN6jM12WGHyoNGX59Jb4uARAqBlBfEYD6Cn1dCCFUYPj15fs6H0J9eRBCubV9/Tu5MHJCIOrLhlBfFojaIGTWByOjPhDpDYOR1jAYaUptGJCULwtIcsOgFEb5SZWIYX+RIdd8WYZdfXYGXq2qhhl0ZcMMu6I+g65QeX0GXq6yBpUCaFiJ75cYfqi4PghF9QEoUmEIRKigPgj59UHIVx6I+nJB1AYgpz4IOcquD0S2suqDkdkwGBkNA5Gh9LMDknZ2MNKU2jAoxVE+v48Y6p9lqDV/pWp/vtqQG1bl+1UG3bBK36807IZV+H6FIddX7utygw6V1WfYZSqtz7BLVVKfgZeouD5DL1ZRyNBDhfUBKFRBfQAKlF8fiHzlhSDUl+vrXAj15fg6B0TDsn0/G0bDsnw/C0bDMn0/E8aXlQHjL/KLWIqjfFQcMdQ/y0Br/laGW312Blx1dgZdeXaGXXF2Bl5+doZe1jBDL22YwZc0zOCLG2bwRQ0z+MKGGXzB2Rl+/tkZft7ZGX7u2Rl+ztnByP5bQck6u8ceeaw0yqeSEQP+iwy45m9l2NVfloFXfUmVhv4XGXrF2Rl8+VmVGf7ZlQL4swCUnFUxhLMrAvFnQSg8OwgFX1I+iL8IRN6XBSP3bwUj58v6T5THn4wY7pdVY7h/M4Ou/htVff+b36sy9LOrNPSzqzD4L6vc8P8iwy87OwClZweg5EsqhvAXQSj6kgpBfFkFIP5a+TD+ZjDy/lpQyqJ8ABYx/C/NwGv+XoZe/dcy/GpVnR2AKlWeHYBKVZwdgAqVnx2EcpU1DEKZSs8ORKlKzg5EiYrPDkaxis4ORpEK/1pACv5eQPL/Wo8+/Gh5lNf6iKH91Qyu5h/NMKv/VoZa9fcy4Mq/lkFX/LUMu/yvZeBlfy1DL/17ASj5W0Eo/kcCUayivxWUiii/XjhikH83w6z5r2Sw1f9Ihlz19zLsyr+XoVf8vQy//O9l+GX/SBBK/yuBKPlHglIZ5bk4Yth/NwOu+e9k4NX/aAZf9Y9k+JX/SAAq/pEglP+jgSj77wSk9B/pP1H84u5vfOWb+sZ/pRrD+59Ubaj/naoM+b9apYH/d6ow/P9J5RD+y/kdDVVRbvuIAf+3Mtia/40MukbV/5MMvup/EoDK/61gVPx3e+ShR6qjrEvEMP7XM6Caf2YGWv3PysCrVfX/RlBqovyfiOH9UzO8iGr+b+7fo75SUzf8APBP6wsUf9PIP6+v/BP/Xv/Mf67/nb9XWJLa3zT0yIOP/P/9XzKD4PH/ABYzZXBSXEBtAAAAAElFTkSuQmCC)",
                height:'101px',
                left:'47px',
                top:'47px',
                width:'101px'
            },
            ADVWHEEL:{
                background: ood.browser.ie6?null:"url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMMAAADDCAYAAAA/f6WqAAAAB3RJTUUH1gcOCDIojJpTggAALYlJREFUeNrtnXmYHUW58H9V1WdmMtlDQtijSSDKorLovRAWAwqyiBJugoCK6CfqRdSLityLkIsiF9SIyqIsRhZBlu+TK0JEQBBFUEAEZQ9LgkCABBPIJJnMdFd9f5wzM2d6qrqr+/SZmUy6nqef06e6z9Ld76/epd6qgrKUpSxlKUtZylKWspSlLGVxF1HeguKLAQmTp0JlOuitQU+BaHJ105NBj4JoDEQKolYwoxAmQtKBxKBYi6ITxWokK1GsQPI6ilcQLEWxjBfpFGDKu13CMBwEXsA2bTB+BzA7Qbgz6B0hmgl6GugxEAG6tkX0va/fr70XBhQgqb72bLb3kgjFy0ieQ/EUiscQPErAo/yNlaL6pWUpYWia8Cv4l21BzwYzG6K9IHo7mBarcPcTfG0BwROGNED67xsUy5E8gOSPBNyD5mH+VGqREoaGhX+/KSD3h+j9EL231uILt+AnaYACYcgCiKADxZ+R3IHgNlp4jFvpKuEoYUgBYL8A2mYB80AfDGZXiCp+gu8CwXY8AYaigHABInkJyW+R3Mga7uBu1pZglDDUAJinIJoOZh5ER0L0LjDSLsjaQ9BThN5VlwZDEUD0hwIkK1DcguQ61vN7cTPrShg2Sef3Q+Nh1GGgPwF6X9CV/K2/zghCThgaAUWmOuXLEPwcxZW8wBJxN2EJw4g3g6btCOLTEM0DPdXd6usMTnAW08hxrB4Gl3AH/YR3YF3Pq+08l3YIYucJulH8HskiWrlJXERHCcOIguC4NmjbB6KTQB8EumWgIOuMwp0Vjoww2IAIKN6UkgM0RP37JUguJeBKfshrI923ECMbghPaITgMzMmg31ONBLkEX3uaP41C4DgnDkMQa8HjMKiCwZBOvwIUKxFcTsAFLOQfI7UfQ4xMCL48GsLDgK+A3qNP2NNMH90kCNLMJgcMPj6ELxg2gQ88YOj/ugrJIgQX0MYL4syRBYUYWRCc1AptBwFngN7dHQnKA4GPo5xUlwJLEgxZBD5wCH1WcylZW6xCcAkB3xdn8koJw7CCYIGEaCcwZ4I+HLRyh0V9Wn2dQ6C1p4lUAAxJgGQxpdIiTK7XvnOXYvgGa7heLGTtxi5HcuMH4VtTQJ4N8o8gjwChqozXb5KBdSQcc21g/245NO2K628Iy99JuwwRuwyfWyh4CwGL2IxbzDnsba5HlTAMkUlk+NZc0PeA+BrIsenSkf50/QBwSdww1Pu+ly499utva/9z9kNwGy/wPfNttihhGDQIEIZzt4dtLgd5PcgdskGQZ8Mi/Hm+owmCPRSbDRbJKARfoMI95gfMNwtoK2Form/QBucdD8EfQH4EpHILv3S85tEOvsJdMBhZv6Z5gu7WEvE2SDEDyTVswU/NhWxbwtAUEH6wDUy+FOSlIKfadLW/VpANCn+jrX9B5lWjFl6WWyQTXgfWKeAjVLjL/ITDzAKCEoZCIJinDD/+AAR3gvgoSJluFskM2sH2HUU1szmBSPu478/JDIKfdgvTbqe0tkkzENzAWznHXMTEEoaGQLi4HQ78Ksj/C2p71x3P1pTZzofGfQhvqTZAN9AJrK1tbwJravvrgK5azNX9dUWYSdIRQUozh4SHU913bhuSLzOGX5irmDXc4w3DFISfbgFiIURHV9MojKW/QJPcsZanL8GzX8C5hRFE6yFcD3otRMsgeh7ClyH8J4SrIHoD9Bro6qyez3qgQkArCoVkDAHjUYwnYBIBUwiYRsAMFJuhaEPRTkCFAJHYv5Clv6K+r0KSrWNOpuz3ZMbC51DcJuZbYC9hsIFwza6gL4NoN7fw+/QupwHQQCdZddMQroNoNURPQPgg6Ceg+3nQS+GZ5YJiH7qZzngqbIdkOhVmongHinejmErAWAIquTvusiT3JeUyJQPSAfw3a7hQHE9nCYM7WiRh54MgvAz0VunCn0cz5Emr6N0MhJ0QrYDoftB3QfgIrH9M8MjqIbtv+xHQxUwUO6PYE8X+KKahGEeAStQasgEgkjTDQK1QX6cRXIThdHEEq0sYBoDwYAWWfRKib4MZlw5AxEDTqdG0bBcA0TqIXoDoFtC/gbV/EdyzatiamPsRUOHtVJhNhblI3oViEgHKy4RKy4LtEe7AA4Iks0lwM4bPig/yUglDLwg3tYM+tbZV0k2jpHyjJCiSxigPgKATwuerAES3QHS/4OaNblikAcFcZqI4AMlcAnZHMYGgFgBNM5V8/Qfbe5noP/TUP4Tgo+JAntjkYTDcNQY6zgZ9YnXscSMQZMlGtYKgQa+E6G4Ir4aOOwU3rWGEFAOSY9iJVo5EMg/FTBQtmf0IHxCUFwg9GmIJAUeJ9/LXTRYGw+3jofs8MJ/oP/CmZzMeplIaCF7aIaqZQdfChqsEVz3BCC/mWMYxhkNRnIDi3QS0o2qRKVfqt8wAhy8Q9ZEmwTHsx31DNaJODB0It04C9SPQ8/3MoiwOs7dmiEA/B9Fl0HWV4JLlbGLFzKOFrZiD4osE7ItktNOx9knz9neibdtyJB9nL347FECIoQHh9vGgLqmCYAoEwXuEmga9DKJFsP4ywUWvsIkXcwIVJvF+JCfXIlLtmUFQHjCkA/EaAUeKPbhnxMNg+NM46Dof9Mft5lBen8ErgmQgehX05dB5keB7/6As/Z/PSbQynkNp4atIdkfV9Vv4hliTzKN0cwkEL6GYL3bj3hELg+E3o2H098CcMBAA4wGAacA8CteCvhHEtwVn/L0U+5Rn9TXGM4GPIjkZyVt7e7obgcEHhD4gliGZK97JQyMOhmo/QvhNMKf0OcvGA4asKRgDHGZd7RXWC6Dzl4Izw1LUMzy3bzMDxQICjkTRnjjnUp6+BjsIPftP08LBYhbPjRgYqj3LH/wcmO+DDuwANAKDE4Q3wFwF684RfP2lUrRzPr+LqbCBuSjOQPE2VK2PwqdHOq926APiHhRzxQ6s2OhhqE7l+JcPgrgazJhk08jk1AoDHGYN0eNVLfT6bwRnlusVFPEsz2crWvgGAcegGOXVz5A9olSVStUPiJ8zhk+LLZs76cAgwPD4bhAthmiqn5/gA0RSx1vYCdENoE8TnFg6yM3QEq18FMkCJNv19k34RpOy+A19GsIgOJdlnC7mNG8OWNFcEJ6dCht+DXpXf7PIBwhnROk10N+AsZcK5neVotvEZ3s576CFHxKwNxLlBUNWEPqbSxsQfIptuUaI5vRBiOaB8GA7jF0E+qg+4faFISsQkQH9GIRfEHzirlJUBwmIq5lMC2ehOA5FW2KOUh4QBg4tXYnkELEVDzTjemRzQDASJn4J5Dz7lamMdyHxPA3yTlAfLkEY3CKOZSUv80UkZyB5I5ew26fHt4OkmIzgJ+bV5kxH06Rhny8cAPK06nhlm1clPO6KV1MSgrwO5NGCo58txXMIgPgiG/grCxGchOTV1MemUh6zcoLQE87dBcV3jaFl2JtJhqVbgrwLzCy3aZSlw81pGnXXcopOEczvKMVyGJhNt3EIkh+j2DZRoPOYSf3NpYiAzzCORUXmMMliQTAVqJwLalZygFmQX59KQG4AdR50fbkEYRhpiQNZjORjSJ5FYgqNLPUXJYXgf1jDTsPYTHrtGFBHu+cOSRsB4nVX1oH4FnScLpi/vhTBYQbE/tyN4WgUj6NiQLh6q33Npv7t6RQCLjCG0cPOTDL8cxroe6tjl02CWZQUUTIpppHeANHZIM4WzCnTKoazyXQ/uyK4DslMJKKBHuiBnXD9X79Che8VEW4VxYBgAlh9OZhj7RAYTxCiBP8h6gJzLrx8Vk8fgjGm7FkeIgXgPCBE7zHzAO8h4OcopjtGuKXHVUTKvmAVitlCND5stCAY3vww6BuAYKDwpznNPs6zCUFfDOu+IpjTO72IMaZrOFz/EP32UH7eCwYA8zD7U+FqJFvk6ltwOdK1VyPACBZLmCsEG4ZUGAxvbAbqPjDb24U/i3awwRLpaup15/GCvfuNRzbGrB3EaxcFnCMG+f8U9d+8/3scBgDzGEehuATFuLpVRf1iKo75XI3oe9WgNRzfKrhyyGAwGAFd3wR9mlsT2LSEC4q4mRSZ6voL+kjBbgOyFo0xqxoQNNEEYRVDCEqzrj9TnRUGEDzDSQjO7ddT7asZ7NogLllLu+A940T+7NYGYejcEeR91XmOkkwjHy1h1Q7PAIcKdnza+vvGrMhwTWIQIRGD9Ps+5zb7+0TMTJL2Z0XAUhYScGJvLpMtUzVhlu8ebaCFs4n9zhj4Wl5nWuQHwQTA9aCPSIYgyTxKNJlWgT5G8LZbnf/BmJcyPsyGH3ZOYRMb0ffn+S6RBgOAWck4urgBwfv7RZg8zCPTZxINkKq6/Y4QZk8S/G1QYejGHCzhJoEJql+SVytY07i7QP8nzDgvqYfRGLM06cEU8XBzfGeW80WD/6VZv5P7s0kwAJgXmEkri1Fs7wVB7dvi2iDBAP/VJDhCiOxz3IqcWqHSBXdK2Lsn3bz6ZYb8TrSp9xOuh67jBDskRgeMMUsyCE8RIOQVHFHQ8WYJtiiqLg0GAPMah1LhWiRjXH5CzEFOBaFOokIFcyaJ7LNr5IKhE3OogZskyP5T9Zve1+waofczS2D9+wQzXki9qcY8nvGBNyqAIid8RQleoYLr8epzLDsMBsEazkVwci21YgAIBn8QLFAsngqHZ9UOIo9WWAt3ippWsK9lUa8pMmmItaCPFWzxS6//YswjOYRBDJJgFfm5Is91fdanEUl69YYBwKxiAi3cgmLPHv/B5SBnAaFWFxrYf2vBH7LIdua1tt6EA4G96gEwdSBU90Vd0pOqQVF/po69CqqhYnE5XPirTK5L9pasaIHJKrB5fyuPgMbPNY738f363zEpdfWf92+FJ7LarOVkJL9GMdFYTKKsENTVBxr+0xj+KAS6KZrBYNQquF3AHJ8lhWXMfErWCtHTEOwnGOM9u50x5r6M2iDPa14zwxe0PN8lMv5n399Nq3Mdr3egMy2MbgxnaTjVgGoEBEtdGMLsGYL7m6IZVsBeAvZ1aYX6OtnvmKgBIeu0RD+tsAHU1wXtWad57M7Q0mcRwqyCluXz3oLlccz3901KnU+jaSz31hQQmfyuhkM07OobezR+YATAfxjDMb79Dt4wLMBIAyebatcIWACoh8JlOonavug7y4BcDC035orwNi6kaQLrC1bS7+eBQWT8ftt7E9tPOm6DxniYTA0VIVjdaTjDwPUaRukcELhMJgMffgpmAU8WaiYtx+xk4CEBLVmWDXavvdnrZP8T5P4C8UhmZ96YW5uh6nEvKisyAiRShDftu/N+n0i5bt/PCs//Vu9Aq+zPEdUB1xo4Uldbx8TwqQcEvceBC94mOKlQzRDCcS4Q4k2MTNAUfa8CAVohFuUBIaYZsgp9ViH0FTAfOLK+9xXGrIIsPZzjNIe5kKxfIYjWGM6MYH8NkzxCp17mUm37yNOG03YQvFkIDC9h2rvhWN81to0HJLXXVzfADxq4j905W/9mtqJ5W9ws/62+Tub8j9oRZRIpPoMrgtQQGGMFj64wXGPgRBPTDnm0Qt02eT0cAVyR9h+8YsKdVQdnqyyrISettRlVNY0O4ZLRiBcbhCFtCxPeh3Vbt2PftnUn1MUuc0Bd5FnnM0OCsfVaWupMhjrXhuUVhzOdq2j4voaVPstP+ixNWXdxn1xg0mU9lWaDEc/AzQIOyboAfXK4lZcE7DYW8Vrem2eM+VmDtrpPnSiotZc5fzvtPJnhs83aeq8tj8/QzwoxLNTwHz3awaYRyKYZalY+79xN8HhDZtKTsKWAA7LecekwnUxfJ+MVExsAoVa6ChTWLALo+9n649rzvKy32uQUXhP7vUb6pgrzH9bDjyvwSQMTsoRUiYFC/+OBgY8AZzRkJkUwV0OrzzKBOkF9xepWGbikgHvXnWNLM3fClM/4mlKhxUxy1UU5N98pyxOTwVLMpbgJFD9WqKk0U7Akgv8XgklamNhncYLYNv96g8qtGQxGPArzohzOsnBrBiPguimIZQXAEGYMS+Zp/X1b86Tv0I46mxbQHorWdcttXUDxvlBivyFjTrUcaMoPiDzFHehCx5ILuEDDRzSMzuEwD6C49vkdtoJdgQdzwfAIvEXAnjQgMZantl7CTwu6b90Z4+CNCr/M4A+k1aWZTtKjnZEOgdcOv0J71NmAMI4IeVNMpbfAI0/CHzUcaHJA4NgEcFRuGCI4TEDFN/aX9LTqDNS/bE1h63R1eQiqLxTS47hO+WzSucIhpGk2vchwjsvfMAxMLtYJmiEOhImBEBd+U6R2EALzqOEKA3M0VBqBIGbXfcgYTnGlZyTAYISBg4yj6ZUWMGwSEXtaoYFFAqEL1AxZW+8iIi8yQ4svE0wXFxw6BRjpMImwdO2kQU0KEMLiI8TrmjHlzk0hvGxgWh4AtCUWbGDGHbA98HQmGB6EURHs49IEJqWu3siseyKvATcWeMO6M9jwPnUyIxB4tPARfhkrLnPIODSCsfgCBnvOpIx1ssXNJCyaAIcTLYrWBLays6DjL4ZrIjiVujBr1s6Q2DGp4f2ZYeiCvYBxcS3gep8ERt3+r3dAvFHgPQubHGOXnsddLbm27MuYA+0j+PH38dBo/HbLmBYwlscU1xRxhU6d7yoHwzyymOk3aviSgVG+ppAjtFoPyYHAhZlgiOB9OLSASdEIWJ4w0CXgfwu+X12DJPhJpk7asA6RAIF2QCUTQLAlBUsGZs9Lh2kUb8fiZpELgDgEJmYuFQ7GUnhoK3gW2NnDH3Bpg/j+fosNrYdYZt8LXP5CBPvkyTwz7qZ6JVD0yjrdBdr5WTSCfbRr8nHtcaxeqHVCJ5kruiMtoU8bFDJmHtnqfGWsaZphviD6g+EXGnbq6ZHGw0ewmUx1x8dreBfwZy8YfgPtGnbzScK33X2Hl7p4d8TaYQCDSGjls9S5nF9bK+8KXwrHvq7TDjZzxWYyxf2GtDoXEMbS2rvqbB1yhZYQfmXgq9TGOvjAQLp22NsbBgF7aGhzAeBrMtVHkTTc0YTGo5viHN1GWn7XexcIwmLX21p9bdEA2qEdbEJvYvuqTm6wdNTVD04nBqgLCNFkLfFwBK8Ab9X+plCaQz0bWBj/IVc6xt6+XeEJ3d/1+QbrgN81CQafbFVbmoUt/SIpJSNL+kVaykZStmpIcpqGLRlYk57x6lp02zXs2KfjtynaoL7MEYQh3OFzM9Lq627WXrYs1sChmt5ta/mT6lL8i0dnI14dIs2Q1fzx0R6S9AF9OsEk0rFzjeO4TQu4Wn1jCY/aepJtDaC0aAzfKGbTp/XX8DsDx9fGNXs50ZCYXLX5DJgGPJ8CgxEadrGZRXFV4vIbLHD8sUn3qSgYpKf5IzPAIRMAS1q+Ly26Y1KO9dQpiwAnJWbGv98XjKZrhxDuN9XIYeDjJJMCRrWTm11SYVgMY7urOUkDhD5tigTHFBKhhD81EYYsznCaRiAmnHgKc2Spiwusy4GWFqfZJuz1Ah73H+LPXaaYwRY3sZ+fEAfL1gs9KCAAHA7P/gKWAzOSWn0PjVD/fhfgpkQYumFHXXcT07SCSIFBQOf6hOSogmDI6+SKlNbbt+X3eXUtyJTU0tvMJOlwklXsNa01t2mGJCjSvqdpUAiBud5wXxyGJMHXjj9WV79zqs/QBbu4Jh8yDhhSzKkXDod/DLKZJGksWlSE8MsEPyIu7PHlOXQCLEmmT1aNYNMOtkiWtsDBYJpLEdwr4JiehjpN8E1CzLd2MekwGNhe4zcHYhIMddri73X9JUMBQ5L5k0X4XX6AzZySHr6By0ewQSBJnxVFZdQEceWuU4AwGeSt8GLgqbAaYWvJoQUG/LkQZi4wyDPrpp8MLM7KdNdIDiyhA+k4Vvu8MSSPOx0EMylJ+NPMpEY1RBoItgVeXVDUH7OdB96ZzE67P2lGwqwTBBStGZ6Oqs/bG4YUWtu2hq2AF50waJhuPIWfBGh07zX4zWaWs3Q5hNRX+Mkh8FkiQ2mtv80kskWNkjrS6h+FItuQTNss0EkAJGmKppaPwUs/gVVQXQTdVz3phJsgYXoiDBFMT1oYIGl+QYs5FZpY+KoJmsFX+H3Mn0Yd4qSl+RTJS3271rGJawRXNoJ0+JQueUlacUg6zCWRYno1rwhMZFgCbJOh9U/09HUVht9bYfgpZoKGcSIh3ECC1rDMQBUKeKGJtygkexKdzOEwZzWFbFBoS51J0BhJGkHG4LBFler3SXhUrnTzeJdRnghV0Z1vzxmYYzyFPUkl1gh/i9OB7obNlaNHsSeYnhGGtR9vTs9zWj9DHi2RxfxpxDeIw5CkGWy+gcrQ+vtGkbAIvw8Ag6ohwioM/Xq9jR0aLxvRwBQnDBo2czUhUcpdtMFgmhdSTfIZfNIlmgmDzFCXpBHix5VFOxiHlqjvc3A5uq7Hlzbm2qSEe5vZ8r0o+oIJia2+cUel6vc3S4Jhiklu6Z130mZKGXi9yTB0F+An5DGRfPyEtDqfTVn6FOJ1PmaRSdEMPhDYhH9Qi4FV2gMGl3awhNDcmiGEKfEBtFlAIBaSYOhgyGMa5QmRpqxl3/BmUuqUBYI0c8k42jkXCPFxGTLFRGvmw14t6uTcpAh82p/SSTAIGOPzJcLjeA2mfzbfjMzkM8iMmsKnTnn6DMpyXFmO+8IQd55VgqaoN5mIWb1xS9g2e0fS4J9BC7GGsEp6wpCmHWplTJJmaBd+Qu7llQ0CDF0ZQqZJHWl5o0eupDtf/yAeMq2HQqXAYNMIqgEHuh4KYemDiHcADnrnWxesrtRk3PeHUhr3dicMUW0xEtedynqlBlYPIzMpr/BnjRjZWvk0bRDV7RuH8yxjEOAAIwkSm0kU1WkL11iMLDO0NLO8GTb4OzEbstUJgwEV75ExBf3wRghDI0BozwhRvIdZxLSFzVwyjqhSHJKefeVW3APg0HVQRHV19Vt8xr1B8xnWgWmluNFEJnZv4tGksUX2kWhYOwxgaDSvKClalOQfiDqhttW5IDEOAJKiS1giTGmCqiymURIIrmGgg1baYW036AK/MtFnKKwIiv3X1t8Q1WkqjTHC0cq6Jgo3jtbYNnAm3hoL0meOiMcZXIm9NoESObp00pa50ikhU+FpGhEDgsEGImrid8d9ho4Cv1tSS6rayMugjPMti5eZNNrkG6vhKmuSzKRQDAXuZSmLR+kEERT0XcISfY3D0FWUM1w7f0L5CMtSYBnXXR3Mn1lVO2zPDUkwrDN+Qp56Tm2bVD6/shQYLZkga2aSaACCumPrUn2GRoCIeYQlDGUprIQwUYIUHoIO9lXfY7La4YQhhBW+wWPjAYOwZMGWpSwNRDImRHUwJAFhG3IQ1xgGVjhhMLAi/gU6Iwyx8aglDGUprGiYSCyaJNyC7mM2rUjyGV7Pkh/uMcRu2/IRlqWo0gXbKA8YpKf/EB9iIGM+w2tR3fq78Vlssy5MHMLoT2Gmlo+xLAVphukhiLwLZlvqVjhh+AFitYY3fRahTlsgvbYFErYrH2NZCnKgp4f5hH7Ae1PdX5qoUSJ4rj4RxWf6b9vc6rX9IIS3lo+xLAV4z6Jngrs0INJAqJua/jmnz0DfCbu6/ACT7DDH/QcFvK18kmVptHwAtg5hou/M8Lb38c465QNDmmOcYWo/AexYPsqyNFoE7BBCRVqE3DXLQdLMkEDnLHg5EYYIluTQAE5IDOwCRjRxvtWybBJWErM0BMYTBkHyFKkCnqmfZ9XlM/zdZmuZDL5DbNvusDLEWpbGI0l7hSDzLGOlLT5DCI/Gf8M28fDjom4kU5oWSBsIq6EtgD1o7sx6ZRnhznMEe9q0QNos8HFtIfrkcgAMAzTD1bBGw1JfLZAUau2JKEXwr+UTLUvesi/MDGHLyDOSpD00h4G/p2oGEEZj/m5is3H7agTHvIezy0dalrwlgncLaPFYO3CABnDUmdACg3T8+AO2tVKT1lpN6X/Yef+yJ7os+WF4r65aGF5ZETZZjdW9djss84KhG+7J28XtOK9dwHvLx1qWHP5CEMH7fHqeM6QN3YsYmINqhWEtPKih00VXGomWLdDwvvLJliVr2RXeFcEWEf5awOXL1smndSlmKwy3w7oIHtIeP5ghxHrIOzCjy8dbliwlhA9G0JY3Mc8GRwj3eMNQdaL5g2/Sk6c3P3k0zCkfb1kymEhKw9zIkqmqM8hkTDu88Qo8nAEGCOGOPFohwZxq0fDh8gmXxbfsALtpmOHrC6TJaO393c+I/hMBpMKwEu4Na+ncOoXKDI7LwbtjxpePuSw+RcMRcRMpTdZ0SuPcDbe5fs8Jw19gvYY/pNlfaZGlWBRg8xCOKB9zWdLKFMOYCI6JEgbzJDXEDi2hu+D2zDCAMBH8JgsAOj36FETwKTCyfNxlSSqtcHgEW2VxmD3k89m/1RJRM8IAGm7W0K09QlgZPP3dZsFu5eMuS4LjLDQcF0El7xBPW8Mcwi8R7klfEmH4AywN4b5GQqqWPzVKw/HlEy+L00SCd4YwO0tOXJK5VNuMgeuSfjfFXBFGww05+hSSHBsRwVFvwUwrH3tZbCWEz2to90nP9oGkduzpR+GvDcAAG+AXEWxw+QRpuUsOWidqOKF87GWJl7GG7Q0cmda3kLUhDuF6RPKM9qkw/BWWR/Bbn8hRBnNKRnDcVMzm5eMvS393gc9GMD7J1HbJXEJiXmjg2rTf9ojqCKPhp0k/6mO3Weq2BP69fPxl6Y0gGWaE8DENIq1T1wWItoNy7zPwZAEwwKuwOISXfbSDT1Jf7ZjUcMIkzDalGJSl5it8ScPkLAN1fML7ISyyZanmgmE5Yp2Gq3WCNvDJUbJc2FQNXyzFoCwYdtaxTra0ccyefWAr18KNPn9B+v9XroigK01FaT8I6n2HT7Zj3llKwyYNggKxwMDEPONmUhroa/8peLNQGJ6AJzQsTnJefHunLZGlBWCCUio21aIOBnUoKEHNntGe1oUmscOtsxsu9P0XGdIihI5gYQRRXtPIEXUSGg5RZc7SpqoVJkDlG6BG1a8KbGpQRBmgsIDxv6/DU02AAZ6D+wz83icnJCkcZoGj1cBZYLYopWNTK2O/AuodVQjiW34oNITdcF5S+kVDMICIumGhri547kWo9gREw0wEXy+T+DYlrTD2X0D9OyhVD8DANePFgImw00x0Dbe/CQ9m+TuZBe8luE3DvQlEeneU9E4PLgCFRPEJWvhgKSWbAgjjJ0Dr90BN6A9B0tYfioSGOOyC//EJpzYEA4juLjgnimmHtE4Q2zFDrCFQjEbxHdpMuabDyPYTBIz6L1D/Ul2izaUVlONV9E536rBEbuuEe7P+rVwmyco67ZBmFrmAQFiuu7rNpMK3wbSWUjNSy9aHgPpcn3kkGQiESgGiCoVF3sKoqhWiQYEBRHcEZ2sIPXNDel+NsFxb/2sXKI5gIp+vnV2WEaUVtpkJwXmgxgzUADIHEH1Q1GRscQj35flruZ3VVXB7BL/yBaFXG7iut399CwGnMYWDSukZSSDMHAejLoRg5sBWUGY0ldQALWGgw8DpebRCQzCACDV8vX4NOBcIA7SBdJpI9dtEAs5nK7NDKUUjwk8IIPgmyAP6/ATpEGwfEGzniB9hmUN1EGCADngihPNdDnSvg5x0HQp3IxEwg4DL2MJMKaVpY3eYdzkR1Akglbt1lwnvU02lpWC+k6VfoVAYQJgNcF4ES5wmkXQArxLuRX//YTaj+RGzzNhSqjbWsut8kN8A1ebWCK79JEHq/R4NagGi/1K2gwwDgHhdwyk9znSiNvABYOB9kUg+BJzDNNNWCtbGphXesz+o70MwLtlOTmo1U0Ott0LndQ1LckFXHACXIzi2F2TXqxwQCPAAH5B0ITmXiLN4XHSVUrYxgPCv7wHxc9DTk3NLezbj2K9/b2L7ehVEsxEdTzT6dwtKfRAhcBqSl1Odf5ViMrn8CEULklNo49Qyw3VjAGHfXaHyM1Bvdbf8MqN2sGkJvgUdTxYixYXegIo5DsllCIIBrb5oSCvUb+tQnMMazi01xHAF4YB3g74czNtBC/dQMJOiHVzaovf1blhxKIK1ww8GTIVWfoLiY06hrzebVAoc7kDDBiQ/IOK/+ZNYX0rfcALhA/uB/gmY6RAJP/PIx1SKgxCtAPZHvPpoUX+9+B7edrMlkruQzLICIHNuAzVlN4pL0XyNu0VHKYXDAYRDDwF+DHpbv6kj8voMOoLoM7B8USOh1Cb5DHVlnViO5CQk65w97Ao/MzKpj0JSQXICLVzCB8p+iKGFAImZ+zGoLAK1rZ8vkGYPi6Rj18Lyq4oEoTmaoXp3JJM4Fck3kUjvaJJKMKHc7zWKu9B8hlvFs6VkDrpZ1ArjvwD6NIjGJw/Vr2/lXT6DTvIRAP13iA5ELHul6EtpYiKcaWdzfoLkI4l+gfBsQJL7JgySxwj4Ar8Qd5USOlggHD0Z1FkQHgemLXlmrSjFUfYymVZCeAji+QeacTnNzQrd3ExF8WsUu2aKIPmAYDefXkPyDeBSbigjTc0F4VPvgOiHoPeGSPkBkAWIATBsAP0peOqaos2jwYEBYEuzGwGLUUzNBYMrf8vdMdmJ4gYqnMbl4h+l1BYNwQkV4KNgFkC0XTV0GnkKvy8QA+oMROfCE6cjCJt1ac0fb7ycvwInIOjI5E8lgZD8mTYkx2JYzPHm4HJMdZEgnLgVVH4E6kKQ06rZp42qea8OqGuhclYzQRgczdDjUM/gc0i+j6x1yCkPLZElodFuOr1BwFUYzuFi8VIpzY1ogzFzITod9NtBS/c8FT7h1DTtUP8+ugfMXMTDK5p9mYM4ksxUmMU3UZyCROTqgfaBYWDqh0bxBJIFPMIvuVuEpXRneWxfmQFqAegjIWpPXrfJd1pqb4f5adAHIx58bjAudXCHVU41o5nMQhSfyeQ7pCU7puVBVffXIrkRwXf4rvhbKeVpEHxtPLR+FPTJEL21rzc5bUFknxU80mDQgFkGG+Yi/vLQYF3y4I8xnmnGMZrzkXy8KTAkgaEwKF5FcgVwId8qHeyBEPygFToOheiroHcHXUmd8N1r33iYT72pFi9CdBTivnsH89KHZsD97mY8cAmS+Q050T6v9jEjmoBlKBbRymWcIl4pIbi4Ah3vh+hkiPasmkQ+k/7oHBoicXsNuo9E/PGewb4FQzf7xI5mEmP4ESoBCIV/eobKAEPfFqF4DsllGH7G18TLmx4EC1pg8hzQXwS9L0Sjk9dj8lkZPC8I0XKIPga/u7NZfQnDE4YeDdHK91Ac3+tUZ8tPyqYVJBBYz4kI+AeKa5FcyYniiZEPwcXjQR4K0Qmg96g5xyLdJEozl9I63FwdbdEyMMcgbrt3qG7J0M9LtJ8Zg+FsJCfWhnjm8x3ShtbWw+AaVBSgkbyO4ncEXI3mTv6PWDOCtICE7XcCcySE80HPgKjFb7W+PP5CUii1X27SEgiPQtz616G8PcNjkq7dTTvjORXJqSgqDadlpDvS/evsgHQS8DyKW2jhFlq5n8PFuo0PAAT8aiZ0HwDhXAh3Bz0BIpm+IJSPv5AlH8m6PQTRsYibnxzqWzV8Zqzb3VSYxCeRfJuAcdbsVd/UjCwgpG8GxToULxBwCxVuw/Agh4lVwxeAuwII3w7de4M+AqJ3gZ4EofJbB8d3xbQsZpJthFt0M2z4LOKWYdEhOsymbzSSgzkIyWUotvLWCD490kEKIGlb0AtGJ4oVVHgAyV0EPIzgcfYZQjjMXQGMnQnrdwG9J0RzQE+DaFwVgKzLimfRCLk62zToi8B8HXHDG8NF+obnXKaHm10RXIZit960DZXDf0gPsbocahsItjpd0xpvEPAEAQ8geBLJc7SzlO1ZjhBRsYL/7HhgO+icDnp7CN8B+t0Qbg7hWIgq/QU1xHsxYnyXFvTRDM76DogWwMsXIe7uHE5iN3wn9j3EbMEoFqI4ul+kKW9vdJpjbRN86YAhSAQmQtFJhXW1Xu9lKJ6nhZeR/JOAVSjeoMIaJJ0ERFRYD90VoLWaDt01ttqqMx7CSRBOgXAaRDMg2gx0G4TtNcEX/YU6JB8MWcOoefoVomXQ/Tnovg1xQzTcRG54z3J9mGlnNCchOR3F6NwzEPoAoRJ8i8BTawQJwFToW5kpIKyFc6PauRFSi5pTK6A7AK2qYEQJQu1zLKtfkBY9ytvrHP2u6h9c/dRwFbfhnd58s1iH5rso/g3BEufEAj4Tl9XXxetdm8859ZuruRH93guggqANwWgEo4FxwFhgNNAOoqWGTsIX2Y75bDLjcdeNTdvvPb8TxELonDucQRj+MADcICJ+Jm5Fsz+CnyHQqc8r6bnLjLLhC4DrOwtX2PEfLwqSLDcnDYLeumdBzoOnTkVcs2q4i9rGM/DlavEihk8j+TSCV1PHhAjPBi1N0PPIkI+si0aAiJ+T96JkxgtMaoX6HYuqM1hEcxAX3oy4e6NIm9+4RoFdITq5lJ8C+yC4FkHopamFBxBpWiSTICfIrMj6wSwfEgVtPjfK2co8A+IYWH084kcbVVbwRjgkUhguFktQfALDUcDTTm2Q10zOoiFkgq8hizCZ6h+Va8ur2ijoJklArgfxQzD7IBZej7iic2OTrI13fPD5YgMXiF8QsTdwLoI1drO1yT7C8G44CtYYTrV7N5gD4ZmTEd/daNPhN/7B8ueLFYzmv4DZtZFsUaYGrSi/YVgIfpKN53uhMov2WArmk9BxKOJb9wzHvoOR08+QtZxkWpnAgQScgWSP1MxWnzEPPkl+efKeBnwuS85QWkeZz3FXz7JXZ9oqiC6B6DzEaa+OFPEZmUvLftmMZhKHIvkqkj1S0zTyJPVlzW+SRcGgyZdg10iaRVQHgV4E0fnQ8Q/EmXokic3IXmd5gWlnFIdR4WQk70HV0jp8YZAFgWFLEvSGIQ0Cn9Zfe9QlQrASwsthwwUjEYJNA4Y+KNqYyD4oTkJyUG0VIP90jaxp4ElawAmUT1pEoxAknWeFYQmYS2HdlfDF1xDCjGQx2TRg6IMiYHN2pMKngXkETE1cilfGWnJJtoFCSblNMg0G3YAfkPZdtvN684i6Qd9dNYc6foX4/Caz9sWmBUNvMYLzGM84DiPgEyj27R1h55vlakv/lp5aIBWGNBB8tUgmv2AZRD8HcSU8uQRx5iY32domCkNdud4oupmOZB6KI1G8C4nM5UNk9SlkVhiS6vOkYEcrILoFzHVQ+T3i8HWbsiiUMNSXu0zASmZR4d+QHFwbXFTJPAVNnjqpG2z5faZ7jAD9IoR3grkR1t4B89aOdF+ghKFhS8pIbmIKo9gfwfuRzEExDYXIPGCoKTB4j0/ugOjPYG6H7ttg1WMwv3so5iUqYRhJ5tQUtqXCbCSzUeyF5O0oWgoBIhEG7esgG9DLQd8P0b1g7oHoYdizs2z9SxiaqTkES2llFbNQ7ETAzkh2RDKzpkHGZAJEag8N0HssAv0yRM+Bfgq6HwPzKISPwo0rR2o/QAnDxmpiLWMqMJ1WtgamoJiMYjKSyQSMQjIGhULQhqINpaPqYHltIFoLUSdEq6sdXtEK0K9D9AqYpRAtQ2xXrn9dlrKUpSxlKUtZylKWwSj/HyHl/ePsagXCAAAAAElFTkSuQmCC)",
                height:'195px',
                width:'195px'
            },
            'ADVMARK1, ADVMARK2':{
                background:ood.browser.ie6?null:"url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAAK3RFWHRDcmVhdGlvbiBUaW1lAHZyIDE0IGp1bCAyMDA2IDEzOjMxOjIzICswMTAwHvJDZwAAAAd0SU1FB9YHDgsgJYiZ4bUAAAAJcEhZcwAALiIAAC4iAari3ZIAAAAEZ0FNQQAAsY8L/GEFAAAB5ElEQVR42q2Tz0sqURTH72Qq4mASSAoSIfSDdCEI8qJFLXSjLYSQNoGLINrI8/0ZD9q0KnDlKkIMebmP9xZRCEEiLQLBiMiNJDYq/Zg573vpCkM6CdGBD3Pn3OvXe77nDGPfENKwJBHx/CxYAtNAAVfgXJKk7khVCCyCP6ALVKAJXkEdbINxw5tgM4HHPphSFEUql8usXq8zWZZZKBRiPp+PH3sBx2Br4FbiBg+aplGxWKRgMPiMH1+YTKZDq9V64na7G+l0mprNJo7RG/g94IEoQSsUCuRyue6QToIJYAJWMA/Bo2QySZ1Ohws9gZBeZI570Gq1yO/395BKGJg+ZbFYznK5HAmf9vQiKW5iqVQim832Fyn5E+83Y7EYieAdY2Nig7dRqtVqrNfr3YiWGsVltVrtr2f0IrwEZrfbGeqWhQ9GMeFwOPprRS9SAWo4HGZOp/MH1l4DAS6+HolE+u9Xek9kcK+qKqVSKUL/s0hPDhFY83g8j5VKhcQg7nxs80/w0mg0KB6Pa2az+RTpDbDA3sd/lwvk8/l+Z7iS/FHEAor8H9rtNmWzWYpGo+T1eikQCFAmkyFxAy7AJ255aMHYcIID8d1oNBi8hGuwwkYFDq0CPlG3YsTb4B/4BRwjBb4S/wGzT16tu5THiAAAAABJRU5ErkJggg==)",
                height:'16px',
                margin:'-8px 0 0 -8px',
                overflow:'hidden',
                width:'16px'
            },
            ".ood-nodatauri ADVCLR":{
                background: ood.browser.ie6?null:ood.UI.$oldBg('clrbg.png', 'no-repeat left top'),
                //for ie6
                _filter: ood.UI.$ieOldBg('clrbg.png'),
                '-ms-filter': ood.browser.ie8?ood.UI.$ieOldBg('clrbg.png'):null
            },
            ".ood-nodatauri ADVWHEEL":{
                background: ood.browser.ie6?null:ood.UI.$oldBg('clr.png', 'no-repeat left top'),
                //for ie6
                _filter: ood.UI.$ieOldBg('clr.png'),
                '-ms-filter': ood.browser.ie8?ood.UI.$ieOldBg('clr.png'):null
            },
            '.ood-nodatauri ADVMARK1, .ood-nodatauri ADVMARK2':{
                background:ood.browser.ie6?null:ood.UI.$oldBg('picker.png', 'no-repeat left top'),
                //for ie6
                _filter: ood.UI.$ieOldBg('picker.png'),
                '-ms-filter': ood.browser.ie8?ood.UI.$ieOldBg('picker.png'):null
            },

            'LIST span':{
                overflow: 'hidden',
                margin: '0',
                cursor: 'pointer',
                margin:'0 -1px -1px 0',
                display: ood.$inlineBlock,
                'font-size': '1.18em'
            },
            TRANS:{
                position:'absolute',
                top:'.25em',
                left:'0',
                display:ood.$inlineBlock,
                cursor:'pointer'
            },
            SET:{
                position:'absolute',
                display:'none',
                top:'.125em',
                right:'2.5em'
            },
            TOGGLE:{
                position:'absolute',
                right:'.5em',
                top:'0.25em',
                display:ood.$inlineBlock,
                cursor:'default'
            }
        },
        Behaviors:{
            HoverEffected:{CLOSE:'CLOSE',SET:'SET',TRANS:'TRANS',TOGGLE:'TOGGLE'},
            ClickEffected:{CLOSE:'CLOSE',SET:'SET',TRANS:'TRANS',TOGGLE:'TOGGLE'},
            KEY:{onClick:function(){return false}},
            SC:{
                onMouseover:function(p,e,s){
                    p.box._setTempUI(p,p.getSubId(s));
                },
                onClick:function(p,e,s){
                    var sid=p.getSubId(s);
                    p.boxing()._setCtrlValue(p.$tempValue=sid,false);
                    p.box._vC(p);
                    if(!p.properties.advance)
                        p.boxing().setUIValue(sid,true,null,'click');
                        
                    return false;
                },
                onDblclick:function(p,e,s){
                    var sid=p.getSubId(s);
                    p.boxing()._setCtrlValue(p.$tempValue=sid,false);
                    p.box._vC(p);
                    p.boxing().setUIValue(sid,true,null,'dblclick');
                    return false;
                }
            },
            LIST:{
                onMouseout:function(p,e,s){
                    p.box._updateDftTip(p);
                }
            },
            SET:{
                onClick:function(p,e,src){
                    p.box._vC(p);
                    p.boxing().setUIValue(p.$tempValue,true,null,'setbtn');
                }
            },
            TRANS:{
                onClick:function(p,e,src){
                    p.box._vC(p);
                    p.boxing().setUIValue(p.$tempValue='transparent',true,null,'transbtn');
                }
            },
            CANCEL:{
                onClick:function(p,e,src){
                    p.getSubNode('CLOSE').onClick(true);
                }
            },
            TOGGLE:{
                onClick:function(p,e,src){
                    p.boxing().setAdvance(!p.properties.advance)
                }
            },
            R:{
                beforeMousedown:function(p, e, src){
                    p.box._dd1(p,e,src);
                },
                onDrag:function(p, e, src){
                    p.box._dd2(p,e,src,0);
                },
                onDragstop:function(p, e, src){
                    p.box._dd3(p,e,src,0);
                }
            },
            G:{
                beforeMousedown:function(p, e, src){
                    p.box._dd1(p,e,src);
                },
                onDrag:function(p, e, src){
                    p.box._dd2(p,e,src,1);
                },
                onDragstop:function(p, e, src){
                    p.box._dd3(p,e,src,1);
                }
            },
            B:{
                beforeMousedown:function(p, e, src){
                    p.box._dd1(p,e,src);
                },
                onDrag:function(p, e, src){
                    p.box._dd2(p,e,src,2);
                },
                onDragstop:function(p, e, src){
                    p.box._dd3(p,e,src,2);
                }
            },
            HH:{
                beforeMousedown:function(p, e, src){
                    p.box._dd1(p,e,src,true);
                },
                onDrag:function(p, e, src){
                    p.box._dd2(p,e,src,0,'hsv1');
                },
                onDragstop:function(p, e, src){
                    p.box._dd3(p,e,src,0,true,'hsv1');
                }
            },
            S:{
                beforeMousedown:function(p, e, src){
                    p.box._dd1(p,e,src,true);
                },
                onDrag:function(p, e, src){
                    p.box._dd2(p,e,src,1,'hsv2');
                },
                onDragstop:function(p, e, src){
                    p.box._dd3(p,e,src,1,true,'hsv2');
                }
            },
            V:{
                beforeMousedown:function(p, e, src){
                    p.box._dd1(p,e,src,true);
                },
                onDrag:function(p, e, src){
                    p.box._dd2(p,e,src,2,'hsv2');
                },
                onDragstop:function(p, e, src){
                    p.box._dd3(p,e,src,2,true,'hsv2');
                }
            },
            H:{
                beforeMousedown:function(p, e, src){
                    p.box._dd1(p,e,src);
                },
                onDrag:function(p, e, src){
                    p.box._dd2(p,e,src,0,'hex');
                },
                onDragstop:function(p, e, src){
                    p.box._dd3(p,e,src,0);
                }
            },
            'E':{
                beforeMousedown:function(p, e, src){
                    p.box._dd1(p,e,src);
                },
                onDrag:function(p, e, src){
                    p.box._dd2(p,e,src,1,'hex');
                },
                onDragstop:function(p, e, src){
                    p.box._dd3(p,e,src,1);
                }
            },
            X:{
                beforeMousedown:function(p, e, src){
                    p.box._dd1(p,e,src);
                },
                onDrag:function(p, e, src){
                    p.box._dd2(p,e,src,2,'hex');
                },
                onDragstop:function(p, e, src){
                    p.box._dd3(p,e,src,2);
                }
            },
            CLOSE:{
                onClick:function(profile, e, src){
                    var properties = profile.properties,
                        instance = profile.boxing();
                    if(properties.disabled||properties.readonly)return;
                    if(false===instance.beforeClose(profile)) return;
                    instance.destroy();
                }
            },
            ADVWHEEL:{
                beforeMousedown:function(p, e, src){
                    var cls=p.box;
                    cls._prepareAdv(p,e);
                    cls._updateClrByPos(p,e,true);
                    p.getSubNode('ADVMARK1').startDrag(e, {
                        dragType:'none'
                    });
                }
            },
            ADVMARK1:{
                beforeMousedown:function(p, e, src){
                    var cls=p.box;
                    cls._prepareAdv(p,e);
                    cls._updateClrByPos(p,e,true);
                    p.getSubNode('ADVMARK1').startDrag(e, {
                        dragType:'none'
                    });
                },
                onDrag:function(p, e, src){
                    var cls=p.box;
                    cls._updateClrByPos(p,e,true);
                },
                onDragstop:function(p, e, src){
                    p.box._updateValueByPos(p, e);
                },
                onDblclick:function(p,e,src){
                    p.box._updateValueByPos(p, e);
                    p.box._vC(p);
                    p.boxing().setUIValue(p.$tempValue,true,null,'advdblclick');
                }
            },
            ADVCLR:{
                beforeMousedown:function(p, e, src){
                    var cls=p.box;
                    cls._prepareAdv(p,e);
                    cls._updateClrByPos(p,e);
                    p.getSubNode('ADVMARK2').startDrag(e, {
                        dragType:'none'
                    });
                    return false;
                }
            },
            ADVMARK2:{
                beforeMousedown:function(p, e, src){
                    var cls=p.box;
                    cls._prepareAdv(p,e);
                    cls._updateClrByPos(p,e);
                    p.getSubNode('ADVMARK2').startDrag(e, {
                        dragType:'none'
                    });
                    return false;
                },
                onDrag:function(p, e, src){
                    var cls=p.box;
                    cls._updateClrByPos(p, e);
                },
                onDragstop:function(p, e, src){
                    p.box._updateValueByPos(p, e);
                },
                onDblclick:function(p,e,src){
                    p.box._updateValueByPos(p, e);
                    p.box._vC(p);
                    p.boxing().setUIValue(p.$tempValue,true,null,'adv2dblclick');
                }
            }
        },
        _vC:function(profile){
            var pro=profile.properties,
                v=pro.$UIvalue,
                d=v==profile.$tempValue;
            profile.getSubNode('SET').css('display',d?'none':'block');
            profile.getSubNode('CAPTION').css('color',d?'var(--text-primary)':'var(--error-color)');
        },
        _prepareData:function(profile){
            var data=arguments.callee.upper.call(this, profile);
            var nodisplay='display:none';
            data.classBar= data.barDisplay?'ood-uibar-top':'ood-uibar-top-s';
            data.closeDisplay = data.closeBtn?'':nodisplay;
            data.advDispay = data.advance?'':'display:none;';
            
            data._transparent = ood.getRes('inline.transparent');
            data._set = ood.wrapRes('inline.set');
            return data;
        },
        EventHandlers:{
            beforeClose:function(profile, src){}
        },
        RenderTrigger:function(){
            this.$onValueSet=this.$onUIValueSet=function(o,v){
                this.box._setClrName(this,v);
            };
            
            // Modern feature initialization
            var self = this;
            ood.asyRun(function(){
                self.boxing().ColorPickerTrigger();
            });
        },

        _setClrName:function(profile,v){
            var p=profile,
                k='color.LIST.',
                vv=ood.getRes(k+v);
            if(vv==v)
                p.$clrN2 = p.$clrN = (v=='transparent'?'':'#')+v;
            else{
                p.$clrN = vv;
                p.$clrN2 = ood.wrapRes(k+v);
            }
        },
        _slist:"FFFFFF,FFFFF0,FFFFE0,FFFF00,FFFAFA,FFFAF0,FFFACD,FFF8DC,FFF5EE,FFF0F5,FFEFD5,FFEBCD,FFE4E1,FFE4C4,FFE4B5,FFDEAD,FFDAB9,FFD700,FFC0CB,FFB6C1,FFA500,FFA07A,FF8C00,FF7F50,FF69B4,FF6347,FF4500,FF1493,FF00FF,FF00FF,FF0000,FDF5E6,FAFAD2,FAF0E6,FAEBD7,FA8072,F8F8FF,F5FFFA,F5F5F5,F5DEB3,F4A460,F0FFFF,F0FFF0,F0F8FF,F0E68C,F08080,EEE8AA,EE82EE,E9967A,E6E6FA,E1FFFF,DEB887,DDA0DD,DCDCDC,DC143C,DB7093,DAA520,DA70D6,D8BFD8,D3D3D3,D2B48C,D2691E,CD853F,CD5C5C,C71585,C0C0C0,BDB76B,BC8F8F,BA55D3,B22222,B0E0E6,B0C4DE,AFEEEE,ADFF2F,ADD8E6,A9A9A9,A52A2A,A0522D,9932CC,98FB98,9400D3,9370DB,90EE90,8FBC8F,8B4513,8B008B,8B0000,8A2BE2,87CEFA,87CEEB,808080,808000,800080,800000,7FFFAA,7FFF00,7CFC00,7B68EE,778899,708090,6B8E23,6A5ACD,696969,6495ED,5F9EA0,556B2F,4B0082,48D1CC,483D8B,4682B4,4169E1,40E0D0,3CB371,32CD32,2F4F4F,2E8B57,228B22,20B2AA,1E90FF,191970,00FFFF,00FFFF,00FF7F,00FF00,00FA9A,00CED1,00BFFF,008B8B,008080,008000,006400,0000FF,0000CD,00008B,000080,000000".split(','),
        _C16:"0123456789ABCDEF",
        //for drag rgb span
        _dd1:function(profile, e, src, hsv){
            if(ood.Event.getBtn(e)!="left")return;
            var p=profile.properties,
                cls=profile.box,
                f=function(){var rgb = cls.hex2rgb(profile.$tempValue||p.$UIvalue); return hsv?cls.rgb2hsv(rgb):rgb;};

            ood.use(src).css('backgroundColor','red').startDrag(e, {
                dragType:'blank',
                targetReposition:false,
                widthIncrement:2,
                dragCursor:true
            });
            profile.$temp=0;
            profile.$start = f();
            profile.$temp2 = f();
        },
        _dd2:function(profile, e, src, i, type){
            var count,
                off = ood.DragDrop.getProfile().offset,
                p=profile.properties,
                old=profile.$temp2,
                cls=profile.box,
                rate = type=='hsv1'?361:type=='hsv2'?101:256,
                v;

            count = (type=='hsv2'?parseInt(profile.$start[i]*100,10):parseInt(profile.$start[i],10))+parseInt(off.x/2,10);

            count=(count%rate+rate)%rate;
            if(profile.$temp!=count){
                old[i]=profile.$temp = type=='hsv2'?count/100:count;
                v = (type=='hsv1'||type=='hsv2')?cls.hsv2rgb(old):old;
                v=cls.rgb2hex(v);
                cls._setTempUI(profile,v);
                ood.use(src).text(type=='hex'?cls._toFF(count):count);
            }
        },
        _dd3:function(profile, e, src, i, hsv){
            if(profile.$start[i] !== profile.$temp){
                var p=profile.properties,
                    cls=profile.box,
                    old=profile.$start,
                    v;
                old[i]=profile.$temp;
                v=hsv?cls.hsv2rgb(old):old;
                v=cls.rgb2hex(v);

                //set the cur hex value of hsv for preventing update adv UI again
                if(hsv)profile.$hexinhsv=v;
                profile.boxing()._setCtrlValue(profile.$tempValue=v,false);
                delete profile.$hexinhsv;
                profile.box._vC(profile);
            }
            ood.use(src).css('backgroundColor','');
            profile.$temp=profile.$start=0;
        },
        //set temp UI
        _setTempUI:function(p,v){
            var cls=this,
                rgb=cls.hex2rgb(v),
                b=p.boxing(),
                ex=b.getSubNode('EXAM'),
                hsv=cls.rgb2hsv(rgb),
                vv=ood.getRes('color.LIST.'+v),
                v1=(v=='transparent'?'':'#')+v;
            ex.css({backgroundColor: v1, color:hsv[2]>0.6?'var(--text-primary)':'var(--text-inverse)'});
            ex.text(p.show_color = vv==v? v1 : vv);
        },
        //reset example block
        _updateDftTip:function(prf){
            var cls=prf.box,
                p=prf.properties,
                trans=(prf.$tempValue||p.$UIvalue)=='transparent',
                ex=prf.boxing().getSubNode('EXAM');
            ex.css({backgroundColor:trans?'transparent':'#'+prf.$hex.join(''), color:trans?'var(--text-primary)':prf.$hsv[2]>0.6?'var(--text-primary)':'var(--text-inverse)'});
            ex.html(prf.$clrN2||'',false);
        },
        _to3:function(s){
            if(!s||s=="transparent")s="FFFFFF";
            return [s.substr(0, 2), s.substr(2, 2), s.substr(4, 2)];
        },
        //0...255 to 00...FF
        _toFF: function(n) {
            var C16=this._C16;
            n = parseInt(n,10)||0;
            n = (n>255||n<0)?0:n;
            return C16.charAt((n-n%16)/16) + C16.charAt(n%16);
        },
        // 00...FF to 0...255
        _to255: function(str) {
            var C16=this._C16, s=str.split('');
            return C16.indexOf(s[0].toUpperCase())*16 + C16.indexOf(s[1].toUpperCase());
        },
        _webSafe:function(r, g, b){
            //safe divisor is 51, smart divisor is 17
            var me=arguments.callee,f=me.f||(me.f=function(n){
                return parseInt(n/51,10)*51;
            });
            if(typeof r=='object'){
                g=r[1];b=r[2];r=r[0];
            }
            return [f(r),f(g),f(b)];
        },
        _updateMarks:function(profile, hex, forcePos, hsv0){
            var cls=this,
                rgb=cls.hex2rgb(hex),
                hsv=cls.rgb2hsv(rgb),
                angle=(hsv[0]/360)*6.28,
                clr=profile.getSubNode('ADVCLR');
            if(forcePos){
                var m1=profile.getSubNode('ADVMARK1'),
                    m2=profile.getSubNode('ADVMARK2');
                m1.cssPos({
                  left: Math.round(Math.sin(angle)*cls._radius+cls._bigRadius),
                  top: Math.round(-Math.cos(angle)*cls._radius+cls._bigRadius)
                });
                m2.cssPos({
                  left: Math.round(cls._square*(hsv[1]-0.5)+cls._bigRadius),
                  top: Math.round(cls._square*(0.5-hsv[2])+cls._bigRadius)
                });
            }

            if(hsv0 !== undefined)
                clr.css('backgroundColor', '#'+cls.rgb2hex(cls.hsv2rgb([hsv0, 1, 1])));
            cls._setTempUI(profile, hex);
        },
        //flag:change h
        _updateClrByPos:function(profile, e, flag){
            var cls=this,
                mPos=ood.Event.getPos(e),
                pos=profile.$tpos,
                left=mPos.left-pos.left,
                top=mPos.top-pos.top,
                angle,m1,m2,
                h,s,v,hsv,rgb,hex;
            ;
            if(flag){
                m1=profile.getSubNode('ADVMARK1');
                angle=Math.atan2(left, -top);
                m1.cssPos({
                  left: Math.round(Math.sin(angle)*cls._radius+cls._bigRadius),
                  top: Math.round(-Math.cos(angle)*cls._radius+cls._bigRadius)
                });
                h=Math.floor((angle/Math.PI)*180);
                if(h<0)h +=360;
                hsv=[h, profile.$hsv[1], profile.$hsv[2]];
                rgb = cls.hsv2rgb(hsv);
                hex = cls.rgb2hex(rgb);
                cls._updateMarks(profile, profile.$t_hex=hex, false, h);
            }else{
                m2=profile.getSubNode('ADVMARK2');
                s=Math.max(0, Math.min(1, (left/cls._square) + 0.5));
                v=Math.max(0, Math.min(1, 0.5 - (top/cls._square)));
                m2.cssPos({
                  left: Math.round(cls._square*(s-0.5)+cls._bigRadius),
                  top: Math.round(cls._square*(0.5-v)+cls._bigRadius)
                });
                hsv=[profile.$hsv[0], s, v];
                rgb = cls.hsv2rgb(hsv);
                hex = cls.rgb2hex(rgb);
                cls._updateMarks(profile, profile.$t_hex=hex);
            }
        },
        _updateValueByPos:function(profile, e){
            //set the cur hex value of adv for preventing update adv UI again
            profile.$hexinadv=profile.$t_hex;
            profile.boxing()._setCtrlValue(profile.$tempValue=profile.$t_hex,false);
            delete profile.$hexinadv;
            profile.box._vC(profile);
        },
        _prepareAdv:function(profile,e){
            var cls=this,
                pos=profile.getSubNode('ADVWHEEL').offset();
            profile.$tpos= { left:pos.left+cls._bigRadius, top:pos.top+cls._bigRadius };
        },
        _ensureValue:function(profile,v){
            var ns=this,me=arguments.callee,map=me.map||(me.map=(function(){
                var h={};
                ood.arr.each(ns._C16.split(''),function(o,i){
                    h[o]=1;
                });
                return h;
            }())),
            reg=me._r||(me._r=/rgb\(([^)]*)\)/);
            if(!v || typeof v !='string'||v=='transparent')return 'transparent';
            if(reg.test(v)){
                v=v.replace(reg,'$1');
                v=v.split(',');
                v[0]=parseInt(v[0],10)||0;
                v[1]=parseInt(v[1],10)||0;
                v[2]=parseInt(v[2],10)||0;
                v=ns.rgb2hex(v);
            }
            if(v.charAt(0)=='#')v=v.substr(1,v.length);
            var a='',k;
            for(var i=0;i<6;i++){
                k=v.charAt(i).toUpperCase();
                a += (map[k]?k:'F');
            }
           return a;
        },
        //HSV (h[0-360], s[0-1]), v[0-1] to RGB [255,255,255]
        hsv2rgb: function(h, s, v) {
            if(h instanceof Array) {
                s=h[1]; v=h[2]; h=h[0];
            }
            var me=arguments.callee, f = me.f ||
                (me.f=function(n) {
                    return Math.min(255, Math.round(n*256));
                }),
                r, g, b, i, k, p, q, t;
            if(s==0)
                return [v=f(v),v,v];
            else{
                i = Math.floor((h/60)%6);
                k = (h/60)-i;
                p = v*(1-s);
                q = v*(1-k*s);
                t = v*(1-(1-k)*s);
                switch(i) {
                    case 0: r=v; g=t; b=p; break;
                    case 1: r=q; g=v; b=p; break;
                    case 2: r=p; g=v; b=t; break;
                    case 3: r=p; g=q; b=v; break;
                    case 4: r=t; g=p; b=v; break;
                    case 5: r=v; g=p; b=q; break;
                }
                return s==0?[v=f(v),v,v]:[f(r), f(g), f(b)];
            }
        },
        // RGB [255,255,255] to HSV (h[0-360], s[0-1]), v[0-1]
        rgb2hsv: function(r, g, b) {
            if(r instanceof Array) {
                g=r[1];b=r[2];r=r[0];
            }
            r=r/255;g=g/255;b=b/255;
            var min=Math.min(r,g,b),
                max=Math.max(r,g,b),
                delta = max-min,
                s = (max===0)?0:1-(min/max),
                v = max,
                h;
            switch (max) {
                case min:
                    h=0;
                    break;
                case r:
                    h=60*(g-b)/delta;
                    if(g<b)h+=360;
                    break;
                case g:
                    h=(60*(b-r)/delta)+120;
                    break;
                case b:
                    h=(60*(r-g)/delta)+240;
                    break;
            }
            return [Math.round(h), s, v];
        },
        //rgb values into a hex string; 255,255,255 -> FFFFFF
        rgb2hex: function(r, g, b) {
            var ns=this;
            if(r instanceof Array) {
                g=r[1];b=r[2];r=r[0];
            }
            return ns._toFF(r) + ns._toFF(g) + ns._toFF(b);
        },
        // Converts a hex string to rgb
        hex2rgb: function(hex) {
            var ns=this;
            if(!hex || hex=="transparent")hex="FFFFFF";
            if(hex.charAt(0)=='#')hex=hex.slice(1);
            return [ns._to255(hex.substr(0, 2)), ns._to255(hex.substr(2, 2)), ns._to255(hex.substr(4, 2))];
        },
        getTextColor:function(value){
            var ns=this;
            value=ns._ensureValue(0,value);
            if(value && value.toLowerCase()=="transparent")return '#000000';

            value=ns.hex2rgb(value);
            value=ns.rgb2hsv(value);
            return (value&&value[2])>0.6?'#000000':'#FFFFFF';
        },
        _onresize:function(){}
    }
});ood.Class('ood.UI.DatePicker', ['ood.UI',"ood.absValue"], {
    Dependencies:['ood.Date'],
    Instance:{
        activate:function(){
            this.getSubNode('PRE').focus(true);
            return this;
        },
        _setCtrlValue:function(value){
            return this.each(function(profile){
                if(!profile.renderId)return;
                var cls = profile.box,
                    p = profile.properties;
                cls._to(profile,value,true);
                if(profile.keys.CAPTION)
                    profile.getSubNode('CAPTION').html(ood.Date.getText(value,'ymd',p.firstDayOfWeek),false);
            });
        },
        getDateFrom:function(){
            return this.get(0)._realstart;
        },
        
        // Set theme
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot(),
                    border = profile.getSubNode('BORDER'),
                    bar = profile.getSubNode('BAR'),
                    main = profile.getSubNode('MAIN'),
                    tail = profile.getSubNode('TAIL'),
                    btns = root.query('.oodfont'),
                    inputs = root.query('.ood-ui-draggable'),
                    table = profile.getSubNode('BODY'),
                    cells = root.query('.ood-node-td'),
                    headers = root.query('.ood-node-th');

                // Add base classes
                root.addClass('datepicker-themed');
                
                // Add component specific classes
                border.addClass('datepicker-border');
                bar.addClass('datepicker-bar');
                main.addClass('datepicker-main');
                tail.addClass('datepicker-tail');
                btns.addClass('datepicker-button');
                inputs.addClass('datepicker-input');
                cells.addClass('datepicker-cell');
                headers.addClass('datepicker-header');
                if (table && !table.isEmpty()) {
                    table.addClass('datepicker-table');
                }

                // Apply theme class
                root.removeClass('datepicker-dark');
                if (theme === 'dark') {
                    root.addClass('datepicker-dark');
                }
                
                // Save theme settings
                localStorage.setItem('datepicker-theme', theme);
            });
        },
        
        // Get current theme
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('datepicker-theme') || 'light';
        },
        
        // Toggle dark mode
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        
        // Responsive layout adjustment
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    bar = profile.getSubNode('BAR'),
                    main = profile.getSubNode('MAIN'),
                    tail = profile.getSubNode('TAIL'),
                    inputs = root.query('.ood-ui-draggable'),
                    btns = root.query('.oodfont'),
                    prop = profile.properties;

                // Adjust layout for small screens
                if (width < 768) {
                    root.addClass('datepicker-mobile');
                    
                    // Adjust button size for mobile
                    btns.css({
                        'min-width': '2.2em',
                        'min-height': '2.2em',
                        'font-size': '1.1em'
                    });
                    
                    // Adjust inputs for mobile
                    inputs.css({
                        'min-height': '2em',
                        'font-size': '0.9em',
                        'padding': '0.3em'
                    });
                } else {
                    root.removeClass('datepicker-mobile');
                    
                    // Restore desktop styles
                    btns.css({
                        'min-width': '',
                        'min-height': '',
                        'font-size': ''
                    });
                    
                    inputs.css({
                        'min-height': '',
                        'font-size': '',
                        'padding': ''
                    });
                }

                // Special handling for extra small screens
                if (width < 480) {
                    root.addClass('datepicker-tiny');
                    
                    // Adjust calendar table display
                    main.css({
                        'font-size': '0.8em'
                    });
                    
                    tail.css({
                        'font-size': '0.8em'
                    });
                } else {
                    root.removeClass('datepicker-tiny');
                    
                    main.css({
                        'font-size': ''
                    });
                    
                    tail.css({
                        'font-size': ''
                    });
                }
            });
        },
        
        // Enhance accessibility support
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    bar = profile.getSubNode('BAR'),
                    main = profile.getSubNode('MAIN'),
                    tail = profile.getSubNode('TAIL'),
                    inputs = root.query('.ood-ui-draggable'),
                    btns = root.query('.oodfont'),
                    cells = root.query('.ood-node-td'),
                    headers = root.query('.ood-node-th'),
                    properties = profile.properties;

                // Add ARIA attributes to container
                root.attr({
                    'role': 'application',
                    'aria-label': ood.getRes('UI.datepicker.label')
                });
                
                // Add ARIA attributes to toolbar
                if (bar && !bar.isEmpty()) {
                    bar.attr({
                        'role': 'toolbar',
                        'aria-label': ood.getRes('UI.datepicker.toolbar')
                    });
                }
                
                // Add ARIA attributes to calendar grid
                if (main && !main.isEmpty()) {
                    main.attr({
                        'role': 'grid',
                        'aria-label': ood.getRes('UI.datepicker.calendar')
                    });
                }
                
                // Add ARIA attributes to navigation buttons
                btns.each(function(btn) {
                    var btnElement = ood(btn),
                        btnClass = btnElement.attr('class') || '',
                        btnLabel = ood.getRes('UI.datepicker.button');
                    
                    if (btnClass.indexOf('doubleleft') > -1) {
                        btnLabel = ood.getRes('UI.datepicker.prevYear');
                    } else if (btnClass.indexOf('singleleft') > -1) {
                        btnLabel = ood.getRes('UI.datepicker.prevMonth');
                    } else if (btnClass.indexOf('singleright') > -1) {
                        btnLabel = ood.getRes('UI.datepicker.nextMonth');
                    } else if (btnClass.indexOf('doubleright') > -1) {
                        btnLabel = ood.getRes('UI.datepicker.nextYear');
                    } else if (btnClass.indexOf('close') > -1) {
                        btnLabel = ood.getRes('UI.datepicker.close');
                    }
                    
                    btnElement.attr({
                        'role': 'button',
                        'aria-label': btnLabel,
                        'tabindex': properties.disabled ? '-1' : '0'
                    });
                });
                
                // Add ARIA attributes to inputs
                inputs.each(function(input) {
                    var inputElement = ood(input);
                    inputElement.attr({
                        'role': 'spinbutton',
                        'aria-label': ood.getRes('UI.datepicker.dateInput'),
                        'tabindex': properties.disabled ? '-1' : '0'
                    });
                });
                
                // Add ARIA attributes to date cells
                cells.each(function(cell) {
                    var cellElement = ood(cell);
                    cellElement.attr({
                        'role': 'gridcell',
                        'tabindex': properties.disabled ? '-1' : '0'
                    });
                });
                
                // Add ARIA attributes to headers
                headers.each(function(header) {
                    var headerElement = ood(header);
                    headerElement.attr({
                        'role': 'columnheader'
                    });
                });
            });
        }
    },
    Initialize:function(){
        var self=this,
            id=ood.UI.$ID,
            tag=ood.UI.$tag_special,
            cls=ood.UI.$CLS,
            key=self.KEY;
            
        self.addTemplateKeys(['H', 'COL', 'W','TBODY', 'THEADER','TD']);
        var colgroup = '<colgroup id="'+key+'-COL:'+id+':"  class="'+tag+'COL_CS'+tag+' ood-custom {comcls}"  style="'+tag+'COL_CS'+tag+'"><col width="1px"/><col width=""/><col width=""/><col width=""/><col width=""/><col width=""/><col width=""/><col width=""/></colgroup>',
            thead1='<thead ID="'+key+'-THEADER:'+id+':" class="'+tag+'THEADER_CS'+tag+' ood-custom {comcls}"  style="'+tag+'THEADER_CS'+tag+'" ><tr height="1px"><th id="'+key+'-H:'+id+':7" class="ood-node  ood-node-th ood-uiborder-b ood-uiborder-r '+cls+'-h '+cls+'-w '+tag+'H_CC'+tag+' ood-custom {comcls}" style="'+tag+'H_CS'+tag+'"></th>',
            thead2='</tr></thead>',
            th='<th id="'+key+'-H:'+id+':@" class="ood-node ood-node-th ood-uiborder-b ood-uiborder-r '+cls+'-h '+tag+'H_CC'+tag+' ood-custom {comcls}"  style="'+tag+'H_CS'+tag+'">@</th>',
            tbody1 = '<tbody id="'+key+'-TBODY:'+id +':"  class="'+tag+'TBODY_CS'+tag+' ood-custom {comcls}"  style="'+tag+'TBODY_CS'+tag+'" >',
            tbody2 = '</tbody>',
            tr1='<tr>',
            tr2='</tr>',
            td1='<th id="'+key+'-W:'+id+':@"  class="ood-node ood-node-th ood-uiborder-b ood-uiborder-r '+cls+'-w '+tag+'W_CC'+tag+' ood-custom {comcls}"  style="'+tag+'W_CS'+tag+'">@</th>',
            td2='<td id="'+key+'-TD:'+id+':@" class="ood-node ood-uicell  ood-node-td ood-uiborder-b ood-uiborder-r '+cls+'-td '+tag+'TD_CC'+tag+' ood-custom {comcls}"  style="'+tag+'TD_CS'+tag+'" '+ood.$IEUNSELECTABLE()+' >'+
                '</td>',
            body,i,j,k,l,a=[],b=[];
        for(i=0;i<7;i++)
            b[b.length]= th.replace(/@/g,i);

        k=l=0;
        for(i=0;i<48;i++){
            j=i%8;
            a[a.length]= (j==0?tr1:'') + (j==0?td1:td2).replace(/@/g,j==0?l:k) + (j==7?tr2:'');
            if(j!==0)k++;
            else l++;
        }

        body=colgroup+thead1+b.join('')+thead2+tbody1+a.join('')+tbody2;

        self.setTemplate({
            tagName : 'div',
            style:'{_style};height:auto;',
            //onselectstart:'return false',
            BORDER:{
                tagName : 'div',
                className: 'ood-uiborder-outset ood-uiborder-box ood-uiborder-radius-big',
                BAR:{
                    tagName:'div',
                    className:'ood-uibar-top',
                    style:'{barDisplay};',
                    BARTDL:{
                        className:'ood-uibar-tdl ood-uibar ood-uiborder-radius-big-tl',
                        BARTDLT:{
                            className:'ood-uibar-tdlt'
                        }
                    },
                    BARTDM:{
                        $order:1,
                        className:'ood-uibar-tdm ood-uibar',
                        BARTDMT:{
                            className:'ood-uibar-tdmt'
                        }
                    },
                    BARTDR:{
                        $order:2,
                        className:'ood-uibar-tdr ood-uibar ood-uiborder-radius-big-tr',
                        BARTDRT:{
                            className:'ood-uibar-tdrt'
                        }
                    },
                    BARCMDL:{
                        $order:3,
                        tagName:'div',
                        className:'ood-uibar-cmdl',
                        PRE2:{
                            $order:0,
                            className:'oodfont',
                            $fonticon:'ood-icon-doubleleft',
                            tabindex: '{tabindex}'
                        },
                        PRE:{
                            $order:1,
                            className:'oodfont',
                            $fonticon:'ood-icon-singleleft',
                            tabindex: '{tabindex}'
                        },
                        YEAR:{
                            $order:2,
                            className:'ood-ui-draggable ood-uibase ood-uiborder-flat ood-uiborder-radius'
                        },
                        YTXT:{$order:3,text:'-'},
                        MONTH:{
                            $order:4,
                            className:'ood-ui-draggable ood-uibase ood-uiborder-flat ood-uiborder-radius'
                        },
                        MTXT:{$order:5,text:'-'},
                        DAY:{
                            $order:6,
                            className:'ood-ui-draggable ood-uibase ood-uiborder-flat ood-uiborder-radius'
                        },
                        NEXT:{
                            $order:7,
                            className:'oodfont',
                            $fonticon:'ood-icon-singleright',
                            tabindex: '{tabindex}'
                        },
                        NEXT2:{
                            $order:8,
                            className:'oodfont',
                            $fonticon:'ood-icon-doubleright',
                            tabindex: '{tabindex}'
                        }
                    },
                    BARCMDR:{
                        $order:4,                        
                        tagName: 'div',
                        className:'ood-uibar-cmdr',
                        CLOSE:{
                            className:'oodfont',
                            $fonticon:'ood-uicmd-close',
                            style:'{closeDisplay}'
                        }
                    },
                    TBARTDB:{
                        $order:5,
                        tagName: 'div',
                        className:'ood-uibar-tdb ood-uiborder-inset ood-uiborder-radius'
                    }
                },
                MAIN:{
                    $order:2,
                    tagName:'div',
                    className:'ood-uicon-main ood-uibar',
                    MAINI:{
                        tagName:'div',
                        className:'ood-uicon-maini ood-uicon-maini ood-uibar',
                        CON:{
                            tagName:'div',
                            className:'ood-uiborder-inset',
                            BODY:{
                                tagName:'table',
                                cellpadding:"0",
                                cellspacing:"0",
                                text:body
                            }
                        }
                    }
                },
                TAIL:{
                    $order:3,
                    tagName:'div',
                    className:'ood-uicon-main ood-uibar',
                    TAILI:{
                        tagName:'div',
                        className:'ood-uicon-maini ood-uibar',
                        CAPTION:{
                            tagName:'div',
                            style:'{_nocap}',
                            text : '{caption}',
                            $order:0
                        },
                        TIME:{
                            style:"{_timectrl}",
                            tagName:'div',
                            TPRE2:{
                                $order:0,
                                className:'oodfont',
                                $fonticon:'ood-icon-doubleleft',
                                tabindex: '{tabindex}'
                            },
                            TPRE:{
                                $order:1,
                                className:'oodfont',
                                $fonticon:'ood-icon-singleleft',
                                tabindex: '{tabindex}'
                            },
                            HOUR:{
                                $order:2,
                                className:'ood-ui-draggable ood-uibase ood-uiborder-flat ood-uiborder-radius'
                            },
                            MTXT:{$order:3,text:':'},
                            MINUTE:{
                                $order:4,
                                className:'ood-ui-draggable ood-uibase ood-uiborder-flat ood-uiborder-radius'
                            },
                            TNEXT:{
                                $order:6,
                                className:'oodfont',
                                $fonticon:'ood-icon-singleright',
                                tabindex: '{tabindex}'
                            },
                            TNEXT2:{
                                $order:7,
                                className:'oodfont',
                                $fonticon:'ood-icon-doubleright',
                                tabindex: '{tabindex}'
                            }
                        },
                        TODAY:{
                             tabindex: '{tabindex}',
                             className:'oodfont',
                            $fonticon:'ood-icon-date',
                             title:"{_todaytitle}"
                        },
                        SET:{
                            tagName:"button",
                            className:'ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius',
                            tabindex: '{tabindex}',
                            text:"{_set}"
                        }
                    }
                },
                BBAR:{
                    $order:4,
                    tagName:'div',
                    className:'ood-uibar-bottom-s',
                    BBARTDL:{
                        className:'ood-uibar-tdl ood-uibar ood-uiborder-radius-big-bl'
                    },
                    BBARTDM:{
                        $order:1,
                        className:'ood-uibar-tdm ood-uibar'
                    },
                    BBARTDR:{
                        $order:2,
                        className:'ood-uibar-tdr ood-uibar ood-uiborder-radius-big-br'
                    }
                }
            }
        });
    },
    Static:{
        Appearances:{
            KEY:{
            },
            'TBART, BBART':{
                'border-spacing':0,
                'border-collapse':'separate'
            },
            BORDER:{
            },
            BODY:{
                position:'relative'
            },
            BARCMDL:{
                top:'.125em'
            },
            TAILI:{
                position:'relative',
                 padding:'.5em 0 0 0'
            },
            TIME:{
                'padding':'.25em 1.5em'
            },
            SET:{
                position:'absolute',
                display:'none',
                top:'.125em',
                right:'.5em'
            },
            TODAY:{
                position:'absolute',
                top:'.25em',
                left:'.125em',
                display:ood.$inlineBlock,
                cursor:'default'
            },
            'PRE,PRE2,NEXT,NEXT2,TPRE,TPRE2,TNEXT,TNEXT2':{
                $order:0,
                display:ood.$inlineBlock,
                position:'relative',
                margin:'0 .25em',
                'vertical-align': 'middle',
                cursor:'default'
            },
            'YEAR,MONTH,DAY,HOUR,MINUTE':{
                $order:4,
                'font-weight':'bold',
                'vertical-align': 'middle',
                cursor:'e-resize',
                margin:'0 .25em',
                'padding':'0 .25em'
            },
            YEAR:{
            },
            'MONTH, DAY,HOUR, MINUTE':{
            },
            CAPTION:{
                'text-align':'center',
                'vertical-align':ood.browser.ie6?'baseline':'middle',
                'font-size':'1em'
            },
            MAINI:{
                 'padding':'.5em .3333em .3333em 0'
            },
            BODY:{
                overflow: 'visible'
            },
            TD:{
                $order:1,
                'text-align':'center'
            },
            'TD-checked':{
                $order:4,
                'font-weight':'bold'
            },
            'W,H':{
                $order:3,
                'vertical-align':'middle',
                'text-align':'center',
                'padding':'.25em'
            },
            W:{
                $order:4,
                padding:'.125em'
            },
            H:{
                $order:4,
                padding:'.25em 0.6666667em'
            }
        },
        Behaviors:{
            HoverEffected:{CLOSE:'CLOSE',TD:'TD',PRE:'PRE',PRE2:'PRE2',NEXT:'NEXT',NEXT2:'NEXT2',TPRE:'TPRE',TPRE2:'TPRE2',TNEXT:'TNEXT',TNEXT2:'TNEXT2',SET:'SET', TODAY:'TODAY'},
            ClickEffected:{CLOSE:'CLOSE',TD:'TD',PRE:'PRE',PRE2:'PRE2',NEXT:'NEXT',NEXT2:'NEXT2',TPRE:'TPRE',TPRE2:'TPRE2',TNEXT:'TNEXT',TNEXT2:'TNEXT2',SET:'SET', TODAY:'TODAY'},
            KEY:{onClick:function(){return false}},
            TD:{
                onClick:function(profile, e, src){
                    var p=profile.properties,
                        id=profile.getSubId(src),
                        map=profile.$daymap,
                        v=map[id];
                    if(p.disabled||p.readonly)return false;

                    ood.use(src).onMouseout(true,{$force:true});

                    v = ood.Date.add(profile.$tempValue, 'd', ood.Date.diff(profile.$tempValue, v, 'd', p.firstDayOfWeek));
                    profile.box._to(profile,v);
                    
                    // set dir
                    if(!p.timeInput)
                        //onClick event
                        profile.boxing().setUIValue(v,null,null,'click');
                },
                onDblclick:function(profile,e,src){
                    var p=profile.properties;
                    if(p.timeInput){
                        ood.use(src).onMouseout(true,{$force:true});
                        profile.boxing().setUIValue(profile.$tempValue, true,null,'dblclick');
                    }
                }
            },
            TODAY:{
                onClick:function(profile,e,src){
                    ood.use(src).onMouseout(true,{$force:true});
                    profile.boxing().setUIValue(
                        profile.properties.timeInput ?
                        new Date :
                        ood.Date.getTimSpanStart(new Date,'d',1)
                    ,true,null,'today');
                }
            },
            SET:{
                onClick:function(profile,e,src){
                    ood.use(src).onMouseout(true,{$force:true});
                    profile.boxing().setUIValue(profile.$tempValue, true,null,'set');
                }
            },
            CLOSE:{
                onClick:function(profile, e, src){
                    var p = profile.properties,
                        instance = profile.boxing();
                    if(p.disabled||p.readonly)return;
                    if(false===instance.beforeClose(profile, src)) return;
                    instance.destroy(true);
                }
            },
            PRE:{
                onClick:function(profile, e, src){
                    var p = profile.properties;
                    if(p.disabled||p.readonly)return;
                    profile.box._to(profile,ood.Date.add(profile.$tempValue,'m',-1));
                }
            },
            NEXT:{
                onClick:function(profile, e, src){
                    var p = profile.properties;
                    if(p.disabled||p.readonly)return;
                    profile.box._to(profile,ood.Date.add(profile.$tempValue,'m',1));
                }
            },
            PRE2:{
                onClick:function(profile, e, src){
                    var p = profile.properties;
                    if(p.disabled||p.readonly)return;
                    profile.box._to(profile,ood.Date.add(profile.$tempValue,'y',-1));
                }
            },
            NEXT2:{
                onClick:function(profile, e, src){
                    var p = profile.properties;
                    if(p.disabled||p.readonly)return;
                    profile.box._to(profile,ood.Date.add(profile.$tempValue,'y',1));
                }
            },
            TPRE:{
                onClick:function(profile, e, src){
                    var p = profile.properties;
                    if(p.disabled||p.readonly)return;
                    profile.box._to(profile,ood.Date.add(profile.$tempValue,'n',-1));
                }
            },
            TNEXT:{
                onClick:function(profile, e, src){
                    var p = profile.properties;
                    if(p.disabled||p.readonly)return;
                    profile.box._to(profile,ood.Date.add(profile.$tempValue,'n',1));
                }
            },
            TPRE2:{
                onClick:function(profile, e, src){
                    var p = profile.properties;
                    if(p.disabled||p.readonly)return;
                    profile.box._to(profile,ood.Date.add(profile.$tempValue,'h',-1));
                }
            },
            TNEXT2:{
                onClick:function(profile, e, src){
                    var p = profile.properties;
                    if(p.disabled||p.readonly)return;
                    profile.box._to(profile,ood.Date.add(profile.$tempValue,'h',1));
                }
            },
            YEAR:{
                beforeMousedown:function(profile, e, src){
                    return profile.box._ondown(profile,e,src,10);
                },
                onDrag:function(profile, e, src){
                    var count,off = ood.DragDrop.getProfile().offset;
                    count=parseInt(profile.$year,10)+parseInt(off.x/10,10);
                    if(profile.$temp!=count){
                        profile.$temp2=parseInt(off.x/10,10);
                        profile.getSubNode('YEAR').html(count,false);
                    }
                },
                onDragstop:function(profile, e, src){
                    return profile.box._onds(profile,e,src,'y');
                }
            },
            MONTH:{
                beforeMousedown:function(profile, e, src){
                    return profile.box._ondown(profile,e,src,20);
                },
                onDrag:function(profile, e, src){
                    var count,off = ood.DragDrop.getProfile().offset;
                    count=parseInt(profile.$month,10)+(parseInt(off.x/20,10)%12);
                    count=(count%12+12)%12;
                    if(profile.$temp!=count){
                        profile.$temp=count;
                        profile.$temp2=count-profile.$month+1;
                        profile.getSubNode('MONTH').html(((count+1)<=9?"0":"")+(count+1),false);
                    }
                },
                onDragstop:function(profile, e, src){
                    return profile.box._onds(profile,e,src,'m');
                }
            },
            DAY:{
                beforeMousedown:function(profile, e, src){
                    return profile.box._ondown(profile,e,src,10);
                },
                onDrag:function(profile, e, src){
                    var date=new Date(profile.$year,profile.$month,0),
                        days=date.getDate();

                    var p=profile.properties,
                        count,
                        off = ood.DragDrop.getProfile().offset;
                    count=parseInt(profile.$day,10)+(parseInt(off.x/10,10)%days);
                    count=(count%days+days)%days + 1;
                    if(profile.$temp!=count){
                        profile.$temp=count;
                        profile.$temp2=count-profile.$day;
                        profile.getSubNode('DAY').html((count<=9?"0":"")+count,false);
                    }
                },
                onDragstop:function(profile, e, src){
                    return profile.box._onds(profile,e,src,'d');
                }
            },
            HOUR:{
                beforeMousedown:function(profile, e, src){
                    return profile.box._ondown(profile,e,src,20);
                },
                onDrag:function(profile, e, src){
                    return profile.box._ondrag(profile,20,24,'HOUR',profile.$hour);
                },
                onDragstop:function(profile, e, src){
                    return profile.box._onds(profile,e,src,'h');
                }
            },
            MINUTE:{
                beforeMousedown:function(profile, e, src){
                    return profile.box._ondown(profile,e,src,10);
                },
                onDrag:function(profile, e, src){
                    return profile.box._ondrag(profile,10,60,'MINUTE',profile.$minute);
                },
                onDragstop:function(profile, e, src){
                    return profile.box._onds(profile,e,src,'n');
                }
            }
        },
        DataModel:{
            // Modern properties
            theme: {
                ini: 'light',
                listbox: ['light', 'dark'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            timeInput:{
                ini:false,
                action:function(v){
                    this.getSubNode('CAPTION').css('display',v?'none':'block');
                    this.getSubNode('SET').css('display',v?'block':'none');
                    this.getSubNode('TIME').css('display',v?'block':'none');
                    this.getSubNode('TODAY').attr("title",ood.getRes(v?"inline.now":"inline.today"));
                }
            },
            height:{
                $spaceunit:1,
                ini:'auto',
                readonly:true
            },
            width:{
                $spaceunit:1,
                ini:'auto',
                readonly:true
            },
            value:{
                ini:new Date,
                format:'date'
            },
            closeBtn:{
                ini:true,
                action:function(v){
                    this.getSubNode('CLOSE').css('display',v?'':'none');
                }
            },
            firstDayOfWeek:{
                ini:0,
                action:function(){
                    this.boxing().refresh();
                }
            },
            offDays:{
                ini:'60',
                action:function(){
                    this.boxing().refresh();
                }
            },
            hideWeekLabels:{
                ini:false,
                action:function(){
                    this.boxing().refresh();
                }
            },
            dateInputFormat:{
                ini:"yyyy-mm-dd",
                listbox:["yyyy-mm-dd","mm-dd-yyyy","dd-mm-yyyy"],
                action:function(){
                    this.boxing().refresh();
                }
            }
        },
        EventHandlers:{
            beforeClose:function(profile, src){}
        },
        _prepareData:function(profile){
            var data=arguments.callee.upper.call(this, profile);
            var nodisplay='display:none';
            data.closeDisplay = data.closeBtn?'':nodisplay;
            
            var none="display:none;";
            if(profile.properties.timeInput){
                data._todaytitle=ood.getRes("inline.now");
                data._nocap=none;
            }else{
                data._todaytitle=ood.getRes("inline.today");
                data._timectrl=none;
            }
            data._set = ood.wrapRes('inline.set');

            return data;
        },
        _ensureValue:function(profile, value){
            var d;
            if(value){
                if(ood.isDate(value))
                    d=value;
                else if(ood.isFinite(value))
                    d=new Date(parseInt(value,10));
            }
            d = d||new Date;
            if(!profile.properties.timeInput)
                d=ood.Date.getTimSpanStart(d,'d');
            return d;
        },
        RenderTrigger:function(){
            var self=this, p=self.properties, o=self.boxing(), b=self.box;
            b._setWeekLabel(self);
            
            var hash={yyyy:'YEAR',mm:'MONTH',dd:'DAY'},arr=p.dateInputFormat.split('-');
            if(hash[arr[0]] && hash[arr[1]] && hash[arr[2]]){
                self.getSubNode('YTXT').addPrev(self.getSubNode(hash[arr[0]]));
                self.getSubNode('MTXT').addPrev(self.getSubNode(hash[arr[1]]));
                self.getSubNode('MTXT').addNext(self.getSubNode(hash[arr[2]]));
            }
            
//            self.getSubNode('YTXT').html(ood.wrapRes('date.Y'),false);
//            self.getSubNode('MTXT').html(ood.wrapRes('date.M'),false);
            
            // Modern feature initialization
            ood.asyRun(function(){
                self.boxing().DatePickerTrigger();
            });
        },
        
        DatePickerTrigger: function() {
            var profile = this.get(0);
            var prop = profile.properties;
            var boxing = this;

            // Initialize theme
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // Restore theme from local storage
                var savedTheme = localStorage.getItem('datepicker-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // Initialize responsive design
            if (prop.responsive !== false) {
                boxing.adjustLayout();
            }

            // Initialize accessibility
            boxing.enhanceAccessibility();
        },
        _getWeekNodes:function(profile){
            return profile.$weeks || (profile.$weeks=profile.getSubNode('W',true));
        },
        _getTDNodes:function(profile){
            return profile.$tds || (profile.$tds=profile.getSubNode('TD',true));
        },
        _getLabelNodes:function(profile){
            return profile.$days || (profile.$days=profile.getSubNode('TD',true));
        },
        _getHeaderNodes:function(profile){
            return profile.$header || (profile.$header=profile.getSubNode('H',true));
        },
        _setWeekLabel:function(profile){
            var p=profile.properties;

            // for week
            var fw=p.firstDayOfWeek,
                f=function(id){
                id=profile.getSubId(id); 

                // The special one
                if(id=='7')return id;
                
                id=(parseInt(id,10)+fw);
                return id<7?id:(id-7);
            };

            profile.box._getHeaderNodes(profile).each(function(node,i){
                node.innerHTML=ood.wrapRes('date.WEEKS.'+f(node.id))
            });
            
            // for weeklable
            if(p.hideWeekLabels){
                profile.getSubNode('BODY').query('TR').first().remove();
                profile.getSubNode('COL').first().remove();
            }

            // for free days            
            var cls2="ood-uicell-alt",
                fdmap={};
            if(p.offDays){
                ood.arr.each(p.offDays.split(""),function(i){
                    i=parseInt(i,10);
                    if(i>=0 && i<=6)
                        fdmap[i]=1;
                });
                profile.box._getTDNodes(profile).each(function(node,i){
                    i = ((i+fw) - 7*parseInt((i+fw)/7,10)) ;
                    if(fdmap[i])node.className=node.className + " " +cls2;
                    else node.className=node.className.replace(cls2,"");
                });
            }
            
        },
        _setBGV:function(profile, v, m){
            var date=ood.Date,
                p=profile.properties,
                daymap=profile.$daymap||(profile.$daymap=[]),
                t,n;
            profile.box._getLabelNodes(profile).each(function(node,i){
                n=date.add(v,'d',i);
                daymap[i]=n;
                t=date.get(n,'m')==m?'#':'<p class="ood-node ood-node-p ood-ui-readonly ood-custom {comcls}">#</p>';
                n=date.get(n,'d');
                node.innerHTML = t.replace('#',n);
            });

            if(!p.hideWeekLabels)
                profile.box._getWeekNodes(profile).each(function(node,i){
                    node.innerHTML=date.get(date.add(v,'ww',i),'ww',p.firstDayOfWeek);
                });
        },
        _to:function(profile, time, force){
            var p = profile.properties,
                fw = p.firstDayOfWeek,
                date=ood.Date,
                keys=profile.keys,
                uiv=p.$UIvalue,
                index=-1,
                node,
                temp,
                _realstart = date.getTimSpanStart(date.getTimSpanStart(time,'m'),'ww',1,fw),
                m=date.get(time,'m',fw);

            profile.$tempValue=time;
            this._setBGV(profile, profile._realstart=_realstart, m);

            //remove checked css class
            if(profile.$selnode)
                profile.$selnode.tagClass('-checked',false);
            //[[add cecked css class
            ood.arr.each(profile.$daymap,function(o,i){
                if(date.get(o,'m',fw)+'-'+date.get(o,'d',fw)==date.get(time,'m',fw)+'-'+date.get(time,'d',fw)){
                    index=i;
                    return false;
                }
            });
            node=this._getTDNodes(profile).get()[index];
            (profile.$selnode=ood([node]).tagClass('-checked'));
            //]]
            
            //[[ show dirty
            profile.getSubNode('SET').css('display',(force||uiv.getTime()==time.getTime())?'none':'block');
            profile.getSubNode('CAPTION').css('color',(force||uiv.getTime()==time.getTime())?'':'var(--error-color)');
            //]]

            temp=date.get(time,'y',fw);
            if(profile.$year!=temp){
                profile.$year=temp;
                profile.getSubNode('YEAR').html(temp,false);
            }
            temp=date.get(time,'m',fw)+1;
            if(profile.$month!=temp){
                profile.$month=temp;
                profile.getSubNode('MONTH').html((temp<=9?"0":"")+temp,false);
            }
            temp=date.get(time||time,'d',fw);
            if(profile.$day!=temp){
                profile.$day=temp;
                profile.getSubNode('DAY').html((temp<=9?"0":"")+temp,false);
            }
            temp=date.get(time,'h',fw);
            if(profile.$hour!=temp){
                profile.$hour=temp;
                profile.getSubNode('HOUR').html((temp<=9?"0":"")+temp,false);
            }
            temp=date.get(time,'n',fw);
            if(profile.$minute!=temp){
                profile.$minute=temp;
                profile.getSubNode('MINUTE').html((temp<=9?"0":"")+temp,false);
            }
        },
        _ondown:function(profile, e, src,increment){
            if(ood.Event.getBtn(e)!="left")return;
            ood.use(src).startDrag(e, {
                dragType:'blank',
                targetReposition:false,
                widthIncrement:increment,
                dragCursor:true
            });
            profile.$temp=profile.$temp2=0;
        },
        _ondrag:function(profile,increment,max,key,data){
            var p=profile.properties,
                count,
                off = ood.DragDrop.getProfile().offset;
            count=parseInt(data,10)+(parseInt(off.x/increment,10)%max);
            count=(count%max+max)%max;
            if(profile.$temp!=count){
                profile.$temp=count;
                profile.$temp2=count-data;
                profile.getSubNode(key).html((count<=9?"0":"")+count,false);
            }
        },
        _onds:function(profile, e, src, type){
            if(profile.$temp2){
                var p=profile.properties,
                    v = ood.Date.add(profile.$tempValue,type,profile.$temp2);
                profile.box._to(profile,v);
            }
            profile.$temp=profile.$temp2=0;
        },
        _onresize:function(){}
    }
});ood.Class('ood.UI.TimePicker', ['ood.UI',"ood.absValue"], {
    Dependencies:['ood.Date'],
    Instance:{
        activate:function(){
            this.getSubNode('PRE').focus(true);
            return this;
        },
        _setCtrlValue:function(value){
            return this.each(function(profile){
                if(!profile.renderId)return;

                var cls = profile.box,
                    arr2=cls._v2a(value);
                profile.$hour=arr2[0];
                profile.$minute=arr2[1];
                
                profile.getSubNode('HI',true).removeClass(cls._excls_c3).removeClass(cls._excls_mo3);
                profile.getSubNode('HI',arr2[0]).addClass(cls._excls_c3);

                profile.getSubNode('MI',true).removeClass(cls._excls_c).removeClass(cls._excls_mo);
                profile.getSubNode('MI',arr2[1]).addClass(cls._excls_c);

                profile.getSubNode('HOUR').html(arr2[0],false);
                profile.getSubNode('MINUTE').html(arr2[1],false);
                profile.getSubNode('CAPTION').html(profile.box._showV(profile,profile.box._v2a(arr2)),false);
            });
        },
        
        // 
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot(),
                    border = profile.getSubNode('BORDER'),
                    bart = profile.getSubNode('BART'),
                    main = profile.getSubNode('MAIN'),
                    tail = profile.getSubNode('TAIL'),
                    btns = root.query('.oodfont'),
                    inputs = root.query('.ood-ui-draggable'),
                    hours = profile.getSubNode('HI', true),
                    minutes = profile.getSubNode('MI', true),
                    setBtn = profile.getSubNode('SET');

                if (theme === 'dark') {
                    // 
                    root.addClass('timepicker-dark');
                    
                    // 
                    border.css({
                        'background-color': 'var(--ood-dark-bg)',
                        'border-color': 'var(--ood-dark-border)',
                        'color': 'var(--ood-dark-text)'
                    });
                    
                    // 
                    bart.css({
                        'background': 'var(--ood-dark-gradient)',
                        'border-color': 'var(--ood-dark-border-secondary)'
                    });
                    
                    // 
                    main.css({
                        'background-color': 'var(--ood-dark-bg-secondary)',
                        'border-color': 'var(--ood-dark-border)'
                    });
                    
                    // 
                    tail.css({
                        'background-color': 'var(--ood-dark-bg-secondary)',
                        'border-color': 'var(--ood-dark-border)'
                    });
                    
                    // 
                    btns.css({
                        'color': 'var(--ood-dark-text)',
                        'background': 'var(--ood-dark-bg-button)',
                        'border-color': 'var(--ood-dark-border-secondary)'
                    });
                    
                    // 
                    inputs.css({
                        'background-color': 'var(--ood-dark-bg-input)',
                        'border-color': 'var(--ood-dark-border-secondary)',
                        'color': 'var(--ood-dark-text)'
                    });
                    
                    // 
                    hours.css({
                        'background-color': 'var(--ood-dark-bg-secondary)',
                        'border-color': 'var(--ood-dark-border)',
                        'color': 'var(--ood-dark-text)'
                    });
                    
                    minutes.css({
                        'background-color': 'var(--ood-dark-bg-secondary)',
                        'border-color': 'var(--ood-dark-border)',
                        'color': 'var(--ood-dark-text)'
                    });
                    
                    // 
                    if (setBtn && !setBtn.isEmpty()) {
                        setBtn.css({
                            'background': 'var(--ood-dark-primary)',
                            'color': 'var(--ood-dark-text-inverse)',
                            'border-color': 'var(--ood-dark-primary-dark)'
                        });
                    }
                } else {
                    // 
                    root.removeClass('timepicker-dark');
                    
                    // 
                    border.css({
                        'background-color': '',
                        'border-color': '',
                        'color': ''
                    });
                    
                    bart.css({
                        'background': '',
                        'border-color': ''
                    });
                    
                    main.css({
                        'background-color': '',
                        'border-color': ''
                    });
                    
                    tail.css({
                        'background-color': '',
                        'border-color': ''
                    });
                    
                    btns.css({
                        'color': '',
                        'background': '',
                        'border-color': ''
                    });
                    
                    inputs.css({
                        'background-color': '',
                        'border-color': '',
                        'color': ''
                    });
                    
                    hours.css({
                        'background-color': '',
                        'border-color': '',
                        'color': ''
                    });
                    
                    minutes.css({
                        'background-color': '',
                        'border-color': '',
                        'color': ''
                    });
                    
                    if (setBtn && !setBtn.isEmpty()) {
                        setBtn.css({
                            'background': '',
                            'color': '',
                            'border-color': ''
                        });
                    }
                }
                
                // 
                localStorage.setItem('timepicker-theme', theme);
            });
        },
        
        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('timepicker-theme') || 'light';
        },
        
        // 
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        
        // 
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    bart = profile.getSubNode('BART'),
                    main = profile.getSubNode('MAIN'),
                    tail = profile.getSubNode('TAIL'),
                    inputs = root.query('.ood-ui-draggable'),
                    btns = root.query('.oodfont'),
                    hours = profile.getSubNode('HI', true),
                    minutes = profile.getSubNode('MI', true),
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('timepicker-mobile');
                    
                    // 
                    btns.css({
                        'min-width': '2.2em',
                        'min-height': '2.2em',
                        'font-size': '1.1em'
                    });
                    
                    // 
                    inputs.css({
                        'min-height': '2em',
                        'font-size': '0.9em',
                        'padding': '0.3em'
                    });
                    
                    // 
                    hours.css({
                        'font-size': '0.9em',
                        'padding': '0.2em'
                    });
                    
                    minutes.css({
                        'font-size': '0.9em',
                        'padding': '0.2em'
                    });
                } else {
                    root.removeClass('timepicker-mobile');
                    
                    // 
                    btns.css({
                        'min-width': '',
                        'min-height': '',
                        'font-size': ''
                    });
                    
                    inputs.css({
                        'min-height': '',
                        'font-size': '',
                        'padding': ''
                    });
                    
                    hours.css({
                        'font-size': '',
                        'padding': ''
                    });
                    
                    minutes.css({
                        'font-size': '',
                        'padding': ''
                    });
                }

                // 
                if (width < 480) {
                    root.addClass('timepicker-tiny');
                    
                    // 
                    main.css({
                        'font-size': '0.8em'
                    });
                    
                    tail.css({
                        'font-size': '0.8em'
                    });
                } else {
                    root.removeClass('timepicker-tiny');
                    
                    main.css({
                        'font-size': ''
                    });
                    
                    tail.css({
                        'font-size': ''
                    });
                }
            });
        },
        
        // 
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    bart = profile.getSubNode('BART'),
                    main = profile.getSubNode('MAIN'),
                    tail = profile.getSubNode('TAIL'),
                    inputs = root.query('.ood-ui-draggable'),
                    btns = root.query('.oodfont'),
                    hours = profile.getSubNode('HI', true),
                    minutes = profile.getSubNode('MI', true),
                    setBtn = profile.getSubNode('SET'),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'application',
                    'aria-label': ood.getRes('UI.timepicker.label')
                });
                
                // ARIA
                if (bart && !bart.isEmpty()) {
                    bart.attr({
                        'role': 'toolbar',
                        'aria-label': ood.getRes('UI.timepicker.toolbar')
                    });
                }
                
                // ARIA
                if (main && !main.isEmpty()) {
                    main.attr({
                        'role': 'group',
                        'aria-label': ood.getRes('UI.timepicker.selection')
                    });
                }
                
                // ARIA
                btns.each(function(btn) {
                    var btnElement = ood(btn),
                        btnClass = btnElement.attr('class') || '',
                        btnLabel = ood.getRes('UI.timepicker.button');
                    
                    if (btnClass.indexOf('doubleleft') > -1) {
                        btnLabel = ood.getRes('UI.timepicker.decreaseHour');
                    } else if (btnClass.indexOf('singleleft') > -1) {
                        btnLabel = ood.getRes('UI.timepicker.decreaseMinute');
                    } else if (btnClass.indexOf('singleright') > -1) {
                        btnLabel = ood.getRes('UI.timepicker.increaseMinute');
                    } else if (btnClass.indexOf('doubleright') > -1) {
                        btnLabel = ood.getRes('UI.timepicker.increaseHour');
                    } else if (btnClass.indexOf('close') > -1) {
                        btnLabel = ood.getRes('UI.timepicker.close');
                    }
                    
                    btnElement.attr({
                        'role': 'button',
                        'aria-label': btnLabel,
                        'tabindex': properties.disabled ? '-1' : '0'
                    });
                });
                
                // ARIA
                inputs.each(function(input) {
                    var inputElement = ood(input),
                        inputId = inputElement.id();
                    
                    var label = ood.getRes('UI.timepicker.timeInput');
                    if (inputId && inputId.indexOf('HOUR') > -1) {
                        label = ood.getRes('UI.timepicker.hourInput');
                    } else if (inputId && inputId.indexOf('MINUTE') > -1) {
                        label = ood.getRes('UI.timepicker.minuteInput');
                    }
                    
                    inputElement.attr({
                        'role': 'spinbutton',
                        'aria-label': label,
                        'tabindex': properties.disabled ? '-1' : '0'
                    });
                });
                
                // ARIA
                hours.each(function(hour) {
                    var hourElement = ood(hour),
                        hourValue = hourElement.text();
                    
                    hourElement.attr({
                        'role': 'gridcell',
                        'aria-label': ood.getRes('UI.timepicker.hour') + ' ' + hourValue,
                        'tabindex': properties.disabled ? '-1' : '0'
                    });
                });
                
                minutes.each(function(minute) {
                    var minuteElement = ood(minute),
                        minuteValue = minuteElement.text();
                    
                    minuteElement.attr({
                        'role': 'gridcell',
                        'aria-label': ood.getRes('UI.timepicker.minute') + ' ' + minuteValue,
                        'tabindex': properties.disabled ? '-1' : '0'
                    });
                });
                
                // ARIA
                if (setBtn && !setBtn.isEmpty()) {
                    setBtn.attr({
                        'role': 'button',
                        'aria-label': '',
                        'tabindex': properties.disabled ? '-1' : '0'
                    });
                }
            });
        }
    },
    Initialize:function(){
        this.addTemplateKeys(['HI','MI']);

        var a,i,h,m,cls,cls2,id,t;

        cls=this._excls3;
        cls2=this._excls4;
        id=ood.UI.$ID;
        t='<span id="'+this.KEY+'-HI:'+id+':@" class="ood-node ood-node-span '+cls+' !" '+ood.$IEUNSELECTABLE()+' >@</span>';
        a=[];
        for(i=0;i<24;i++){
            a[a.length]=t.replace(/@/g,i<10?('0'+i):i).replace('!',((i%6===0)?cls2:'')+" ood-custom {comcls}");
             if(i+1==12)a[a.length]='<br />';
        }
        h=a.join('');
        a.length=0;

        cls=this._excls;
        cls2=this._excls2;
        id=ood.UI.$ID;
        t='<span id="'+this.KEY+'-MI:'+id+':@" class="ood-node ood-node-span '+cls+' !" '+ood.$IEUNSELECTABLE()+' >@</span>';
        a=[];
        for(i=0;i<60;i++){
            a[a.length]=t.replace(/@/g,i<10?('0'+i):i).replace('!',((i%5===0)?cls2:'') +" ood-custom {comcls}");
            if((i+1) % 10 ===0 && i!=59 )a[a.length]='<br />';
        }
        m=a.join('');
        a.length=0;
        
        this.setTemplate({
            tagName : 'div',
            //onselectstart:'return false',
            style:'{_style};height:auto;',
            BORDER:{
                tagName : 'div',
                className: 'ood-uiborder-outset ood-uiborder-box ood-uiborder-radius-big',
                BART:{
                    tagName:'div',
                    className:'ood-uibar-top',
                    style:'{barDisplay};',
                    BARTDL:{
                        className:'ood-uibar-tdl ood-uibar ood-uiborder-radius-big-tl',
                        BARTDLT:{
                            className:'ood-uibar-tdlt'
                        }
                    },
                    BARTDM:{
                        $order:1,
                        className:'ood-uibar-tdm ood-uibar',
                        BARTDMT:{
                            className:'ood-uibar-tdmt'
                        }
                    },
                    BARTDR:{
                        $order:2,
                        className:'ood-uibar-tdr ood-uibar ood-uiborder-radius-big-tr',
                        BARTDRT:{
                            className:'ood-uibar-tdrt'
                        }
                    },
                    BARCMDL:{
                        $order:3,
                        tagName: 'div',
                        className:'ood-uibar-cmdl',
                        PRE2:{
                            $order:0,
                            className:'oodfont',
                            $fonticon:'ood-icon-doubleleft',                                                        
                            tabindex: '{tabindex}'
                        },
                        PRE:{
                            $order:1,
                            className:'oodfont',
                            $fonticon:'ood-icon-singleleft',                                                        
                            tabindex: '{tabindex}'
                        },
                        HOUR:{
                            $order:2,
                            className:'ood-ui-draggable ood-uibase ood-uiborder-flat ood-uiborder-radius'
                        },
                        MTXT:{$order:3,text:':'},
                        MINUTE:{
                                $order:4,
                                className:'ood-ui-draggable ood-uibase ood-uiborder-flat ood-uiborder-radius'
                            },
                        NEXT:{
                            $order:6,
                            className:'oodfont',
                            $fonticon:'ood-icon-singleright',                            
                            tabindex: '{tabindex}'
                        },
                        NEXT2:{
                            $order:7,
                            className:'oodfont',
                            $fonticon:'ood-icon-doubleright',                            
                            tabindex: '{tabindex}'
                        }
                    },
                    BARCMDR:{
                        $order:4,
                        tagName: 'div',
                        className:'ood-uibar-cmdr',
                        CLOSE:{
                            className:'oodfont',
                            $fonticon:'ood-uicmd-close',
                            style:'{closeDisplay}'
                        }
                    },
                    TBARTDB:{
                        $order:5,
                        tagName: 'div',
                        className:'ood-uibar-tdb ood-uiborder-inset ood-uiborder-radius'
                    }
                },
                MAIN:{
                    $order:2,
                    tagName:'div',
                    className:'ood-uicon-main ood-uibar',
                    MAINI:{
                        tagName:'div',
                        className:'ood-uibar ood-uicon-maini ood-uibar',
                        CONH:{
                            tagName:'div',
                            className:'ood-uibase ood-uiborder-flat',
                            text:h
                        },
                        CONM:{
                            $order:2,
                            tagName:'div',
                            className:'ood-uibase ood-uiborder-flat',
                            text:m
                        }
                    }
                },
                TAIL:{
                    $order:3,
                    tagName:'div',
                    className:'ood-uicon-main ood-uibar',
                    TAILI:{
                        tagName:'div',
                        className:'ood-uibar ood-uicon-maini',
                        CAPTION:{
                            text : '{caption}'
                        },
                        SET:{
                            tagName:'button',
                            className:'ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius',
                            tabindex: '{tabindex}',
                            text:"{_set}"
                        }
                    }
                },
                BBAR:{
                    $order:4,
                    tagName:'div',
                    className:'ood-uibar-bottom-s',
                    BBARTDL:{
                        className:'ood-uibar-tdl ood-uibar ood-uiborder-radius-big-bl'
                    },
                    BBARTDM:{
                        $order:1,
                        className:'ood-uibar-tdm ood-uibar'
                    },
                    BBARTDR:{
                        $order:2,
                        className:'ood-uibar-tdr ood-uibar ood-uiborder-radius-big-br'
                    }
                }
            }
        });
    },
    Static:{
        _excls:'oodex-timepicker ood-uicell',
        _excls2:'oodex-timepicker ood-uicell ood-uicell-alt ',
        _excls3:'oodex-timepicker3 ood-uicell',
        _excls4:'oodex-timepicker ood-uicell ood-uicell-alt',

        _excls_mo:'ood-uicell-hover',
        _excls_c:'ood-uicell-checked',
        _excls_mo3:'ood-uicell-hover',
        _excls_c3:'ood-uicell-checked',
        _mover:function(src, type){
            var b=this,cn=src.className;
            if(type==2){
                if(cn.indexOf(b._excls_mo3)==-1)
                    src.className=cn + ' ' + b._excls_mo3;
            }else{
                if(cn.indexOf(b._excls_mo)==-1)
                    src.className=cn + ' ' + b._excls_mo;
            }
            src=null;
        },
        _mout:function(src,type){
            var b=this,cn=src.className;
            if(type==2){
                if(cn.indexOf(b._excls_mo3)!=-1)
                    src.className=cn.replace(b._excls_mo3,'');
            }else{
                if(cn.indexOf(b._excls_mo)!=-1)
                    src.className=cn.replace(b._excls_mo,'');
            }
            src=null;
        },
        Appearances:{
            KEY:{
            },
            'TBART, BBART':{
                'border-spacing':0,
                'border-collapse':'separate'
            },
            MAINI:{
                'padding':'.5em .3333em .3333em 0'
            },
            CONH:{
                'white-space': 'nowrap',
                'text-align':'center'
            },
            CONM:{
                'margin-top':'.5em',
                'white-space': 'nowrap',
                'text-align':'center'
            },
            BARCMDL:{
                top:'.125em'
            },
            'PRE,PRE2,NEXT,NEXT2':{
                position:'relative',
                margin:'0 .25em',
                'vertical-align': 'middle',
                cursor:'default'
            },
            'HOUR, MINUTE':{
                $order:3,
                'font-weight':'bold',
                'vertical-align': 'middle',
                cursor:'e-resize',
                margin:'0 .25em',
                'padding':'0 .25em'
            },
            SET:{
                position:'absolute',
                display:'none',
                top:'.125em',
                right:'.5em'
            },
            TAILI:{
                position:'relative',
                padding:'.5em 0 0 0',
                'text-align':'center'
            },
            CAPTION:{
                'vertical-align':ood.browser.ie6?'baseline':'middle',
                'font-size':'1em'
            },
            '.oodex-timepicker':{
                width:'2em',
                'text-align':'center',
                padding:'.25em 0',
                margin:0
            },
            '.oodex-timepicker3':{
                width:'1.6666em',
                'text-align':'center',
                'font-weight':'bold',
                padding:'.25em 0',
                margin:0
            }
        },
        Behaviors:{
            HoverEffected:{CLOSE:'CLOSE',PRE:'PRE',NEXT:'NEXT',PRE2:'PRE2',NEXT2:'NEXT2',SET:'SET'},
            ClickEffected:{CLOSE:'CLOSE',PRE:'PRE',NEXT:'NEXT',PRE2:'PRE2',NEXT2:'NEXT2',SET:'SET'},
            KEY:{onClick:function(){return false}},
            HOUR:{
                beforeMousedown:function(profile, e, src){
                    if(ood.Event.getBtn(e)!="left")return;
                    ood(src).startDrag(e, {
                        dragType:'blank',
                        targetReposition:false,
                        widthIncrement:5,
                        dragCursor:true
                    });
                    profile.$temp2=0;
                },
                onDrag:function(profile, e, src){
                    var count,off = ood.DragDrop.getProfile().offset,v=profile.properties.$UIvalue,a=v.split(':');
                    a[0]=Math.round( (parseFloat(a[0])||0)+parseInt(off.x/10) );
                    a[0]=(a[0]%24+24)%24;
                    profile.$temp2=(a[0]<=9?'0':'')+a[0];

                    if(v[0]!=profile.$temp2)
                        profile.getSubNode('HOUR').html(profile.$temp2,false);
                },
                onDragstop:function(profile, e, src){
                    if(profile.$temp2){
                        profile.$hour=profile.$temp2;
                        profile.boxing()._setCtrlValue(profile.$hour+":"+profile.$minute);
                    }
                    profile.$temp2=0;
                    profile.box._hourC(profile);
                }
            },
             MINUTE:{
                beforeMousedown:function(profile, e, src){
                    if(ood.Event.getBtn(e)!="left")return;
                    ood(src).startDrag(e, {
                        dragType:'blank',
                        targetReposition:false,
                        widthIncrement:5,
                        dragCursor:true
                    });
                    profile.$temp2=0;
                },
                onDrag:function(profile, e, src){
                    var count,off = ood.DragDrop.getProfile().offset,v=profile.properties.$UIvalue,a=v.split(':');
                    a[0]=Math.round( (parseFloat(a[0])||0) + parseFloat(off.x/20) );
                    a[0]=(a[0]%60+60)%60;
                    profile.$temp2=(a[0]<=9?'0':'')+a[0];

                    if(v[0]!=profile.$temp2)
                        profile.getSubNode('MINUTE').html(profile.$temp2,false);
                },
                onDragstop:function(profile, e, src){
                    if(profile.$temp2){
                        profile.$minute=profile.$temp2;
                        profile.boxing()._setCtrlValue(profile.$hour+":"+profile.$minute);
                    }
                    profile.$temp2=0;
                    profile.box._hourC(profile);
                }
            },
            SET:{
                onClick:function(profile){
                    var pro=profile.properties,
                        v=pro.$UIvalue,
                        a=v.split(':');
                    a[0]=profile.$hour;
                    a[1]=profile.$minute;
                    profile.boxing().setUIValue(a.join(':'),true,null,'click');
                    if(profile.box)profile.box._hourC(profile);
                }
            },
            HI:{
                onMouseover:function(profile, e, src){
                    if(profile.properties.disableHoverEffect)return;
                    profile.box._mover(ood.use(src).get(0),2);
                },
                onMouseout:function(profile, e, src){
                    if(profile.properties.disableHoverEffect)return;
                    profile.box._mout(ood.use(src).get(0),2);
                },
                onClick:function(profile, e, src){
                    profile.$hour=profile.getSubId(src);
                    profile.boxing()._setCtrlValue(profile.$hour+":"+profile.$minute);
                    if(profile.box)profile.box._hourC(profile);
                },
                onDblclick:function(profile, e, src){
                    profile.$hour=profile.getSubId(src);
                    profile.boxing().setUIValue(profile.$hour+":"+profile.$minute,true,null,'dblclick');
                    if(profile.box)profile.box._hourC(profile);
                }
            },
            MI:{
                onMouseover:function(profile, e, src){
                    if(profile.properties.disableHoverEffect)return;
                    profile.box._mover(ood.use(src).get(0));
                },
                onMouseout:function(profile, e, src){
                    if(profile.properties.disableHoverEffect)return;
                    profile.box._mout(ood.use(src).get(0));
                },
                onClick:function(profile, e, src){
                    profile.$minute=profile.getSubId(src);
                    profile.boxing().setUIValue(profile.$hour+":"+profile.$minute,true,null,'click2');
                    if(profile.box)profile.box._hourC(profile);
                }
            },
            PRE:{
                onClick:function(profile, e, src){
                    var p = profile.properties;
                    if(p.disabled||p.readonly)return;
                    var v=profile.$minute;
                    v=(parseFloat(v)||0)-1;
                    v=(v%60+60)%60;
                    profile.$minute=v=(v<=9?'0':'')+v;
                    profile.boxing()._setCtrlValue(profile.$hour+":"+profile.$minute);
                    if(profile.box)profile.box._hourC(profile);
                }
            },
            NEXT:{
                onClick:function(profile, e, src){
                    var p = profile.properties;
                    if(p.disabled||p.readonly)return;
                    var v=profile.$minute;
                    v=(parseFloat(v)||0)+1;
                    v=(v%60+60)%60;
                    profile.$minute=v=(v<=9?'0':'')+v;
                    profile.boxing()._setCtrlValue(profile.$hour+":"+profile.$minute);
                    if(profile.box)profile.box._hourC(profile);
                }
            },
            PRE2:{
                onClick:function(profile, e, src){
                    var p = profile.properties;
                    if(p.disabled||p.readonly)return;
                    var v=profile.$hour;
                    v=(parseFloat(v)||0)-1;
                    v=(v%24+24)%24;
                    profile.$hour=v=(v<=9?'0':'')+v;
                    profile.boxing()._setCtrlValue(profile.$hour+":"+profile.$minute);
                    if(profile.box)profile.box._hourC(profile);
                }
            },
            NEXT2:{
                onClick:function(profile, e, src){
                    var p = profile.properties;
                    if(p.disabled||p.readonly)return;
                    var v=profile.$hour;
                    v=(parseFloat(v)||0)+1;
                    v=(v%24+24)%24;
                    profile.$hour=v=(v<=9?'0':'')+v;
                    profile.boxing()._setCtrlValue(profile.$hour+":"+profile.$minute);
                    if(profile.box)profile.box._hourC(profile);
                }
            },
            CLOSE:{
                onClick:function(profile, e, src){
                    var properties = profile.properties,
                        instance = profile.boxing();
                    if(properties.disabled||properties.readonly)return;
                    if(false===instance.beforeClose(profile, src)) return;
                    instance.destroy(true);
                }
            }
        },
        DataModel:{
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            expression:{
                ini:'',
                action:function () {
                }
            },
            height:{
                ini:'auto',
                readonly:true
            },
            width:{
                ini:'auto',
                readonly:true
            },
            value:{
                ini:'00:00',
                format:'time'
            },
            closeBtn:{
                ini:true,
                action:function(v){
                    this.getSubNode('CLOSE').css('display',v?'':'none');
                }
            }
        },
        EventHandlers:{
            beforeClose:function(profile, src){}
        },
        _hourC:function(profile){
            var pro=profile.properties,
                v=pro.$UIvalue,
                a=v.split(':'),
                d = (a[0]+"")==(profile.$hour+"") && (a[1]+"")==(profile.$minute+"");
            profile.getSubNode('SET').css('display',d?'none':'block');
            profile.getSubNode('CAPTION').css('color',d?'':'var(--ood-error)');
        },
        _prepareData:function(profile){
            var data=arguments.callee.upper.call(this, profile);
            var nodisplay='display:none';
            data.closeDisplay = data.closeBtn?'':nodisplay;
            data._set = ood.wrapRes('inline.set');
            return data;
        },
        
        RenderTrigger: function() {
            // 
            var self = this;
            ood.asyRun(function(){
                self.TimePickerTrigger();
            });
        },
        
        TimePickerTrigger: function() {
            var profile = this.get(0);
            var prop = profile.properties;
            var boxing = this;

            // 
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('timepicker-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                boxing.adjustLayout();
            }

            // 
            boxing.enhanceAccessibility();
        },
        _ensureValue:function(profile, value){
            var a,b=[];
            if(value&& typeof value == 'string')
                a=value.split(':')
            else if(value && typeof value=='object' && ood.isArr(value))
                a=value;
            else a=[];

            b[0]= parseFloat(a[0])||0;
            b[1]=parseFloat(a[1])||0;
            if(b[0]<0)b[0]=0;
            if(b[0]>23)b[0]=23;
            if(b[1]<0)b[1]=0;
            if(b[1]>59)b[1]=59;

            b[0]=(b[0]<=9?'0':'')+b[0];
            b[1]=(b[1]<=9?'0':'')+b[1];

            return b.join(':');
        },
        formatValue:function(value){
            return value.join(':');
        },
        _v2a:function(v){
            return typeof v == 'string'? v.split(':') : v;
        },
        _showV:function(profile, a){
            var f=profile.CF;
            if(typeof f.formatCaption == 'function')
                return f.formatCaption(a);
            else
                return a.join(':');
        },
        _onresize:function(){}
    }
});ood.Class("ood.UI.List", ["ood.UI", "ood.absList", "ood.absValue"], {
    Instance: {
        //  iniProp 
        iniProp: {
            items: [{id: 'a', caption: 'item 1', imageClass: 'ri-number-1'}, {
                id: 'b',
                caption: 'item 2',
                imageClass: 'ri-number-2'
            }, {id: 'c', caption: 'item 3', imageClass: 'ri-number-3'}, {
                id: 'd',
                caption: 'item 4',
                imageClass: 'ri-number-4',
                disabled: true
            }],
            theme: 'light',
            responsive: true,
            selMode: 'single',
            borderType: 'flat',
            noCtrlKey: true,
            width: 320,
            height: '15em',
            maxHeight: 420,
            itemRow: '',
            optBtn: "",
            tagCmds: [],
            tagCmdsAlign: "right",
            labelSize: '4em',
            labelPos: "left",
            labelGap: 4,
            labelCaption: '$RAD.widgets.optionList',
            labelHAlign: 'right',
            labelVAlign: 'top',
            value: 'a'
        },

        //  ()
        setTheme: function(theme) {
            return this.each(function(profile) {
                var p = profile.properties;
                p.theme = theme;
                var root = profile.getRoot(),
                    items = profile.getSubNode('ITEMS'),
                    itemNodes = profile.getSubNode('ITEM', true),
                    label = profile.getSubNode('LABEL');

                // 
                root.removeClass('list-dark list-hc');
                
                // 
                if (theme === 'dark') {
                    root.addClass('list-dark');
                } else if (theme === 'high-contrast') {
                    root.addClass('list-hc');
                }
                
                // CSS
                root.attr('data-theme', theme);
                
                // 
                localStorage.setItem('list-theme', theme);
            });
        },
        
        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('list-theme') || 'light';
        },


        // 
        ListTrigger: function () {
            var profile = this.get(0);
            var prop = profile.properties,
                boxing = this;

            // 
            if (prop.theme) {
                this.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('list-theme');
                if (savedTheme) {
                    this.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                this.adjustLayout();
                // 
                // OOD
            }

            // 
            this.enhanceAccessibility();
        },
        
        // 
        toggleTheme: function() {
            const themes = ['light', 'dark', 'high-contrast'];
            const currentTheme = this.getTheme();
            const nextIndex = (themes.indexOf(currentTheme) + 1) % themes.length;
            this.setTheme(themes[nextIndex]);
            return this;
        },
        
        // 
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    items = profile.getSubNode('ITEMS'),
                    itemNodes = profile.getSubNode('ITEM', true),
                    label = profile.getSubNode('LABEL'),
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('list-mobile');
                    
                    // 
                    itemNodes.css({
                        'padding': '0.6em',
                        'font-size': '0.9em',
                        'min-height': '2.8em'
                    });
                    
                    // 
                    if (label && prop.labelPos && prop.labelPos !== 'none') {
                        if (prop.labelPos === 'left' || prop.labelPos === 'right') {
                            // 
                            label.css({
                                'font-size': '0.85em',
                                'margin-bottom': '0.3em'
                            });
                        }
                    }
                } else {
                    root.removeClass('list-mobile');
                    
                    // 
                    itemNodes.css({
                        'padding': '',
                        'font-size': '',
                        'min-height': ''
                    });
                    
                    if (label) {
                        label.css({
                            'font-size': '',
                            'margin-bottom': ''
                        });
                    }
                }

                // 
                if (width < 480) {
                    root.addClass('list-tiny');
                    
                    // 
                    var extraNodes = profile.getSubNode('EXTRA', true);
                    extraNodes.css('display', 'none');
                    
                    // 
                    var iconNodes = profile.getSubNode('ICON', true);
                    iconNodes.css({
                        'width': '1.2em',
                        'height': '1.2em'
                    });
                } else {
                    root.removeClass('list-tiny');
                    
                    // 
                    var extraNodes = profile.getSubNode('EXTRA', true);
                    extraNodes.css('display', '');
                    
                    // 
                    var iconNodes = profile.getSubNode('ICON', true);
                    iconNodes.css({
                        'width': '',
                        'height': ''
                    });
                }
            });
        },
        
        //  ()
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    items = profile.getSubNode('ITEMS'),
                    itemNodes = profile.getSubNode('ITEM', true),
                    label = profile.getSubNode('LABEL'),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'application',
                    'aria-orientation': properties.vertical ? 'vertical' : 'horizontal'
                });
                
                items.attr({
                    'role': 'listbox',
                    'aria-label': properties.caption || '',
                    'aria-multiselectable': (properties.selMode === 'multi' || properties.selMode === 'multibycheckbox') ? 'true' : 'false'
                });
                
                // ARIA
                if (label && properties.labelCaption) {
                    label.attr({
                        'id': 'list-label-' + profile.$xid,
                        'role': 'label',
                        'aria-hidden': properties.labelPos === 'none' ? 'true' : 'false'
                    });
                    items.attr('aria-labelledby', 'list-label-' + profile.$xid);
                }
                
                // ARIA
                itemNodes.each(function(item) {
                    var itemNode = ood(item);
                    var itemId = itemNode.id();
                    if (itemId) {
                        var itemData = profile.getItemByDom(item);
                        var isSelected = itemNode.hasClass('ood-ui-item-checked');
                        var selMode = properties.selMode;
                        
                        itemNode.attr({
                            'role': selMode === 'single' ? 'option' : 'checkbox',
                            'aria-label': ': ' + (itemData ? itemData.caption : itemId),
                            'aria-selected': isSelected ? 'true' : 'false',
                            'aria-disabled': itemData.disabled ? 'true' : 'false',
                            'tabindex': isSelected && selMode === 'single' ? '0' : '-1'
                        });
                        
                        // 
                        itemNode.on('keydown', function(e) {
                            if (e.key === 'Enter' || e.key === ' ') {
                                itemNode.fireEvent('click');
                                e.preventDefault();
                            }
                        });
                    }
                });
            });
        },
        _setCtrlValue: function (value) {
            return this.each(function (profile) {
                if (!profile.renderId) return;

                var box = profile.box,
                    uiv = profile.boxing().getUIValue(),
                    p = profile.properties,
                    item = box._ITEMKEY || 'ITEM',
                    k = box._DIRTYKEY || 'ITEM',
                    mk = 'MARK',
                    getN = function (k, i) {
                        return profile.getSubNode(k, i)
                    },
                    getI = function (i) {
                        return profile.getSubIdByItemId(i)
                    };
                if (p.selMode == 'single') {
                    var itemId = getI(uiv);
                    if (uiv !== null && itemId) {
                        getN(item, itemId).tagClass('-checked', false).tagClass('-hover', false);
                        getN(mk, itemId).tagClass('-checked', false);
                    }

                    itemId = getI(value);
                    if (itemId) {
                        getN(item, itemId).tagClass('-checked');
                        getN(mk, itemId).tagClass('-checked');
                    }

                    //scroll
                    try {
                        if (itemId) {
                            var o = getN(item, itemId);
                            if (o) {
                                var items = profile.getSubNode('ITEMS'),
                                    offset = o.offset(null, items),
                                    top = offset ? offset.top : 0,
                                    height = o.offsetHeight(),
                                    sh = items.scrollHeight(),
                                    st = items.scrollTop(),
                                    hh = items.height();
                                if (sh > hh)
                                    if (top < st || (top + height) > (st + hh))
                                        items.scrollTop(top);
                            }
                        }
                    } catch (e) {
                        console.warn(e);
                    }

                } else if (p.selMode == 'multi' || p.selMode == 'multibycheckbox') {
                    uiv = uiv ? uiv.split(p.valueSeparator) : [];
                    value = value ? value.split(p.valueSeparator) : [];
                    //check all
                    ood.arr.each(uiv, function (o) {
                        getN(item, getI(o)).tagClass('-checked', false).tagClass('-hover', false);
                        getN(mk, getI(o)).tagClass('-checked', false);
                    });
                    ood.arr.each(value, function (o) {
                        getN(item, getI(o)).tagClass('-checked');
                        getN(mk, getI(o)).tagClass('-checked');
                    });
                }
            });
        },
        _clearMouseOver: function () {
            var box = this.constructor,
                item = box._ITEMKEY || 'ITEM';
            this.getSubNode(item, true).tagClass('-hover', false);
        },
        adjustSize: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    items = profile.getSubNode('ITEMS'),
                    pp = profile.properties,
                    mh = pp.maxHeight,
                    h_em = profile.$isEm(pp.height),
                    h, flag;

                if (profile.$isEm(mh)) mh = profile.$em2px(mh, items, true);

                if (root.css('display') == 'none') {
                    flag = 1;
                    root.css('visibility', 'hidden');
                }
                items.height('auto');
                if (profile.properties.height != 'auto') {
                    h = Math.min(mh, items.offsetHeight());
                    if (h_em) h = profile.$px2em(h, items) + 'em';
                    items.height(pp.height = h);
                } else {
                    h = items.offsetHeight();
                    if (h > mh) {
                        items.height(pp.maxHeight);
                        profile.getRoot().height(pp.maxHeight);
                    }
                }
                if (flag) {
                    root.css('visibility', '');
                    root.css('display', 'none');
                }
                profile.getRoot().height('auto');
            });
        },
        activate: function () {
            return ood.absList.prototype.activate.call(this);
        },

        setCaptionValue: function (value) {
            var upper = arguments.callee.upper,
                v = upper.apply(this, ood.toArr(arguments));
            upper = null;

        },

        getCaptionValue: function () {
            var upper = arguments.callee.upper,
                v = upper.apply(this, ood.toArr(arguments));
            upper = null;
            return v;
        },

        getSelectedItem: function () {
            var upper = arguments.callee.upper,
                v = upper.apply(this, ood.toArr(arguments));
            upper = null;
            return v;
        },

        getShowValue: function (value) {
            var profile = this.get(0),
                pro = profile.properties, v, t;
            if (!ood.isDefined(value))
                value = pro.$UIvalue;
            if ((v = ood.arr.subIndexOf(pro.items, 'id', value)) != -1) {
                v = pro.items[v].caption;
                v = v.charAt(0) == '$' ? ood.getRes(v.slice(1)) : v;
            } else
                v = '';
            return v;
        },
        _setDirtyMark: function () {
            return arguments.callee.upper.apply(this, ['ITEMS']);
        }
    },
    Static: {
        _DIRTYKEY: 'ITEM',
        Templates: {
            tagName: 'div',
            style: '{_style}',
            className: '{_className}',
            LABEL: {
                className: '{_required} ood-ui-ellipsis',
                style: '{labelShow};width:{_labelSize};{_labelHAlign};{_labelVAlign};color:var(--ood-text-heading)',
                text: '{labelCaption}'
            },
            ITEMS: {
                $order: 10,
                tagName: 'div',
                className: 'ood-uibase {_cmdsalign} {_bordertype} {_itemscls1}',
                style: 'background-color:var(--ood-bg-card);border-radius:var(--ood-radius-md)',
                text: "{items}"
            },
            $submap: {
                items: {
                    ITEM: {
                        className: 'ood-uitembg ood-uiborder-radius ood-showfocus {_itemRow} {_split} {itemClass} {disabled} {readonly}',
                        style: '{itemStyle}{_itemDisplay};background-color:var(--ood-bg);color:var(--ood-text)',
                        tabindex: '{_tabindex}',
                        LTAGCMDS: {
                            $order: 2,
                            tagName: 'span',
                            style: '{_ltagDisplay}',
                            text: "{ltagCmds}"
                        },
                        MARK: {
                            $order: 5,
                            className: 'oodfont',
                            $fonticon: 'ood-uicmd-check',
                            style: "{_cbDisplay}"
                        },
                        ICON: {
                            $order: 10,
                            className: 'oodcon {imageClass}  {picClass}',
                            style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{imageDisplay}{iconStyle}',
                            text: '{iconFontCode}'
                        },
                        CAPTION: {
                            style: '{_capDisplay}',
                            text: '{caption}',
                            $order: 20
                        },
                        EXTRA: {
                            style: '{_extraDisplay}',
                            text: '{ext}',
                            $order: 30
                        },
                        RTAGCMDS: {
                            $order: 40,
                            tagName: 'span',
                            style: '{_rtagDisplay}',
                            text: "{rtagCmds}"
                        },
                        OPT: {
                            $order: 50,
                            style: '{_optDisplay}',
                            className: 'oodfont',
                            $fonticon: '{_fi_optClass}'
                        }
                    }
                },

                'items.ltagCmds': function (profile, template, v, tag, result) {
                    var me = arguments.callee,
                        map = me._m || (me._m = {'text': '.text', 'button': '.button', 'image': '.image'});
                    ood.UI.$doTemplate(profile, template, v, "items.tagCmds" + (map[v.type] || '.button'), result)
                },
                'items.rtagCmds': function (profile, template, v, tag, result) {
                    var me = arguments.callee,
                        map = me._m || (me._m = {'text': '.text', 'button': '.button', 'image': '.image'});
                    ood.UI.$doTemplate(profile, template, v, "items.tagCmds" + (map[v.type] || '.button'), result)
                },
                'items.tagCmds.text': ood.UI.$getTagCmdsTpl('text'),
                'items.tagCmds.button': ood.UI.$getTagCmdsTpl('button'),
                'items.tagCmds.image': ood.UI.$getTagCmdsTpl('image')
            }
        },
        Appearances: {
            KEY: {},
            LABEL: {
                'z-index': 1,
                top: 0,
                left: 0,
                display: ood.browser.isWebKit ? '-webkit-flex' : 'flex',
                position: 'absolute',
                'padding-top': '.333em',
                'color': 'var(--ood-text-heading)'
            },
            EXTRA: {
                display: 'none',
                'color': 'var(--ood-text-muted)'
            },
            ITEMS: {
                position: 'relative',
                overflow: 'auto',
                'overflow-x': 'hidden',
                'background-color': 'var(--ood-bg-card)',
                'border-radius': 'var(--ood-radius-md)'
            },
            ITEM: {
                display: 'block',
                zoom: ood.browser.ie ? 1 : null,
                cursor: 'pointer',
                position: 'relative',
                'white-space': 'nowrap',
                'background-color': 'var(--ood-bg)',
                'color': 'var(--ood-text)',
                'transition': 'background-color var(--ood-transition-fast)'
            },
            MARK: {
                $order: 1,
                cursor: 'pointer',
                'vertical-align': 'middle'
            },
            CAPTION: {
                'vertical-align': ood.browser.ie6 ? 'baseline' : 'middle',
                padding: '.167em',
                'font-size': '1em',
                'white-space': 'normal',
                'color': 'var(--ood-text)'
            },
            OPT: {
                $order: 10,
                position: 'absolute',
                left: 'auto',
                top: '50%',
                'margin-top': '-0.5em',
                right: '.167em',
                display: 'none'
            },
            'LTAGCMDS, RTAGCMDS': {
                padding: 0,
                margin: 0,
                'vertical-align': 'middle'
            },
            'ITEMS-tagcmdleft RTAGCMDS': {
                "padding-right": '.333em',
                "float": "left"
            },
            'ITEMS-tagcmdfloatright RTAGCMDS': {
                "padding-right": '.333em',
                "float": "right"
            }
        },
        Behaviors: {
            HoverEffected: {ITEM: 'ITEM', OPT: 'OPT', CMD: 'CMD', ICON: 'ICON'},
            ClickEffected: {ITEM: 'ITEM', OPT: 'OPT', CMD: 'CMD'},
            DraggableKeys: ["ITEM"],
            DroppableKeys: ["ITEM", "ITEMS"],
            ITEM: {
                onDblclick: function (profile, e, src) {
                    var properties = profile.properties,
                        item = profile.getItemByDom(src);
                    profile.boxing().onDblclick(profile, item, e, src);
                },
                onClick: function (profile, e, src) {
                    var properties = profile.properties,
                        item = profile.getItemByDom(src),
                        itemId = profile.getSubId(src),
                        box = profile.boxing(),
                        ks = ood.Event.getKey(e);

                    if (profile.beforeClick && false === box.beforeClick(profile, item, e, src)) return false;

                    if (properties.disabled || item.disabled || item.type == 'split') return false;

                    if (profile.onClick)
                        box.onClick(profile, item, e, src);

                    ood.use(src).focus(true);

                    switch (properties.selMode) {
                        case 'none':
                            box.onItemSelected(profile, item, e, src, 0);
                            break;
                        case 'multibycheckbox':
                            if (properties.readonly || item.readonly) return false;
                            var value = box.getUIValue(),
                                arr = value ? value.split(properties.valueSeparator) : [],
                                checktype = 1;
                            if (arr.length) {
                                if (ood.arr.indexOf(arr, item.id) != -1) {
                                    ood.arr.removeValue(arr, item.id);
                                    checktype = -1
                                } else {
                                    arr.push(item.id);
                                }
                                arr.sort();
                                value = arr.join(properties.valueSeparator);

                                //update string value only for setCtrlValue
                                if (box.getUIValue() !== value) {
                                    box.setUIValue(value, null, null, 'click');
                                    if (box.get(0) && box.getUIValue() == value)
                                        box.onItemSelected(profile, item, e, src, checktype);
                                }
                                break;
                            }
                        case 'multi':
                            if (properties.readonly || item.readonly) return false;
                            var value = box.getUIValue(),
                                arr = value ? value.split(properties.valueSeparator) : [],
                                checktype = 1;

                            if (arr.length && (ks.ctrlKey || ks.shiftKey || properties.noCtrlKey || properties.$checkbox)) {
                                //for select
                                if (ks.shiftKey) {
                                    var items = properties.items,
                                        i1 = ood.arr.subIndexOf(items, 'id', profile.$firstV.id),
                                        i2 = ood.arr.subIndexOf(items, 'id', item.id),
                                        i;
                                    arr.length = 0;
                                    for (i = Math.min(i1, i2); i <= Math.max(i1, i2); i++)
                                        arr.push(items[i].id);
                                } else {
                                    if (ood.arr.indexOf(arr, item.id) != -1) {
                                        ood.arr.removeValue(arr, item.id);
                                        checktype = -1
                                    } else
                                        arr.push(item.id);
                                }

                                arr.sort();
                                value = arr.join(properties.valueSeparator);

                                //update string value only for setCtrlValue
                                if (box.getUIValue() !== value) {
                                    box.setUIValue(value, null, null, 'click');
                                    if (box.get(0) && box.getUIValue() == value)
                                        box.onItemSelected(profile, item, e, src, checktype);
                                }
                                break;
                            }
                        case 'single':
                            if (properties.readonly || item.readonly) return false;
                            if (box.getUIValue() !== item.id) {
                                profile.$firstV = item;
                                box.setUIValue(item.id, null, null, 'click');
                                if (box.get(0) && box.getUIValue() == item.id)
                                    box.onItemSelected(profile, item, e, src, 1);
                            }

                            break;
                    }
                    if (profile.afterClick) box.afterClick(profile, item, e, src);
                },
                onKeydown: function (profile, e, src) {
                    var keys = ood.Event.getKey(e), key = keys[0], shift = keys[2],
                        cur = ood(src),
                        first = profile.getRoot().nextFocus(true, true, false),
                        last = profile.getRoot().nextFocus(false, true, false);

                    switch (ood.Event.getKey(e)[0]) {
                        case 'tab':
                            if (shift) {
                                if (cur.get(0) != first.get(0)) {
                                    first.focus(true);
                                    return false;
                                }
                            } else {
                                if (cur.get(0) != last.get(0)) {
                                    last.focus(true);
                                    return false;
                                }
                            }
                            break;
                        case 'left':
                        case 'up':
                            var next = cur.nextFocus(false, true, false);
                            if (cur.get(0) == first.get(0))
                                last.focus(true);
                            else
                                cur.nextFocus(false);
                            return false;
                            break;
                        case 'right':
                        case 'down':
                            var next = cur.nextFocus(true, false, false);
                            if (cur.get(0) == last.get(0))
                                first.focus(true);
                            else
                                cur.nextFocus();
                            return false;
                            break;
                        case 'enter':
                            cur.onClick(true);
                            break;
                    }
                },
                onContextmenu: function (profile, e, src) {
                    if (profile.onContextmenu)
                        return profile.boxing().onContextmenu(profile, e, src, profile.getItemByDom(src),ood.Event.getPos(e)) !== false;
                },
                onMouseover: function (profile, e, src) {
                    if (ood.browser.fakeTouch || ood.browser.deviceType == 'touchOnly') return;
                    var item = profile.getItemByDom(src);
                    if (!item) return;
                    if (!profile.properties.optBtn && !item.optBtn) return;
                    profile.getSubNode('OPT', profile.getSubId(src)).setInlineBlock();
                },
                onMouseout: function (profile, e, src) {
                    if (ood.browser.fakeTouch || ood.browser.deviceType == 'touchOnly') return;
                    var item = profile.getItemByDom(src);
                    if (!item) return;
                    if (!profile.properties.optBtn && !item.optBtn) return;
                    profile.getSubNode('OPT', profile.getSubId(src)).css('display', 'none');
                }
            },
            OPT: {
                onClick: function (profile, e, src) {
                    if (profile.onShowOptions) {
                        var item = profile.getItemByDom(src);
                        if (!item) return;
                        if (!profile.properties.optBtn && !item.optBtn) return;
                        profile.boxing().onShowOptions(profile, item, e, src);
                    }
                    return false;
                },
                onDblclick: function (profile, e, src) {
                    return false;
                }
            },
            CMD: {
                onClick: function (profile, e, src) {
                    var prop = profile.properties,
                        item = profile.getItemByDom(ood.use(src).parent().get(0));
                    if (!item) return false;

                    if (prop.disabled || item.disabled || item.type == 'split') return false;
                    if (profile.onCmd)
                        profile.boxing().onCmd(profile, item, ood.use(src).id().split('_')[1], e, src);
                    return false;
                }
            },
            LABEL: {
                onClick: function (profile, e, src) {
                    if (profile.properties.disabled) return false;
                    if (profile.onLabelClick)
                        profile.boxing().onLabelClick(profile, e, src);
                },
                onDblClick: function (profile, e, src) {
                    if (profile.properties.disabled) return false;
                    if (profile.onLabelDblClick)
                        profile.boxing().onLabelDblClick(profile, e, src);
                },
                onMousedown: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != 'left') return;
                    if (profile.properties.disabled) return false;
                    if (profile.onLabelActive)
                        profile.boxing().onLabelActive(profile, e, src);
                }
            }
        },
        DataModel: {
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark', 'high-contrast'],
                action: function(value) {
                    this.boxing().setTheme(value);
                },
                caption: ood.getResText("DataModel.theme") || ""
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                },
                caption: ood.getResText("DataModel.responsive") || ""
            },
            
            expression: {
                ini: '',
                action: function () {
                },
                caption: ood.getResText("DataModel.expression") || ""
            },
            selMode: {
                ini: 'single',
                listbox: ['single', 'none', 'multi', 'multibycheckbox'],
                action: function (value) {
                    if (!this.box._ITEMMARKED)
                        this.getSubNode('MARK', true).css('display', (value == 'multi' || value == 'multibycheckbox') ? '' : 'none');
                },
                caption: ood.getResText("DataModel.selectionMode") || ""
            },
            borderType: {
                ini: 'flat',
                listbox: ['none', 'flat', 'inset', 'outset'],
                action: function (v) {
                    var ns = this,
                        p = ns.properties,
                        node = ns.getSubNode('ITEMS'),
                        reg = /^ood-uiborder-/, 
                        pretag = 'ood-uiborder-',
                        root = ns.getRoot();
                    node.removeClass(reg);
                    node.addClass(pretag + v);

                    //force to resize
                    ns.adjustSize();
                },
                caption: ood.getResText("DataModel.borderType") || ""
            },

            noCtrlKey: {
                ini: true,
                caption: ood.getResText("DataModel.noCtrlKey") || "Ctrl"
            },
            width: {
                $spaceunit: 1,
                ini: 'auto',
                caption: ood.getResText("DataModel.width") || ""
            },
            height: {
                $spaceunit: 1,
                ini: '15em',
                caption: ood.getResText("DataModel.height") || ""
            },
            maxHeight: {
                ini: 420,
                caption: ood.getResText("DataModel.maxHeight") || ""
            },
            itemRow: {
                ini: '',
                combobox: ["row", "cell"],
                action: function (v) {
                    var ns = this.getSubNode('ITEM', true);
                    ns.removeClass(/ood-item-[\w]+/);
                    if (v) ns.addClass('ood-item-' + (v || 'row'));
                },
                caption: ood.getResText("DataModel.itemRowType") || ""
            },
            optBtn: {
                ini: "",
                combobox: ood.toArr("ood-uicmd-opt,ood-icon-singleright"),
                action: function () {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.optionButton") || ""
            },
            tagCmds: {
                ini: [],
                action: function () {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.labelCommand") || ""
            },
            tagCmdsAlign: {
                ini: "right",
                listbox: ['left', 'right', 'floatright'],
                action: function (v) {
                    var profile = this, box = profile.getSubNode("ITEMS"), cls = profile.getClass('ITEMS', '-tagcmd');
                    box.removeClass(new RegExp(cls + '[\w]*')).addClass(profile.getClass('ITEMS', '-tagcmd' + v));
                },
                caption: ood.getResText("DataModel.labelCommandAlign") || ""
            },
            // label
            labelSize: {
                $spaceunit: 2,
                ini: 0,
                action: function (v) {
                    this.getSubNode('LABEL').css({display: v ? '' : 'none'});
                    ood.UI.$doResize(this, this.properties.width, this.properties.height, true);
                },
                caption: ood.getResText("DataModel.labelSize") || ""
            },
            labelPos: {
                ini: "left",
                listbox: ['none', 'left', 'top', 'right', 'bottom'],
                action: function (v) {
                    ood.UI.$doResize(this, this.properties.width, this.properties.height, true);
                },
                caption: ood.getResText("DataModel.labelPosition") || ""
            },

            labelGap: {
                $spaceunit: 2,
                ini: 4,
                action: function (v) {
                    ood.UI.$doResize(this, this.properties.width, this.properties.height, true);
                },
                caption: ood.getResText("DataModel.labelGap") || ""
            },
            labelCaption: {
                ini: "",
                action: function (v) {
                    v = (ood.isSet(v) ? v : "") + "";
                    this.getSubNode('LABEL').html(ood.adjustRes(v, true));
                },
                caption: ood.getResText("DataModel.labelCaption") || ""
            },
            labelHAlign: {
                ini: 'right',
                listbox: ['', 'left', 'center', 'right'],
                action: function (v) {
                    this.getSubNode('LABEL').css({
                        'textAlign': v || '',
                        'justifyContent': v == 'right' ? 'flex-end' : v == 'center' ? 'center' : v == 'left' ? 'flex-start' : ''
                    });
                },
                caption: ood.getResText("DataModel.labelHAlign") || ""
            },
            labelVAlign: {
                ini: 'top',
                listbox: ['', 'top', 'middle', 'bottom'],
                action: function (v) {
                    this.getSubNode('LABEL').css('align-items', v == 'bottom' ? 'flex-end' : v == 'middle' ? 'center' : v == 'top' ? 'flex-start' : '');
                },
                caption: ood.getResText("DataModel.labelVAlign") || ""
            }
        },
        EventHandlers: {
            onClick: function (profile, item, e, src) {
            },
            onCmd: function (profile, item, cmdkey, e, src) {
            },
            beforeClick: function (profile, item, e, src) {
            },
            afterClick: function (profile, item, e, src) {
            },
            onDblclick: function (profile, item, e, src) {
            },
            onShowOptions: function (profile, item, e, src) {
            },
            onItemSelected: function (profile, item, e, src, type) {
            },

            onLabelClick: function (profile, e, src) {
            },
            onLabelDblClick: function (profile, e, src) {
            },
            onLabelActive: function (profile, e, src) {
            }
        },
        _onStartDrag: function (profile, e, src, pos) {
            var pos = ood.Event.getPos(e);
            ood.use(src).startDrag(e, {
                dragSource: profile.$xid,
                dragType: 'icon',
                shadowFrom: src,
                targetLeft: pos.left + 12,
                targetTop: pos.top + 12,
                dragCursor: 'pointer',
                dragDefer: 2,
                dragKey: profile.box.getDragKey(profile, src),
                dragData: profile.box.getDragData(profile, e, src)
            });
            return false;
        },
        _onDropTest: function (profile, e, src, key, data, item) {
            var fid = data && data.domId, tid = ood.use(src).id();
            if (fid) {
                if (fid == tid) return false;
                if (ood.get(ood.use(src).get(0), ['previousSibling', 'id']) == fid) return false;
            }
        },
        _onDrop: function (profile, e, src, key, data, item) {
            var k = profile.getKey(ood.use(src).id()),
                po = data.profile,
                ps = data.domId,
                oitem,
                t = ood.absObj.$specialChars,
                uiv = profile.properties.$UIvalue;
            //remove
            oitem = ood.clone(po.getItemByDom(ps), function (o, i) {
                return !t[(i + '').charAt(0)]
            });
            po.boxing().removeItems([oitem.id]);

            if (k == profile.keys.ITEM)
                profile.boxing().insertItems([oitem], item.id, true);
            else
                profile.boxing().insertItems([oitem]);

            if (oitem.id == uiv)
                profile.boxing().setUIValue(oitem.id, true, null, 'drop');

            data._new = oitem;
            return false;
        },
        _prepareData: function (profile) {
            var p = profile.properties, d = arguments.callee.upper.call(this, profile), t, v;
            d._bordertype = 'ood-uiborder-' + d.borderType;
            d._labelHAlign = 'text-align:' + (v = d.labelHAlign || '') + ';justify-content:' + (v == 'right' ? 'flex-end' : v == 'center' ? 'center' : v == 'left' ? 'flex-start' : '');
            d._labelVAlign = 'align-items:' + ((v = d.labelVAlign) == 'bottom' ? 'flex-end' : v == 'middle' ? 'center' : v == 'top' ? 'flex-start' : '');
            d.labelShow = d.labelPos != 'none' && d.labelSize && d.labelSize != 'auto' ? "" : "display:none";
            d._labelSize = d.labelSize ? '' : 0 + profile.$picku();
            // adjustRes for labelCaption
            if (d.labelCaption)
                d.labelCaption = ood.adjustRes(d.labelCaption, true);
            d._cmdsalign = profile.getClass('ITEMS', '-tagcmd' + profile.properties.tagCmdsAlign);


            ood.arr.each(d.items, function (item) {
                var index = item.index;
                if (!index) {
                    index = ood.arr.indexOf(d.items, item);
                }
                profile.boxing()._autoColor(item, index, p);
            })


            return d;
        },
        _prepareItem: function (profile, item, oitem, pid, index, len) {
            var p = profile.properties, m = p.selMode, t;
            item._cbDisplay = (m == 'multi' || m == 'multibycheckbox') ? '' : 'display:none;';
            item._itemRow = (t = profile.properties.itemRow) ? ('ood-item-' + t) : '';

            profile.boxing()._autoColor(item, index, p);

            if (ood.browser.fakeTouch || ood.browser.deviceType !== 'mouseOnly') {
                item._optDisplay = p.optBtn ? 'display:block;' : '';
            }

            item._fi_optClass = p.optBtn;

            if (item.type == 'split') {
                item._split = 'ood-uitem-split';
                item._ltagDisplay = item._rtagDisplay = item.imageDisplay = item._cbDisplay = item._capDisplay = item._extraDisplay = item._optDisplay = 'display:none;';
            }
            this._prepareCmds(profile, item);
        },
        RenderTrigger: function () {
            if (this.key != "ood.UI.List") return;

            var p = this.properties;
            ood.UI.$doResize(this, p.width, p.height);
            
            // 
            var self = this;
            ood.asyRun(function(){
                self.boxing().ListTrigger();
            });
        },
        _onresize: function (profile, width, height) {
            var prop = profile.properties,
                // compare with px
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                root = profile.getRoot(),
                cb = ood.browser.contentBox,

                f = function (k) {
                    return profile.getSubNode(k)
                },
                items = f('ITEMS'),
                label = f('LABEL'),

                fzrate = profile.getEmSize() / root._getEmSize(),
                itemsfz = items._getEmSize(fzrate),
                labelfz = label._getEmSize(fzrate),

                border = !cb ? 0 : prop.borderType != 'none' ? items._borderW() : 0,
                dock = prop.dock,
                max = prop.maxHeight,

                labelPos = prop.labelPos,
                labelSize = (labelPos == 'none' || !labelPos) ? 0 : profile.$px(prop.labelSize, labelfz) || 0,
                labelGap = (labelPos == 'none' || !labelPos) ? 0 : profile.$px(prop.labelGap) || 0,
                ll, tt, ww, hh;

            // caculate by px
            if (width && width != 'auto') width = profile.$px(width);
            if (height && height != 'auto') height = profile.$px(height);

            items.cssRegion({
                left: adjustunit(ll = labelPos == 'left' ? labelSize : 0, itemsfz),
                top: adjustunit(tt = labelPos == 'top' ? labelSize : 0, itemsfz),
                width: adjustunit(ww = width === null ? null : width == 'auto' ? width : Math.max(0, (width - (!cb ? 0 : items._paddingW('both')) - ((labelPos == 'left' || labelPos == 'right') ? labelSize : 0) - border)), itemsfz),
                height: adjustunit(hh = height === null ? null : height == 'auto' ? height : Math.max(0, (height - (!cb ? 0 : items._paddingH('both')) - ((labelPos == 'top' || labelPos == 'bottom') ? labelSize : 0) - border)), itemsfz)
            });


            if (height == "auto") {
                if (dock != "fill" && dock != "cover" && dock != "height" && dock != "left" && dock != "right") {
                    if (items.height() > max) {
                        items.height(adjustunit(max, itemsfz));
                        root.height('auto');
                    }
                }
            }
            if (labelSize) {
                if (width == 'auto') ww = items.offsetWidth();
                if (height == 'auto') hh = items.offsetHeight();
                label.cssRegion({
                    left: adjustunit(width === null ? null : Math.max(0, labelPos == 'right' ? ((width == 'auto' ? ww : (width - labelSize)) + labelGap) : 0), labelfz),
                    top: adjustunit(height === null ? null : Math.max(0, labelPos == 'bottom' ? ((height == 'auto' ? hh : (height - labelSize)) + labelGap) : 0), labelfz),
                    width: adjustunit(width === null ? null : Math.max(0, ((labelPos == 'left' || labelPos == 'right') ? (labelSize - labelGap) : (width == 'auto' ? ww : width))), labelfz),
                    height: adjustunit(height === null ? null : Math.max(0, ((labelPos == 'top' || labelPos == 'bottom') ? (labelSize - labelGap) : (height == 'auto' ? hh : height))), labelfz)
                });
            }
        }
    }
});ood.Class("ood.UI.Gallery", "ood.UI.List", {
    Instance: {
        //  iniProp 
        iniProp: {
            items: [
                {id: 'item1', caption: '1', imageClass: 'ri ri-image-line', desc: ''},
                {id: 'item2', caption: '2', imageClass: 'ri ri-image-2-line', desc: ''},
                {id: 'item3', caption: '3', imageClass: 'ri ri-image-add-line', desc: ''},
                {id: 'item4', caption: '4', imageClass: 'ri ri-gallery-line', desc: ''}
            ],
            value: 'item1',
            width: '32em',
            height: '20em'
        },

        getStatus: function (id) {
            var item = this.get(0).getItemByItemId(id);
            return (item && item._status) || 'ini';
        },
        _afterInsertItems: function (profile) {
            profile.getSubNodes("IMAGE", true).each(function (o) {
                if (o.src == ood.ini.img_bg) {
                    // bug fix for firefox
                    if (ood.browser.isFF) o.src = '';
                    o.src = o.title;
                    o.title = '';
                }
            });
        },

        updateItemData: function (profile, item) {
            this.get(0).box._prepareItem(this.get(0), item);
            this.get(0).boxing().refresh();
        },

        // 
        setTheme: function (theme) {
            return this.each(function (profile) {
                var p = profile.properties;
                p.theme = theme;

                var root = profile.getRoot();
                // 
                root.removeClass('gallery-light gallery-dark gallery-highcontrast');
                // 
                root.addClass('gallery-' + theme);

                // data-themeCSS
                root.attr('data-theme', theme);

                // 
                localStorage.setItem('gallery-theme', theme);
            });
        },

        // 
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('gallery-theme') || 'light';
        },

        GalleryTrigger: function () {
            var profile = this.get(0);
            var prop = profile.properties

            // 
            // 
            if (prop.theme) {
                this.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('gallery-theme');
                if (savedTheme) {
                    this.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                this.adjustLayout();
            }

            // 
            this.enhanceAccessibility();
        },

        // 
        toggleDarkMode: function () {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },

        // 
        adjustLayout: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    items = profile.getSubNode('ITEM', true),
                    captions = profile.getSubNode('CAPTION', true),
                    comments = profile.getSubNode('COMMENT', true),
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('gallery-mobile');
                } else {
                    root.removeClass('gallery-mobile');
                }

                // 
                if (width < 480) {
                    root.addClass('gallery-tiny');

                    // 
                    if (prop.autoColumns) {
                        var newCols = Math.max(2, Math.floor(width / 120)); // 2
                        if (newCols !== prop.columns) {
                            profile.boxing().updateItem('columns', newCols);
                        }
                    }
                } else {
                    root.removeClass('gallery-tiny');
                }
            });
        },

        // 
        enhanceAccessibility: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    items = profile.getSubNode('ITEM', true),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'grid',
                    'aria-label': properties.caption || ''
                });

                // ARIA
                items.each(function (item, index) {
                    var itemNode = ood(item);
                    var itemId = itemNode.id();
                    if (itemId) {
                        var itemData = profile.getItemByDom(item);
                        if (itemData) {
                            itemNode.attr({
                                'role': 'gridcell',
                                'aria-label': itemData.caption || itemData.comment || itemData.id,
                                'tabindex': index === 0 ? '0' : '-1', // 
                                'aria-describedby': itemData.comment ? itemId + '_comment' : null
                            });

                            // ID
                            if (itemData.comment) {
                                var commentNode = profile.getSubNodeByItemId('COMMENT', itemData.id);
                                if (commentNode && !commentNode.isEmpty()) {
                                    commentNode.attr('id', itemId + '_comment');
                                }
                            }
                        }
                    }
                });

                // ARIA
                var icons = profile.getSubNode('ICON', true);
                icons.each(function (icon) {
                    var iconNode = ood(icon);
                    iconNode.attr({
                        'aria-hidden': 'true' // 
                    });
                });
            });
        }

    },
    Initialize: function () {
        //modify default template fro shell


        var t = this.getTemplate();

        t.$submap = {
            items: {
                ITEM: {
                    tabindex: '{_tabindex}',
                    className: 'ood-uitembg ood-uiborder-radius ood-showfocus {itemClass} {disabled} {readonly}',
                    style: 'padding:{itemPadding};margin:{itemMargin};{_itemSize};{itemStyle}{_itemColor}',
                    ITEMFRAME: {
                        style: '{_inneritemSize};{_bgimg}; {_itemposition}',
                        COMMENT: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            text: '{comment}',
                            style: '{commentDisplay};{_fontColor}',
                            $order: 2
                        },
                        CONTENT: {
                            tagName: 'div',
                            $order: 1,
                            className: '{contentClass}',
                            style: '{_loadbg}',
                            ICON: {
                                className: 'oodfont {_imageClass}',
                                style: "{_fontSize};{_iconColor};{_icon};{_position};}",
                                text: '{iconFontCode}'
                            },
                            IMAGE: {
                                tagName: 'img',
                                src: ood.ini.img_bg,
                                title: '{image}',
                                style: '{_innerimgSize};{imgStyle}'
                            }
                        },
                        CAPTION: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            style: '{capDisplay}',
                            text: '{caption}',
                            $order: 0
                        }

                    },
                    FLAG: {
                        $order: 20,
                        className: 'ood-display-none {flagClass}',
                        style: '{_flagStyle};{flagStyle}',
                        text: '{flagText}'
                    },
                    EXTRA: {
                        text: '{ext}',
                        $order: 30
                    }
                }
            }
        };
        this.setTemplate(t);

        // compitable
        ood.UI.IconList = ood.UI.Gallery;
        var key = "ood.UI.IconList";
        ood.absBox.$type[key.replace("ood.UI.", "")] = ood.absBox.$type[key] = key;
    },
    Static: {
        IMGNODE: 1,
        Appearances: {
            EXTRA: {
                display: 'none'
            },
            KEY: {
                overflow: 'visible'
            },
            ITEMS: {
                position: 'relative',
                overflow: 'auto',
                'overflow-x': 'hidden',
                zoom: ood.browser.ie6 ? 1 : null
            },
            'ITEMS-nowrap': {
                'white-space': 'nowrap'
            },
            ITEM: {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie67 ? 1 : null,
                position: 'relative',
                cursor: 'pointer',
                'vertical-align': 'top',
                margin: 'var(--ood-spacing-xs)',
                'background-color': 'var(--ood-bg-card)',
                'border-radius': 'var(--ood-radius-md)',
                'box-shadow': 'var(--ood-shadow-sm)',
                transition: 'all 0.2s ease'
            },
            'ITEM:hover': {
                'box-shadow': 'var(--ood-shadow-md)',
                'transform': 'translateY(-2px)'
            },
            ITEMFRAME: {
                display: ood.browser.ie67 ? ood.$inlineBlock : 'block',
                zoom: ood.browser.ie67 ? 1 : null,
                position: 'relative',
                overflow: 'hidden',
                border: 0,
                padding: 0,
                margin: 0,
//                width:'100%',
//                height:'100%',
                '-moz-box-flex': '1'
            },
            IBWRAP: {},
            IMAGE: {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie6 ? 1 : null,
                visibility: 'hidden',
                'vertical-align': 'middle'
            },
            CAPTION: {
                'text-align': 'center',
                overflow: 'hidden',
                'white-space': 'nowrap',
                'font-weight': 'bold',
                "font-size": "var(--ood-font-size-lg)",
                "margin-top": "var(--ood-spacing-md)",
                "height": "auto",
                "color": "var(--ood-text-heading)"
            },
            CONTENT: {
                'text-align': 'center',
                'white-space': 'nowrap',
                'background-repeat': 'no-repeat',
                'font-size': 'var(--ood-font-size-base)',
                'color': 'var(--ood-text-body)'
            },
            COMMENT: {
                display: 'block',
                margin: 'var(--ood-spacing-xs)',
                'text-align': 'center',
                'font-size': 'var(--ood-font-size-sm)',
                'color': 'var(--ood-text-muted)'
            },
            FLAG: {
                'width': "2em",
                "height": "2em",
                'right': "5em",
                'top': "1em",
                'font-size': "16px",
                'color': "var(--ood-warning)",
                'position': 'absolute',
                'z-index': 10
            }
        },
        Behaviors: {
            IMAGE: {
                onLoad: function (profile, e, src) {
                    var img = ood.use(src).get(0), path = img.src;
                    if (path != ood.ini.img_bg) {
                        var p = profile.properties,
                            nn = ood.use(src),
                            node = nn.get(0),
                            item = profile.getItemByDom(src);
                        if (!item) return;
                        var icon = profile.getSubNodeByItemId('ICON', item.id);
                        if (item.autoImgSize || p.autoImgSize) {
                            nn.attr('width', '');
                            nn.attr('height', '');
                        } else {
                            nn.attr('width', item.imgWidth);
                            nn.attr('height', item.imgWidth);
                        }

                        icon.removeClass('ood-icon-loading');
                        // hide
                        if (!item.iconFontCode && !item.imageClass && !item.icon) {
                            icon.addClass("ood-display-none");
                        }
                        nn.onLoad(null).onError(null).$removeEventHandler('load').$removeEventHandler('error');

                        item._status = 'loaded';
                        // don't show img_blank
                        if (ood.ini.img_blank == path) {
                            node.style.visibility = "hidden";
                            node.style.display = "none";
                        } else {
                            node.style.visibility = "visible";
                            node.style.display = "";
                        }
                    }
                },
                onError: function (profile, e, src) {
                    var item = profile.getItemByDom(src);
                    if (item._status == 'error') return;

                    var p = profile.properties,
                        nn = ood.use(src),
                        node = nn.get(0),
                        icon = profile.getSubNodeByItemId('ICON', item.id);

                    icon.removeClass('ood-icon-loading ood-display-none').addClass('ood-load-error');
                    nn.onLoad(null).onError(null).$removeEventHandler('load').$removeEventHandler('error');
                    node.style.visibility = "hidden";
                    node.style.display = "none";
                    item._status = 'error';
                }
            },
            ITEMS: {
                swipeleft: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swipeleft) {
                        box.swipeleft(profile, item, e, src);
                        return false;
                    }
                },
                swiperight: function (profile, item, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swiperight) {
                        box.swipeleft(profile, item, e, src);
                        return false;
                    }
                },
                // PC
                onKeyDown: function (profile, e, src) {
                    var keyCode = e.keyCode || e.which;
                    var items = profile.getSubNode('ITEM', true);
                    var currentFocus = document.activeElement;
                    var currentIndex = -1;

                    // 
                    items.each(function (item, index) {
                        if (item === currentFocus) {
                            currentIndex = index;
                            return false;
                        }
                    });

                    // 
                    switch (keyCode) {
                        case 37: // 
                            if (currentIndex > 0) {
                                items.get(currentIndex - 1).focus();
                            }
                            e.preventDefault();
                            break;
                        case 39: // 
                            if (currentIndex < items.length - 1) {
                                items.get(currentIndex + 1).focus();
                            }
                            e.preventDefault();
                            break;
                        case 13: // 
                        case 32: // 
                            if (currentFocus) {
                                // 
                                var clickEvent = new MouseEvent('click', {
                                    view: window,
                                    bubbles: true,
                                    cancelable: true
                                });
                                currentFocus.dispatchEvent(clickEvent);
                            }
                            e.preventDefault();
                            break;
                    }
                },
                // PC
                onMouseOver: function (profile, e, src) {
                    // 
                    var container = ood.use(src);
                    container.addClass('ood-items-hover');
                },
                onMouseOut: function (profile, e, src) {
                    // 
                    var container = ood.use(src);
                    container.removeClass('ood-items-hover');
                }
            },

            ITEM: {
                // PC
                onMouseOver: function (profile, e, src) {
                    var item = profile.getItemByDom(src);
                    var itemNode = ood.use(src);

                    // 
                    itemNode.addClass('ood-uitem-hover');

                    // 
                    if (profile.onItemHover) {
                        profile.boxing().onItemHover(profile, item, e, src);
                    }
                },

                onMouseOut: function (profile, e, src) {
                    var item = profile.getItemByDom(src);
                    var itemNode = ood.use(src);

                    // 
                    itemNode.removeClass('ood-uitem-hover');

                    // 
                    if (profile.onItemLeave) {
                        profile.boxing().onItemLeave(profile, item, e, src);
                    }
                },

                swipeleft: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swipeleft) {
                        box.swipeleft(profile, item, e, src);
                        return false;
                    }
                },

                swiperight: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swiperight) {
                        box.swiperight(profile, item, e, src);
                        return false;
                    }
                },
                swipedown: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swipedown) {
                        box.swipedown(profile, item, e, src);
                        return false;
                    }
                },
                swipeup: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swipeup) {
                        box.swipeup(profile, item, e, src);
                        return false;
                    }
                },

                // PC
                onKeyDown: function (profile, e, src) {
                    var keyCode = e.keyCode || e.which;
                    var item = profile.getItemByDom(src);

                    // 
                    if (keyCode === 13 || keyCode === 32) {
                        // 
                        var clickEvent = new MouseEvent('click', {
                            view: window,
                            bubbles: true,
                            cancelable: true
                        });
                        src.dispatchEvent(clickEvent);
                        e.preventDefault();
                    }

                    // 
                    switch (keyCode) {
                        case 37: // 
                        case 38: // 
                            // 
                            var items = profile.getSubNode('ITEM', true);
                            var currentIndex = -1;
                            items.each(function (item, index) {
                                if (item === src) {
                                    currentIndex = index;
                                    return false;
                                }
                            });

                            if (currentIndex > 0) {
                                items.get(currentIndex - 1).focus();
                            }
                            e.preventDefault();
                            break;

                        case 39: // 
                        case 40: // 
                            // 
                            var items = profile.getSubNode('ITEM', true);
                            var currentIndex = -1;
                            items.each(function (item, index) {
                                if (item === src) {
                                    currentIndex = index;
                                    return false;
                                }
                            });

                            if (currentIndex < items.length - 1) {
                                items.get(currentIndex + 1).focus();
                            }
                            e.preventDefault();
                            break;
                    }
                },

                // PC
                onFocus: function (profile, e, src) {
                    var item = profile.getItemByDom(src);
                    var itemNode = ood.use(src);

                    // 
                    itemNode.addClass('ood-uitem-focus');

                    // 
                    if (profile.onItemFocus) {
                        profile.boxing().onItemFocus(profile, item, e, src);
                    }
                },

                onBlur: function (profile, e, src) {
                    var item = profile.getItemByDom(src);
                    var itemNode = ood.use(src);

                    // 
                    itemNode.removeClass('ood-uitem-focus');

                    // 
                    if (profile.onItemBlur) {
                        profile.boxing().onItemBlur(profile, item, e, src);
                    }
                },

                // PC
                onDblclick: function (profile, e, src) {
                    var item = profile.getItemByDom(src);
                    var box = profile.boxing();

                    // 
                    if (profile.onItemDblClick) {
                        box.onItemDblClick(profile, item, e, src);
                    }
                },

                // PC
                onContextmenu: function (profile, e, src) {
                    var item = profile.getItemByDom(src);
                    var box = profile.boxing();

                    // 
                    if (profile.onItemContextmenu) {
                        return box.onItemContextmenu(profile, item, e, src) !== false;
                    }
                }
            },

            FLAG: {
                onClick: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.onFlagClick) {
                        box.onFlagClick(profile, item, e, src);
                        return false;
                    }
                },
                // PC
                onMouseOver: function (profile, e, src) {
                    var flag = ood.use(src);
                    flag.addClass('ood-flag-hover');
                },
                onMouseOut: function (profile, e, src) {
                    var flag = ood.use(src);
                    flag.removeClass('ood-flag-hover');
                }
            }
        },
        DataModel: {
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark'],
                caption: ood.getResText("DataModel.theme") || "",
                action: function (value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                caption: ood.getResText("DataModel.responsive") || "",
                action: function (value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            autoColumns: {
                ini: false,
                caption: ood.getResText("DataModel.autoColumns") || "",
                action: function (value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },

            tagCmds: {
                ini: null,
                caption: ood.getResText("DataModel.tagCommands") || ""
            },
            expression: {
                ini: '',
                caption: ood.getResText("DataModel.expression") || "",
                action: function () {
                }
            },
            bgimg: {
                ini: null,
                caption: ood.getResText("DataModel.backgroundImage") || ""
            },
            iotStatus: {
                ini: null,
                caption: ood.getResText("DataModel.iotStatus") || ""
            },
            tagCmdsAlign: {
                ini: null,
                caption: ood.getResText("DataModel.tagCommandsAlign") || ""
            },
            flagText: {
                ini: null,
                caption: ood.getResText("DataModel.flagText") || ""
            },
            flagClass: {
                ini: null,
                caption: ood.getResText("DataModel.flagClass") || ""
            },
            flagStyle: {
                ini: null,
                caption: ood.getResText("DataModel.markStyle") || ""
            },

            iconColors: {
                ini: null,
                caption: ood.getResText("DataModel.iconColors") || ""
            },
            itemColors: {
                ini: null,
                caption: ood.getResText("DataModel.itemColors") || ""
            },
            fontColors: {
                ini: null,
                caption: ood.getResText("DataModel.fontColors") || ""
            },

            autoFontColor: {
                ini: false,
                caption: ood.getResText("DataModel.autoFontColor") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoIconColor: {
                ini: true,
                caption: ood.getResText("DataModel.autoIconColor") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemColor: {
                ini: false,
                caption: ood.getResText("DataModel.autoItemColor") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },


            autoImgSize: {
                ini: false,
                caption: ood.getResText("DataModel.autoImgSize") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemSize: {
                ini: true,
                caption: ood.getResText("DataModel.autoItemSize") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            iconOnly: {
                ini: false,
                caption: ood.getResText("DataModel.iconOnly") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            iconFontSize: {
                ini: '',
                caption: ood.getResText("DataModel.iconFontSize") || "",
                action: function (v) {
                    this.getSubNode('ICON', true).css('font-size', v);
                }
            },

            backgroundColor: {
                ini: '',
                type: "color",
                caption: ood.getResText("DataModel.bgColor") || "",
                action: function (value) {
                    this.getSubNode('ITEMS', true).css('background-color', value);
                }
            },

            itemMargin: {
                ini: 6,
                caption: ood.getResText("DataModel.itemSpacing") || "",
                action: function (v) {
                    this.getSubNode('ITEM', true).css('margin', v || 0);
                }
            },
            itemPadding: {
                ini: 2,
                caption: ood.getResText("DataModel.itemPadding") || "",
                action: function (v) {
                    this.getSubNode('ITEM', true).css('padding', v || 0);
                }
            },
            itemWidth: {
                $spaceunit: 1,
                ini: 32,
                caption: ood.getResText("DataModel.itemWidth") || "",
                action: function (v) {
                    this.getSubNode('ITEMFRAME', true).width(v || '');
                }
            },
            itemHeight: {
                $spaceunit: 1,
                ini: 32,
                caption: ood.getResText("DataModel.itemHeight") || "",
                action: function (v) {
                    this.getSubNode('ITEMFRAME', true).height(v || '');
                }
            },
            imgWidth: {
                ini: 16,
                caption: ood.getResText("DataModel.imgWidth") || "",
                action: function (v) {
                    this.getSubNode('IMAGE', true).width(v || '');
                }
            },
            imgHeight: {
                ini: 16,
                caption: ood.getResText("DataModel.imgHeight") || "",
                action: function (v) {
                    this.getSubNode('IMAGE', true).height(v || '');
                }
            },
            width: {
                $spaceunit: 1,
                //ini: '16rem',
                caption: ood.getResText("DataModel.width") || ""
            },
            height: {
                $spaceunit: 1,
             //   ini: '16rem',
                caption: ood.getResText("DataModel.height") || ""
            },
            columns: {
                ini: 0,
                caption: ood.getResText("DataModel.columns") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },


            rows: {
                ini: 0,
                caption: ood.getResText("DataModel.rows") || "",
                action: function () {
                    this.boxing().refresh();
                }
            }
        },
        EventHandlers: {
            onCmd: null,

            onFlagClick: function (profile, item, e, src) {
            },
            touchstart: function (profile, item, e, src) {
            },
            touchmove: function (profile, item, e, src) {
            },
            touchend: function (profile, item, e, src) {
            },
            touchcancel: function (profile, item, e, src) {
            },

            swipe: function (profile, item, e, src) {
            },
            swipeleft: function (profile, item, e, src) {
            },
            swiperight: function (profile, item, e, src) {
            },
            swipeup: function (profile, item, e, src) {
            },
            swipedown: function (profile, item, e, src) {
            },


            press: function (profile, item, e, src) {
            },
            pressup: function (profile, item, e, src) {
            }


        },
        _prepareData: function (profile) {
            var d = arguments.callee.upper.call(this, profile), p = profile.properties, ns = this;
            if (p.cols) d._itemscls1 = profile.getClass('ITEMS', '-nowrap');


            ood.arr.each(d.items, function (item) {
                var index = item.index;
                if (!index) {
                    index = ood.arr.indexOf(d.items, item);
                }
                profile.boxing()._autoColor(item, index, p);
            })


            return d;
        },


        _prepareItem: function (profile, item, oitem, pid, index, len) {
            var p = profile.properties,
                cols = p.columns,
                rows = p.rows,
                auto1 = item.autoItemSize || p.autoItemSize,
                auto2 = item.autoImgSize || p.autoImgSize,
                t;

            profile.boxing()._autoColor(item, index, p);

            ood.arr.each(ood.toArr('itemWidth,backgroundColor,bgimg,iconColor,fontColor,itemColor,iotStatus,position,itemHeight,imgWidth,imgHeight,itemPadding,itemMargin,iconFontSize,autoItemSize,autoImgSize'), function (i) {
                item[i] = ood.isSet(item[i]) ? item[i] : p[i];
            });

            if (p.flagClass && !item.flagClass) {
                item.flagClass = p.flagClass;
            }
            if (p.flagStyle && !item.flagStyle) {
                item.flagStyle = p.flagStyle;
            }
            if (p.flagText && !item.flagText) {
                item.flagText = p.flagText;
            }


            item.itemWidth = (!auto1 && (t = item.itemWidth)) ? profile.$forceu(t) : '';
            item.itemHeight = (!auto1 && (t = item.itemHeight)) ? profile.$forceu(t) : '';
            item.itemMargin = (t = item.itemMargin) ? profile.$forceu(t) : 0;
            item.itemPadding = (t = item.itemPadding) ? profile.$forceu(t) : 0;
            item.imgWidth = (!auto2 && (t = item.imgWidth)) ? profile.$forceu(t) : '';
            item.imgHeight = (!auto2 && (t = item.imgHeight)) ? profile.$forceu(t) : '';
            item._tabindex = p.tabindex;

            if (item.fontColor) item._fontColor = "color:" + item.fontColor;
            if (item.iconColor) item._iconColor = "color:" + item.iconColor;
            if (item.itemColor) item._iconColor = "color:" + item.itemColor;
            if (item.icon) item._icon = "background-image: url(" + item.icon + ")";
            if (item.position) item._position = "background-position:" + item.position;

            if (item.bgimg) item._bgimg = "background-image: url(/" + item.bgimg + ")";

            if (t = item.iconFontSize) item._fontSize = "font-size:" + t;

            item._imageClass = '';
            if (!item.iconFontCode && !item.imageClass) item._imageClass += 'ood-icon-loading';

            if (item.imageClass) {
                item._imageClass += ' ' + item.imageClass;
            } else {
                item._imageClass = ' icon1';
            }


            if (item.flagText || item.flagClass) item._flagStyle = 'display:block';
            if (!item.flagClass) item.flagClass = 'ood-uiflag-1';

            if (p.iconOnly) {
                delete item.caption;
                delete item.comment;
            }

            if ((item.caption = item.caption || '') === '') item.capDisplay = 'display:none;';
            if ((item.comment = item.comment || '') === '') item.commentDisplay = 'display:none;';
            item._itemSize = '';
            if (cols)
                item._itemSize += 'width:' + (100 / cols + '%') + ';border:0;margin-left:0;margin-right:0;padding-left:0;padding-right:0;';
            if (rows)
                item._itemSize += 'height:' + (100 / rows + '%') + ';border:0;margin-top:0;margin-bottom:0;padding-top:0;padding-bottom:0;';

            if (!auto1) item._inneritemSize = (!cols && item.itemWidth ? ('width:' + item.itemWidth + ';') : '') +
                (!rows && item.itemHeight ? ('height:' + item.itemHeight) : '');
            if (!auto2)
                item._innerimgSize = (item.imgWidth ? ('width:' + item.imgWidth + ';') : '') + (!rows && item.imgHeight ? ('height:' + item.imgHeight) : '');
        }
        ,
        RenderTrigger: function () {
            var profile = this,
                p = profile.properties;
            if (p.backgroundColor) {
                if (!p.autoItemColor) {
                    profile.getSubNode('ITEMS', true).css('background-color', p.backgroundColor);
                }
            }

            this.boxing()._afterInsertItems(this);

            // 
            var self = this;
            ood.asyRun(function () {
                if (self.boxing() && self.boxing().GalleryTrigger()) {
                    self.boxing().GalleryTrigger();
                }
            });
        }


    }
});
ood.Class("ood.UI.ButtonLayout", "ood.UI.List", {
    Instance: {
        //  iniProp 
        iniProp: {
            "value": "mywork",
            "showDirtyMark": false,
            "items": [
                {
                    "caption": "",
                    "comment": ood.getRes('RAD.widgets.home') || "",
                    "id": "index",
                    "imageClass": "ri-link"
                },
                {
                    "caption": "",
                    "comment": ood.getRes('RAD.widgets.todo') || "",
                    "id": "waitedwork",
                    "imageClass": "ri-calendar-line"
                },
                {
                    "caption": "",
                    "comment": ood.getRes('RAD.widgets.draft') || "",
                    "id": "startWork",
                    "imageClass": "ri-flashlight-line"
                },
                {
                    "caption": "",
                    "comment": "",
                    "id": "mywork",
                    "imageClass": "ri-user-line"
                },
                {
                    "caption": "",
                    "comment": "",
                    "id": "msg",
                    "imageClass": "ri-message-line"
                }
            ],
            "dock": "fill",
            "borderType": "none",
            "iconFontSize": "2em",
            "columns": 5
        },

        _afterInsertItems: function (profile) {
            profile.getSubNodes("IMAGE", true).each(function (o) {
                if (o.src == ood.ini.img_bg) {
                    // bug fix for firefox
                    if (ood.browser.isFF) o.src = '';
                    o.src = o.title;
                    o.title = '';
                }
            });
        },
        updateItemData: function (profile, item) {
            this.get(0).box._prepareItem(this.get(0), item);
            this.updateItem(item.id, item);
            this.get(0).boxing().refresh();
        },

        // 
        setTheme: function (theme) {
            return this.each(function (profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();
                root.attr('data-theme', theme);

                // 
                localStorage.setItem('buttonlayout-theme', theme);
            });
        }
        ,

        ButtonLayoutTrigger: function () {
            var profile = this.get(0);
            var prop = profile.properties,
                boxing = this;

            // 
            // 
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('buttonlayout-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                boxing.adjustLayout();
            }

            // 
            boxing.enhanceAccessibility();
        },


        // 
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('buttonlayout-theme') || 'light';
        },

        // 
        toggleDarkMode: function () {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },

        // 
        adjustLayout: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    prop = profile.properties;

                // 
                root.removeClass('buttonlayout-mobile buttonlayout-tiny buttonlayout-small');

                // 
                if (width < 480) {
                    root.addClass('buttonlayout-tiny');
                } else if (width < 768) {
                    root.addClass('buttonlayout-mobile');
                } else if (width < 1024) {
                    root.addClass('buttonlayout-small');
                }

                // 
                if (prop.autoColumns) {
                    var newCols = Math.max(2, Math.floor(width / 80)); // 2
                    if (newCols !== prop.columns) {
                        profile.boxing().updateItem('columns', newCols);
                    }
                }

                // resizeCSS
                //ood(window).fireEvent('resize');
            });
        },

        // 
        enhanceAccessibility: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    items = profile.getSubNode('ITEM', true),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'grid',
                    'aria-label': properties.caption || ood.getRes('UI.buttonlayout.label') || ''
                });

                // ARIA
                items.each(function (item, index) {
                    var itemNode = ood(item);
                    var itemId = itemNode.id();
                    if (itemId) {
                        var itemData = profile.getItemByDom(item);
                        if (itemData) {
                            itemNode.attr({
                                'role': 'gridcell',
                                'aria-label': itemData.caption || itemData.comment || itemData.id,
                                'tabindex': index === 0 ? '0' : '-1', // 
                                'aria-describedby': itemData.comment ? itemId + '_comment' : null
                            });

                            // ID
                            if (itemData.comment) {
                                var commentNode = profile.getSubNodeByItemId('COMMENT', itemData.id);
                                if (commentNode && !commentNode.isEmpty()) {
                                    commentNode.attr('id', itemId + '_comment');
                                }
                            }
                        }
                    }
                });

                // ARIA
                var icons = profile.getSubNode('ICON', true);
                icons.each(function (icon) {
                    var iconNode = ood(icon);
                    iconNode.attr({
                        'aria-hidden': 'true' // 
                    });
                });
            });
        }
    },
    Initialize: function () {
        //modify default template fro shell
        var t = this.getTemplate();
        // 
        if (!t) {
            t = {};
        }
        t.$submap = {
            items: {
                ITEM: {
                    tabindex: '{_tabindex}',
                    className: '{itemClass} {disabled} {readonly}',
                    style: 'padding:{itemPadding};margin:{itemMargin};{_itemSize};{itemStyle} {_itemColor}',
                    ITEMFRAME: {
                        style: '{_inneritemSize};{_bgimg}; {_itemposition}',
                        COMMENT: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            text: '{comment}',
                            style: '{commentDisplay};{_fontColor}',
                            $order: 2
                        },
                        CONTENT: {
                            tagName: 'div',
                            $order: 1,
                            className: '{contentClass}',
                            style: '{_loadbg}',
                            ICON: {
                                className: 'oodfont {_imageClass} ood-showfocus',
                                style: "{_fontSize};{_icon};{_position}{_iconColor}",
                                text: '{iconFontCode}'
                            },
                            IMAGE: {
                                tagName: 'img',
                                src: ood.ini.img_bg,
                                title: '{image}',
                                style: '{_innerimgSize};{imgStyle}'
                            }
                        },
                        CAPTION: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            style: '{capDisplay} {_iconColor}',
                            text: '{caption}',
                            $order: 0
                        }

                    },
                    FLAG: {
                        $order: 20,
                        className: 'ood-display-none {flagClass}',
                        style: '{_flagStyle};{flagStyle}',
                        text: '{flagText}'
                    },
                    EXTRA: {
                        text: '{ext}',
                        $order: 30
                    }
                }
            }
        };
        this.setTemplate(t);

        // compitable
        ood.UI.IconList = ood.UI.ButtonLayout;
        var key = "ood.UI.IconList";
        ood.absBox.$type[key.replace("ood.UI.", "")] = ood.absBox.$type[key] = key;
    },
    Static: {
        IMGNODE: 1,
        Appearances: {
            EXTRA: {
                display: 'none'
            },
            KEY: {
                overflow: 'visible'
            },
            ITEMS: {
                position: 'relative',
                overflow: 'auto',
                'overflow-x': 'hidden',
                zoom: ood.browser.ie6 ? 1 : null
            },
            'ITEMS-nowrap': {
                'white-space': 'nowrap'
            },
            ITEM: {
                display: 'inline-flex',
                position: 'relative',
                cursor: 'pointer',
                'flex-direction': 'column',
                'align-items': 'center',
                'justify-content': 'center',
                margin: '0.25em',
                padding: '0.5em',
                'border-radius': 'var(--ood-border-radius)',
                'background-color': 'var(--ood-primary-color)',
                'color': 'var(--ood-text-on-primary)',
                'transition': 'all 0.2s ease',
                'box-shadow': '0 1px 2px rgba(0,0,0,0.1)',
                'border': '1px solid transparent'
            },
            'ITEM:hover': {
                'box-shadow': '0 2px 6px rgba(0,0,0,0.15)',
                'transform': 'translateY(-1px)'
            },
            'ITEM:focus': {
                'box-shadow': '0 0 0 2px rgba(0, 120, 212, 0.3)',
                'outline': 'none'
            },
            ITEMFRAME: {
                display: ood.browser.ie67 ? ood.$inlineBlock : 'block',
                zoom: ood.browser.ie67 ? 1 : null,
                position: 'relative',
                overflow: 'hidden',
                border: 0,
                padding: 0,
                margin: 0,
                '-moz-box-flex': '1',
                // 
                'border-radius': '4px'
            },
            IBWRAP: {},
            IMAGE: {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie6 ? 1 : null,
                visibility: 'hidden',
                'vertical-align': 'middle',
                // 
                'border-radius': '3px'
            },
            CAPTION: {
                'text-align': 'center',
                'font-weight': '500',
                "font-size": "1em",
                "margin": "0.5em 0 0 0",
                "line-height": "1.2",
                'white-space': 'normal',
                'max-width': '100%',
                'overflow': 'hidden',
                'text-overflow': 'ellipsis',
                'display': '-webkit-box',
                '-webkit-line-clamp': '2',
                '-webkit-box-orient': 'vertical'
            },
            CONTENT: {
                'text-align': 'center',
                'white-space': 'nowrap',
                'background-repeat': 'no-repeat',
                'font-size': '1em',
                // 
                transition: 'background-color 0.3s ease'
            },
            COMMENT: {
                display: 'block',
                margin: '0.25em 0 0 0',
                'text-align': 'center',
                'font-size': '0.75em',
                'color': 'var(--ood-text-secondary)',
                'line-height': '1.3',
                'max-width': '100%',
                'overflow': 'hidden',
                'text-overflow': 'ellipsis'
            },
            FLAG: {
                'right': "30%",
                'top': "0.125em",
                'font-size': "8px",
                'color': "var(--ood-warning)",
                'position': 'absolute',
                'z-index': 10,
                // 
                'border-radius': '50%',
                'box-shadow': '0 1px 2px rgba(0,0,0,0.2)'
            },

            // 
            'buttonlayout-dark ITEM': {
                'background-color': '#2d2d30',
                'border-color': '#3c3c3c',
                'color': '#cccccc',
                'box-shadow': '0 1px 3px rgba(0,0,0,0.3)'
            },
            'buttonlayout-dark ITEM:hover': {
                'background-color': '#3c3c3c',
                'box-shadow': '0 2px 6px rgba(0,0,0,0.4)'
            },
            'buttonlayout-dark CAPTION': {
                'color': '#d4d4d4'
            },
            'buttonlayout-dark COMMENT': {
                'color': '#cccccc'
            },
            'buttonlayout-dark CONTENT': {
                'background-color': 'transparent'
            },

            // 
            'buttonlayout-mobile ITEM': {
                'padding': '0.6em',
                'margin': '0.3em'
            },
            'buttonlayout-mobile CAPTION': {
                'font-size': '16px',
                'margin-top': '10px',
                'height': '30px'
            },
            'buttonlayout-mobile COMMENT': {
                'font-size': '0.7em'
            },
            'buttonlayout-mobile ICON': {
                'font-size': '1.2em'
            },

            // 
            'buttonlayout-tiny CAPTION': {
                'font-size': '14px',
                'margin-top': '8px',
                'height': '25px'
            },
            'buttonlayout-tiny COMMENT': {
                'font-size': '0.6em'
            }
        },
        Behaviors: {
            IMAGE: {
                onLoad: function (profile, e, src) {
                    var img = ood.use(src).get(0), path = img.src;
                    if (path != ood.ini.img_bg) {
                        var p = profile.properties,
                            nn = ood.use(src),
                            node = nn.get(0),
                            item = profile.getItemByDom(src);
                        if (!item) return;
                        var icon = profile.getSubNodeByItemId('ICON', item.id);
                        if (item.autoImgSize || p.autoImgSize) {
                            nn.attr('width', '');
                            nn.attr('height', '');
                        } else {
                            nn.attr('width', item.imgWidth);
                            nn.attr('height', item.imgWidth);
                        }

                        icon.removeClass('ood-icon-loading');
                        // hide
                        if (!item.iconFontCode && !item.imageClass && !item.icon) {
                            icon.addClass("ood-display-none");
                        }
                        nn.onLoad(null).onError(null).$removeEventHandler('load').$removeEventHandler('error');

                        item._status = 'loaded';
                        // don't show img_blank
                        if (ood.ini.img_blank == path) {
                            node.style.visibility = "hidden";
                            node.style.display = "none";
                        } else {
                            node.style.visibility = "visible";
                            node.style.display = "";
                        }
                    }
                },
                onError: function (profile, e, src) {
                    var item = profile.getItemByDom(src);
                    if (item._status == 'error') return;

                    var p = profile.properties,
                        nn = ood.use(src),
                        node = nn.get(0),
                        icon = profile.getSubNodeByItemId('ICON', item.id);

                    icon.removeClass('ood-icon-loading ood-display-none').addClass('ood-load-error');
                    nn.onLoad(null).onError(null).$removeEventHandler('load').$removeEventHandler('error');
                    node.style.visibility = "hidden";
                    node.style.display = "none";
                    item._status = 'error';
                }
            },

            ITEMS: {

                swipeleft: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swipeleft) {
                        box.swipeleft(profile, item, e, src);
                        return false;
                    }
                },
                swiperight: function (profile, item, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swiperight) {
                        box.swiperight(profile, item, e, src);
                        return false;
                    }
                }

            },

            FLAG: {
                onClick: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.onFlagClick) {
                        box.onFlagClick(profile, item, e, src);
                        return false;
                    }
                }
            }
        },
        DataModel: {
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark', 'high-contrast'],
                action: function (value) {
                    this.boxing().setTheme(value);
                },
                caption: ood.getResText("DataModel.theme") || ""
            },
            responsive: {
                ini: true,
                action: function (value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                },
                caption: ood.getResText("DataModel.responsive") || ""
            },
            autoColumns: {
                ini: false,
                action: function (value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                },
                caption: ood.getResText("DataModel.autoColumns") || ""
            },

            tagCmds: null,
            expression: {
                ini: '',
                action: function () {
                },
                caption: ood.getResText("DataModel.expression") || ""
            },
            bgimg: null,
            tagCmdsAlign: null,
            flagText: null,
            flagClass: null,
            flagStyle: null,


            autoFontColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.autoFontColor") || ""
            },
            autoIconColor: {
                ini: true,
                action: function () {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.autoIconColor") || ""
            },
            autoItemColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.autoItemColor") || ""
            },
            iconColors: null,
            itemColors: null,
            fontColors: null,


            autoImgSize: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.autoImgSize") || ""
            },
            autoItemSize: {
                ini: true,
                action: function () {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.autoItemSize") || ""
            },
            iconOnly: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.iconOnly") || ""
            },
            iconFontSize: {
                ini: '',
                action: function (v) {
                    this.getSubNode('ICON', true).css('font-size', v);
                }
            },
            itemMargin: {
                ini: 6,
                action: function (v) {
                    this.getSubNode('ITEM', true).css('margin', v || 0);
                },
                caption: ood.getResText("DataModel.itemMargin") || ""
            },
            itemPadding: {
                ini: 2,
                action: function (v) {
                    this.getSubNode('ITEM', true).css('padding', v || 0);
                },
                caption: ood.getResText("DataModel.itemPadding") || ""
            },
            itemWidth: {
                $spaceunit: 1,
                ini: 32,
                action: function (v) {
                    this.getSubNode('ITEMFRAME', true).width(v || '');
                },
                caption: ood.getResText("DataModel.itemWidth") || ""
            },
            itemHeight: {
                $spaceunit: 1,
                ini: 32,
                action: function (v) {
                    this.getSubNode('ITEMFRAME', true).height(v || '');
                },
                caption: ood.getResText("DataModel.itemHeight") || ""
            },
            imgWidth: {
                ini: 16,
                action: function (v) {
                    this.getSubNode('IMAGE', true).width(v || '');
                },
                caption: ood.getResText("DataModel.imgWidth") || ""
            },
            imgHeight: {
                ini: 16,
                action: function (v) {
                    this.getSubNode('IMAGE', true).height(v || '');
                },
                caption: ood.getResText("DataModel.imgHeight") || ""
            },
            width: {
                $spaceunit: 1,
                ini: '16rem',
                caption: ood.getResText("DataModel.width") || ""
            },
            height: {
                $spaceunit: 1,
                ini: '16rem',
                caption: ood.getResText("DataModel.height") || ""
            },
            columns: {
                ini: 0,
                action: function () {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.columns") || ""
            },

            rows: {
                ini: 0,
                action: function () {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.rows") || ""
            }
        },
        EventHandlers: {
            onCmd: null,

            onFlagClick: function (profile, item, e, src) {
            },
            touchstart: function (profile, item, e, src) {
            },
            touchmove: function (profile, item, e, src) {
            },
            touchend: function (profile, item, e, src) {
            },
            touchcancel: function (profile, item, e, src) {
            },

            swipe: function (profile, item, e, src) {
            },
            swipeleft: function (profile, item, e, src) {
            },
            swiperight: function (profile, item, e, src) {
            },
            swipeup: function (profile, item, e, src) {
            },
            swipedown: function (profile, item, e, src) {
            },


            press: function (profile, item, e, src) {
            },
            pressup: function (profile, item, e, src) {
            }


        },
        _prepareData: function (profile) {
            var d = arguments.callee.upper.call(this, profile), p = profile.properties, ns = this;
            if (p.cols) d._itemscls1 = profile.getClass('ITEMS', '-nowrap');

            ood.arr.each(d.items, function (item) {
                var index = item.index;
                if (!index) {
                    index = ood.arr.indexOf(d.items, item);
                }
                profile.boxing()._autoColor(item, index, p);
            })
            return d;
        },

        _prepareItem: function (profile, item, oitem, pid, index, len) {
            var p = profile.properties,
                cols = p.columns,
                rows = p.rows,
                auto1 = item.autoItemSize || p.autoItemSize,
                auto2 = item.autoImgSize || p.autoImgSize,
                t;
            profile.boxing()._autoColor(item, index, p);
            ood.arr.each(ood.toArr('itemWidth,bgimg,position,itemHeight,imgWidth,imgHeight,itemPadding,itemMargin,iconFontSize,autoItemSize,autoImgSize'), function (i) {
                item[i] = ood.isSet(item[i]) ? item[i] : p[i];
            });

            if (p.flagClass && !item.flagClass) {
                item.flagClass = p.flagClass;
            }
            if (!item.flagStyle) {
                item.flagStyle = p.flagStyle;
            }
            if (!item.flagText) {
                item.flagText = p.flagText;
            }

            item.itemWidth = (!auto1 && (t = item.itemWidth)) ? profile.$forceu(t) : '';
            item.itemHeight = (!auto1 && (t = item.itemHeight)) ? profile.$forceu(t) : '';
            item.itemMargin = (t = item.itemMargin) ? profile.$forceu(t) : 0;
            item.itemPadding = (t = item.itemPadding) ? profile.$forceu(t) : 0;
            item.imgWidth = (!auto2 && (t = item.imgWidth)) ? profile.$forceu(t) : '';
            item.imgHeight = (!auto2 && (t = item.imgHeight)) ? profile.$forceu(t) : '';
            item._tabindex = p.tabindex;

            if (item.icon) item._icon = "background-image: url(" + item.icon + ")";
            if (item.position) item._position = "background-position:" + item.position;

            if (item.bgimg) item._bgimg = "background-image: url(/" + item.bgimg + ")";

            if (t = item.iconFontSize) item._fontSize = "font-size:" + t;

            item._imageClass = '';
            if (!item.iconFontCode && !item.imageClass) item._imageClass += 'ood-icon-loading';

            if (item.imageClass) {
                item._imageClass += ' ' + item.imageClass;
            } else {
                item._imageClass = ' icon1';
            }


            if (item.flagText || item.flagClass) item._flagStyle = 'display:block';
            if (!item.flagClass) item.flagClass = 'ood-uiflag-1';

            if (p.iconOnly) {
                delete item.caption;
                delete item.comment;
            }

            if ((item.caption = item.caption || '') === '') item.capDisplay = 'display:none;';
            if ((item.comment = item.comment || '') === '') item.commentDisplay = 'display:none;';
            item._itemSize = '';
            if (cols)
                item._itemSize += 'width:' + (100 / cols + '%') + ';border:0;margin-left:0;margin-right:0;padding-left:0;padding-right:0;';
            if (rows)
                item._itemSize += 'height:' + (100 / rows + '%') + ';border:0;margin-top:0;margin-bottom:0;padding-top:0;padding-bottom:0;';

            if (!auto1) item._inneritemSize = (!cols && item.itemWidth ? ('width:' + item.itemWidth + ';') : '') +
                (!rows && item.itemHeight ? ('height:' + item.itemHeight) : '');
            if (!auto2)
                item._innerimgSize = (item.imgWidth ? ('width:' + item.imgWidth + ';') : '') + (!rows && item.imgHeight ? ('height:' + item.imgHeight) : '');
        }
        ,
        RenderTrigger: function () {
            this.boxing()._afterInsertItems(this);

            // 
            var self = this;
            ood.asyRun(function () {
                if (self.boxing() && ood.isFun(self.boxing().ButtonLayoutTrigger)) {
                    self.boxing().ButtonLayoutTrigger();
                }

            });
        }
    }
});
ood.Class("ood.UI.TitleBlock", "ood.UI.List", {
    Instance: {
        //  iniProp 
        iniProp: {
            "items": [
                {
                    "id": "item1",
                    "title": "",
                    "more": "&gt;&gt; ",
                    "msgnum": "1",
                    "flagClass": "ri-grid-line",
                    "caption": "item1"
                },
                {
                    "id": "item2",
                    "title": "",
                    "more": "&gt;&gt; ",
                    "msgnum": "21",
                    "flagClass": "bpmfont bpmVueFlyActivityOperation",
                    "caption": "item2"
                },
                {
                    "id": "item3",
                    "title": "",
                    "more": "&gt;&gt; ",
                    "msgnum": "7",
                    "flagClass": "bpmfont bpmhuiyitongzhi2",
                    "caption": "item3"
                },
                {
                    "id": "item4",
                    "title": "",
                    "more": "&gt;&gt; ",
                    "msgnum": "0",
                    "flagClass": "ri ri-time-line",
                    "caption": "item4"
                }
            ],
            "dock": "fill",
            "selMode": "none",
            "borderType": "none",
            "columns": 2
        },

        _afterInsertItems: function (profile) {
            profile.getSubNodes("IMAGE", true).each(function (o) {
                if (o.src == ood.ini.img_bg) {
                    // bug fix for firefox
                    if (ood.browser.isFF) o.src = '';
                    o.src = o.title;
                    o.title = '';
                }
            });
        },
        updateItemData: function (profile, item) {
            this.get(0).box._prepareItem(this.get(0), item);
            this.get(0).boxing().refresh();
        }

    },
    Initialize: function () {
        //modify default template fro shell
        var t = this.getTemplate();
        t.$submap = {
            items: {
                ITEM: {
                    tabindex: '{_tabindex}',
                    className: 'ood-uitembg ood-uiborder-radius ood-showfocus {itemClass} {disabled} {readonly}',
                    style: 'padding:{itemPadding};margin:{itemMargin};{_itemSize}{itemStyle};{_itemColor}',

                    ITEMFRAME: {
                        style: '{_inneritemSize};{_bgColor}; {_position}',
                        MSGNUM: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            style: '{capDisplay}; {_fontColor}',
                            text: '{msgnum}',
                            $order: 0
                        },
                        TITLE: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            style: '{capDisplay};{_fontColor}',
                            text: '{_title}',
                            $order: 3,
                            IMAGE: {
                                tagName: 'img',
                                src: ood.ini.img_bg,
                                title: '{image}',
                                style: '{_innerimgSize};{imgStyle};{_iconColor}}'
                            }

                        },
                        MORE: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            style: '{capDisplay};{_moreBgColor};',
                            text: '{more}',
                            $order: 4
                        }

                    },
                    FLAG: {
                        $order: 20,
                        className: 'ood-display-none {flagClass}',
                        style: '{_flagStyle};{flagStyle};font-size:{iconFontSize};{_fontColor}',
                        text: '{flagText}'
                    },
                    EXTRA: {
                        text: '{ext}',
                        $order: 30
                    }
                }
            }
        };
        this.setTemplate(t);

        // compitable
        ood.UI.IconList = ood.UI.TitleBlock;
        var key = "ood.UI.IconList";
        ood.absBox.$type[key.replace("ood.UI.", "")] = ood.absBox.$type[key] = key;
    },
    Static: {
        IMGNODE: 1,
        Appearances: {
            EXTRA: {
                display: 'none'
            },
            KEY: {
                overflow: 'visible'
            },
            ITEMS: {
                position: 'relative',
                overflow: 'auto',
                'overflow-x': 'hidden',
                zoom: ood.browser.ie6 ? 1 : null
            },
            'ITEMS-nowrap': {
                'white-space': 'nowrap'
            },
            ITEM: {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie67 ? 1 : null,
                position: 'relative',
                cursor: 'pointer',
                'vertical-align': 'top',
                margin: 0
            },
            ITEMFRAME: {
                display: ood.browser.ie67 ? ood.$inlineBlock : 'block',
                zoom: ood.browser.ie67 ? 1 : null,
                position: 'relative',
                overflow: 'hidden',
                border: 0,
                padding: 0,
                margin: 0,
                '-moz-box-flex': '1'
            },
            IBWRAP: {},
            IMAGE: {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie6 ? 1 : null,
                visibility: 'hidden',
                'vertical-align': 'middle'
            },
            MSGNUM: {
                'text-align': 'right',
                overflow: 'hidden',
                "color": "var(--ood-title-text)",
                'white-space': 'nowrap',
                'font-weight': 'bold',
                "font-size": '2em',
                "margin-top": "var(--ood-spacing-xs)",
                "margin-right": "var(--ood-spacing-sm)",
                "height": "35px"
            },

            TITLE: {
                "color": "var(--ood-title-text)",
                display: 'block',
                'margin-right': 'var(--ood-spacing-xs)',
                'text-align': 'right',
                'font-size': '1em'
            },
            MORE: {
                "color": "var(--ood-title-text)",
                display: 'block',
                "background-color": "var(--ood-title-more-bg)",
                'margin-top': 'var(--ood-spacing-sm)',
                "text-align": "center",
                'font-size': '0.75em'
            },
            FLAG: {
                'left': "var(--ood-spacing-sm)",
                'top': "0.2em",
                'text-align': "left",
                'color': "var(--ood-title-text)",
                "opacity": 0.2,
                'position': 'absolute',
                'z-index': 10
            }
        },
        Behaviors: {
            ITEMS: {
                swipeleft: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swipeleft) {
                        box.swipeleft(profile, item, e, src);
                        return false;
                    }
                },
                swiperight: function (profile, item, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swiperight) {
                        box.swipeleft(profile, item, e, src);
                        return false;
                    }
                },
            },
            IMAGE: {
                onLoad: function (profile, e, src) {
                    var img = ood.use(src).get(0), path = img.src;
                    if (path != ood.ini.img_bg) {
                        var p = profile.properties,
                            nn = ood.use(src),
                            node = nn.get(0),
                            item = profile.getItemByDom(src);
                        if (!item) return;
                        var icon = profile.getSubNodeByItemId('ICON', item.id);
                        if (item.autoImgSize || p.autoImgSize) {
                            nn.attr('width', '');
                            nn.attr('height', '');
                        } else {
                            nn.attr('width', item.imgWidth);
                            nn.attr('height', item.imgWidth);
                        }

                        icon.removeClass('ood-icon-loading');
                        // hide
                        if (!item.iconFontCode && !item.imageClass && !item.icon) {
                            icon.addClass("ood-display-none");
                        }
                        nn.onLoad(null).onError(null).$removeEventHandler('load').$removeEventHandler('error');

                        item._status = 'loaded';
                        // don't show img_blank
                        if (ood.ini.img_blank == path) {
                            node.style.visibility = "hidden";
                            node.style.display = "none";
                        } else {
                            node.style.visibility = "visible";
                            node.style.display = "";
                        }
                    }
                },
                onError: function (profile, e, src) {
                    var item = profile.getItemByDom(src);
                    if (item._status == 'error') return;

                    var p = profile.properties,
                        nn = ood.use(src),
                        node = nn.get(0),
                        icon = profile.getSubNodeByItemId('ICON', item.id);

                    icon.removeClass('ood-icon-loading ood-display-none').addClass('ood-load-error');
                    nn.onLoad(null).onError(null).$removeEventHandler('load').$removeEventHandler('error');
                    node.style.visibility = "hidden";
                    node.style.display = "none";
                    item._status = 'error';
                }
            },
            TITLE: {
                onClick: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.onTitleClick) {
                        box.onTitleClick(profile, item, e, src);
                        return false;
                    }
                }
            },
            MORE: {
                onClick: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.onMoreClick) {
                        box.onMoreClick(profile, item, e, src);
                        return false;
                    }
                }
            }
        },

        DataModel: {
            flagText: null,
            flagClass: null,
            flagStyle: null,

            iconColors:null,
            itemColors:null,
            fontColors: null,
            moreColors:null,

            autoFontColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoIconColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemColor: {
                ini: true,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoImgSize: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemSize: {
                ini: true,
                action: function () {
                    this.boxing().refresh();
                }
            },

            iconFontSize: {
                ini: '3.5em',
                action: function (v) {
                    this.getSubNode('FLAG', true).css('font-size', v);
                }
            },

            itemMargin: {
                ini: 0,
                action: function (v) {
                    this.getSubNode('ITEM', true).css('margin', v || 0);
                }
            },
            itemPadding: {
                ini: 0,
                action: function (v) {
                    this.getSubNode('ITEM', true).css('padding', v || 0);
                }
            },
            itemWidth: {
                $spaceunit: 1,
                ini: 32,
                action: function (v) {
                    this.getSubNode('ITEMFRAME', true).width(v || '');
                }
            },
            itemHeight: {
                $spaceunit: 1,
                ini: 32,
                action: function (v) {
                    this.getSubNode('ITEMFRAME', true).height(v || '');
                }
            },
            width: {
                $spaceunit: 1,
                ini: '16rem'
            },
            height: {
                $spaceunit: 1,
                ini: '16rem'
            },
            columns: {
                ini: 0,
                action: function () {
                    this.boxing().refresh();
                }
            },
            rows: {
                ini: 0,
                action: function () {
                    this.boxing().refresh();
                }
            }
        },
        EventHandlers: {
            onCmd: null,
            onMoreClick: function (profile, item, e, src) {
            },
            onTitleClick: function (profile, item, e, src) {
            },
            touchstart: function (profile, item, e, src) {
            },
            touchmove: function (profile, item, e, src) {
            },
            touchend: function (profile, item, e, src) {
            },
            touchcancel: function (profile, item, e, src) {
            },

            swipe: function (profile, item, e, src) {
            },
            swipeleft: function (profile, item, e, src) {
            },
            swiperight: function (profile, item, e, src) {
            },
            swipeup: function (profile, item, e, src) {
            },
            swipedown: function (profile, item, e, src) {
            },


            press: function (profile, item, e, src) {
            },
            pressup: function (profile, item, e, src) {
            }
        },
        _prepareData: function (profile) {
            var d = arguments.callee.upper.call(this, profile), p = profile.properties, ns = this;
            if (p.cols) d._itemscls1 = profile.getClass('ITEMS', '-nowrap');

            ood.arr.each(d.items, function (item) {
                var index = item.index;
                if (!index) {
                    index = ood.arr.indexOf(d.items, item);
                }
                profile.boxing()._autoColor(item, index, p);
            })

            return d;
        },




        _prepareItem: function (profile, item, oitem, pid, index, len) {
            var p = profile.properties,
                cols = p.columns,
                rows = p.rows,
                auto1 = item.autoItemSize || p.autoItemSize,
                t;
            profile.boxing()._autoColor(item, index, p);
            ood.arr.each(ood.toArr('itemWidth,position,itemHeight,imgWidth,imgHeight,itemPadding,itemMargin,iconFontSize,iconColor,fontColor,itemColor'), function (i) {
                item[i] = ood.isSet(item[i]) ? item[i] : p[i];
            });


            item.itemWidth = (!auto1 && (t = item.itemWidth)) ? profile.$forceu(t) : '';
            item.itemHeight = (!auto1 && (t = item.itemHeight)) ? profile.$forceu(t) : '';
            item.itemMargin = (t = item.itemMargin) ? profile.$forceu(t) : 0;
            item.itemPadding = (t = item.itemPadding) ? profile.$forceu(t) : 0;
            item._tabindex = p.tabindex;

            if (item.title) {
                item._title = item.title;
            } else if (item.caption) {
                item._title = item.caption;
            }

            if (p.flagClass && !item.flagClass) {
                item.flagClass = p.flagClass;
            }
            if (p.flagStyle && !item.flagStyle) {
                item.flagStyle = p.flagStyle;
            }
            if (p.flagText && !item.flagText) {
                item.flagText = p.flagText;
            }
            //      if (t = item.iconFontSize) item._fontSize = "font-size:" + t;

            item._imageClass = '';
            if (!item.iconFontCode && !item.imageClass) item._imageClass += 'ood-icon-loading';

            if (item.imageClass) {
                item._imageClass += ' ' + item.imageClass;
            } else {
                item._imageClass = ' icon1';
            }

            // if (item.fontColor) item._fontColor = "color:"+ item.fontColor ;
            // if (item.iconColor) item._iconColor = "color:" + item.iconColor ;
            // if (item.itemColor) item._iconColor = "color:" + item.itemColor ;

            // if (item.bgColor) item._bgColor = ' background-color:' + item.bgColor;
            // if (item.moreBgColor) item._moreBgColor = ' background-color:' + item.moreBgColor;
            //

            if (item.flagText || item.flagClass) item._flagStyle = 'display:block';
            if (!item.flagClass) item.flagClass = 'ood-uiflag-1';

            item._itemSize = '';
            if (cols)
                item._itemSize += 'width:' + (100 / cols + '%') + ';border:0;margin-left:0;margin-right:0;padding-left:0;padding-right:0;';
            if (rows)
                item._itemSize += 'height:' + (100 / rows + '%') + ';border:0;margin-top:0;margin-bottom:0;padding-top:0;padding-bottom:0;';

        }
        ,
        RenderTrigger: function () {
            this.boxing()._afterInsertItems(this);
        }
    }
});
ood.Class("ood.UI.ContentBlock", "ood.UI.List", {
    Instance: {
        //  iniProp 
        iniProp: {
            "items": [
                {
                    "id": "item1",
                    "title": "",
                    "datetime": "2024-9-9 12:00",
                    "flagClass": "ri-arrow-left-right-line",
                    "flagText": "",
                    "caption": "item1"
                },
                {
                    "id": "item2",
                    "title": "",
                    "datetime": "2024-9-9 12:00",
                    "flagClass": "ri ri-drag-move-line",
                    "flagText": "",
                    "caption": "item2"
                }
            ],
            "dock": "fill",
            "selMode": "none",
            "borderType": "none",
            "columns": 1
        },

        _afterInsertItems: function (profile) {
            profile.getSubNodes("IMAGE", true).each(function (o) {
                if (o.src == ood.ini.img_bg) {
                    // bug fix for firefox
                    if (ood.browser.isFF) o.src = '';
                    o.src = o.title;
                    o.title = '';
                }
            });
        },
        updateItemData: function (profile, item) {
            this.get(0).box._prepareItem(this.get(0), item);
            this.get(0).boxing().refresh();
        },
        
        // 
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot(),
                    items = profile.getSubNode('ITEM', true),
                    itemframes = profile.getSubNode('ITEMFRAME', true),
                    datetimes = profile.getSubNode('DATETIME', true),
                    titles = profile.getSubNode('TITLE', true),
                    mores = profile.getSubNode('MORE', true),
                    flags = profile.getSubNode('FLAG', true),
                    images = profile.getSubNode('IMAGE', true);

                // 
                root.removeClass('contentblock-dark contentblock-light contentblock-hc');
                
                // 
                switch(theme) {
                    case 'dark':
                        root.addClass('contentblock-dark');
                        break;
                    case 'high-contrast':
                        root.addClass('contentblock-hc');
                        break;
                    default:
                        root.addClass('contentblock-light');
                }

                // 
                items.css({
                    'background-color': '',
                    'border-color': '',
                    'color': ''
                });
                itemframes.css({
                    'background-color': ''
                });
                datetimes.css({
                    'color': ''
                });
                titles.css({
                    'color': ''
                });
                mores.css({
                    'background-color': '',
                    'color': ''
                });
                flags.css({
                    'color': ''
                });
                images.css({
                    'filter': ''
                });
                
                // 
                localStorage.setItem('contentblock-theme', theme);
            });
        },
        
        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('contentblock-theme') || 'light';
        },
        
        // 
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        
        // 
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    items = profile.getSubNode('ITEM', true),
                    itemframes = profile.getSubNode('ITEMFRAME', true),
                    datetimes = profile.getSubNode('DATETIME', true),
                    titles = profile.getSubNode('TITLE', true),
                    mores = profile.getSubNode('MORE', true),
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('contentblock-mobile');
                    
                    // 
                    itemframes.css({
                        'padding': '1em'
                    });
                    datetimes.css({
                        'font-size': '20px',
                        'line-height': '28px'
                    });
                    titles.css({
                        'font-size': '22px',
                        'line-height': '32px'
                    });
                    mores.css({
                        'font-size': '0.8em',
                        'padding': '0.5em'
                    });
                } else {
                    root.removeClass('contentblock-mobile');
                    
                    // 
                    itemframes.css({
                        'padding': ''
                    });
                    datetimes.css({
                        'font-size': '',
                        'line-height': ''
                    });
                    titles.css({
                        'font-size': '',
                        'line-height': ''
                    });
                    mores.css({
                        'font-size': '',
                        'padding': ''
                    });
                }

                // 
                if (width < 480) {
                    root.addClass('contentblock-tiny');
                    
                    // 
                    datetimes.css({
                        'font-size': '18px',
                        'line-height': '24px'
                    });
                    titles.css({
                        'font-size': '20px',
                        'line-height': '28px'
                    });
                    mores.css({
                        'font-size': '0.7em'
                    });
                } else {
                    root.removeClass('contentblock-tiny');
                }
            });
        },
        
        // 
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    items = profile.getSubNode('ITEM', true),
                    images = profile.getSubNode('IMAGE', true),
                    mores = profile.getSubNode('MORE', true),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'list',
                    'aria-label': properties.caption || ''
                });
                
                // ARIA
                items.each(function(item, index) {
                    var itemNode = ood(item);
                    var itemData = profile.getItemByDom(item);
                    
                    // ARIA
                    itemNode.attr({
                        'role': 'listitem',
                        'tabindex': itemData.disabled ? '-1' : '0',
                        'aria-label': itemData.title || itemData.datetime || '',
                        'aria-disabled': itemData.disabled ? 'true' : 'false'
                    });
                    
                    // 
                    if (itemData.datetime) {
                        itemNode.attr('aria-describedby', profile.serialId + '_datetime_' + index);
                        var datetimeNode = itemNode.find('.ood-ui-ellipsis').filter(function() {
                            return ood(this).text() === itemData.datetime;
                        });
                        if (datetimeNode.length) {
                            datetimeNode.attr('id', profile.serialId + '_datetime_' + index);
                        }
                    }
                });
                
                // ARIA
                images.each(function(img) {
                    var imgNode = ood(img);
                    var itemData = profile.getItemByDom(img);
                    imgNode.attr({
                        'alt': itemData.title || itemData.datetime || '',
                        'role': 'img'
                    });
                });
                
                // ARIA
                mores.each(function(more) {
                    ood(more).attr({
                        'role': 'button',
                        'tabindex': '0',
                        'aria-label': ''
                    });
                });
            });
        },
        
        ContentBlockTrigger: function() {
            var profile = this.get(0);
            var prop = profile.properties;

            // 
            // 
            if (prop.theme) {
                this.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('contentblock-theme');
                if (savedTheme) {
                    this.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                this.adjustLayout();
            }

            // 
            this.enhanceAccessibility();
        }

    },
    Initialize: function () {
        //modify default template fro shell
        var t = this.getTemplate();
        // 
        if(!t){
            t = {};
        }
        t.$submap = {
            items: {
                ITEM: {
                    tabindex: '{_tabindex}',
                    className: 'ood-uitembg ood-uiborder-radius ood-showfocus {itemClass} {disabled} {readonly}',
                    style: 'padding:{itemPadding};margin:{itemMargin};{_itemSize};{itemStyle}{_itemColor}',

                    ITEMFRAME: {
                        style: '{_inneritemSize};{_bgColor}; {_position}',
                        DATETIME: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            style: '{capDisplay} ;{_fontColor}',
                            text: '{datetime}',
                            $order: 0
                        },
                        TITLE: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            style: '{capDisplay};{_fontColor}',
                            text: '{_title}',
                            $order: 3,
                            IMAGE: {
                                tagName: 'img',
                                src: ood.ini.img_bg,
                                title: '{image}',
                                style: '{_innerimgSize};{imgStyle};{_iconColor}'
                            }

                        },
                        MORE: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            style: '{capDisplay};{_moreBgColor};',
                            text: '{more}',
                            $order: 4
                        }

                    },
                    FLAG: {
                        $order: 20,
                        className: 'ood-display-none {flagClass}',
                        style: '{_flagStyle};{flagStyle};font-size:{iconFontSize}{_fontColor}',
                        text: '{flagText}'
                    },
                    EXTRA: {
                        text: '{ext}',
                        $order: 30
                    }
                }
            }
        };
        this.setTemplate(t);

        // compitable
        ood.UI.IconList = ood.UI.TitleBlock;
        var key = "ood.UI.IconList";
        ood.absBox.$type[key.replace("ood.UI.", "")] = ood.absBox.$type[key] = key;
    },
    Static: {
        IMGNODE: 1,
        Appearances: {
            EXTRA: {
                display: 'none'
            },
            KEY: {
                overflow: 'visible'
            },
            ITEMS: {
                position: 'relative',
                overflow: 'auto',
                'overflow-x': 'hidden',
                padding: "32px 0px 20px 0px",
                zoom: ood.browser.ie6 ? 1 : null
            },
            'ITEMS-nowrap': {
                'white-space': 'nowrap'
            },
            ITEM: {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie67 ? 1 : null,
                position: 'relative',
                cursor: 'pointer',
                'vertical-align': 'top',
                margin: 0
            },
            ITEMFRAME: {
                display: ood.browser.ie67 ? ood.$inlineBlock : 'block',
                zoom: ood.browser.ie67 ? 1 : null,
                position: 'relative',
                overflow: 'hidden',
                border: 0,
                padding:  "10px 32px 10px 32px",
                margin: 0,
                '-moz-box-flex': '1'
            },
            IBWRAP: {},
            IMAGE: {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie6 ? 1 : null,
                visibility: 'hidden',
                'vertical-align': 'middle'
            },
            DATETIME: {
                'text-align': 'left',
                overflow: 'hidden',
                "color": "var(--ood-text-secondary)",
                'white-space': 'nowrap',
                'font-weight': 'Regular',
                "font-size": '26px',
                "left":"0.5em",
                "line-height":"36px",
                "margin-top": "5px",
                "margin-right": "0.5em",
                "height": "36px"
            },

            TITLE: {
                "color": "var(--ood-text-heading)",
                display: 'block',
                "font-size": "28px",
                "line-height":"40px",
                "font-weight":"Medium",
                'margin-right': '0.25em',
                'text-align': 'left'
            },
            MORE: {
                "color": "var(--ood-text-inverse)",
                display: 'block',
                "background-color": "var(--ood-primary)",
                'margin-top': '0.5em',
                "text-align": "center",
                'font-size': '0.75em'
            },
            FLAG: {
                "color": "var(--ood-text-heading)",
                'right': "0.5em",
                'top': "0.2em",
                'text-align': "left",

                "font-size": '26px',
                "line-height":"36px",
                "opacity": 1,
                'position': 'absolute',
                'z-index': 10
            }
        },
        Behaviors: {
            ITEMS: {
                swipeleft: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swipeleft) {
                        box.swipeleft(profile, item, e, src);
                        return false;
                    }
                },
                swiperight: function (profile, item, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swiperight) {
                        box.swipeleft(profile, item, e, src);
                        return false;
                    }
                },
            },
            IMAGE: {
                onLoad: function (profile, e, src) {
                    var img = ood.use(src).get(0), path = img.src;
                    if (path != ood.ini.img_bg) {
                        var p = profile.properties,
                            nn = ood.use(src),
                            node = nn.get(0),
                            item = profile.getItemByDom(src);
                        if (!item) return;
                        var icon = profile.getSubNodeByItemId('ICON', item.id);
                        if (item.autoImgSize || p.autoImgSize) {
                            nn.attr('width', '');
                            nn.attr('height', '');
                        } else {
                            nn.attr('width', item.imgWidth);
                            nn.attr('height', item.imgWidth);
                        }

                        icon.removeClass('ood-icon-loading');
                        // hide
                        if (!item.iconFontCode && !item.imageClass && !item.icon) {
                            icon.addClass("ood-display-none");
                        }
                        nn.onLoad(null).onError(null).$removeEventHandler('load').$removeEventHandler('error');

                        item._status = 'loaded';
                        // don't show img_blank
                        if (ood.ini.img_blank == path) {
                            node.style.visibility = "hidden";
                            node.style.display = "none";
                        } else {
                            node.style.visibility = "visible";
                            node.style.display = "";
                        }
                    }
                },
                onError: function (profile, e, src) {
                    var item = profile.getItemByDom(src);
                    if (item._status == 'error') return;

                    var p = profile.properties,
                        nn = ood.use(src),
                        node = nn.get(0),
                        icon = profile.getSubNodeByItemId('ICON', item.id);

                    icon.removeClass('ood-icon-loading ood-display-none').addClass('ood-load-error');
                    nn.onLoad(null).onError(null).$removeEventHandler('load').$removeEventHandler('error');
                    node.style.visibility = "hidden";
                    node.style.display = "none";
                    item._status = 'error';
                }
            },
            TITLE: {
                onClick: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.onTitleClick) {
                        box.onTitleClick(profile, item, e, src);
                        return false;
                    }
                }
            },
            MORE: {
                onClick: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.onMoreClick) {
                        box.onMoreClick(profile, item, e, src);
                        return false;
                    }
                }
            }
        },

        DataModel: {
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark', 'high-contrast'],
                caption: ood.getResText("DataModel.theme") || "",
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                caption: ood.getResText("DataModel.responsive") || "",
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            flagText: {
                ini: null,
                caption: ood.getResText("DataModel.markText") || ""
            },
            flagClass: {
                ini: null,
                caption: ood.getResText("DataModel.markStyleClass") || ""
            },
            flagStyle: {
                ini: null,
                caption: ood.getResText("DataModel.markStyle") || ""
            },

            iconColors: {
                ini: null,
                caption: ood.getResText("DataModel.iconColor") || ""
            },
            itemColors: {
                ini: null,
                caption: ood.getResText("DataModel.itemColor") || ""
            },
            fontColors: {
                ini: null,
                caption: ood.getResText("DataModel.fontColor") || ""
            },
            moreColors: {
                ini: null,
                caption: ood.getResText("DataModel.moreColors") || ""
            },

            autoFontColor: {
                ini: false,
                caption: ood.getResText("DataModel.autoFontColor") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoIconColor: {
                ini: false,
                caption: ood.getResText("DataModel.autoIconColor") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemColor: {
                ini: false,
                caption: ood.getResText("DataModel.autoItemColor") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoImgSize: {
                ini: false,
                caption: ood.getResText("DataModel.autoImgSize") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemSize: {
                ini: true,
                caption: ood.getResText("DataModel.autoItemSize") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },

            iconFontSize: {
                ini: '1.5em',
                caption: ood.getResText("DataModel.iconFontSize") || "",
                action: function (v) {
                    this.getSubNode('FLAG', true).css('font-size', v);
                }
            },

            itemMargin: {
                ini: 0,
                caption: ood.getResText("DataModel.itemSpacing") || "",
                action: function (v) {
                    this.getSubNode('ITEM', true).css('margin', v || 0);
                }
            },
            itemPadding: {
                ini: 0,
                caption: ood.getResText("DataModel.itemPadding") || "",
                action: function (v) {
                    this.getSubNode('ITEM', true).css('padding', v || 0);
                }
            },
            itemWidth: {
                $spaceunit: 1,
                ini: 32,
                caption: ood.getResText("DataModel.itemWidth") || "",
                action: function (v) {
                    this.getSubNode('ITEMFRAME', true).width(v || '');
                }
            },
            itemHeight: {
                $spaceunit: 1,
                ini: 32,
                caption: ood.getResText("DataModel.itemHeight") || "",
                action: function (v) {
                    this.getSubNode('ITEMFRAME', true).height(v || '');
                }
            },
            width: {
                $spaceunit: 1,
                ini: '16rem',
                caption: ood.getResText("DataModel.width") || ""
            },
            height: {
                $spaceunit: 1,
                ini: '16rem',
                caption: ood.getResText("DataModel.height") || ""
            },
            columns: {
                ini: 0,
                caption: ood.getResText("DataModel.columns") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            rows: {
                ini: 0,
                caption: ood.getResText("DataModel.rows") || "",
                action: function () {
                    this.boxing().refresh();
                }
            }
        },
        EventHandlers: {
            onCmd: null,
            onMoreClick: function (profile, item, e, src) {
            },
            onTitleClick: function (profile, item, e, src) {
            },
            touchstart: function (profile, item, e, src) {
            },
            touchmove: function (profile, item, e, src) {
            },
            touchend: function (profile, item, e, src) {
            },
            touchcancel: function (profile, item, e, src) {
            },

            swipe: function (profile, item, e, src) {
            },
            swipeleft: function (profile, item, e, src) {
            },
            swiperight: function (profile, item, e, src) {
            },
            swipeup: function (profile, item, e, src) {
            },
            swipedown: function (profile, item, e, src) {
            },


            press: function (profile, item, e, src) {
            },
            pressup: function (profile, item, e, src) {
            }
        },
        _prepareData: function (profile) {
            var d = arguments.callee.upper.call(this, profile), p = profile.properties, ns = this;
            if (p.cols) d._itemscls1 = profile.getClass('ITEMS', '-nowrap');

            ood.arr.each(d.items, function (item) {
                var index = item.index;
                if (!index) {
                    index = ood.arr.indexOf(d.items, item);
                }
                profile.boxing()._autoColor(item, index, p);
            })

            return d;
        },





        _prepareItem: function (profile, item, oitem, pid, index, len) {
            var p = profile.properties,
                cols = p.columns,
                rows = p.rows,
                auto1 = item.autoItemSize || p.autoItemSize,
                t;

            profile.boxing()._autoColor(item, index, p);
            ood.arr.each(ood.toArr('itemWidth,position,itemHeight,imgWidth,imgHeight,itemPadding,itemMargin,iconFontSize,iconColor,fontColor,itemColor'), function (i) {
                item[i] = ood.isSet(item[i]) ? item[i] : p[i];
            });


            item.itemWidth = (!auto1 && (t = item.itemWidth)) ? profile.$forceu(t) : '';
            item.itemHeight = (!auto1 && (t = item.itemHeight)) ? profile.$forceu(t) : '';
            item.itemMargin = (t = item.itemMargin) ? profile.$forceu(t) : 0;
            item.itemPadding = (t = item.itemPadding) ? profile.$forceu(t) : 0;
            item._tabindex = p.tabindex;

            if (item.title) {
                item._title = item.title;
            } else if (item.caption) {
                item._title = item.caption;
            }

            if (p.flagClass && !item.flagClass) {
                item.flagClass = p.flagClass;
            }
            if (p.flagStyle && !item.flagStyle) {
                item.flagStyle = p.flagStyle;
            }
            if (p.flagText && !item.flagText) {
                item.flagText = p.flagText;
            }
            //      if (t = item.iconFontSize) item._fontSize = "font-size:" + t;

            item._imageClass = '';
            if (!item.iconFontCode && !item.imageClass) item._imageClass += 'ood-icon-loading';

            if (item.imageClass) {
                item._imageClass += ' ' + item.imageClass;
            } else {
                item._imageClass = ' icon1';
            }


            if (item.flagText || item.flagClass) item._flagStyle = 'display:block';
            if (!item.flagClass) item.flagClass = 'ood-uiflag-1';

            item._itemSize = '';
            if (cols)
                item._itemSize += 'width:' + (100 / cols + '%') + ';border:0;margin-left:0;margin-right:0;padding-left:0;padding-right:0;';
            if (rows)
                item._itemSize += 'height:' + (100 / rows + '%') + ';border:0;margin-top:0;margin-bottom:0;padding-top:0;padding-bottom:0;';

        }
        ,
        RenderTrigger: function () {

            this.boxing()._afterInsertItems(this);
        }
    }
});
ood.Class("ood.UI.Panel", "ood.UI.Div", {
    Instance: {
        //  iniProp 

        iniProp: {
            caption: '',
            dock: 'none',
            width: '18em',
            height: '18em',
            toggleBtn: true,
            closeBtn: true,
            refreshBtn: true
        },


        activate: function () {
            var profile = this.get(0);
            profile.getSubNode('CAPTION').focus(true);
            return this;
        },

        getAllFormValues: function (isAll) {
            var a = this.getChildren(),
                elems = ood.absValue.pack(a),
                formValue = {},
                profile = this.get(0);
            ood.arr.each(profile.children, function (o) {
                var oo = o[0].boxing(), name = oo.getProperties().name || o[0].alias;
                if (oo.Class['ood.UI.Tabs']) {
                    ood.merge(formValue, oo.getAllFormValues(isAll), 'all')
                    //formValue[name] = oo.getAllFormValues();
                } else if (oo.Class['ood.UI.Block'] || oo.Class["ood.UI.Panel"] || oo.Class["ood.UI.Layout"]) {
                    ood.merge(formValue, oo.getAllFormValues(isAll), 'all')
                } else if (oo.getFormValues) {
                    ood.merge(formValue, oo.getFormValues(isAll), 'all')
                } else if (oo.getUIValue) {
                    formValue[name] = oo.getUIValue();
                } else if (oo.getValue) {
                    formValue[name] = oo.getValue();
                }
            });

            return formValue;
        },

        resetPanelView: function (removeChildren, destroyChildren) {
            if (!ood.isSet(removeChildren)) removeChildren = true;
            if (!ood.isSet(destroyChildren)) destroyChildren = true;
            var ins;
            return this.each(function (profile) {
                if (profile.renderId) {
                    delete profile.$ini;
                    if (removeChildren) {
                        ins = profile.boxing();
                        ins.removeChildren(true, destroyChildren);
                    }
                    if (profile.properties.toggle)
                        ins.setToggle(false);
                }
            });
        },
        iniPanelView: function () {
            return this.each(function (profile) {
                if (!profile.$ini) {
                    profile.$ini = true;
                    var p = profile.properties;
                    if (profile.onIniPanelView) profile.boxing().onIniPanelView(profile);
                    if (p.iframeAutoLoad || p.ajaxAutoLoad)
                        ood.UI.Div._applyAutoLoad(profile);
                }
            });
        },

        // Set theme - CSS
        setTheme: function (theme) {
            return this.each(function (profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();

                // 
                root.removeClass('panel-dark panel-hc');

                // 
                if (theme === 'dark') {
                    root.addClass('panel-dark');
                } else if (theme === 'high-contrast') {
                    root.addClass('panel-hc');
                }

                // 
                profile.boxing()._checkResponsiveLayout();

                // 
                if (typeof localStorage !== 'undefined') {
                    localStorage.setItem('panel-theme', theme);
                }
            });
        },

        // Get current theme
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('panel-theme') || 'light';
        },


        // Modern initialization trigger - 
        PanelTrigger: function () {
            var profile = this.get(0);
            var prop = profile.properties;
            var self = this;

            this._initPanel();
            return this;
        },

        // 
        _initPanel: function () {
            var profile = this.get(0);
            var prop = profile.properties;
            var self = this;

            // 
            var theme = prop.theme || localStorage.getItem('panel-theme') || 'light';
            this.setTheme(theme);

            // 
            if (prop.responsive !== false) {
                // 
                this._checkResponsiveLayout();

                // 
                var resizeHandler = function () {
                    self._checkResponsiveLayout();
                };
                //
                // // OOD
                // var eventId = 'resize.' + profile.serialId;
                // ood.Event.off(window, eventId);
                // ood.Event.on(window, eventId, resizeHandler);
                //
                // // handler
                // profile._resizeHandler = resizeHandler;
            }

            // 
            this.enhanceAccessibility();
        },

        // Toggle dark mode
        toggleDarkMode: function () {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
        },

        //  - CSS
        _checkResponsiveLayout: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width;

                // 
                root.removeClass('panel-mobile panel-tiny');

                // 
                if (width < 400) {
                    root.addClass('panel-tiny');
                } else if (width < 600) {
                    root.addClass('panel-mobile');
                }
            });
        },

        // Responsive layout adjustment - 
        adjustLayout: function () {
            return this._checkResponsiveLayout();
        },

        // Enhance accessibility support
        enhanceAccessibility: function () {
            return this.each(function (profile) {
                var caption = profile.getSubNode('CAPTION'),
                    panel = profile.getSubNode('PANEL'),
                    buttons = ['INFO', 'OPT', 'CLOSE', 'POP', 'REFRESH', 'TOGGLE'];

                // Add ARIA attributes to panel
                caption.attr({
                    'role': 'heading',
                    'aria-level': '2',
                    'tabindex': '0'
                });

                panel.attr({
                    'role': 'region',
                    'aria-labelledby': caption.id()
                });

                // Add ARIA labels and keyboard support for buttons
                ood.arr.each(buttons, function (btnName) {
                    var btn = profile.getSubNode(btnName);
                    if (btn && !btn.isEmpty()) {
                        var label = btnName.toLowerCase();
                        var ariaLabel = {
                            'info': ood.getRes('UI.panel.showInfo'),
                            'opt': ood.getRes('UI.panel.showOptions'),
                            'close': ood.getRes('UI.panel.close'),
                            'pop': ood.getRes('UI.panel.pop'),
                            'refresh': ood.getRes('UI.panel.refresh'),
                            'toggle': ood.getRes('UI.panel.toggle')
                        }[label] || label + ' button';

                        btn.attr({
                            'role': 'button',
                            'aria-label': ariaLabel,
                            'tabindex': '0'
                        });
                    }
                });


                caption.on('keydown', function (e) {
                    if (e.keyCode === 13 || e.keyCode === 32) { // Enter or Space
                        // Toggle panel expand/collapse state
                        if (profile.properties.toggleBtn) {
                            profile.getSubNode('TOGGLE').click();
                        }
                        e.preventDefault();
                    }
                });
            });
        }
    },
    Static: {
        Templates: {
            tagName: 'div',
            style: '{_style}',
            className: '{_className}',
            BORDER: {
                tagName: 'div',
                className: 'ood-uiborder-outset ood-uiborder-box ood-uiborder-radius-big',
                TBAR: {
                    tagName: 'div',
                    className: 'ood-uibar-top',
                    BARTDL: {
                        className: 'ood-uibar-tdl ood-uibar ood-uiborder-radius-big-tl',
                        BARTDLT: {
                            className: 'ood-uibar-tdlt'
                        }
                    },
                    BARTDM: {
                        $order: 1,
                        className: 'ood-uibar-tdm ood-uibar',
                        BARTDMT: {
                            className: 'ood-uibar-tdmt'
                        }
                    },
                    BARTDR: {
                        $order: 2,
                        className: 'ood-uibar-tdr ood-uibar ood-uiborder-radius-big-tr',
                        BARTDRT: {
                            className: 'ood-uibar-tdrt'
                        }
                    },
                    BARCMDL: {
                        $order: 3,
                        tagName: 'div',
                        className: 'ood-uibar-cmdl',
                        style: '{_align}',
                        LTAGCMDS: {
                            tagName: 'span',
                            className: 'ood-ltag-cmds',
                            style: '{_ltagDisplay}',
                            text: "{ltagCmds}"
                        },
                        TOGGLE: {
                            $order: 1,
                            className: 'oodfont',
                            $fonticon: '{_fi_toggleCls2}',
                            style: '{toggleDisplay}',
                            $order: 0
                        },
                        ICON: {
                            $order: 2,
                            className: 'oodcon {imageClass}  {picClass}',
                            style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{imageDisplay}{iconStyle}',
                            text: '{iconFontCode}'
                        },
                        CAPTION: {
                            tabindex: '{tabindex}',
                            className: "ood-title-node",
                            text: '{caption}',
                            $order: 3
                        }
                    },
                    BARCMDR: {
                        $order: 4,
                        tagName: 'div',
                        className: 'ood-uibar-cmdr',
                        RTAGCMDS: {
                            $order: 0,
                            tagName: 'span',
                            className: 'ood-rtag-cmds',
                            style: '{_rtagDisplay}',
                            text: "{rtagCmds}"
                        },
                        INFO: {
                            className: 'oodcon',
                            $fonticon: 'ood-uicmd-info',
                            style: '{infoDisplay}',
                            $order: 1
                        },
                        OPT: {
                            className: 'oodcon',
                            $fonticon: 'ood-uicmd-opt',
                            style: '{optDisplay}',
                            $order: 2
                        },
                        POP: {
                            className: 'oodcon',
                            $fonticon: 'ood-uicmd-pop',
                            style: '{popDisplay}',
                            $order: 3
                        },
                        REFRESH: {
                            className: 'oodcon',
                            $fonticon: 'ood-uicmd-refresh',
                            style: '{refreshDisplay}',
                            $order: 4
                        },
                        CLOSE: {
                            className: 'oodcon',
                            $fonticon: 'ood-uicmd-close',
                            style: '{closeDisplay}',
                            $order: 5
                        }
                    }
                },
                MAIN: {
                    $order: 2,
                    tagName: 'div',
                    className: 'ood-uicon-main ood-uibar',
                    style: "{_leftp}",
                    MAINI: {
                        tagName: 'div',
                        className: 'ood-uicon-maini ood-uibar',
                        style: "{_rightp}",
                        PANEL: {
                            tagName: 'div',
                            className: 'ood-uibase ood-uicontainer {_bordertype}',
                            style: '{panelDisplay};{_panelstyle};{_overflow};',
                            text: '{html}' + ood.UI.$childTag
                        }
                    }
                },
                BBAR: {
                    $order: 3,
                    tagName: 'div',
                    className: 'ood-uibar-bottom-s',
                    style: "{_bbarDisplay}",
                    BBARTDL: {
                        className: 'ood-uibar-tdl ood-uibar ood-uiborder-radius-big-bl'
                    },
                    BBARTDM: {
                        $order: 1,
                        className: 'ood-uibar-tdm ood-uibar'
                    },
                    BBARTDR: {
                        $order: 2,
                        className: 'ood-uibar-tdr ood-uibar ood-uiborder-radius-big-br'
                    }
                }
            },
            $submap: ood.UI.$getTagCmdsTpl()
        },
        // Appearances - panel-themes.css
        Appearances: {
            KEY: {
                background: 'transparent'
            },
            'KEY BORDER': {
                zoom: ood.browser.ie6 ? 1 : null
            },
            'MIN:hover, MAX:hover,  INFO:hover, OPT:hover, REFRESH:hover, PIN:hover, LAND:hover': {
                'background-color': 'rgba(0,0,0,0.1)',
                'color': 'var(--ood-success)',
                'transform': 'scale(1.1)'
            },
            'CLOSE:hover': {
                'background-color': 'var(--ood-error)',
                'color': 'var(--ood-text-inverse)'
            },
            PANEL: {
                position: 'relative',
                left: 0,
                top: 0,
                overflow: 'auto',
                zoom: ood.browser.ie6 ? 1 : null
            },
            CAPTION: {
                display: 'inline',
                'vertical-align': ood.browser.ie6 ? 'baseline' : 'middle'
            }
        },
        Behaviors: {
            DroppableKeys: ['PANEL'],
            PanelKeys: ['PANEL'],
            DraggableKeys: ['TBAR'],
            NavKeys: {CAPTION: 1},
            NoDraggableKeys: ['INFO', 'OPT', 'CLOSE', 'POP', 'REFRESH', 'TOGGLE', 'CMD', 'TOGGLE'],
            HoverEffected: {
                INFO: 'INFO',
                OPT: 'OPT',
                CLOSE: 'CLOSE',
                POP: 'POP',
                REFRESH: 'REFRESH',
                CMD: 'CMD',
                TOGGLE: 'TOGGLE',
                ICON: 'ICON'
            },
            ClickEffected: {
                INFO: 'INFO',
                OPT: 'OPT',
                CLOSE: 'CLOSE',
                POP: 'POP',
                REFRESH: 'REFRESH',
                CMD: 'CMD',
                TOGGLE: 'TOGGLE'
            },
            TOGGLE: {
                onClick: function (profile, e, src) {
                    if (profile.properties.toggleBtn) {
                        profile.box._toggle(profile, !profile.properties.toggle);
                        return false;
                    }
                }
            },
            CAPTION: {
                onClick: function (profile, e, src) {
                    if (!profile.onClickBar || false === profile.boxing().onClickBar(profile, src))
                        return ood.Event.getKey(e).shiftKey;
                }
            },
            PANEL: {
                onClick: function (profile, e, src) {
                    var p = profile.properties;
                    if (p.disabled) return false;
                    if (profile.onClickPanel)
                        return profile.boxing().onClickPanel(profile, e, src);
                }
            },

            INFO: {
                onClick: function (profile, e, src) {
                    profile.boxing().onShowInfo(profile, e, src);
                }
            },
            OPT: {
                onClick: function (profile, e, src) {
                    profile.boxing().onShowOptions(profile, e, src);
                }
            },
            REFRESH: {
                onClick: function (profile, e, src) {
                    profile.boxing().onRefresh(profile);
                }
            },
            CLOSE: {
                onClick: function (profile, e, src) {
                    var properties = profile.properties;
                    if (properties.disabled) return;
                    var instance = profile.boxing();

                    if (false === instance.beforeClose(profile)) return;

                    instance.destroy();
                }
            },
            POP: {
                onClick: function (profile, e, src) {
                    var properties = profile.properties;
                    if (properties.disabled) return;
                    var pos = profile.getRoot().offset(), size = profile.getRoot().cssSize(),
                        options = {
                            parent: null,
                            host: null,
                            properties: null,
                            events: null,
                            CS: null,
                            CC: null,
                            CB: null,
                            CF: null,
                            init: null
                        };

                    if (profile.beforePop && false == profile.boxing().beforePop(profile, options, e, src))
                        return false;

                    var pro = ood.copy(ood.UI.Dialog.$DataStruct),
                        events = {};
                    ood.merge(pro, properties, 'with');
                    ood.merge(pro, {
                        dock: 'none',
                        width: Math.max(size.width, 200),
                        height: Math.max(size.height, 100),
                        left: pos.left,
                        top: pos.top,
                        landBtn: true
                    }, 'all');
                    if (options.properties)
                        ood.merge(pro, options.properties, 'with');

                    if (options.events)
                        ood.merge(events, options.events, 'all');

                    var dialog = new ood.UI.Dialog(pro, events, options.host || profile.host, options.CS || null, options.CC || null, options.CB || null, options.CF || null);

                    if (ood.isFun(options.init) && false === options.init(dialog, profile, options)) {
                    } else {
                        dialog.show(options.parent || ood('body'));
                        var arr = [];
                        ood.arr.each(profile.children, function (o) {
                            arr.push(o[0]);
                        });
                        if (arr.length) {
                            dialog.append(ood.UI.pack(arr, false));
                        }
                        profile.boxing().removeChildren().destroy(true);
                    }
                }
            },
            CMD: {
                onClick: function (profile, e, src) {
                    var prop = profile.properties;
                    if (prop.disabled) return false;
                    if (profile.onCmd)
                        profile.boxing().onCmd(profile, ood.use(src).id().split('_')[1], e, src);
                    return false;
                }
            }
        },
        DataModel: {
            // 
            theme: {
                ini: 'dark',
                listbox: ['light', 'dark', 'high-contrast'],
                action: function (v) {
                    this.boxing().setTheme(v);
                },
                caption: ood.getResText("DataModel.theme") || ""
            },
            // 
            responsive: {
                ini: true,
                action: function (v) {
                    if (v) {
                        this.boxing().adjustLayout();
                        // resize
                        ood.Event.on(window, 'resize.' + this.get(0).serialId, this.boxing().adjustLayout.bind(this.boxing()));
                    } else {
                        // resize
                        ood.Event.off(window, 'resize.' + this.get(0).serialId);
                    }
                },
                caption: ood.getResText("DataModel.responsiveDesign") || ""
            },
            rotate: {
                ini: null,
                caption: ood.getResText("DataModel.rotation") || ""
            },
            selectable: {
                ini: true,
                caption: ood.getResText("DataModel.selectable") || ""
            },
            dock: {
                ini: 'fill',
                caption: ood.getResText("DataModel.dockMode") || ""
            },
            caption: {
                ini: undefined,
                // ui update function when setCaption
                action: function (v) {
                    v = (ood.isSet(v) ? v : "") + "";
                    this.getSubNode('CAPTION').html(ood.adjustRes(v, true));
                },
                caption: ood.getResText("DataModel.title") || ""
            },
            html: {
                action: function (v, ov, force) {
                    this.getSubNode('PANEL').html(ood.adjustRes(v, 0, 1), null, null, force);
                },
                caption: ood.getResText("DataModel.htmlContent") || "HTML"
            },
            toggle: {
                ini: true,
                action: function (v) {
                    this.box._toggle(this, v);
                },
                caption: ood.getResText("DataModel.toggle") || ""
            },
            image: {
                format: 'image',
                action: function (v) {
                    ood.UI.$iconAction(this);
                },
                caption: ood.getResText("DataModel.image") || ""
            },
            imagePos: {
                action: function (value) {
                    this.getSubNode('ICON').css('backgroundPosition', value || 'center');
                },
                caption: ood.getResText("DataModel.imagePosition") || ""
            },
            imageBgSize: {
                action: function (value) {
                    this.getSubNode('ICON').css('backgroundSize', value || '');
                },
                caption: ood.getResText("DataModel.imageBackgroundSize") || ""
            },
            imageClass: {
                ini: '',
                action: function (v, ov) {
                    ood.UI.$iconAction(this, 'ICON', ov);
                },
                caption: ood.getResText("DataModel.imageClass") || ""
            },
            iconFontCode: {
                action: function (v) {
                    ood.UI.$iconAction(this);
                },
                caption: ood.getResText("DataModel.iconFontCode") || ""
            },
            borderType: {
                ini: 'inset',
                listbox: ['none', 'flat', 'inset', 'outset'],
                action: function (v) {
                    var ns = this,
                        p = ns.properties,
                        node = ns.getSubNode('PANEL'),
                        reg = /^ood-uiborder-/,
                        pretag = 'ood-uiborder-',
                        root = ns.getRoot();
                    node.removeClass(reg);
                    node.addClass(pretag + v);

                    //force to resize
                    ns.adjustSize();
                },
                caption: ood.getResText("DataModel.borderType") || ""
            },
            noFrame: {
                ini: false,
                action: function (v) {
                    var ns = this, root = ns.getRoot();
                    ns.getSubNode('BBAR').css('display', v ? 'none' : '');
                    ns.getSubNode('MAIN').css('paddingLeft', v ? '0' : '');
                    ns.getSubNode('MAINI').css('paddingRight', v ? '0' : '').css('backgroundImage', v ? 'none' : '');
                    //force to resize
                    ns.adjustSize();
                },
                caption: ood.getResText("DataModel.noFrame") || ""
            },
            hAlign: {
                ini: 'left',
                listbox: ['left', 'center', 'right'],
                action: function (v) {
                    this.getSubNode("BARCMDL").css('textAlign', v);
                },
                caption: ood.getResText("DataModel.horizontalAlign") || ""
            },
            toggleIcon: {
                listbox: ['ood-uicmd-toggle', 'ood-uicmd-check'],
                ini: 'ood-uicmd-toggle',
                action: function (v, ov) {
                    this.getSubNode('TOGGLE').replaceClass(new RegExp("\\b" + ov, 'img'), v);
                },
                caption: ood.getResText("DataModel.toggleIcon") || ""
            },

            infoBtn: {
                ini: false,
                action: function (v) {
                    this.getSubNode('INFO').css('display', v ? '' : 'none');
                },
                caption: ood.getResText("DataModel.infoButton") || ""
            },
            optBtn: {
                ini: false,
                action: function (v) {
                    this.getSubNode('OPT').css('display', v ? '' : 'none');
                },
                caption: ood.getResText("DataModel.optionButton") || ""
            },
            toggleBtn: {
                ini: false,
                action: function (v) {
                    this.getSubNode('TOGGLE').css('display', v ? '' : 'none');
                },
                caption: ood.getResText("DataModel.toggleButton") || ""
            },
            closeBtn: {
                ini: false,
                action: function (v) {
                    this.getSubNode('CLOSE').css('display', v ? '' : 'none');
                },
                caption: ood.getResText("DataModel.closeButton") || ""
            },
            refreshBtn: {
                ini: false,
                action: function (v) {
                    this.getSubNode('REFRESH').css('display', v ? '' : 'none');
                },
                caption: ood.getResText("DataModel.refreshButton") || ""
            },
            popBtn: {
                ini: false,
                action: function (v) {
                    this.getSubNode('POP').css('display', v ? '' : 'none');
                },
                caption: ood.getResText("DataModel.popButton") || ""
            },
            tagCmds: {
                ini: [],
                action: function () {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.labelCommand") || ""
            }
        },
        RenderTrigger: function () {
            var self = this;

            //force to resize
            self.boxing().adjustSize();

            // 
            self.boxing().PanelTrigger();
        },
        LayoutTrigger: function () {
            var self = this, t = self.properties;
            if (!t.toggle) {
                self.box._toggle(self, false, true);
            } else {
                // for default expand container
                self.boxing().iniPanelView();
            }

            // 
            self.boxing().PanelTrigger();


        },

        EventHandlers: {
            onIniPanelView: function (profile) {
            },
            beforeFold: function (profile) {
            },
            beforeExpand: function (profile) {
            },
            afterFold: function (profile) {
            },
            afterExpand: function (profile) {
            },
            onClickBar: function (profile, src) {
            },
            onClickPanel: function (profile, e, src) {
            },

            beforePop: function (profile, options, e, src) {
            },
            beforeClose: function (profile) {
            },
            onShowInfo: function (profile, e, src) {
            },
            onShowOptions: function (profile, e, src) {
            },
            onRefresh: function (profile) {
            },
            onCmd: function (profile, cmdkey, e, src) {
            }
        },
        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile),
                nodisplay = 'display:none';

            data._bordertype = 'ood-uiborder-' + data.borderType;
            data._bbarDisplay = data.noFrame ? nodisplay : "";
            data._leftp = data.noFrame ? "padding-left:0;" : "";
            data._rightp = data.noFrame ? "padding-right:0;background-image:none;" : "";

            data.toggleDisplay = data.toggleBtn ? '' : nodisplay;
            data.panelDisplay = data.toggleBtn && !data.toggle ? nodisplay : '';
            data._fi_toggleCls2 = data.toggleIcon + (data.toggleBtn && data.toggle ? ' oodfont-checked ' + data.toggleIcon + '-checked' : '');
            profile._toggle = !!data.toggle;

            data.infoDisplay = data.infoBtn ? '' : nodisplay;
            data.optDisplay = data.optBtn ? '' : nodisplay;
            data.closeDisplay = data.closeBtn ? '' : nodisplay;
            data.popDisplay = data.popBtn ? '' : nodisplay;
            data.refreshDisplay = data.refreshBtn ? '' : nodisplay;

            data._align = 'text-align:' + data.hAlign + ';';

            if (!ood.isEmpty(data.tagCmds))
                this._prepareCmds(profile, data);

            return data;
        },
        _toggle: function (profile, value, ignoreEvent) {
            var p = profile.properties, ins = profile.boxing();

            //event
            if (value) {
                ins.iniPanelView();
            }
            if (ignoreEvent || profile._toggle !== !!value) {
                //set toggle mark
                profile._toggle = p.toggle = !!value;
                if (!ignoreEvent) {
                    if (value) {
                        if (ins.beforeExpand && false === ins.beforeExpand(profile)) return;
                    } else {
                        if (ins.beforeFold && false === ins.beforeFold(profile)) return;
                    }
                }
                //chang toggle button
                if (p.toggleBtn)
                    profile.getSubNode('TOGGLE').tagClass('-checked', !!value);

                // use onresize function
                profile.adjustSize(true);

                if (!ignoreEvent) {
                    if (value) {
                        if (ins.afterExpand)
                            ins.afterExpand(profile);
                    } else {
                        if (ins.afterFold)
                            ins.afterFold(profile);
                    }
                }
                // try redock
                if (p.dock && p.dock != 'none') {
                    ins.adjustDock(true);
                }
            }
        },
        _onresize: function (profile, width, height) {
            var prop = profile.properties,
                // compare with px
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                root = profile.getRoot();

            var isize = {},
                noFrame = prop.noFrame,
                border = profile.getSubNode('BORDER'),
                v1 = profile.getSubNode('TBAR'),
                panel = profile.getSubNode('PANEL'),
                v4 = profile.getSubNode('BBAR'),
                v5 = profile.getSubNode('MAIN'),
                v6 = profile.getSubNode('MAINI'),
                fzrate = profile.getEmSize() / root._getEmSize(),
                panelfz = panel._getEmSize(fzrate),

                cb1 = border.contentBox(),
                h0 = border._borderH(),
                cb2 = panel.contentBox(),
                bordersize = profile.properties.borderType != 'none' ? panel._borderW() : 0,
                h1, h4, t;

            // caculate by px
            if (width && width != 'auto') width = profile.$px(width, null, true);
            if (height && height != 'auto') height = profile.$px(height, null, true);

            if (height) {
                if (profile._toggle) {
                    panel.css('display', '');
                } else {
                    panel.css('display', 'none');
                }
                if (height == 'auto') {
                    root.height(isize.height = 'auto');
                } else {
                    if (profile._toggle) {
                        //force to get height
                        h1 = v1.offsetHeight(true);
                        h4 = noFrame ? 0 : v4.offsetHeight(true);
                        if ((t = height - h0 - h1 - h4) > 0)
                            isize.height = adjustunit(t - (cb2 ? bordersize : 0), panelfz);

                        border.height(adjustunit(height - (cb1 ? h0 : 0), border));
                        root.height(adjustunit(height));
                    } else {
                        border.height('auto');
                        root.height('auto');
                    }
                }
            }
            if (width) {
                isize.width = adjustunit(width
                    - (noFrame ? 0 : (Math.round(parseFloat(v6.css('paddingRight'))) || 0))
                    - (noFrame ? 0 : (Math.round(parseFloat(v5.css('paddingLeft'))) || 0))
                    - h0
                    - bordersize
                    - (v5._borderW())
                    - (v6._borderW())
                    , panelfz);
            }

            if (profile._toggle) {
                panel.cssSize(isize, true);
                if (width) {
                    ood.UI._adjustConW(profile, panel, isize.width);
                }
            }
        }
    }
});ood.Class("ood.UI.Group", "ood.UI.Panel",{
    Instance: {
        iniProp: {caption: '', toggleBtn: false, width: '18em'}
    },

    Static:{
        Templates:{
            tagName : 'div',
            style:'{_style}',
            className:'{_className}',
            BORDER:{
                tagName : 'div', // div
                className: '{_fieldCls} ood-group-container',
                TBAR:{
                    tagName : 'div',
                    style:'{_align} ',
                    className: 'ood-group-header',
                    BARCMDL:{
                        LTAGCMDS:{
                            tagName:'span',
                            className:'ood-ltag-cmds',
                            style:'{_ltagDisplay}',
                            text:"{ltagCmds}"
                        },
                        TOGGLE:{
                            $order:1,
                            className: 'oodfont ood-group-toggle',
                            $fonticon:'{_fi_toggleCls2}',
                            style:'{toggleDisplay}',
                            $order:0
                        },
                        ICON:{
                            $order:2,
                            className:'oodcon {imageClass} {picClass} ood-group-icon',
                            style:'{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{imageDisplay}{iconStyle}',
                            text:'{iconFontCode}'
                        },
                        CAPTION : {
                            tabindex: '{tabindex}',
                            className:"ood-title-node ood-group-caption",
                            text:   '{caption}',
                            $order:3
                        }
                    },
                    BARCMDR:{
                        $order:4,
                        tagName: 'div',
                        className:'ood-uibar-cmdr ood-uibase',
                        RTAGCMDS:{
                            $order:0,
                            tagName:'span',
                            className:'ood-rtag-cmds',
                            style:'{_rtagDisplay}',
                            text:"{rtagCmds}"
                        } ,
                        INFO:{className:'oodcon', $fonticon:'ood-uicmd-info', style:'{infoDisplay}', $order:1},
                        OPT:{className:'oodcon', $fonticon:'ood-uicmd-opt', style:'{optDisplay}', $order:2},
                        POP:{className:'oodcon', $fonticon:'ood-uicmd-pop', style:'{popDisplay}', $order:3},
                        REFRESH:{className:'oodcon', $fonticon:'ood-uicmd-refresh', style:'{refreshDisplay}', $order:4},
                        CLOSE:{className:'oodcon', $fonticon:'ood-uicmd-close', style:'{closeDisplay}', $order:5}
                    }
                },
                PANEL:{
                    $order:1,
                    tagName:'div',
                    style:'{panelDisplay};{_panelstyle};{_overflow};',
                    className:'ood-uicontainer ood-group-panel',
                    text:'{html}'+ood.UI.$childTag
                }
            },
            $submap:ood.UI.$getTagCmdsTpl()
        },
        Appearances:{
            KEY:{},
            BORDER:{
                position:'relative',
                overflow:'visible',
                backgroundColor: 'var(--ood-bg-card)',
                borderRadius: 'var(--ood-radius-md)',
                border: '1px solid var(--ood-border)',
                boxShadow: 'var(--ood-shadow-sm)',
                transition: 'all var(--ood-transition-normal)'
            },
            'LTAGCMDS, RTAGCMDS':{
                padding:0,
                margin:0,
                'vertical-align': 'middle'
            },
            'TBAR':{
                width: 'auto',
                padding: 'var(--ood-spacing-sm) var(--ood-spacing-md)',
                margin: 0,
                border: 0,
                'font-size': 'inherit',
                'border-bottom': '1px solid var(--ood-border)',
                cursor: 'pointer',
                transition: 'background-color var(--ood-transition-fast)',
                display: 'flex',
                'align-items': 'center',
                'justify-content': 'space-between',
                'background-color': 'var(--ood-bg-header)'
            },
            'TBAR:hover':{
                backgroundColor: 'var(--ood-bg-hover)'
            },
            'BORDER-checked TBAR':{
                'margin-left':'0'
            },
            'BORDER-checked BARCMDL':{
                'padding-left':'0'
            },
            'BARCMDL':{
                cursor:'default',
                'padding-right':'var(--ood-spacing-xs)',
                display:ood.$inlineBlock,
                'align-items': 'center',
                gap: 'var(--ood-spacing-sm)'
            },
            'PANEL':{
                position:'relative',
                overflow:'auto',
                'line-height':'normal',
                padding: 'var(--ood-spacing-md)',
                backgroundColor: 'var(--ood-bg)',
                transition: 'all var(--ood-transition-normal)',
            },
            'CAPTION':{
                display:'inline',
                'vertical-align':'middle',
                color: 'var(--ood-text-heading)',
                'font-weight': '500',
                'font-size': 'var(--ood-font-size-lg)'
            },
            'TOGGLE':{
                padding:'0 var(--ood-spacing-xs) 0 0',
                color: 'var(--ood-text-muted)',
                transition: 'transform var(--ood-transition-normal), color var(--ood-transition-fast)'
            },
            'TOGGLE-checked':{
                transform: 'rotate(180deg)',
                color: 'var(--ood-primary)'
            },
            'TOGGLE:hover':{
                color: 'var(--ood-text-heading)'
            },
            'ICON':{
                margin: '0 var(--ood-spacing-sm) 0 0',
                color: 'var(--ood-text-muted)'
            },
            'BARCMDR':{
                display: 'flex',
                'align-items': 'center',
                gap: 'var(--ood-spacing-xs)'
            },
            'BARCMDR .oodcon':{
                padding: 'var(--ood-spacing-xs)',
                borderRadius: 'var(--ood-radius-sm)',
                transition: 'all var(--ood-transition-fast)'
            },
            'BARCMDR .oodcon:hover':{
                backgroundColor: 'var(--ood-bg-hover)',
                color: 'var(--ood-text-heading)'
            }
        },
        DataModel:{
            expression:{ini:'',action:function () {}},
            euClassName:'',
            dock:'none',
            noFrame:null,
            borderType:null,
            toggleBtn:{ini:true},

            transitionDuration: {
                ini: 'normal', // fast, normal, slow
                action: function(value) {
                    var transitionMap = {'fast': 'var(--transition-fast)', 'normal': 'var(--transition-normal)', 'slow': 'var(--transition-slow)'},
                        duration = transitionMap[value] || transitionMap.normal,
                        profile = this.get(0),
                        border = profile.getSubNode('BORDER'),
                        tbar = profile.getSubNode('TBAR');
                     
                    if (border) border.css('transition', 'all ' + duration);
                    if (tbar) tbar.css('transition', 'background-color ' + duration);
                }
            },
            // 
            responsiveBreakpoint: {
                ini: 'md', // sm, md, lg, xl
                action: function(value) {
                    var profile = this.get(0),
                        border = profile.getSubNode('BORDER');
                    if (border) {
                        border.removeClass('responsive-sm responsive-md responsive-lg responsive-xl');
                        border.addClass('responsive-' + value);
                    }
                }
            },
            // 
            ariaLabel: {
                ini: '',
                action: function(value) {
                    var profile = this.get(0),
                        border = profile.getSubNode('BORDER');
                    if (border && value) {
                        border.attr('aria-label', value);
                    }
                }
            },
            // 
            tabIndex: {
                ini: 0,
                action: function(value) {
                    var profile = this.get(0),
                        tbar = profile.getSubNode('TBAR'),
                        caption = profile.getSubNode('CAPTION');
                    if (tbar) tbar.attr('tabindex', value);
                    if (caption) caption.attr('tabindex', value);
                }
            }
        },
        _prepareData:function(profile){
            var data=arguments.callee.upper.call(this, profile);
            if(!profile.properties.toggle)data.height="auto";
            data._fieldCls = data.toggleBtn && !data.toggle ? ' ood-group-collapsed' : '';
            
            // 
            if (data.transitionDuration) {
                var transitionMap = {'fast': 'var(--transition-fast)', 'normal': 'var(--transition-normal)', 'slow': 'var(--transition-slow)'},
                    duration = transitionMap[data.transitionDuration] || transitionMap.normal;
                data._transition = 'all ' + duration;
            }
            
            return data;
        },
        _toggle:function(profile, value, ignoreEvent){
            var p=profile.properties, ins=profile.boxing();

            //event
            if(value){
                ins.iniPanelView();
            }
            if(ignoreEvent || profile._toggle !== !!value){
                //set toggle mark
                profile._toggle = p.toggle = !!value;
                if(!ignoreEvent){
                    if(value){
                        if(ins.beforeExpand && false===ins.beforeExpand(profile))return;
                    }else{
                        if(ins.beforeFold && false===ins.beforeFold(profile))return;
                    }
                }
                //chang toggle button
                if(p.toggleBtn){
                    var toggleNode = profile.getSubNode('TOGGLE');
                    if (toggleNode) toggleNode.tagClass('-checked', !!value);
                }
                
                var border=profile.getSubNode('BORDER'),
                    panel=profile.getSubNode('PANEL');
                
                if(border){
                    border.toggleClass('ood-group-collapsed', !value);
                }
                
                // 
                if(panel){
                    if(value){
                        panel.css({'display': 'block', 'max-height': '0', 'opacity': '0'});
                        // 
                       //anel[0].offsetHeight;
                        panel.css({'max-height': '2000px', 'opacity': '1'});
                    }else{
                        panel.css({'max-height': '0', 'opacity': '0'});
                        // 
                        setTimeout(function(){
                            if(!profile._toggle){
                                panel.css('display', 'none');
                            }
                        }, 300);
                    }
                }
                
                // use onresize function
                profile.adjustSize(true);

                if(!ignoreEvent){
                    if(value){
                        if(ins.afterExpand) ins.afterExpand(profile);
                    }else{
                        if(ins.afterFold) ins.afterFold(profile);
                    }
                }
                // try redock
                if(p.dock && p.dock!='none'){
                    ins.adjustDock(true);
                }
            }
        },
        _onresize:function(profile,width,height){
            var prop=profile.properties,
                
                // compare with px
                us = ood.$us(profile),
                adjustunit = function(v,emRate){return profile.$forceu(v, us>0?'em':'px', emRate)},

                border = profile.getSubNode('BORDER'),
                panel =profile.getSubNode('PANEL'), 
                root = profile.getRoot(),
                cb = border.contentBox(),
                h0=border._borderH(),
                // caculate by px
                ww=width?profile.$px(width):null, 
                hh=height?profile.$px(height):null;
            
            if(height){
                if(height=='auto'){
                    if(panel) panel.height('auto');
                    if(border) border.height('auto');
                    if(root) root.height('auto');
                }else{
                    if(profile._toggle && panel && border && root){
                        panel.height(adjustunit(hh - profile.getSubNode('TBAR').offsetHeight(true) - h0/2, panel));
                        border.height(adjustunit(hh - (cb?h0:0), border));
                        root.height(adjustunit(hh));
                    }else if(!profile._toggle && border && root){
                        // here, panel's display is 'none'
                        border.height('auto');
                        root.height('auto');
                    }
                }
            }

            if(width && width!='auto' && ww>=2 && profile._toggle && panel){
                panel.width(ww = adjustunit(ww-2));
                ood.UI._adjustConW(profile, panel, ww);
            }
        },

        // 
        setTheme: function(profile, theme) {
            var border = profile.getSubNode('BORDER');
            if (border) {
                // 
                border.removeClass('group-themed-light group-themed-dark group-themed-highcontrast');
                // 
                if (theme === 'dark') {
                    border.addClass('group-themed-dark');
                } else if (theme === 'highcontrast') {
                    border.addClass('group-themed-highcontrast');
                } else {
                    border.addClass('group-themed-light');
                }
                // 
                border.addClass('group-themed');
            }
        },

        // 
        toggleTheme: function(profile) {
            var border = profile.getSubNode('BORDER');
            if (border) {
                var currentTheme = 'light';
                if (border.hasClass('group-themed-dark')) {
                    currentTheme = 'dark';
                } else if (border.hasClass('group-themed-highcontrast')) {
                    currentTheme = 'highcontrast';
                }
                
                var nextTheme = currentTheme === 'light' ? 'dark' : 
                               currentTheme === 'dark' ? 'highcontrast' : 'light';
                this.setTheme(profile, nextTheme);
                return nextTheme;
            }
        },

        // 
        enableKeyboardNavigation: function(profile) {
            var tbar = profile.getSubNode('TBAR'),
                caption = profile.getSubNode('CAPTION');
            
            if (tbar) {
                tbar.attr('tabindex', '0');
                tbar.on('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        profile._toggle(profile, !profile.properties.toggle);
                    }
                });
            }
            
            if (caption) {
                caption.attr('tabindex', '0');
            }
        },

        // 
        setScreenReaderLabel: function(profile, label) {
            var border = profile.getSubNode('BORDER');
            if (border) {
                border.attr('aria-label', label);
                
                // 
                var srText = border.find('.sr-only');
                if (srText.length === 0) {
                    border.append('<span class="sr-only">' + label + '</span>');
                } else {
                    srText.text(label);
                }
            }
        },

        // 
        updateResponsiveLayout: function(profile, breakpoint) {
            var border = profile.getSubNode('BORDER');
            if (border) {
                // 
                border.removeClass('responsive-sm responsive-md responsive-lg responsive-xl');
                // 
                border.addClass('responsive-' + breakpoint);
                // DataModel
                profile.properties.responsiveBreakpoint = breakpoint;
            }
        }
    }
});ood.Class("ood.UI.PageBar", ["ood.UI", "ood.absValue"], {

    Instance: {
        //  iniProp 
        iniProp: {
            caption: '$RAD.widgets.pagination'
        },

        _setCtrlValue: function (value) {
            return this.each(function (profile) {
                if (!profile.renderId) return;
                var t,
                    prop = profile.properties,
                    hidemore = !prop.showMoreBtns,
                    arr = profile.box._v2a(value),
                    min = arr[0],
                    cur = arr[1],
                    max = arr[2],
                    keys = profile.keys,
                    fun = function (p, k) {
                        return p.getSubNode(k)
                    },

                    first = fun(profile, 'FIRST'),
                    prev = fun(profile, 'PREV'),
                    prem = fun(profile, 'PREM'),
                    current = fun(profile, 'CUR'),
                    next = fun(profile, 'NEXT'),
                    nextm = fun(profile, 'NEXTM'),
                    last = fun(profile, 'LAST'),

                    change = function (n, i, j, k, t) {
                        if (i) {
                            n.attr('href', prop.uriTpl.replace('*', i));
                            n.attr('title', i);
                        } else if (t) {
                            n.attr('title', t);
                        }
                        if (ood.isSet(j))
                            n.html(prop.textTpl.replace('*', j), false);

                        if (ood.isSet(k))
                            n.get(0)._real_page = k;
                    },
                    display = function (n, f) {
                        n.css('display', f ? '' : 'none')
                    }
                ;
                //change href and text
                change(first, min, min);
                change(prem, '', '..' + ood.str.repeat('.', String(cur - 1 - min).length), 1, (min + 1) + "~" + (cur - 2));
                change(prev, cur - 1, prop.prevMark || (cur - 1));
                current.get(0).value = cur + "";
                change(next, cur + 1, prop.nextMark || (cur + 1));
                change(nextm, '', '..' + ood.str.repeat('.', String(max - cur - 1).length), 1, (cur + 2) + "~" + (max - 1));
                change(last, max, max);

                //show or hide
                if ((t = cur - min) <= 0) {
                    display(first, 0);
                    display(prem, 0);
                    display(prev, 0);
                } else if (t == 1) {
                    display(first, 1);
                    display(prem, 0);
                    display(prev, 0);
                } else if (t == 2) {
                    display(first, 1);
                    display(prem, 0);
                    display(prev, 1);
                    change(prev, cur - 1, cur - 1);
                } else {
                    display(first, 1);
                    display(prem, hidemore ? 0 : 1);
                    display(prev, 1);
                    if (t == 3) {
                        change(prev, cur - 1, cur - 1);
                        change(prem, cur - 2, cur - 2, 0);
                    }
                }
                if ((t = max - cur) <= 0) {
                    display(last, 0);
                    display(nextm, 0);
                    display(next, 0);
                } else if (t == 1) {
                    display(last, 1);
                    display(nextm, 0);
                    display(next, 0);
                } else if (t == 2) {
                    display(last, 1);
                    display(nextm, 0);
                    display(next, 1);
                    change(next, cur + 1, cur + 1);
                } else {
                    display(last, 1);
                    display(nextm, hidemore ? 0 : 1);
                    display(next, 1);
                    if (t == 3) {
                        change(next, cur + 1, cur + 1);
                        change(nextm, cur + 2, cur + 2, 0);
                    }
                }
            });
        },
        setPage: function (value, force, type) {
            return this.each(function (o) {
                if (!/^[1-9]\d*$/.test(value + "")) return;

                var p = o.properties,
                    pc = p.pageCount,
                    v = (p.$UIvalue || p.value || "") + "",
                    a = v.split(':'),
                    b = parseInt(a[1], 10);

                if (value > parseInt(a[2], 10)) return;
                a[1] = parseInt(value, 10) || b;

                if (force || a[1] !== b) {
                    o.boxing().setUIValue(a.join(':'), false, false, 'page');
                    if (o.onPageSet) o.boxing().onPageSet(o, a[1], (a[1] - 1) * pc, pc, type || "code", b, (b - 1) * pc);
                }
            });
        },
        getPage: function (total) {
            var o = this.get(0),
                p = o.properties,
                v = (p.$UIvalue || p.value || "") + "",
                a = v.split(':');
            return a[total ? 2 : 1];
        },

        buindAPI: function (api) {
            this.api = api;
            return api;
        },

        getTotalPages: function () {
            return this.getPage(true);
        },
        setTotalCount: function (count) {
            if (!/^[1-9]\d*$/.test(count + "")) return this;
            count = parseInt(count, 10);
            return this.each(function (o) {
                var p = o.properties,
                    pc = parseInt(p.pageCount, 10),
                    max = parseInt((count + pc - 1) / pc, 10),
                    v = (p.$UIvalue || p.value || "") + "",
                    a = v.split(':');

                a[2] = max;
                if (parseInt(a[1], 10) > max) a[1] = 1;

                o.boxing().setUIValue(a.join(':'), false, false, 'settotal');
            });
        },
        
        // 
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot(),
                    first = profile.getSubNode('FIRST'),
                    prev = profile.getSubNode('PREV'),
                    prem = profile.getSubNode('PREM'),
                    current = profile.getSubNode('CUR'),
                    next = profile.getSubNode('NEXT'),
                    nextm = profile.getSubNode('NEXTM'),
                    last = profile.getSubNode('LAST'),
                    input = profile.getSubNode('CUR'),
                    label = profile.getSubNode('LABEL');
                // 
                var buttons = [first, prev, prem, next, nextm, last];
                // 
                root.removeClass('pagebar-dark pagebar-hc');

                if (theme === 'dark') {
                    // 
                    root.addClass('pagebar-dark');

                    // 
                    input.css({
                        'background-color': 'var(--dark-bg-input)',
                        'border-color': 'var(--dark-border)',
                        'color': 'var(--dark-text)'
                    });

                    // 
                    if (label && !label.isEmpty()) {
                        label.css({
                            'color': 'var(--dark-text)'
                        });
                    }


                    buttons.forEach(function(btn) {
                        if (btn && !btn.isEmpty()) {
                            btn.css({
                                'background-color': 'var(--dark-bg-btn)',
                                'border-color': 'var(--dark-border)',
                                'color': 'var(--dark-text)'
                            });
                        }
                    });
                } else if (theme === 'high-contrast') {
                    // 
                    root.addClass('pagebar-hc');

                    // 
                    input.css({
                        'background-color': 'var(--hc-bg-input)',
                        'border': '2px solid var(--hc-border)',
                        'color': 'var(--hc-text)',
                        'font-weight': 'bold'
                    });

                    // 
                    if (label && !label.isEmpty()) {
                        label.css({
                            'color': 'var(--hc-text)',
                            'font-weight': 'bold'
                        });
                    }

                    // 
                    buttons.forEach(function(btn) {
                        if (btn && !btn.isEmpty()) {
                            btn.css({
                                'background-color': 'var(--hc-bg-btn)',
                                'border': '2px solid var(--hc-border)',
                                'color': 'var(--hc-text)',
                                'font-weight': 'bold'
                            });
                        }
                    });
                } else {
                    //  ()
                    // 
                    input.css({
                        'background-color': 'var(--light-bg-input)',
                        'border-color': 'var(--light-border)',
                        'color': 'var(--light-text)'
                    });

                    // 
                    if (label && !label.isEmpty()) {
                        label.css({
                            'color': 'var(--light-text)'
                        });
                    }

                    // 
                    buttons.forEach(function(btn) {
                        if (btn && !btn.isEmpty()) {
                            btn.css({
                                'background-color': 'var(--light-bg-btn)',
                                'border-color': 'var(--light-border)',
                                'color': 'var(--light-text)'
                            });
                        }
                    });
                }
                
                // 
                window.localStorage.setItem('pagebar-theme', theme);
            });
        },

        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('pagebar-theme') || 'light';
        },

        // 
        toggleTheme: function() {
            var current = this.getTheme();
            var next = current === 'light' ? 'dark' : 
                      current === 'dark' ? 'high-contrast' : 'light';
            this.setTheme(next);
            return this;
        },


        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('pagebar-theme') || 'light';
        },
        
        // 
        toggleDarkMode: function() {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },
        
        // 
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    buttons = root.find('a.ood-ui-btn'),
                    input = profile.getSubNode('CUR'),
                    label = profile.getSubNode('LABEL'),
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('pagebar-mobile');
                    
                    // 
                    buttons.css({
                        'padding': '0.4em 0.6em',
                        'font-size': '0.9em',
                        'min-height': '36px'
                    });
                    
                    input.css({
                        'width': '3em',
                        'height': '36px',
                        'font-size': '0.9em'
                    });
                    
                    label.css({
                        'font-size': '0.9em'
                    });
                    
                    // 
                    if (width < 480) {
                        profile.getSubNode('PREM').css('font-size', '0.8em');
                        profile.getSubNode('NEXTM').css('font-size', '0.8em');
                    }
                } else {
                    root.removeClass('pagebar-mobile');

                    // 
                    buttons.css({
                        'padding': '',
                        'font-size': '',
                        'min-height': ''
                    });
                    
                    input.css({
                        'width': '',
                        'height': '',
                        'font-size': ''
                    });
                    
                    label.css({
                        'font-size': ''
                    });
                }

                // 
                if (width < 480) {
                    root.addClass('pagebar-tiny');
                    
                    // 
                    label.css({
                        'font-size': '0.8em'
                    });
                    
                    input.css({
                        'width': '2.5em',
                        'font-size': '0.8em'
                    });
                    
                    // 
                    if (!prop.showMoreBtns) {
                        profile.getSubNode('PREM').css('display', 'none');
                        profile.getSubNode('NEXTM').css('display', 'none');
                    }
                } else {
                    root.removeClass('pagebar-tiny');
                }
            });
        },
        
        // 
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    buttons = root.find('a.ood-ui-btn'),
                    input = profile.getSubNode('CUR'),
                    label = profile.getSubNode('LABEL'),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'navigation',
                    'aria-label': ''
                });
                
                // ARIA
                profile.getSubNode('FIRST').attr({
                    'role': 'button',
                    'aria-label': '',
                    'tabindex': '0'
                });
                
                profile.getSubNode('PREV').attr({
                    'role': 'button',
                    'aria-label': '',
                    'tabindex': '0'
                });
                
                profile.getSubNode('NEXT').attr({
                    'role': 'button',
                    'aria-label': '',
                    'tabindex': '0'
                });
                
                profile.getSubNode('LAST').attr({
                    'role': 'button',
                    'aria-label': '',
                    'tabindex': '0'
                });
                
                profile.getSubNode('PREM').attr({
                    'role': 'button',
                    'aria-label': '',
                    'tabindex': '0'
                });
                
                profile.getSubNode('NEXTM').attr({
                    'role': 'button',
                    'aria-label': '',
                    'tabindex': '0'
                });
                
                // ARIA
                input.attr({
                    'role': 'spinbutton',
                    'aria-label': '',
                    'aria-valuemin': '1',
                    'aria-valuemax': profile.boxing().getPage(true) || '1',
                    'aria-valuenow': profile.boxing().getPage() || '1'
                });
                
                // 
                if (label && !label.isEmpty()) {
                    var labelId = profile.serialId + '_label';
                    label.attr('id', labelId);
                    input.attr('aria-labelledby', labelId);
                }
            });
        },
        
        PageBarTrigger: function() {
            var profile = this.get(0);
            var prop = profile.properties;

            // 
            // 
            if (prop.theme) {
                this.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('pagebar-theme');
                if (savedTheme) {
                    this.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                this.adjustLayout();
            }

            // 
            this.enhanceAccessibility();
        }
    },
    Static: {
        Templates: {
            style: '{_style} {_hiddenBar}',
            className: '{_className}',
            POOL: {
                style: 'position:absolute;display:none;',
                POP: {
                    tagName: 'div',
                    className: 'ood-uibase ood-ui-reset ood-ui-ctrl'
                }
            },
            LABEL: {
                text: '{caption}'
            },
            FIRST: {
                $order: 1,
                tagName: "a",
                className: 'ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius',
                href: '#',
                tabindex: '{tabindex}'
            },
            PREM: {
                $order: 2,
                className: 'ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius',
                style: '{_css2}',
                tagName: 'a',
                href: '#',
                tabindex: '{tabindex}'
            },
            PREV: {
                $order: 3,
                className: 'ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius',
                tagName: 'a',
                href: '#',
                tabindex: '{tabindex}',
                text: '{prevMark}'
            },
            CUR: {
                $order: 4,
                className: 'ood-ui-input ood-ui-shadow-input ood-uiborder-flat ood-uiborder-radius ood-uibase',
                tagName: 'input',
                tabindex: '{tabindex}',
                style: '{_css}'
            },
            NEXT: {
                $order: 5,
                className: 'ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius',
                tagName: 'a',
                href: '#',
                tabindex: '{tabindex}',
                text: '{nextMark}'
            },
            NEXTM: {
                $order: 6,
                className: 'ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius',
                style: '{_css2}',
                tagName: 'a',
                href: '#',
                tabindex: '{tabindex}'
            },
            LAST: {
                $order: 7,
                className: 'ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius',
                tagName: 'a',
                href: '#',
                tabindex: '{tabindex}'
            }
        },
        Appearances: {
            LABEL: {
                padding: 'var(--spacing-xs) var(--spacing-sm) 0 var(--spacing-sm)',
                'vertical-align': 'top',
                'white-space': 'nowrap',
                color: 'var(--text)'
            },
            KEY: {
                display: 'inline',
                overflow: 'visible'
            },
            'KEY a:focus, POP a:focus': {
                'outline': '2px solid var(--rimary)',
                'outline-offset': '2px'
            },
            'KEY .ood-ui-btn, KEY .ood-ui-input, POP .ood-ui-btn': {
                'margin-right': 'var(--spacing-xs)',
                transition: 'all 0.2s ease'
            },
            CUR: {
                'font-weight': 'bold',
                'text-align': 'center',
                padding: 'var(--spacing-xs)',
                'width': '3em',
                'margin-top': '-1px',
                border: '1px solid var(--border)',
                'border-radius': 'var(--radius-sm)',
                background: 'var(--bg)',
                color: 'var(--text)'
            },
            POP: {
                border: '1px solid var(--border)',
                position: 'absolute',
                padding: 'var(--spacing-xs)',
                'line-height': '2.25em',
                background: 'var(--bg)',
                'border-radius': 'var(--radius-md)',
                'box-shadow': 'var(--shadow-md)'
            },
            // 
            '.pagebar-dark': {
                '--bg': 'var(--dark-bg)',
                '--text': 'var(--dark-text)',
                '--border': 'var(--dark-border)'
            },
            // 
            '.pagebar-mobile': {
                'font-size': '0.9em',
                '--spacing-xs': '0.4em',
                '--spacing-sm': '0.6em'
            },
            '.pagebar-tiny': {
                'font-size': '0.8em',
                '--spacing-xs': '0.3em',
                '--spacing-sm': '0.5em'
            }
        },
        Behaviors: {
            HoverEffected: {
                FIRST: 'FIRST',
                PREM: 'PREM',
                PREV: 'PREV',
                NEXT: 'NEXT',
                NEXTM: 'NEXTM',
                LAST: 'LAST',
                POPI: 'POPI',
                CUR: 'CUR'
            },
            ClickEffected: {
                FIRST: 'FIRST',
                PREM: 'PREM',
                PREV: 'PREV',
                NEXT: 'NEXT',
                NEXTM: 'NEXTM',
                LAST: 'LAST',
                POPI: 'POPI'
            },
            POP: {
                onClick: function (profile, e, src) {
                    var o = ood(src),
                        r = ood.Event.getSrc(e)
                    ;
                    o.setBlurTrigger(profile.key + ":" + profile.$xid, null);
                    profile.getSubNode('POOL').append(o);
                    if (r.tagName.toLowerCase() == 'a' || ((r = r.firstChild) && (r.tagName.toLowerCase() == 'a')) || ((r = r.firstChild) && (r.tagName.toLowerCase() == 'a')) || ((r = r.firstChild) && (r.tagName.toLowerCase() == 'a')))
                        return profile.box._click(profile, r);
                }
            },
            FIRST: {
                onClick: function (profile, e, src) {
                    return profile.box._click(profile, src);
                }
            },
            PREM: {
                onClick: function (profile, e, src) {
                    if (ood.use(src).get(0)._real_page) {
                        profile.box._show(profile, e, src, 0);
                        return false;
                    } else {
                        return profile.box._click(profile, src);
                    }
                }
            },
            PREV: {
                onClick: function (profile, e, src) {
                    return profile.box._click(profile, src);
                }
            },
            CUR: {
                onKeypress: function (profile, e, src) {
                    var k = ood.Event.getKey(e),
                        caret = ood.use(src).caret();
                    // if not positive integer, set back
                    if (!/^\d$/.test(k.key)) {
                        return false;
                    }
                    if (k.key === '0' && caret[0] === 0) {
                        return false;
                    }
                },
                onChange: function (profile, e, src) {
                    var p = profile.properties;
                    if (p.disabled || p.readonly) return;

                    var v = (p.$UIvalue || p.value || "") + "",
                        a = v.split(':'),
                        cur = parseInt(a[1] || "", 10),
                        max = parseInt(a[2] || "", 10),
                        value = ood.use(src).get(0).value || "";

                    // if not positive integer, set back
                    if (!/^[1-9]\d*$/.test(value)) {
                        ood(src).attr('value', cur + "");
                        return;
                    }

                    value = parseInt(value, 10);
                    if (cur !== value) {
                        value = value > max ? max : value;
                        ood(src).attr('value', value + "");
                        profile.boxing().setPage(value, false, 'input');
                    }
                },
                onKeydown: function (profile, e, src) {
                    var p = profile.properties, b = profile.box,
                        evt = ood.Event,
                        k = evt.getKey(e);
                    if (p.disabled || p.readonly) return;

                    //fire onchange
                    if (k.key == 'enter')
                        ood.use(src).onChange();
                }
            },
            NEXT: {
                onClick: function (profile, e, src) {
                    return profile.box._click(profile, src);
                }
            },
            NEXTM: {
                onClick: function (profile, e, src) {
                    if (ood.use(src).get(0)._real_page) {
                        profile.box._show(profile, e, src, 1);
                        return false;
                    } else {
                        return profile.box._click(profile, src);
                    }
                }
            },
            LAST: {
                onClick: function (profile, e, src) {
                    return profile.box._click(profile, src);
                }
            }
        },
        DataModel: {
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            dataField: null,
            dataBinder: null,
            autoTips: false,
            dirtyMark: false,
            showDirtyMark: false,
            parentID: '',

            hiddenBar: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            isFormField: {
                hidden: true,
                ini: false
            },
            caption: {
                ini: ' Page: ',
                action: function (v) {
                    v = (ood.isSet(v) ? v : "") + "";
                    this.getSubNode('LABEL').html(ood.adjustRes(v, true));
                }
            },
            showMoreBtns: {
                ini: true,
                action: function (v) {
                    this.getSubNodes(['PREM', 'NEXTM']).css('display', v ? '' : 'none');
                }
            },
            pageCount: 20,
            disabled: {
                ini: false,
                action: function (v) {
                    var i = this.getSubNode('CUR'),
                        cls = "ood-ui-disabled";

                    if (v) this.getRoot().addClass(cls);
                    else this.getRoot().removeClass(cls);

                    if (!v && this.properties.readonly)
                        v = true;
                    // use 'readonly'(not 'disabled') for selection
                    i.attr('readonly', v);
                }
            },
            readonly: {
                ini: false,
                action: function (v) {
                    var i = this.getSubNode('CUR'),
                        cls = "ood-ui-readonly";

                    if (v) this.getRoot().addClass(cls);
                    else this.getRoot().removeClass(cls);

                    if (!v && this.properties.disabled)
                        v = true;
                    // use 'readonly'(not 'disabled') for selection
                    i.attr('readonly', v);
                }
            },
            value: "1:1:1",
            uriTpl: "#*",
            textTpl: "*",
            prevMark: '',
            api: null,
            nextMark: '',
            _moreStep: 30
        },
        EventHandlers: {
            onClick: function (profile, page) {
            },
            onPageSet: function (profile, page, start, count, eventType, opage, ostart) {
            }
        },
        RenderTrigger: function () {
            var ns = this, p = ns.properties, a = ((p.value || "") + "").split(':');
            if (p.readonly)
                ns.boxing().setReadonly(true, true);
            if (!ns.$inDesign)
                ns.boxing().setPage(a[1] || a[0], true, 'inited');
            
            // 
            ns.boxing().PageBarTrigger();
        },
        _ensureValue: function (profile, value) {
            value = value + '';
            var a = value.split(':'),
                p = profile.properties,
                b = [],
                fun = function (a) {
                    return parseInt(a, 10) || 1
                };
            if (a.length < 3) {
                b = ((p.$UIvalue || p.value || '') + '').split(':');
                a[1] = a[0];
                a[0] = b[0];
                a[2] = b[2];
            }
            b[0] = fun(a[0]);
            b[1] = fun(a[1]);
            b[2] = fun(a[2]);

            b[0] = Math.max(b[0], 1);
            b[0] = Math.min(b[0], b[1]);
            b[2] = Math.max(b[1], b[2]);

            return b.join(':');
        },
        _v2a: function (v) {
            v = typeof v == 'string' ? v.split(':') : v;
            v[0] = parseInt(v[0], 10);
            v[1] = parseInt(v[1], 10);
            v[2] = parseInt(v[2], 10);
            return v;
        },
        _click: function (profile, src) {
            var p = profile.properties;
            if (p.disabled || p.readonly) return false;
            var b = profile.boxing(),
                a = (p.$UIvalue || p.value || "").split(':'),
                nv = parseInt(ood(src).attr('href').split('#')[1], 10) || a[1] || a[0];

            var r = b.onClick(nv);

            // if didn't call setPage  in onclick event, setPage here
            if (!a.length || (nv + "") !== (a[1] + "")) {
                b.setPage(nv, false, 'click');
            }

            return typeof r == "boolean" ? r : false;
        },
        _show: function (profile, e, src, flag) {
            var prop = profile.properties;
            if (prop.disabled || prop.readonly) return false;

            var pid = prop.parentID || ood.ini.$rootContainer,
                arr = profile.box._v2a(prop.value),
                min = arr[0],
                cur = arr[1],
                max = arr[2],

                keys = profile.keys,
                fun = function (p, k) {
                    return p.getSubNode(k)
                },
                pool = fun(profile, 'POOL'),
                pop = fun(profile, 'POP'),
                ceil = function (n) {
                    return Math.ceil((n + 1) / 10) * 10
                },
                a = [],
                t, m, n, i, l
            ;

            if (flag) {
                if ((t = max - 1 - cur) <= 0) return;
                n = cur + 1;
                l = max;
            } else {
                if ((t = cur - 1 - min) <= 0) return;
                n = 1;
                l = cur - 1;
            }
            m = Math.ceil(t / prop._moreStep);
            if (m > 10) {
                n = ceil(n);
                l = ceil(l) - 1;
                m = ceil(m);
            } else
                n = n + m;
            //
            var _id = profile.keys.POPI + ':' + profile.serialId + ':';
            while (n < l) {
                //margin-top for ie6
                a.push('<a style="margin-top:.25em;" id="' + _id + n + '" class="ood-node ood-node-span ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius" href="' + prop.uriTpl.replace('*', n) + '">' + prop.textTpl.replace('*', n) + '</a>')
                n = n + m;
            }
            pop.width('auto');
            pop.html(a.join(' '));
            ood('body').append(pop);
            if (pop.width() > 300) pop.width(300);
            pop.popToTop(src, null, pid ? ood.get(profile, ["host", pid]) ? profile.host[pid].getContainer() : ood(pid) : null);
            pop.setBlurTrigger(profile.key + ":" + profile.$xid, function () {
                pool.append(pop);
            });
        },
        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile),
                prop = profile.properties;
            data._hiddenBar = prop.hiddenBar ? ";display:none" : "";
            data._css = ood.browser.kde ? 'resize:none;' : '';
            data._css2 = data.showMoreBtns ? '' : 'display:none;';
            return data;
        }
    },
    Initialize: function () {
        this.addTemplateKeys(['POPI']);
    }
});
ood.Class("ood.UI.Tabs", ["ood.UI", "ood.absList", "ood.absValue"], {
    Instance: {

        iniProp: {
            items: [
                {id: 'a', caption: 'page1', imageClass: "ri-image-line"},
                {id: 'b', caption: 'page2'},
                {id: 'c', caption: 'page3'},
                {id: 'd', caption: 'page4', closeBtn: true, optBtn: 'ood-uicmd-opt', popBtn: true}
            ],
            autoFontColor: true,
            value: 'a',
            caption: 'TABS'
        },

        // 
        /**
         * 
         * @param {string} theme -  (light/dark/high-contrast)
         * @returns {Object} 
         */
        setTheme: function (theme) {
            return this.each(function (profile) {
                // 
                var root = profile.getRoot();
                // 
                root.removeClass('tabs-light tabs-dark tabs-highcontrast');
                // 
                root.addClass('gallery-' + theme);

                // data-themeCSS
                root.attr('data-theme', theme);

                // 
                try {
                    profile.boxing()._checkResponsiveLayout();
                } catch (e) {
                    console.warn('Responsive layout check failed:', e);
                }

                // 
                try {
                    if (typeof localStorage !== 'undefined') {
                        localStorage.setItem('tabs-theme', theme);
                    }
                } catch (e) {
                    console.warn('Theme preference save failed:', e);
                }
            });
        },

        // 
        _checkResponsiveLayout: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width;

                // 
                root.removeClass('tabs-mobile tabs-tiny');

                // 
                if (width < 400) {
                    root.addClass('tabs-tiny');
                } else if (width < 600) {
                    root.addClass('tabs-mobile');
                }
            });
        },


        // 
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('tabs-theme') || 'light';
        },

        // 
        toggleDarkMode: function () {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },

        // 
        adjustLayout: function (profile) {
            if (profile) {
                this.each(function (pf) {
                    if (pf.serialId === profile.serialId) {
                        this._onresize(pf, null, null, true);
                    }
                });
            } else {
                this.each(function (pf) {
                    if (pf.boxing()._onresize) {
                        pf.boxing()._onresize(pf, null, null, true);
                    }

                });
            }
            return this;
        },
        _setCtrlValue: function (value) {
            this.each(function (profile) {
                var id = profile.domId,
                    box = profile.boxing(),
                    uiv = box.getUIValue(),
                    prop = profile.properties,
                    dm = profile.box.$DataModel,
                    mcap = profile.getSubNode('MENUCAPTION'),
                    mcls = profile.getSubNode('MENUCLOSE'),
                    fold = function (itemId, arr) {
                        var subId = profile.getSubIdByItemId(itemId),
                            item = profile.getItemByItemId(itemId);
                        if (subId) {
                            arr.push(subId);
                            if (!dm.hasOwnProperty("noPanel") || !prop.noPanel) {
                                // hide pane
                                //box.getPanel(itemId).hide();
                                var pn = box.getPanel(itemId).get(0);
                                if (pn && (item._scrollTop = pn.scrollTop || 0))
                                    pn.scrollTop = 0;

                                box.getPanel(itemId).css('display', 'none');
                            }
                        }
                    },
                    expand = function (itemId, arr) {
                        var subId = profile.getSubIdByItemId(itemId),
                            item = profile.getItemByItemId(itemId);
                        if (subId) {
                            arr.push(subId);
                            mcap.html(item.caption);
                            mcls.css('display', item.closeBtn ? '' : 'none');
                            profile._menuId = item.id;
                            if (!dm.hasOwnProperty("noPanel") || !prop.noPanel) {
                                // show pane
                                //box.getPanel(value).css('position','relative').show('auto','auto');
                                box.getPanel(itemId).css('display', 'block');
                                if (item._scrollTop)
                                    box.getPanel(itemId).get(0).scrollTop = item._scrollTop;

                                profile.adjustSize(false, false, value);

                                profile.box._forLazyAppend(profile, item, value);
                                profile.box._forIniPanelView(profile, item);
                            }
                        }
                    };
                var arr1 = [], arr2 = [];
                if (dm.hasOwnProperty("selMode") &&
                    dm.hasOwnProperty("noPanel") &&
                    prop.noPanel &&
                    prop.selMode == "multi") {

                    uiv = uiv ? uiv.split(prop.valueSeparator) : [];
                    ood.arr.each(uiv, function (key) {
                        fold(key, arr1);
                    });
                    value = value ? value.split(prop.valueSeparator) : [];
                    var lastV = "";
                    ood.arr.each(value, function (key) {
                        var l = arr2.length;
                        expand(key, arr2);
                        // the last one
                        if (l < arr2.length)
                            lastV = key;
                    });
                } else {
                    fold(uiv, arr1);
                    expand(value, arr2);
                }

                if (arr1.length) {
                    profile.getSubNodes(['ITEM', 'TOGGLE'], arr1).tagClass('-checked', false);
                    profile.getSubNodes('ITEM', arr1).tagClass('-checked', false);
                }
                if (arr2.length) {
                    profile.getSubNodes(['ITEM', 'TOGGLE'], arr2).tagClass('-checked');
                    profile.getSubNodes('ITEM', arr2).tagClass('-checked');
                }

            });
        },
        append: function (target, subId, pre, base) {
            var p = this.get(0).properties;
            if (subId = subId || p.$UIvalue || p.value)
                arguments.callee.upper.call(this, target, subId + '', pre, base);
            return this;
        },
        getCurPanel: function () {
            var profile = this.get(0),
                dm = profile.box.$DataModel,
                v = profile.properties.$UIvalue;
            if (dm.hasOwnProperty("noPanel") && dm.hasOwnProperty("selMode") && profile.properties.selMode == 'multi') {
                v = v.split(prop.valueSeparator);
                v = v[0] || null;
            }
            return v ? this.getPanel(v) : null;
        },
        autoSave: function () {
            var module = this.getActiveModule();
            if (module) {
                module.autoSave();
            }
        },

        getActiveModule: function () {
            if (this.getSelectedItem()) {
                var cls = this.getSelectedItem().euClassName;
                return this.getModule().getChildModule(cls);
            }
            return null;
        },


        // get pane in page views
        getPanel: function (subId) {
            var profile = this.get(0);
            return profile.getSubNodeByItemId('PANEL', subId + '');
        },
        ////
        addPanel: function (paras, children, item) {
            var ns = this,
                i = {}, arr = [],
                id = item && item.id,
                items = ns.getItems(),
                id2 = paras.id || paras.tag;
            if (items.length) {
                if (-1 != ood.arr.subIndexOf(items, 'id', id2))
                    return false;
            }

            ood.merge(i, {
                caption: paras.caption,
                image: paras.image,
                closeBtn: paras.closeBtn || false,
                popBtn: paras.popBtn || false,
                optBtn: paras.optBtn || false,
                imagePos: paras.imagePos,
                imageBgSize: paras.imageBgSize,
                dragKey: paras.dragKey,
                dropKeys: paras.dropKeys,
                id: paras.id || paras.tag || ood.id()
            });

            if (id) ns.insertItems([i], id, true);
            else ns.insertItems([i]);

            ood.arr.each(children, function (o) {
                arr.push(o[0]);
            });
            ns.append(ood.UI.pack(arr, false), i.id);

            return ns;
        },
        removePanel: function (domId) {
            var self = this,
                item = self.getItemByDom(domId);
            return self.removeItems([item.id]);
        },
        getPanelPara: function (domId) {
            var profile = this.get(0),
                pp = profile.properties,
                item = profile.getItemByDom(domId),
                paras = ood.clone(item, false);
            if (!paras.dragKey) paras.dragKey = pp.dragKey;
            if (!paras.dropKeys) paras.dropKeys = pp.dropKeys;
            return paras;
        },
        getAllFormValues: function (isAll) {
            var a = this.getChildren(),
                elems = ood.absValue.pack(a),
                tabValue = {},
                formValue = {},
                profile = this.get(0);
            ood.arr.each(profile.children, function (o) {
                var oo = o[0].boxing(), name = oo.getProperties().name || o[0].alias;
                if (ood.isArr(o) && o.length > 1 && ood.isStr(o[1])) {
                    name = o[1];
                }
                if (oo.Class['ood.UI.Tabs']) {
                    //  formValue[name] = oo.getAllFormValues();
                    ood.merge(formValue, oo.getAllFormValues(isAll), 'all')
                } else if (oo.Class['ood.UI.Block'] || oo.Class["ood.UI.Panel"] || oo.Class["ood.UI.Layout"]) {
                    if (isAll && !ood.str.endWith(name, 'Main')) {
                        if (!formValue[name]) {
                            formValue[name] = oo.getAllFormValues(isAll);
                        } else {
                            ood.merge(formValue[name], oo.getAllFormValues(isAll), 'all')
                        }
                    } else {
                        ood.merge(formValue, oo.getAllFormValues(isAll), 'all')
                    }

                } else if (oo.getFormValues) {
                    formValue[name] = oo.getFormValues();
                } else if (oo.getUIValue) {
                    formValue[name] = oo.getUIValue();
                } else if (oo.getValue) {
                    formValue[name] = oo.getValue();
                }
            });
            tabValue[profile.properties.name || profile.alias] = formValue;

            return tabValue;
        },

        getPanelChildren: function (domId) {
            var profile = this.get(0),
                id = profile.getItemIdByDom(domId),
                arr = [];
            if (id)
                ood.arr.each(profile.children, function (o) {
                    if (o[1] == id) arr.push(o);
                });
            return arr;
        },

        resetPanelView: function (subId, removeChildren, destroyChildren) {
            if (!ood.isSet(removeChildren)) removeChildren = true;
            if (!ood.isSet(destroyChildren)) destroyChildren = true;
            var ins, item;
            return this.each(function (profile) {
                if (profile.renderId) {
                    ood.arr.each(profile.properties.items, function (o) {
                        if (subId === true || (subId + '') === o.id)
                            delete o._$ini;
                    });
                    if (removeChildren)
                        profile.boxing().removeChildren(subId, destroyChildren)
                }
            });
        },

        iniPanelView: function (subId) {
            return this.each(function (profile) {
                if (subId) {
                    if (subId = profile.getItemByItemId(subId + '')) {
                        profile.box._forIniPanelView(profile, subId);
                    }
                } else {
                    ood.arr.each(profile.properties.items, function (item) {
                        profile.box._forIniPanelView(profile, item);
                    });
                }
            });
        },

        ////
        fireItemClickEvent: function (subId) {
            var node = this.getSubNodeByItemId('ITEM', subId + ''), ev = ood.Event;
            node.onClick(true);

            //if(ev.__realtouch)ev.__simulatedMousedown=1;
            //node.onMousedown(true).onMouseup(true);
            //if(ev.__realtouch)ev.__simulatedMousedown=0;
            return this;
        },
        /* insert some views to pageView widgets
            arr: hash(view properties) or array of hash
            before: views will insert before it, string
        */
        _afterInsertItems: function (profile, data) {
            if (!profile.renderId) return;
            var box = profile.box, obj, v, pp = profile.properties;
            if (obj = profile.getSubNode(profile.keys.BOX || profile.keys.KEY)) {
                // add panels anyway
                obj.append(profile._buildItems('panels', data));
                // for stacks only
                if (!profile.box.$DataModel.hasOwnProperty("noPanel")) {
                    if (!(v = this.getUIValue()))
                        this.fireItemClickEvent((v = pp.items[0]) && v.id);
                }
                profile.adjustSize();
            }
        },
        /*  remove some views from pageView
            arr: array for id
        */


        removeItems: function (arr/*default is the current*/, purgeNow) {
            var self = this,
                p, obj, serialId;
            self.each(function (profile) {
                var p = profile.properties;
                arr = ood.isSet(arr) ? ood.isArr(arr) ? arr : (arr + "").split(p.valueSeparator) : null;
                if (!arr) arr = ((p.$UIvalue || p.value) + "").split(p.valueSeparator);
                if (!profile.box.$DataModel.hasOwnProperty("noPanel") || !profile.properties.noPanel)
                    ood.arr.each(arr, function (o) {
                        // get ui serial id
                        serialId = profile.getSubIdByItemId(o + "");
                        if (serialId && !(obj = profile.getSubNode('PANEL', serialId)).isEmpty()) {
                            // remove ui
                            obj.remove(true, purgeNow);
                        }
                    });
            });
            arguments.callee.upper.apply(self, arguments);

            self.each(function (profile) {
                if (!profile.boxing().getUIValue()) {
                    ood.asyRun(function () {
                        if (!profile || !profile.renderId || !profile.properties || !profile.properties.items.length) return;
                        var i;
                        profile.boxing().fireItemClickEvent((i = profile.properties.items[0]) && i.id);
                    });
                }

                profile.adjustSize();
            });

            return self;
        },
        clearItems: function (purgeNow) {
            var self = this;
            self.each(function (profile) {
                if (!profile.box.$DataModel.hasOwnProperty("noPanel") || !profile.properties.noPanel)
                    profile.getSubNode('PANEL', true).remove(true, purgeNow);
            });
            self.setValue(null, true, 'clear');
            arguments.callee.upper.apply(self, arguments);
            return self;
        },
        markItemCaption: function (subId, mark, force, tag, cls) {
            var profile = this.get(0);
            subId = profile.getItemByItemId(subId + '');

            if ((subId._dirty != mark) || force) {
                var id = subId.id,
                    item = profile.getItemByItemId(id),
                    caption = item.caption,
                    node = profile.getSubNodeByItemId('CAPTION', id);
                if (tag) {
                    if (ood.isFun(tag)) {
                        item.caption = tag(profile, item, mark);
                        node.html(item.caption);
                    } else
                        node.html(item.caption = mark ? tag + caption : caption.replace(new RegExp("^" + tag), ''));
                } else
                    node.html(item.caption = mark ? '*' + caption : caption.replace(/^\*/, ''));
                if (cls) {
                    if (mark) node.addCalss(cls);
                    else node.removeCalss(cls);
                } else
                    node.css({'font-weight': mark ? 'bold' : '', 'font-style': mark ? 'italic' : ''});

                subId._dirty = mark;
            }
            return this;
        }
    },
    Static: {
        Templates: {
            tagName: 'div',
            style: '{_style};',
            className: '{_className}',
            LIST: {
                $order: 1,
                tagName: 'div',
                style: '{_liststyle}',
                LISTBG: {
                    $order: 0,
                    className: 'ood-uiborder-t ood-uiborder-b ood-uiborder-dark ood-uibar-checked'
                },
                MENU: {
                    className: 'ood-ui-unselectable ood-uiborder-hidden ood-uiborder-radius',
                    MENUICON: {
                        className: 'oodfont',
                        $fonticon: 'ri-menu-3-line'
                    },
                    MENUCAPTION: {},
                    MENUCLOSE: {
                        className: 'oodfont',
                        $fonticon: 'ri-close-line',
                        $order: 2
                    }
                },
                MENU2: {
                    tagName: 'div',
                    className: 'ood-ui-unselectable',
                    MENUICON2: {
                        className: 'ood-uiborder-hidden ood-uiborder-radius oodcon {_iconChecked}',
                        $fonticon: 'ri-menu-3-line'
                    }
                },
                ITEMS: {
                    tagName: 'div',
                    className: 'ood-ui-unselectable {_specialIconCls}',
                    text: "{items}",
                    style: '{HAlign}'
                }
            },
            PNAELS: {
                $order: 2,
                tagName: 'text',
                text: '{panels}'
            },
            $submap: {
                items: {
                    ITEM: {
                        className: 'ood-uiborder-flat ood-uiborder-nob ood-uiborder-box ood-uiborder-radius-big-tl ood-uiborder-radius-big-tr ood-uibar {itemClass} {disabled} {readonly}',
                        style: '{_itemDisplay} {itemStyle}{_itemColor}',
                        ITEMI: {
                            ITEMC: {
                                HANDLE: {
                                    tabindex: '{_tabindex}',
                                    className: 'ood-showfocus',
                                    IBWRAP: {
                                        tagName: 'div',
                                        style: "white-space:nowrap;",
                                        RULER: {},
                                        LTAGCMDS: {
                                            $order: 1,
                                            tagName: 'span',
                                            className: 'ood-ltag-cmds',
                                            style: '{_ltagDisplay}',
                                            text: "{ltagCmds}"
                                        },
                                        ICON: {
                                            $order: 2,
                                            className: ' {imageClass}  {picClass}',
                                            style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{imageDisplay}{iconStyle}{_iconColor}',
                                            text: '{iconFontCode}'
                                        },
                                        CAPTION: {
                                            $order: 3,
                                            text: '{caption}',
                                            className: "ood-title-node",
                                            style: '{itemWidth};{itemAlign}{_fontColor}'
                                        },
                                        CMDS: {
                                            $order: 4,
                                            RTAGCMDS: {
                                                $order: 0,
                                                tagName: 'span',
                                                className: 'ood-rtag-cmds',
                                                style: '{_rtagDisplay}',
                                                text: "{rtagCmds}"
                                            },
                                            OPT: {
                                                $order: 1,
                                                className: 'oodfont',
                                                $fonticon: 'ood-uicmd-opt',
                                                style: '{_opt}'
                                            },
                                            POP: {
                                                className: 'oodfont',
                                                $fonticon: 'ood-uicmd-pop',
                                                style: '{popDisplay}',
                                                $order: 1
                                            },
                                            CLOSE: {
                                                className: 'oodfont',
                                                $fonticon: 'ood-uicmd-close',
                                                style: '{closeDisplay}',
                                                $order: 2
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                panels: {
                    PANEL: {
                        tagName: 'div',
                        className: 'ood-uibase ood-uicontainer',
                        style: "{_overflow};{_bginfo}",
                        text: '{html}' + ood.UI.$childTag
                    }
                },
                'items.ltagCmds': function (profile, template, v, tag, result) {
                    var me = arguments.callee,
                        map = me._m || (me._m = {'text': '.text', 'button': '.button', 'image': '.image'});
                    ood.UI.$doTemplate(profile, template, v, "items.tagCmds" + (map[v.type] || '.button'), result)
                },
                'items.rtagCmds': function (profile, template, v, tag, result) {
                    var me = arguments.callee,
                        map = me._m || (me._m = {'text': '.text', 'button': '.button', 'image': '.image'});
                    ood.UI.$doTemplate(profile, template, v, "items.tagCmds" + (map[v.type] || '.button'), result)
                },
                'items.tagCmds.text': ood.UI.$getTagCmdsTpl('text'),
                'items.tagCmds.button': ood.UI.$getTagCmdsTpl('button'),
                'items.tagCmds.image': ood.UI.$getTagCmdsTpl('image')
            }
        },
        Appearances: {
            KEY: {
                position: 'absolute',
                overflow: 'hidden'
            },
            LIST: {
                position: 'relative',
                overflow: 'hidden',
                left: 0,
                width: '100%',
                // padding: '.25em .25em 0 .25em ',
                'white-space': 'nowrap'
            },
            LISTBG: {
                position: 'absolute',
                overflow: 'hidden',
                left: 0,
                bottom: 0,
                height: '3px',
                width: '100%'
            },
            MENU: {
                display: 'none',
                margin: '.25em',
                padding: '.16667em',
                cursor: 'pointer'
            },
            MENU2: {
                display: 'none'
            },
            MENUCAPTION: {
                'vertical-align': ood.browser.ie6 ? 'baseline' : 'middle',
                margin: '0 4px',
                'font-size': '1em'
            },
            ITEMS: {
                padding: ood.browser.contentBox ? '0 0 4px 0' : '0 0 2px 0',
                position: 'relative',
                left: 0,
                top: 0,
                'white-space': 'nowrap'
            },
            'ITEMS-icon CAPTION, ITEMS-icon OPT, ITEMS-icon POP, ITEMS-icon2 CAPTION, ITEMS-icon2 OPT, ITEMS-icon2 POP': {
                display: 'none'
            },

            'ITEMS-menu ITEM': {
                display: 'none'
            },
            ITEM: {
                $order: 0,
                cursor: 'pointer',
                //  padding: '0.75rem 1rem',
                'vertical-align': 'top',
                height: 'auto',
                'border-bottom': '2px solid transparent',
                transition: 'all 0.2s ease',
                color: 'var(--text)'
            },
            'ITEM-checked': {
                'border-bottom-color': 'var(--primary)',
                color: 'var(--primary-active) !important',
                fontWeight: '100'
            },
            'ITEM-checked:hover': {
                'border-bottom-color': 'var(--primary)',
                color: 'var(--primary-active) !important',
                fontWeight: '100'
            },
            ITEMI: {
                $order: 0,
                'padding-left': '.5em',
                //keep this same with ITEM
                'vertical-align': 'top'
            },
            ITEMC: {
                $order: 0,
                padding: '0.75em 0 0 0',
                //keep this same with ITEM
                'vertical-align': 'top',
                'text-align': 'center'
            },
            HANDLE: {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie6 ? 1 : null,
                cursor: 'pointer',
                'vertical-align': 'middle',
                padding: 0
            },
            'ITEM-checked HANDLE': {
                'padding-bottom': '1px'
            },
            RULER: {
                height: '1.5em',
                width: '0',
                'vertical-align': 'middle'
            },
            PANEL: {
                position: 'relative',
                display: 'none',
                width: '100%',
                overflow: 'auto',
                background: 'var(--bg)',
                padding: '1rem',
                border: '1px solid var(--border)',
                'border-radius': '0 0 4px 4px'
            },
            CAPTION: {
                'vertical-align': ood.browser.ie6 ? 'baseline' : 'middle',
                margin: '6px 6px 0 6px',
                overflow: 'hidden'
            },
            CMDS: {
                'vertical-align': 'middle',
                'padding-right': '0.25em'
            },
            'LTAGCMDS, RTAGCMDS': {
                padding: 0,
                margin: 0,
                'vertical-align': 'middle'
            },
            CMD: {
                padding: 0,
                margin: 0
            }
        },
        Behaviors: {
            NOTIPS: ["GROUP", "HANDLER"],
            DroppableKeys: ['PANEL', 'LIST', 'ITEM'],
            PanelKeys: ['PANEL'],
            DraggableKeys: ['ITEM'],
            HoverEffected: {
                ITEM: 'ITEM',
                MENU: 'MENU',
                MENU2: 'MENU2',
                MENUICON2: 'MENUICON2',
                OPT: 'OPT',
                CLOSE: 'CLOSE',
                MENUCLOSE: 'MENUCLOSE',
                POP: 'POP',
                ICON: 'ICON',
                CMD: 'CMD'
            },
            ClickEffected: {
                ITEM: 'ITEM',
                MENU: 'MENU',
                MENU2: 'MENU2',
                MENUICON2: 'MENUICON2',
                OPT: 'OPT',
                CLOSE: 'CLOSE',
                MENUCLOSE: 'MENUCLOSE',
                POP: 'POP',
                CMD: 'CMD'
            },
            CAPTION: {
                onMousedown: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != 'left') return;
                    var properties = profile.properties,
                        item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (properties.disabled || item.disabled) return false;
                    if (properties.readonly || item.readonly) return false;
                    if (box.getUIValue() == item.id) {
                        if (profile.onCaptionActive)
                            profile.boxing().onCaptionActive(profile, profile.getItemByDom(src), e, src);
                    }
                }
            },
            ITEM: {
                onClick: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != 'left') return false;
                    var t;
                    if ((t = ood.Event.getSrc(e).parentNode) && t.id && (profile.getKey(t.id)) == profile.keys.CMDS) return false;

                    var prop = profile.properties,
                        dm = profile.box.$DataModel,
                        itemId = profile.getSubId(src),
                        item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (prop.disabled || item.disabled) return false;
                    if (prop.readonly || item.readonly) return false;

                    //for some input onblur event
                    //profile.getSubNode('HANDLE', itemId).focus(true);

                    if (dm.hasOwnProperty("selMode") &&
                        dm.hasOwnProperty("noPanel") &&
                        prop.noPanel &&
                        prop.selMode == "multi") {

                        var value = box.getUIValue(),
                            arr = value ? value.split(prop.valueSeparator) : [],
                            checktype = 1,
                            rt = false,
                            rt2 = false;
                        // for multi selection
                        if (arr.length) {
                            //for select
                            if (ood.arr.indexOf(arr, item.id) != -1) {
                                ood.arr.removeValue(arr, item.id);
                                checktype = -1
                            } else
                                arr.push(item.id);

                            arr.sort();
                            value = arr.join(prop.valueSeparator);

                            //update string value only for setCtrlValue
                            if (box.getUIValue() == value)
                                rt = false;
                            else {
                                box.setUIValue(value, null, null, 'md');
                                if (box.get(0) && box.getUIValue() == value)
                                    rt = box.onItemSelected(profile, item, e, src, checktype) || rt2;
                            }
                            return rt;
                        }

                    }
                    // for single selection
                    if (box.getUIValue() != item.id) {
                        box.setUIValue(item.id, null, null, 'md');
                        //if success
                        if (box.getUIValue() == item.id) {
                            rt = box.onItemSelected(profile, item, e, src) || rt2;
                            return rt;
                        }
                    }
                }
            },
            HANDLE: {
                onKeydown: function (profile, e, src) {
                    var keys = ood.Event.getKey(e), key = keys.key, shift = keys.shiftKey;
                    if (key == ' ' || key == 'enter') {
                        profile.getSubNode('ITEM', profile.getSubId(src)).onClick();
                        return false;
                    }

                    var cur = ood(src),
                        target = profile.getSubNode('ITEMS'),
                        first = target.nextFocus(true, true, false),
                        last = target.nextFocus(false, true, false);

                    switch (key) {
                        case 'tab':
                            if (shift) {
                                if (cur.get(0) != first.get(0)) {
                                    first.focus(true);
                                    return false;
                                }
                            } else {
                                if (cur.get(0) != last.get(0)) {
                                    last.focus(true);
                                    return false;
                                }
                            }
                            break;
                        case 'left':
                        case 'up':
                            var next = cur.nextFocus(false, true, false);
                            if (cur.get(0) == first.get(0))
                                last.focus(true);
                            else
                                cur.nextFocus(false);
                            return false;
                            break;
                        case 'right':
                        case 'down':
                            var next = cur.nextFocus(true, false, false);
                            if (cur.get(0) == last.get(0))
                                first.focus(true);
                            else
                                cur.nextFocus();
                            return false;
                            break;
                    }
                }
            },
            CMD: {
                onClick: function (profile, e, src) {
                    var prop = profile.properties,
                        item = profile.getItemByDom(ood.use(src).parent().get(0));
                    if (!item) return false;

                    if (prop.disabled || item.disabled || item.type == 'split') return false;
                    if (profile.onCmd)
                        profile.boxing().onCmd(profile, item, ood.use(src).id().split('_')[1], e, src);
                    return false;
                }
            },
            OPT: {
                onClick: function (profile, e, src) {
                    profile.boxing().onShowOptions(profile, profile.getItemByDom(src), e, src);
                    return false;
                }
            },
            CLOSE: {
                onClick: function (profile, e, src) {
                    var properties = profile.properties,
                        item = profile.getItemByDom(src),
                        uiv = properties.$UIvalue,
                        bak;

                    if (properties.disabled || item.disabled) return;
                    if (properties.readonly || item.readonly) return false;
                    var instance = profile.boxing();

                    if (false === instance.beforePageClose(profile, item, src)) return;

                    bak = ood.copy(item);

                    // if the current item is selected, select the next or the pre one item
                    if (uiv && uiv == item.id) {
                        var items = properties.items,
                            index = ood.arr.subIndexOf(items, "id", item.id),
                            t,
                            nuiv = (t = items[index + 1]) ? t.id : (t = items[index - 1]) ? t.id : (t = items[0]) ? t.id : null;
                        if (nuiv && nuiv != uiv) {
                            profile.boxing().fireItemClickEvent(nuiv);
                        }
                    }

                    instance.removeItems(item.id);

                    instance.afterPageClose(profile, bak);

                    profile.adjustSize();

                    return false;
                }
            },
            MENUCLOSE: {
                onClick: function (profile, e, src) {
                    profile.getSubNodeByItemId("CLOSE", profile._menuId).onClick(true);
                }
            },
            POP: {
                onClick: function (profile, e, src) {
                    var properties = profile.properties,
                        item = profile.getItemByDom(src),
                        options = {
                            parent: null,
                            host: null,
                            properties: null,
                            events: null,
                            CS: null,
                            CC: null,
                            CB: null,
                            CF: null,
                            init: null
                        },
                        id = item.id;
                    if (properties.disabled || item.disabled) return false;
                    if (properties.readonly || item.readonly) return false;

                    if (profile.beforePagePop && false == profile.boxing().beforePagePop(profile, item, options, e, src))
                        return false;

                    var panel = profile.boxing().getPanel(id),
                        pos = profile.getRoot().offset(),
                        size = profile.getRoot().cssSize(),
                        pro = ood.copy(ood.UI.Dialog.$DataStruct),
                        events = {};

                    ood.merge(pro, item, 'with');
                    ood.merge(pro, {
                        dragKey: item.dragkey || properties.dragKey,
                        dock: 'none',
                        tag: item.tag || item.id,
                        width: Math.max(size.width, 200),
                        height: Math.max(size.height, 100),
                        left: pos.left,
                        top: pos.top,
                        landBtn: true
                    }, 'all');
                    if (options.properties)
                        ood.merge(pro, options.properties, 'with');

                    if (options.events)
                        ood.merge(events, options.events, 'all');

                    var dialog = new ood.UI.Dialog(pro, events, options.host || profile.host, options.CS || null, options.CC || null, options.CB || null, options.CF || null);

                    if (ood.isFun(options.init) && false === options.init(dialog, profile, options)) {
                    } else {
                        dialog.show(options.parent || ood('body'));
                        var arr = [];
                        ood.arr.each(profile.children, function (o) {
                            if (o[1] == id) {
                                arr.push(o[0]);
                            }
                        });
                        if (arr.length) {
                            dialog.append(ood.UI.pack(arr, false));
                        }
                        profile.boxing().removeChildren(id).removeItems(id);
                    }
                    return false;
                }
            },
            MENU: {
                onMouseover: function (profile, e, src) {
                    var menu = profile._droppopmenu;
                    if (menu) return;

                    var ins = profile.boxing(),
                        items = profile.properties.items,
                        nitems = [],
                        l = items.length,
                        ll;
                    if (items.length > 10) {
                        ll = Math.ceil(l / 10);
                        for (var i = 0; i < ll; i++)
                            nitems.push({caption: (i * 10 + 1) + " - " + Math.min(l, ((i + 1) * 10 + 1)), sub: []});
                        ood.arr.each(items, function (item, i) {
                            nitems[parseInt(i / 10)].sub.push(ood.clone(item, false, 1));
                        });
                    } else {
                        nitems = ood.clone(items, false, 2);
                    }
                    //POPMENU
                    menu = profile._droppopmenu = new ood.UI.PopMenu({
                        items: nitems,
                        autoHide: true
                    }, {
                        onMenuSelected: function (profile, item) {
                            ins.fireItemClickEvent(item.id);
                        },
                        beforeHide: function (p, e) {
                            if (e) {
                                var node = ood(src),
                                    p1 = ood.Event.getPos(e),
                                    size = node.cssSize(),
                                    add = 3,
                                    p2 = node.offset();

                                if (p1.left > p2.left && p1.top > p2.top - add && p1.left < p2.left + size.width && p1.top < p2.top + size.height) {
                                    return false;
                                }
                            }
                        }, onHide: function () {
                            profile._droppopmenu.destroy(true);
                            delete profile._droppopmenu;
                        }
                    });
                    menu.pop(src);
                },
                onMouseout: function (profile, e, src) {
                    var pop;
                    if (pop = profile._droppopmenu) {
                        var node = pop.get(0).getRoot(),
                            p1 = ood.Event.getPos(e),
                            size = node.cssSize(),
                            add = 3,
                            p2 = node.offset();

                        if (p1.left > p2.left && p1.top > p2.top - add && p1.left < p2.left + size.width && p1.top < p2.top + size.height) {
                        } else
                            pop.hide();
                    }
                },
                onClick: function (p, e, src) {
                    ood(src).onMouseover(true);
                }
            },
            PANEL: {
                onClick: function (profile, e, src) {
                    var p = profile.properties,
                        item = profile.getItemByDom(src);
                    if (p.disabled || item.disabled) return false;
                    if (profile.onClickPanel)
                        return profile.boxing().onClickPanel(profile, item, e, src);
                }
            }
        },
        DataModel: {

            rotate: null,
            iconColors: null,
            itemColors: null,
            fontColors: null,

            autoFontColor: {
                caption: ood.getResText("DataModel.autoFontColor") || "",
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoIconColor: {
                caption: ood.getResText("DataModel.autoIconColor") || "",
                ini: true,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemColor: {
                caption: ood.getResText("DataModel.autoItemColor") || "",
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },

            expression: {
                caption: ood.getResText("DataModel.expression") || "",
                ini: '',
                action: function () {
                }
            },
            selectable: {
                caption: ood.getResText("DataModel.selectable") || "",
                ini: true
            },
            dirtyMark: {
                caption: ood.getResText("DataModel.dirtyMark") || "",
                ini: false
            },

            lazyAppend: {
                caption: ood.getResText("DataModel.delayAppend") || "",
                ini: true
            },
            isFormField: {
                caption: ood.getResText("DataModel.formField") || "",
                hidden: true,
                ini: false
            },


            dock: {
                caption: ood.getResText("DataModel.dockMode") || "",
                ini: 'fill'
            },
            width: {
                caption: ood.getResText("DataModel.width") || "",
                $spaceunit: 1,
                ini: '18em'
            },
            height: {
                caption: ood.getResText("DataModel.height") || "",
                $spaceunit: 1,
                ini: '18em'
            },
            position: {
                caption: ood.getResText("DataModel.position") || "",
                ini: 'absolute'
            },
            itemWidth: {
                caption: ood.getResText("DataModel.itemWidth") || "",
                ini: 0,
                action: function (value) {
                    this.getSubNode('CAPTION', true).width(value);
                }
            },
            itemAlign: {
                caption: ood.getResText("DataModel.itemAlign") || "",
                ini: "",
                listbox: ['', 'left', 'center', 'right'],
                action: function (value) {
                    this.getSubNode('CAPTION', true).css('text-align', value);
                }
            },
            HAlign: {
                caption: ood.getResText("DataModel.hAlign") || "",
                ini: 'left',
                listbox: ['left', 'center', 'right'],
                action: function (value) {
                    this.getSubNode('ITEMS').css('textAlign', value);
                }
            },
            dropKeysPanel: {
                caption: ood.getResText("DataModel.dropKeysPanel") || "",
                ini: ''
            },
            value: {
                caption: ood.getResText("DataModel.value") || "",
                ini: ''
            },
            selMode: {
                caption: ood.getResText("DataModel.selMode") || "",
                ini: 'single',
                listbox: ['single', 'multi']
            },
            noPanel: {
                caption: ood.getResText("DataModel.noPanel") || "",
                ini: false,
                action: function (value) {
                    this.getSubNode('PANEL', true).css('display', value ? 'none' : 'block');
                    this.adjustSize(null, true);
                }
            },
            noHandler: {
                caption: ood.getResText("DataModel.noHandler") || "",
                ini: false,
                action: function (value) {
                    this.getSubNode('LIST').css('display', value ? 'none' : 'block');
                    this.adjustSize(null, true);
                }
            },
            tagCmds: {
                caption: ood.getResText("DataModel.tagCmds") || "",
                ini: [],
                action: function () {
                    this.boxing().refresh();
                }
            }
        },
        EventHandlers: {
            onCmd: function (profile, item, cmdkey, e, src) {
            },
            onIniPanelView: function (profile, item) {
            },
            beforePagePop: function (profile, item, options, e, src) {
            },
            beforePageClose: function (profile, item, src) {
            },
            afterPageClose: function (profile, item) {
            },
            onShowOptions: function (profile, item, e, src) {
            },
            onItemSelected: function (profile, item, e, src, type) {
            },
            onCaptionActive: function (profile, item, e, src) {
            },
            onClickPanel: function (profile, item, e, src) {
            }
        },
        RenderTrigger: function () {
            var self = this, v, i, ins;
            // set default value
            if (v = self.properties.value) {
                (ins = self.boxing()).setUIValue(v, null, null, 'render');
                if (i = self.getItemByItemId(v))
                    ins.onItemSelected(self, i);
            }
        },
        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile);
            data.panels = data.items, p = profile.properties, ns = this;
            if (data.HAlign)
                data.HAlign = 'text-align:' + data.HAlign + ';';
            data._liststyle = data.noHandler ? 'display:none' : '';
            if (data.sideBarStatus == 'fold') {
                data._specialIconCls = profile.getClass('ITEMS') + '-icon2';
                data._iconChecked = ' ood-uiborder-hidden-checked ood-icon-menu-checked ';
            }


            ood.arr.each(data.items, function (item) {
                var index = item.index;
                if (!index) {
                    index = ood.arr.indexOf(data.items, item);
                }

                profile.boxing()._autoColor(item, index, p);
            })

            return data;
        },

        _prepareItem: function (profile, item, oitem, pid, index, len) {
            var dpn = 'display:none', p = profile.properties, t;
            profile.boxing()._autoColor(item, index, p);

            if (!item.closeBtn) {
                item.closeBtn = p.closeBtn;
            }
            if (!item.autoSave) {
                item.autoSave = p.autoSave;
            }

            if (!item.optBtn) {
                item.optBtn = p.optBtn;
            }

            item.closeDisplay = item.closeBtn ? '' : dpn;
            item.popDisplay = item.popBtn ? '' : dpn;
            item._opt = item.optBtn ? '' : dpn;
            item._itemDisplay = item.hidden ? dpn : '';
            if (t = item.itemWidth || p.itemWidth)
                item.itemWidth = "width:" + t + (ood.isFinite(t) ? "px" : "");
            if (t = item.itemAlign || p.itemAlign)
                item.itemAlign = "text-align:" + t;

            item._bginfo = "";
            if (t = item.panelBgClr || p.panelBgClr)
                item._bginfo += "background-color:" + t + ";";
            if (t = item.panelBgImg || p.panelBgImg)
                item._bginfo += "background-image:url(" + ood.adjustRes(t) + ");";
            if (t = item.panelBgImgPos || p.panelBgImgPos)
                item._bginfo += "background-position:" + t + ";";
            if (t = item.panelBgImgRepeat || p.panelBgImgRepeat)
                item._bginfo += "background-repeat:" + t + ";";
            if (t = item.panelBgImgAttachment || p.panelBgImgAttachment)
                item._bginfo += "background-attachment:" + t + ";";

            if (ood.isStr(item.overflow))
                item._overflow = item.overflow.indexOf(':') != -1 ? (item.overflow) : (data.overflow ? ("overflow:" + data.overflow) : "");
            else if (ood.isStr(p.overflow))
                item._overflow = p.overflow.indexOf(':') != -1 ? (p.overflow) : (p.overflow ? ("overflow:" + p.overflow) : "");

            this._prepareCmds(profile, item);
        },
        getDropKeys: function (profile, node) {
            var prop = profile.properties, item = profile.getItemByDom(node);
            return profile.getKey(ood.use(node).id()) == profile.keys.PANEL
                ? ((item && item.dropKeysPanel) || prop.dropKeysPanel)
                : ((item && item.dropKeys) || prop.dropKeys);
        },
        _forLazyAppend: function (profile, item, value) {
            var prop = profile.properties, box = profile.boxing(),
                moduleHash = {},
                zz = profile.moduleClass + "[" + profile.moduleXid + "]";
            //dynamic render
            if (prop.lazyAppend) {
                var arr = profile.children, a = [];
                ood.arr.each(arr, function (o) {
                    if (o[1] == value &&
                        // not rendered, or node not in
                        (!o[0].renderId || ood.UIProfile.getFromDom(ood(o[0].renderId).parent().id()) != profile)
                    ) {
                        a.push(o[0]);
                    }
                });
                if (a.length)
                    ood.arr.each(a, function (o, y, z) {
                        if (o.moduleClass && o.moduleXid && (y = ood.SC.get(o.moduleClass)) && (y = y.getInstance(o.moduleXid)) && y["ood.Module"]) {
                            z = o.moduleClass + "[" + o.moduleXid + "]";
                            if (zz != z && !moduleHash[z]) {
                                moduleHash[z] = y;
                            }
                        }
                        box.append(ood(o), value);
                    });

                // $attached is dynamic
                if (profile.$attached) {
                    for (var i = 0, v; v = profile.$attached[i++];)
                        if (v._render)
                            v._render(true);
                    delete profile.$attached;
                }

                arr = profile.exchildren;
                if (arr && arr.length) {
                    a = [];
                    ood.filter(arr, function (o) {
                        if (o[1] == value) {
                            a.push(o[0]);
                            return false;
                        }
                    });
                    if (a.length)
                        ood.arr.each(a, function (o) {
                            if (o.moduleClass && o.moduleXid && (y = ood.SC.get(o.moduleClass)) && (y = y.getInstance(o.moduleXid)) && y["ood.Module"]) {
                                z = o.moduleClass + "[" + o.moduleXid + "]";
                                if (zz != z && !moduleHash[z]) {
                                    moduleHash[z] = y;
                                }
                            }
                            box.append(ood(o), value);
                        });
                }

                arr = profile.excoms;
                if (arr && arr.length) {
                    a = [];
                    ood.filter(arr, function (o) {
                        if (o[1] == value) {
                            a.push(o[0]);
                            return false;
                        }
                    });
                    if (a.length)
                        ood.arr.each(a, function (o) {
                            o.show(null, box, value, false);
                        });
                }

                ood.each(moduleHash, function (o) {
                    o.render();
                });
            }
        },
        _forIniPanelView: function (profile, item) {
            if (!item) return;
            var prop = profile.properties, box = profile.boxing();
            if (!item._$ini) {
                item._$ini = true;
                if (profile.onIniPanelView) box.onIniPanelView(profile, item);
                if (item.iframeAutoLoad) {
                    box.getPanel(item.id).css('overflow', 'hidden');
                    var _if = typeof item.iframeAutoLoad == 'string' ? {url: item.iframeAutoLoad} : ood.clone(item.iframeAutoLoad, true),
                        id = "diframe_" + ood.rand(),
                        e = ood.browser.ie && ood.browser.ver < 9,
                        ifr = document.createElement(e ? "<iframe name='" + id + "'>" : "iframe");

                    _if.url = ood.adjustRes(_if.url, false, true);

                    ifr.id = ifr.name = id;
                    if (ood.isHash(item.iframeAutoLoad)) item.iframeAutoLoad.frameName = id;
                    item._frameName = id;

                    if (!_if.query) _if.query = {};
                    _if.query._rand = ood.rand();
                    ifr.frameBorder = '0';
                    ifr.marginWidth = '0';
                    ifr.marginHeight = '0';
                    ifr.vspace = '0';
                    ifr.hspace = '0';
                    ifr.allowTransparency = 'true';
                    ifr.width = '100%';
                    ifr.height = '100%';
                    box.getPanel(item.id).html("").append(ifr);

                    if ((_if.method || "").toLowerCase() == "post")
                        ood.Dom.submit(_if.url, _if.query, "post", id, _if.enctype);
                    else
                        ifr.src = _if.url;
                } else if (item.ajaxAutoLoad) {
                    var _ajax = typeof item.ajaxAutoLoad == 'string' ? {url: item.ajaxAutoLoad} : ood.clone(item.ajaxAutoLoad, true),
                        options = {rspType: "text"};
                    ood.merge(options, _ajax.options);
                    if (!_ajax.query) _ajax.query = {};
                    _ajax.query._rand = ood.rand();
                    box.busy(false, null, "PANEL", profile.getSubIdByItemId(item.id));
                    var node = box.getPanel(item.id);
                    ood.Ajax(ood.adjustRes(_ajax.url, false, true), _ajax.query, function (rsp) {
                        node.html(rsp, true, true);
                        box.free();
                    }, function (err) {
                        node.html("<div>" + err + "</div>", true, false);
                        box.free();
                    }, null, options).start();
                }
            }
        },
        _showTips: function (profile, node, pos) {
            if (profile.properties.disableTips) return;
            if (profile.onShowTips)
                return profile.boxing().onShowTips(profile, node, pos);
            if (!ood.Tips) return;
            var id = node.id, pid, ppid, ks = profile.keys;
            pid = ood.get(node, ["parentNode", "id"]) || "";
            ppid = ood.get(node, ["parentNode", "parentNode", "id"]) || "";
            if (id.indexOf(ks.ITEM) === 0 || pid.indexOf(ks.ITEM) === 0 || ppid.indexOf(ks.ITEM) === 0 ||
                id.indexOf(ks.HANDLE) === 0 || pid.indexOf(ks.HANDLE) === 0 || ppid.indexOf(ks.HANDLE) === 0 ||
                id.indexOf(ks.CMDS) === 0 || pid.indexOf(ks.CMDS) === 0 || ppid.indexOf(ks.CMDS) === 0) {
                var upper = arguments.callee.upper,
                    rtn = upper.apply(this, ood.toArr(arguments));
                upper = null;
                return rtn;
            }
        },
        // drop item
        _onDrop: ood.UI.List._onDrop,
        //for tabs only
        _onresize: function (profile, width, height, force, key) {
            var prop = profile.properties,
                item = profile.getItemByItemId(key);

            if (!item) {
                key = prop.$UIvalue || prop.value;
                item = profile.getItemByItemId(key);
            }
            if (!item) {
                item = prop.items[0];
                key = item && item.id;
            }
            if (!item) return;
            var panel = profile.boxing().getPanel(key),
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                root = profile.getRoot(),
                list = profile.getSubNode('LIST'),

                fzrate = profile.getEmSize() / root._getEmSize(),
                panelfz = panel._getEmSize(fzrate),
                listfz = list._getEmSize(fzrate),

                wc = null,
                hc = null,
                listH;

            // caculate by px
            if (width && width != 'auto') width = profile.$px(width, null, true);
            if (height && height != 'auto') height = profile.$px(height, null, true);

            if (!panel || panel.isEmpty()) return;

            if (!prop.noHandler) {
                //force to get offsetHeight
                listH = list.offsetHeight(true);
                if (profile._listH != listH) {
                    profile._listH = listH;
                    force = true;
                }
            }

            if (force) item._w = item._h = null;
            if (height && item._h != height) {
                item._h = height;
                if (height == 'auto') {
                    hc = 'auto';
                } else {
                    if (!prop.noHandler) {
                        height = height - listH;
                    }
                    if (height > 0) hc = height;
                }
                ;
            } else hc = height;

            if (width && item._w != width) {
                list.width(wc = adjustunit(item._w = width, listfz));
                if (!prop.noHandler) {
                    this._adjustHScroll(profile);
                }
            }

            if (!prop.noPanel && (hc || wc)) panel.height(adjustunit(hc, panelfz)).onSize();

            if (wc) {
                ood.UI._adjustConW(profile, panel, wc);
            }
        },
        _adjustHScroll: function (profile) {
            // SCROLL
            var items = profile.getSubNode('ITEMS'),
                innerW = items.width(),
                list = profile.getSubNode('LIST'),
                menu = profile.getSubNode('MENU'),
                caps = profile.getSubNode('CAPTION', true),
                itemsW = 0,
                getItemsW = function () {
                    var w = 0;
                    items.children().each(function (item) {
                        if (item.offsetWidth == 0) return;
                        if (!w) {
                            w = item.offsetLeft + item.offsetWidth;
                            return false;
                        }
                    }, true);
                    return w;
                },
                getCapsW = function () {
                    var w = 0;
                    caps.each(function (item) {
                        if (item.clientWidth == 0) return;
                        w += item.clientWidth;
                    });
                    return w;
                },
                ignoreCap;

            // init
            items.tagClass('-icon', false);
            items.tagClass('-icon2', false);
            items.tagClass('-menu', false);
            menu.css('display', 'none');
            caps.css('width', '');

            profile._mode = 'normal';
            // try 1: minus caption width
            itemsW = getItemsW();
            if (itemsW > innerW) {
                var capw = getCapsW();
                if ((itemsW - innerW) < capw * .75) {
                    var percent = 1 - (itemsW - innerW) / capw;
                    caps.each(function (cap) {
                        ood(cap).width(Math.floor(cap.clientWidth * percent) + 'px');
                    });
                    profile._mode = 'narrow';
                } else {
                    ignoreCap = 1;
                }

                // try 2: icon mode
                if (ignoreCap || getItemsW() > innerW) {
                    items.tagClass('-icon', true);
                    profile._mode = 'icon';
                    // try 3: menu mode
                    if (getItemsW() > innerW) {
                        items.tagClass('-menu', true);
                        menu.setInlineBlock();
                        profile._mode = 'menu';
                    }
                }
            }
        }
    }
});ood.Class("ood.UI.Stacks", "ood.UI.Tabs", {
    Initialize: function () {// 
        var t = this.getTemplate(), keys = this.$Keys;
        // tundefined
        if (!t) {
            t = {};
            t.LIST = {};
            t.PNAELS = {};
        }
        // LIST
        if (!t.LIST) t.LIST = {};
        // PNAELS
        if (!t.PNAELS) t.PNAELS = {};
        t.BOX = {tagName: 'div', LIST: t.LIST, PNAELS: t.PNAELS};
        // LIST
        if (t.LIST) {
            delete t.LIST.LEFT;
            delete t.LIST.RIGHT;
            delete t.LIST.DROP;
            delete t.LIST;
        }
        delete t.PNAELS;
        t.$submap.items.ITEM.className = 'ood-uibar ood-uiborder-t ood-uiborder-b';
        t.$submap.items.ITEM.ITEMI.ITEMC.HANDLE.IBWRAP.TOGGLE = {
            $order: 1,
            className: 'oodfont {_tlgchecked}',
            $fonticon: 'ood-uicmd-toggle'
        };
        this.setTemplate(t);
        delete keys.LEFT;
        delete keys.RIGHT;
        delete keys.DROP;
    },
    
    Instance: {
        //  iniProp 
        iniProp: {
            items: [{id: 'a', caption: 'tab1', message: "normal"}, {id: 'b', caption: 'tab2', message: "with image", imageClass: "ri-image-line"}, {id: 'c', caption: 'tab3', message: "height:100", height: 100}, {
                id: 'd',
                caption: '$RAD.widgets.collapsible',
                message: "with commands",
                closeBtn: true,
                optBtn: 'ood-uicmd-opt',
                popBtn: true
            }],
            autoItemColor: true,
            value: 'a',
            caption: '$RAD.widgets.folding'
        }
    },
    
    Static: {
        Behaviors: {
            DroppableKeys: ['PANEL', 'KEY', 'ITEM']
        },
        Appearances: {
            BOX: {
                position: 'absolute',
                overflow: 'hidden',
                left: 0,
                top: 0,
                'background-color': 'var(--ood-bg)',
                'border': '1px solid var(--ood-border)',
                'border-radius': 'var(--ood-radius-lg)'
            },
            LIST: {
                position: 'static'
            },
            ITEMS: {
                position: 'static'
            },
            ITEM: {
                $order: 0,
                display: 'block',
                position: 'absolute',
                cursor: 'pointer',
                width: '100%',
                left: 0,
                'background-color': 'var(--ood-bg)',
                'border-bottom': '1px solid var(--ood-border)',
                transition: 'background-color 0.2s ease'
            },
            'ITEM:hover': {
                'background-color': 'var(--ood-bg-hover)'
            },
            'ITEM-checked': {
                'background-color': 'var(--ood-primary-light)'
            },
            ITEMC: {
                display: 'block'
            },
            ITEMI: {
                display: 'block'
            },
            HANDLE: {
                cursor: 'pointer',
                display: 'block',
                'white-space': 'nowrap'
            },
            PANEL: {
                position: 'absolute',
                display: 'none',
                overflow: 'auto',
                'background-color': 'var(--ood-bg)',
                padding: 'var(--ood-spacing-md)'
            },
            CMDS: {
                position: 'absolute',
                top: 'var(--ood-spacing-sm)',
                right: 'var(--ood-spacing-md)',
                'text-align': 'right',
                'vertical-align': 'middle'
            }
        },
        DataModel: {
            expression: {
                ini: '', caption: ood.getResText("DataModel.expression") || "", action: function () {
                }
            },
            noPanel: {ini: null, caption: ood.getResText("DataModel.noPanel") || ""},
            noHandler: {ini: null, caption: ood.getResText("DataModel.noHandler") || ""},
            selMode: {ini: null, caption: ood.getResText("DataModel.Stacks.selMode") || ""},
            borderType: {
                ini: 'flat',
                caption: ood.getResText("DataModel.borderType") || "",
                listbox: ['none', 'flat', 'inset', 'outset'],
                action: function (v) {
                    var ns = this, p = ns.properties, n1 = ns.getSubNode('BOX'), reg = /^ood-uiborder-/,
                        flat = 'ood-uiborder-flat  ood-uiborder-radius',
                        ins = 'ood-uiborder-inset  ood-uiborder-radius',
                        outs = 'ood-uiborder-outset  ood-uiborder-radius', root = ns.getRoot();
                    n1.removeClass(reg);
                    switch (v) {
                        case 'flat':
                            n1.addClass(flat);
                            break;
                        case 'inset':
                            n1.addClass(ins);
                            break;
                        case 'outset':
                            n1.addClass(outs);
                            break;
                    }

                    //force to resize
                    ns.adjustSize();
                }
            }
        },
        LayoutTrigger: function () {
            var v = this.properties.borderType;
            if (v && v != 'none') this.boxing().setBorderType(v, true);
        },
        _onresize: function (profile, width, height, force, key) {
            var prop = profile.properties,
                noPanel = prop.noPanel,
                cb = ood.browser.contentBox,
                item = profile.getItemByItemId(key);

            if (!item) {
                key = prop.$UIvalue || prop.value;
                item = profile.getItemByItemId(key);
            }
            if (!item) {
                item = prop.items[0];
                key = item && item.id;
            }
            if (!item) return;

            var panel = profile.boxing().getPanel(key),
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                root = profile.getRoot(),
                box = profile.getSubNode('BOX'),
                list = profile.getSubNode('LIST'),

                fzrate = profile.getEmSize() / root._getEmSize(),
                panelfz = panel._getEmSize(fzrate),
                listfz = list._getEmSize(fzrate),

                type = prop.borderType,
                // have to use borderLeftWidth( ff will result 0 with borderWidth)
                bw = !cb ? 0 : (type == 'flat' || type == 'inset' || type == 'outset') ? box._borderW() : 0,
                wc = null,
                hc = null,
                off,
                temp, t1, t2, obj, top;

            if (!panel || panel.isEmpty()) return;

            // caculate by px
            width = width ? profile.$px(width, null, true) : width;
            height = height ? profile.$px(height, null, true) : height;

            // change value
            if (height) {
                height -= bw;
                t2 = t1 = 0;
                ood.arr.each(prop.items, function (o) {
                    obj = profile.getSubNodeByItemId('ITEM', o.id);
                    obj.cssRegion({bottom: 'auto', top: adjustunit(t1, obj)});

                    // force to get offsetHeight
                    off = o.hidden ? 0 : obj.offsetHeight(true);
                    t1 += off
                    if (o.id == key) return false;
                });
                ood.arr.each(prop.items, function (o) {
                    if (o.id == key) return false;
                    obj = profile.getSubNodeByItemId('ITEM', o.id);
                    obj.cssRegion({top: 'auto', bottom: adjustunit(t2, obj)});

                    // offsetHeight maybe not set here
                    off = o.hidden ? 0 : obj.offsetHeight(true);
                    t2 += off
                }, null, true);

                temp = height - t1 - t2;
                if (temp > 0) {
                    top = t1;
                    hc = temp;
                }

                box.height(adjustunit(height));
            }
            if (width) {
                width -= bw;
                wc = width;
                box.width(adjustunit(width));
            }

            panel.cssRegion({
                width: wc ? adjustunit(wc, panelfz) : null,
                height: hc ? adjustunit(hc, panelfz) : null,
                top: adjustunit(top, panelfz),
                left: 0 + profile.$picku()
            }, true);
            if (wc) {
                list.width(wc = adjustunit(wc, listfz));
                ood.UI._adjustConW(profile, panel, wc);
            }
        },
        _adjustScroll: null
    }
});
ood.Class("ood.UI.ButtonViews", "ood.UI.Tabs", {
    Instance: {
        iniProp: {
            barLocation: 'left',
            items: [{id: 'a', caption: 'page1', imageClass: 'ri-image-line'}, {id: 'b', caption: 'page2'}, {
                id: 'c',
                caption: 'page3'
            }, {id: 'd', caption: 'page4', closeBtn: true, optBtn: 'ood-uicmd-opt', popBtn: true}],
            autoItemColor: true,
            barSize: 220,
            value: 'a',
            caption: '$RAD.widgets.navBar'
        },

        Initialize: function () {
            var t = this.getTemplate(), keys = this.$Keys;
            // ARIA
            if (t && !t.LIST.role) {
                t.LIST.role = 'toolbar';
                t.LIST['aria-orientation'] = 'horizontal';
            }
            // 
            if (!t) {
                t = {};
                t.LIST = {};
                t.$submap = {items: {ITEM: {}}};
            }
            // LIST
            if (!t.LIST) t.LIST = {};
            // $submap
            if (!t.$submap) t.$submap = {};
            if (!t.$submap.items) t.$submap.items = {};
            if (!t.$submap.items.ITEM) t.$submap.items.ITEM = {};

            t.LIST.className = 'ood-btn-container';
            this.setTemplate(t);
            //t.$submap.items.ITEM.className = 'ood-btn {itemClass} {disabled} {readonly} {itemPosCls}';
            delete keys.LEFT;
            delete keys.RIGHT;
            delete keys.DROP;

            // 
            this.enhanceAccessibility();
        },

        // ARIA
        enhanceAccessibility: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    items = root.find('.ood-btn');

                // ARIA
                items.each(function (item) {
                    var el = ood(item),
                        label = el.attr('aria-label') || el.text().trim();

                    if (!el.attr('role')) {
                        el.attr('role', 'button');
                    }
                    if (!el.attr('aria-label') && label) {
                        el.attr('aria-label', label);
                    }
                    if (el.hasClass('ood-btn-disabled')) {
                        el.attr('aria-disabled', 'true');
                    } else {
                        el.attr('aria-disabled', 'false');
                    }
                });

                // 
                root.on('keydown', '.ood-btn:not(.ood-btn-disabled)', function (e) {
                    var key = e.keyCode;
                    // 
                    if (key === 32 || key === 13) {
                        e.preventDefault();
                       ood(this).fireEvent('click');
                    }
                });
            });
        },


        // 
        setTheme: function (theme) {
            return this.each(function (profile) {
                var root = profile.getRoot();
                // 
                root.removeClass('ood-theme-dark ood-theme-light ood-theme-hc');
                // 
                if (theme === 'dark') {
                    root.addClass('ood-theme-dark');
                } else if (theme === 'high-contrast') {
                    root.addClass('ood-theme-hc');
                } else {
                    root.addClass('ood-theme-light');
                }
                // 
                profile.properties.theme = theme;
                localStorage.setItem('ood-btn-theme', theme);
            });
        },

        // 
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('ood-btn-theme') || 'light';
        },

        // 
        toggleDarkMode: function () {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'dark' ? 'light' : 'dark');
        },

        // 
        adjustResponsive: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width;

                // 
                if (width < 768) {
                    root.addClass('ood-mobile');
                } else {
                    root.removeClass('ood-mobile');
                }

                // 
                if (width < 480) {
                    root.addClass('ood-tiny');
                } else {
                    root.removeClass('ood-tiny');
                }
            });
        }
    },


    Static: {
        Appearances: {
            // ...

            LIST: {
                'z-index': '2',
                position: 'absolute',
                //    'white-space': 'nowrap',
                overflow: 'hidden',
                'background-color': 'var(--bg-primary)'
                //  'font-size': '1.5em'
            },
            // for auto height
            'LIST-attop, LIST-atbottom': {
                $order: 2,
                position: 'relative'
            },
            LISTBG: {},
            MENU: {
                display: 'none',
                margin: '.25em',
                padding: '.25em',
                cursor: 'pointer'
            },

            MENU2: {
                display: 'none',
                'text-align': 'center'
            },
            MENUICON2: {
                position: 'relative',
                margin: '.09375em',
                padding: '.1875em',
                "font-size": "1.5em",
                cursor: 'pointer'
            },
            ITEMS: {
                'z-index': '2',
                position: 'relative',
                left: 0,
                //   width: '100%',
                //  height: '100%',
                'white-space': 'nowrap',
                'overflow-x': 'hidden',
                'overflow-y': 'scroll'
            },

            'ITEMS-left, ITEMS-left ITEMC': {
                $order: 1,
                top: '-1.5rem !important',
                height: 'auto',
                'text-align': 'left'
            },
            'ITEMS-center, ITEMS-center ITEMC': {
                $order: 1,
                height: 'auto',
                'text-align': 'center'
            },
            'ITEMS-right, ITEMS-right ITEMC': {
                $order: 1,
                top: '-1.5em',
                height: 'auto',
                'text-align': 'right'
            },
            'ITEMS-left HANDLE, ITEMS-right HANDLE': {
                $order: 2,
                display: 'block'
            },
            ITEM: {
                $order: 0,
                className: 'ood-btn'
            },
            'ITEM:hover': {
                className: 'ood-btn:hover'
            },
            'ITEM:active': {
                className: 'ood-btn:active'
            },
            'ITEM-disabled': {
                className: 'ood-btn-disabled'
            },
            // ITEMI: {
            //     $order: 0,
            //  //   'padding-left': '.125em',
            //     //keep this same with ITEM
            //     'vertical-align': 'top'
            // },
            'ITEMS-block ITEM, ITEMS-block ITEMI, ITEMS-block ITEMC': {
                $order: 2,
                display: 'block'
            },
            ITEMC: {
                $order: 0,
                padding: '0.25em 0em',
                'vertical-align': 'top',
                'text-align': 'center',
                'display': 'flex',
                'align-items': 'center',
                'justify-content': 'center'
            },

            HANDLE: {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie6 ? 1 : null,
                cursor: 'pointer',
                'vertical-align': 'middle',
                margin: '.125em'
            },
            'ITEM-checked HANDLE': {}
        },
        DataModel: {
            HAlign: null,
            barLocation: {
                ini: 'top',
                listbox: ['top', 'bottom', 'left', 'right'],
                action: function (v) {
                    var self = this,
                        hs = self.getSubNode('LIST'),
                        h = self.getSubNode('ITEMS'),
                        unit = 0 + self.$picku();
                    switch (v) {
                        case 'left':
                            hs.cssRegion({left: unit, top: unit, right: 'auto', bottom: unit});
                            break;
                        case 'top':
                            hs.cssRegion({left: unit, top: unit, right: unit, bottom: 'auto'});
                            break;
                        case 'right':
                            hs.cssRegion({left: 'auto', top: unit, right: unit, bottom: unit});
                            break;
                        case 'bottom':
                            hs.cssRegion({left: unit, top: 'auto', right: unit, bottom: unit});
                            break;
                    }
                    switch (v) {
                        case 'left':
                        case 'right':
                            h.tagClass('-block', true);
                            break;
                        case 'top':
                        case 'bottom':
                            h.tagClass('-block', false);
                            hs.height('auto');
                            break;
                    }
                    // add 'at' to be distinguished from ood-uibar-bottom
                    hs.tagClass('(-attop|-atbottom|-atleft|-atright)', false).tagClass('-at' + v, true);
                    this.adjustSize();
                }
            },
            barHAlign: {
                ini: 'left',
                listbox: ['left', 'center', 'right'],
                action: function (v) {
                    var hl = this.getSubNode('ITEMS');
                    hl.tagClass('(-left|-right|-center)', false).tagClass('-' + v, true);
                }
            },
            barVAlign: {
                ini: 'top',
                listbox: ['top', 'bottom'],
                action: function (v) {
                    var hl = this.getSubNode('ITEMS'),
                        unit = 0 + this.$picku();
                    if (v == 'top')
                        hl.cssRegion({top: unit, bottom: 'auto'});
                    else
                        hl.cssRegion({bottom: unit, top: 'auto'});
                    this.adjustSize();
                }
            },
            barSize: {
                $spaceunit: 1,
                ini: '2.5em',
                action: function (v) {
                    this.adjustSize();
                }
            },
            borderType: {
                ini: 'none',
                listbox: ['none', 'flat', 'inset', 'outset'],
                action: function (v) {
                    var ns = this,
                        p = ns.properties,
                        n1 = ns.getSubNode('LIST'),
                        reg = /^ood-uiborder-/,
                        flat = 'ood-uiborder-flat ood-uiborder-radius',
                        ins = 'ood-uiborder-inset ood-uiborder-radius',
                        outs = 'ood-uiborder-outset ood-uiborder-radius',
                        root = ns.getRoot();
                    n1.removeClass(reg);
                    switch (v) {
                        case 'flat':
                            n1.addClass(flat);
                            break;
                        case 'inset':
                            n1.addClass(ins);
                            break;
                        case 'outset':
                            n1.addClass(outs);
                            break;
                    }

                    //force to resize
                    this.adjustSize();
                }
            },
            noFoldBar: {
                ini: false,
                action: function (value) {
                    this.getSubNode('MENU2', true).css('display', value ? 'none' : 'block');
                }
            },
            sideBarStatus: {
                ini: 'expand',
                listbox: ['expand', 'fold'],
                action: function (v) {
                    var self = this,
                        t = self.properties,
                        us = ood.$us(self),
                        adjustunit = function (v, emRate) {
                            return self.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                        },
                        hl = self.getSubNode('ITEMS'),
                        menu2 = self.getSubNode('MENUICON2');

                    if (t.sideBarStatus == 'fold') {
                        hl.tagClass('-icon2', true);
                        menu2.tagClass('-checked', true);
                    } else {
                        hl.tagClass('-icon2', false);
                        menu2.tagClass('-checked', false);
                    }

                    this.adjustSize();
                }
            },
            sideBarSize: {
                ini: '3.25em',
                action: function (v) {
                    this.adjustSize();
                }
            }
        },
        Behaviors: {
            MENU2: {
                onClick: function (profile, e, src) {
                    profile.boxing().setSideBarStatus(profile.properties.sideBarStatus == 'fold' ? 'expand' : 'fold', true);
                }
            }
        },


        LayoutTrigger: function () {
            var pro = this.properties;
            this.boxing().setBarLocation(pro.barLocation, true)
                .setBarHAlign(pro.barHAlign, true)
                .setBarVAlign(pro.barVAlign, true);

            if (pro.barLocation == 'top' || pro.barLocation == 'bottom') {
                this.getSubNode('ITEMS').addClass('ood-css-noscroll');
            }
            if (pro.borderType && pro.borderType != 'none') this.boxing().setBorderType(pro.borderType, true);
        },
        _onresize: function (profile, width, height, force, key) {
            var prop = profile.properties,
                noPanel = prop.noPanel,
                noHandler = prop.noHandler,
                item = profile.getItemByItemId(key);

            if (!item) {
                key = prop.$UIvalue || prop.value;
                item = profile.getItemByItemId(key);
            }
            if (!item) {
                item = prop.items[0];
                key = item && item.id;
            }
            if (!item) return;

            var panel = profile.boxing().getPanel(key),
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                // caculate by px
                ww = width ? profile.$px(width, null, true) : width,
                hh = (height && height != 'auto') ? profile.$px(height, null, true) : height,
                root = profile.getRootNode(),
                hs = profile.getSubNode('LIST'),
                hl = profile.getSubNode('ITEMS'),
                menu2 = profile.getSubNode('MENU2'),

                fzrate = profile.getEmSize() / profile.getRoot()._getEmSize(),
                panelfz = panel._getEmSize(fzrate),
                hsfz = hs._getEmSize(fzrate),
                hlfz = hl._getEmSize(fzrate),
                cb = ood(root).contentBox(),
                type = prop.borderType,
                bw = !cb ? 0 : (type == 'flat' || type == 'inset' || type == 'outset') ? hs._borderW() : 0,
                wc = null,
                hc = null,
                top, left, itmsH;

            // side bar
            menu2.css('display', 'none');

            if (noHandler) {
                wc = ww;
                hc = hh;
            } else {
                if (prop.barLocation == 'top' || prop.barLocation == 'bottom') {
                    if (ood.browser.isTouch && (ood.browser.isAndroid || ood.browser.isBB)) {
                    } else {
                        hl.css('overflow-y', 'hidden');
                    }
                    itmsH = hs.height(prop.barSize || 'auto').offsetHeight(true);
                    hl.css('position', 'relative');

                    if (width) {
                        hs.width(adjustunit(ww - bw, hsfz));
                        hl.width(adjustunit(ww - bw, hlfz));

                        // for nopanel:
                        if (noPanel && height != 'auto') {
                            hs.height(adjustunit(hh - bw, hsfz));
                            hl.height(adjustunit(hh - bw, hsfz));
                        }

                        if (!noHandler) {
                            profile.box._adjustHScroll(profile);
                        }


                        left = 0;
                        wc = ww;
                    }
                    if (hh != 'auto') {
                        // caculate by px
                        if (hh - itmsH > 0) hc = hh - itmsH - bw;
                        //hs.height(adjustunit(itmsH, hsfz));
                    } else {
                        hc = hh;
                    }
                    var t;
                    if (prop.barLocation == 'top') {
                        // ensure it's the last
                        if ((t = root.firstElementChild || root.firstChild) != hs.get(0)) {
                            if (t) root.insertBefore(hs.get(0), t);
                            else root.appendChild(hs.get(0));
                        }
                    } else if (prop.barLocation == 'bottom') {
                        // ensure it's the last
                        if ((root.lastElementChild || root.lastChild) != hs.get(0)) {
                            root.appendChild(hs.get(0));
                        }
                    }
                } else {
                    //reset to default
                    if (ood.browser.isTouch && (ood.browser.isAndroid || ood.browser.isBB)) {
                    } else {
                        // bug: in mobile android, it will make hs._nodes.length=0
                        hl.css('overflow-y', 'scroll');
                    }
                    // side bar

                    menu2.css('display', (prop.sideBarSize && prop.noFoldBar) ? 'block' : 'none');

                    if (!noHandler)
                        profile.getSubNode('CAPTION', true).css('width', '');

                    // dont support auto height for 'top' or 'bottom' barLocation
                    // if (hh == 'auto') {
                    //     hh = 300;
                    // }

                    if (height) {
                        // for nopanel:
                        if (noPanel) {
                            if (ood.browser.isTouch && (ood.browser.isAndroid || ood.browser.isBB)) {
                            } else {
                                hl.css('overflow-y', 'hidden');
                            }
                            hs.width(adjustunit(ww - bw, hsfz));
                            hl.width(adjustunit(ww - bw, hsfz));
                        }

                        // for nopanel:
                        hs.height(adjustunit(hh - bw, hsfz));
                        hl.height('auto');
                        // for scroll by mouse wheel
                        if (hl.height() >= hs.height()) {
                            hl.height(adjustunit(hh - bw - (prop.sideBarSize ? menu2.offsetHeight() : 0), hlfz));
                        }
                        hl.css('position', prop.barVAlign == 'bottom' ? 'absolute' : 'relative');
                        hc = hh;
                    }
                    if (height || width) {
                        var v = profile.$px(prop.sideBarStatus == 'fold' ? prop.sideBarSize : prop.barSize, hlfz, true);
                        var vv = !cb ? 0 : (hl._paddingW() + hl._marginW());

                        //caculate by px
                        left = prop.barLocation == 'left' ? bw + profile.$px(v + vv, hsfz, true) : 0;
                        wc = ww - profile.$px(v + vv, hsfz, true) - bw;

                        hl.width('auto');

                        if (!noPanel) {
                            hs.width(adjustunit(v + vv, hsfz));
                            hl.width(adjustunit(v + ood.Dom.getScrollBarSize(), hlfz));
                        }
                    }
                }
            }

            if (!noPanel) {
                panel.cssRegion({
                    width: (wc = wc ? adjustunit(wc, panelfz) : null),
                    height: hc ? adjustunit(hc, panelfz) : null,
                    left: noHandler ? 0 : adjustunit(left, panelfz)
                }, true);
                if (wc) {
                    ood.UI._adjustConW(profile, panel, wc);
                }
            }
        }
    }
});ood.Class("ood.UI.MTabs", "ood.UI.Tabs", {

    Initialize: function () {
        var t = this.getTemplate(), keys = this.$Keys;
        // 
        if(!t){
            t = {};
            t.LIST = {};
            t.$submap = { items: { ITEM: {} } };
        }
        // LIST
        if(!t.LIST) t.LIST = {};
        // $submap
        if(!t.$submap) t.$submap = {};
        if(!t.$submap.items) t.$submap.items = {};
        if(!t.$submap.items.ITEM) t.$submap.items.ITEM = {};
        
        t.LIST.className = 'ood-uibar';
        this.setTemplate(t);
        t.$submap.items.ITEM.className = 'ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius {itemClass} {disabled} {readonly} {itemPosCls}';
        delete keys.LEFT;
        delete keys.RIGHT;
        delete keys.DROP;


    },
    
    Instance: {
        //  iniProp 
        iniProp: {
            "barLocation": "left",
            "barSize": "12em",
            "sideBarStatus": "fold",
            items: [{
                "caption": "item 1",
                "id": "a",
                "imageClass": "ri-number-1",
                "name": "item 1"
            },
                {
                    "caption": "item 2",
                    "id": "b",
                    "imageClass": "ri-number-2",
                    "name": "item 2"
                },
                {
                    "caption": "item 3",
                    "id": "c",
                    "imageClass": "ri-number-3",
                    "name": "item 3"
                },
                {
                    "caption": "item 4",
                    "id": "d",
                    "imageClass": "ri-number-4",
                    "name": "item 4"
                }],
            value: 'a'
        }
    },

    Static: {
        Appearances: {
            LIST: {
                'z-index': '2',
                position: 'absolute',
                'white-space': 'nowrap',
                overflow: 'hidden'
            },
            // for auto height
            'LIST-attop, LIST-atbottom': {
                $order: 2,
                position: 'relative'
            },
            LISTBG: {
                display: 'none'
            },
            MENU: {
                display: 'none',
                margin: '.25em',
                padding: '.25em',
                cursor: 'pointer'
            },
            MENU2: {
                display: 'none',
                'text-align': 'center'
            },
            MENUICON2: {
                position: 'relative',
                margin: '.09375em',
                padding: '.1875em',
                cursor: 'pointer'
            },
            ITEMS: {
                'z-index': '2',
                position: 'relative',
                left: 0,
                top: 0,
                width: '100%',
                height: '100%',
                'white-space': 'nowrap',
                'overflow-x': 'hidden',
                'overflow-y': 'scroll'
            },
            'ITEMS-left, ITEMS-left ITEMC': {
                $order: 1,
                height: 'auto',
                'text-align': 'left'
            },
            'ITEMS-center, ITEMS-center ITEMC': {
                $order: 1,
                height: 'auto',
                'text-align': 'center'
            },
            'ITEMS-right, ITEMS-right ITEMC': {
                $order: 1,
                height: 'auto',
                'text-align': 'right'
            },
            'ITEMS-left HANDLE, ITEMS-right HANDLE': {
                $order: 2,
                display: 'block'
            },
            ITEM: {
                $order: 0,
                margin: '.166667em',
                position: 'relative',
                cursor: 'pointer',
                'padding': '0 .125em 0 0',
                'vertical-align': 'top'
            },
            ITEMI: {
                $order: 0,
                'padding-left': '.125em',
                //keep this same with ITEM
                'vertical-align': 'top'
            },
            'ITEMS-block ITEM, ITEMS-block ITEMI, ITEMS-block ITEMC': {
                $order: 2,
                display: 'block'
            },
            ITEMC: {
                $order: 0,
                padding: '.15em 0 .125em 0',
                //keep this same with ITEM
                'vertical-align': 'top',
                'text-align': 'center'
            },
            HANDLE: {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie6 ? 1 : null,
                cursor: 'pointer',
                'vertical-align': 'middle',
                margin: '.125em'
            },
            'ITEM-checked HANDLE': {}
        },
        DataModel: {
            HAlign: null,
            barLocation: {
                ini: 'top',
                listbox: ['top', 'bottom', 'left', 'right'],
                action: function (v) {
                    var self = this,
                        hs = self.getSubNode('LIST'),
                        h = self.getSubNode('ITEMS'),
                        unit = 0 + self.$picku();
                    switch (v) {
                        case 'left':
                            hs.cssRegion({left: unit, top: unit, right: 'auto', bottom: unit});
                            break;
                        case 'top':
                            hs.cssRegion({left: unit, top: unit, right: unit, bottom: 'auto'});
                            break;
                        case 'right':
                            hs.cssRegion({left: 'auto', top: unit, right: unit, bottom: unit});
                            break;
                        case 'bottom':
                            hs.cssRegion({left: unit, top: 'auto', right: unit, bottom: unit});
                            break;
                    }
                    switch (v) {
                        case 'left':
                        case 'right':
                            h.tagClass('-block', true);
                            break;
                        case 'top':
                        case 'bottom':
                            h.tagClass('-block', false);
                            hs.height('auto');
                            break;
                    }
                    // add 'at' to be distinguished from ood-uibar-bottom
                    hs.tagClass('(-attop|-atbottom|-atleft|-atright)', false).tagClass('-at' + v, true);
                    this.adjustSize();
                }
            },
            barHAlign: {
                ini: 'left',
                listbox: ['left', 'center', 'right'],
                action: function (v) {
                    var hl = this.getSubNode('ITEMS');
                    hl.tagClass('(-left|-right|-center)', false).tagClass('-' + v, true);
                }
            },
            barVAlign: {
                ini: 'top',
                listbox: ['top', 'bottom'],
                action: function (v) {
                    var hl = this.getSubNode('ITEMS'),
                        unit = 0 + this.$picku();
                    if (v == 'top')
                        hl.cssRegion({top: unit, bottom: 'auto'});
                    else
                        hl.cssRegion({bottom: unit, top: 'auto'});
                    this.adjustSize();
                }
            },
            barSize: {
                $spaceunit: 1,
                ini: '2.5em',
                action: function (v) {
                    this.adjustSize();
                }
            },
            borderType: {
                ini: 'none',
                listbox: ['none', 'flat', 'inset', 'outset'],
                action: function (v) {
                    var ns = this,
                        p = ns.properties,
                        n1 = ns.getSubNode('LIST'),
                        reg = /^ood-uiborder-/,
                        flat = 'ood-uiborder-flat ood-uiborder-radius',
                        ins = 'ood-uiborder-inset ood-uiborder-radius',
                        outs = 'ood-uiborder-outset ood-uiborder-radius',
                        root = ns.getRoot();
                    n1.removeClass(reg);
                    switch (v) {
                        case 'flat':
                            n1.addClass(flat);
                            break;
                        case 'inset':
                            n1.addClass(ins);
                            break;
                        case 'outset':
                            n1.addClass(outs);
                            break;
                    }

                    //force to resize
                    this.adjustSize();
                }
            },
            noFoldBar: {
                ini: false,
                action: function (value) {
                    this.getSubNode('MENU2', true).css('display', value ? 'none' : 'block');
                }
            },
            sideBarStatus: {
                ini: 'expand',
                listbox: ['expand', 'fold'],
                action: function (v) {
                    var self = this,
                        t = self.properties,
                        us = ood.$us(self),
                        adjustunit = function (v, emRate) {
                            return self.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                        },
                        hl = self.getSubNode('ITEMS'),
                        menu2 = self.getSubNode('MENUICON2');

                    if (t.sideBarStatus == 'fold') {
                        hl.tagClass('-icon2', true);
                        menu2.tagClass('-checked', true);
                    } else {
                        hl.tagClass('-icon2', false);
                        menu2.tagClass('-checked', false);
                    }

                    this.adjustSize();
                }
            },
            sideBarSize: {
                ini: '3em',
                action: function (v) {
                    this.adjustSize();
                }
            }
        },
        Behaviors: {
            MENU2: {
                onClick: function (profile, e, src) {
                    profile.boxing().setSideBarStatus(profile.properties.sideBarStatus == 'fold' ? 'expand' : 'fold', true);
                }
            }
        },

        LayoutTrigger: function () {
            var pro = this.properties;
            this.boxing().setBarLocation(pro.barLocation, true)
                .setBarHAlign(pro.barHAlign, true)
                .setBarVAlign(pro.barVAlign, true);

            if (pro.barLocation == 'top' || pro.barLocation == 'bottom') {
                this.getSubNode('ITEMS').addClass('ood-css-noscroll');
            }
            if (pro.borderType && pro.borderType != 'none') this.boxing().setBorderType(pro.borderType, true);
        },
        _onresize: function (profile, width, height, force, key) {
            var prop = profile.properties,
                noPanel = prop.noPanel,
                noHandler = prop.noHandler,
                item = profile.getItemByItemId(key);

            if (!item) {
                key = prop.$UIvalue || prop.value;
                item = profile.getItemByItemId(key);
            }
            if (!item) {
                item = prop.items[0];
                key = item && item.id;
            }
            if (!item) return;

            var panel = profile.boxing().getPanel(key),
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                // caculate by px
                ww = width ? profile.$px(width, null, true) : width,
                hh = (height && height != 'auto') ? profile.$px(height, null, true) : height,
                root = profile.getRootNode(),
                hs = profile.getSubNode('LIST'),
                hl = profile.getSubNode('ITEMS'),
                menu2 = profile.getSubNode('MENU2'),

                fzrate = profile.getEmSize() / profile.getRoot()._getEmSize(),
                panelfz = panel._getEmSize(fzrate),
                hsfz = hs._getEmSize(fzrate),
                hlfz = hl._getEmSize(fzrate),
                cb = ood(root).contentBox(),
                type = prop.borderType,
                bw = !cb ? 0 : (type == 'flat' || type == 'inset' || type == 'outset') ? hs._borderW() : 0,
                wc = null,
                hc = null,
                top, left, itmsH;

            // side bar
            menu2.css('display', 'none');

            if (noHandler) {
                wc = ww;
                hc = hh;
            } else {
                if (prop.barLocation == 'top' || prop.barLocation == 'bottom') {
                    if (ood.browser.isTouch && (ood.browser.isAndroid || ood.browser.isBB)) {
                    } else {
                        hl.css('overflow-y', 'hidden');
                    }
                    itmsH = hs.height(prop.barSize || 'auto').offsetHeight(true);
                    hl.css('position', 'relative');

                    if (width) {
                        hs.width(adjustunit(ww - bw, hsfz));
                        hl.width(adjustunit(ww - bw, hlfz));

                        // for nopanel:
                        if (noPanel && height != 'auto') {
                            hs.height(adjustunit(hh - bw, hsfz));
                            hl.height(adjustunit(hh - bw, hsfz));
                        }

                        if (!noHandler)
                            profile.box._adjustHScroll(profile);

                        left = 0;
                        wc = ww;
                    }
                    if (hh != 'auto') {
                        // caculate by px
                        if (hh - itmsH > 0) hc = hh - itmsH - bw;
                        //hs.height(adjustunit(itmsH, hsfz));
                    } else {
                        hc = hh;
                    }
                    var t;
                    if (prop.barLocation == 'top') {
                        // ensure it's the last
                        if ((t = root.firstElementChild || root.firstChild) != hs.get(0)) {
                            if (t) root.insertBefore(hs.get(0), t);
                            else root.appendChild(hs.get(0));
                        }
                    } else if (prop.barLocation == 'bottom') {
                        // ensure it's the last
                        if ((root.lastElementChild || root.lastChild) != hs.get(0)) {
                            root.appendChild(hs.get(0));
                        }
                    }
                } else {
                    //reset to default
                    if (ood.browser.isTouch && (ood.browser.isAndroid || ood.browser.isBB)) {
                    } else {
                        // bug: in mobile android, it will make hs._nodes.length=0
                        hl.css('overflow-y', 'scroll');
                    }
                    // side bar

                    menu2.css('display', (prop.sideBarSize && prop.noFoldBar) ? 'block' : 'none');

                    if (!noHandler)
                        profile.getSubNode('CAPTION', true).css('width', '');

                    // dont support auto height for 'top' or 'bottom' barLocation
                    if (hh == 'auto') {
                        hh = 300;
                    }

                    if (height) {
                        // for nopanel:
                        if (noPanel) {
                            if (ood.browser.isTouch && (ood.browser.isAndroid || ood.browser.isBB)) {
                            } else {
                                hl.css('overflow-y', 'hidden');
                            }
                            hs.width(adjustunit(ww - bw, hsfz));
                            hl.width(adjustunit(ww - bw, hsfz));
                        }

                        // for nopanel:
                        hs.height(adjustunit(hh - bw, hsfz));
                        hl.height('auto');
                        // for scroll by mouse wheel
                        if (hl.height() >= hs.height()) {
                            hl.height(adjustunit(hh - bw - (prop.sideBarSize ? menu2.offsetHeight() : 0), hlfz));
                        }
                        hl.css('position', prop.barVAlign == 'bottom' ? 'absolute' : 'relative');
                        hc = hh;
                    }
                    if (height || width) {
                        var v = profile.$px(prop.sideBarStatus == 'fold' ? prop.sideBarSize : prop.barSize, hlfz, true);
                        var vv = !cb ? 0 : (hl._paddingW() + hl._marginW());

                        //caculate by px
                        left = prop.barLocation == 'left' ? bw + profile.$px(v + vv, hsfz, true) : 0;
                        wc = ww - profile.$px(v + vv, hsfz, true) - bw;

                        hl.width('auto');

                        if (!noPanel) {
                            hs.width(adjustunit(v + vv, hsfz));
                            hl.width(adjustunit(v + ood.Dom.getScrollBarSize(), hlfz));
                        }
                    }
                }
            }

            if (!noPanel) {
                panel.cssRegion({
                    width: (wc = wc ? adjustunit(wc, panelfz) : null),
                    height: hc ? adjustunit(hc, panelfz) : null,
                    left: noHandler ? 0 : adjustunit(left, panelfz)
                }, true);
                if (wc) {
                    ood.UI._adjustConW(profile, panel, wc);
                }
            }
        }
    }
});ood.Class("ood.UI.RadioBox", "ood.UI.List", {
        Initialize: function () {
            //modify default template for shell
            var t = this.getTemplate();
            t.className = '{_className}';
            t.ITEMS.className = '{_bordertype}';
            t.$submap = {
                items: {
                    ITEM: {
                        className: 'ood-showfocus {_itemRow} {itemClass} {disabled} {readonly}',
                        style: '{itemStyle}{_itemDisplay}',
                        tabindex: '{_tabindex}',
                        MARK: {
                            $order: 0,
                            className: 'oodfont',
                            $fonticon: '{_fi_markcls}'
                        },
                        ICON: {
                            $order: 1,
                            className: 'oodcon {imageClass}  {picClass}',
                            style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{imageDisplay}{iconStyle}',
                            text: '{iconFontCode}'
                        },
                        CAPTION: {
                            text: '{caption}',
                            $order: 2
                        }
                    }
                }
            };
            this.setTemplate(t);
        },
        Instance: {

            iniProp: {
                items: [
                    {id: 'option1', caption: '1', value: '1'},
                    {id: 'option2', caption: '2', value: '2'},
                    {id: 'option3', caption: '3', value: '3'},
                    {id: 'option4', caption: '4', value: '4', disabled: true}
                ],

            value: 'option1',
            checkBox: true,
            selMode: "multibycheckbox"
            , caption: ood.getRes('RAD.widgets.selection') || ""
        },
        //  ()
        setTheme: function (theme) {
            return this.each(function (profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();

                // CSS
                if (!document.getElementById('radiobox-theme-css')) {
                    var link = document.createElement('link');
                    link.id = 'radiobox-theme-css';
                    link.rel = 'stylesheet';
                    link.href = '/ood/css/radiobox-themes.css';
                    document.head.appendChild(link);
                }


                // 
                root.removeClass('radiobox-dark radiobox-light radiobox-hc');
                root.addClass('radiobox-' + theme);

                // 
                localStorage.setItem('radiobox-theme', theme);

                // 
                //  ood(root).trigger('themeChanged', {theme: theme});
            });
        },

        // 
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('radiobox-theme') || 'light';
        },


        RadioBoxTrigger: function () {
            var profile = this.get(0);
            var prop = profile.properties,
                boxing = this;

            // 
            // 
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('radiobox-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                boxing.adjustLayout();
            }

            // 
            boxing.enhanceAccessibility();
        },
        // 
        toggleDarkMode: function () {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },

        // 
        adjustLayout: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    prop = profile.properties;

                // 
                root.removeClass('radiobox-mobile radiobox-tiny radiobox-small');

                // 
                if (width < 480) {
                    root.addClass('radiobox-tiny');
                } else if (width < 768) {
                    root.addClass('radiobox-mobile');
                } else if (width < 1024) {
                    root.addClass('radiobox-small');
                }

                // resizeCSS
                //ood(window).fireEvent('resize');
            });
        },

        //  ()
        enhanceAccessibility: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    items = profile.getSubNode('ITEM', true),
                    marks = profile.getSubNode('MARK', true),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'radiogroup',
                    'aria-label': properties.caption || '',
                    'aria-orientation': properties.vertical ? 'vertical' : 'horizontal'
                });

                // ARIA
                items.each(function (item) {
                    var itemNode = ood(item);
                    var itemId = itemNode.id();
                    if (itemId) {
                        var itemData = profile.getItemByDom(item);
                        if (itemData) {
                            itemNode.attr({
                                'role': 'radio',
                                'aria-checked': itemData.selected ? 'true' : 'false',
                                'aria-label': itemData.caption || itemData.id,
                                'tabindex': itemData.selected ? '0' : '-1',
                                'aria-disabled': itemData.disabled ? 'true' : 'false'
                            });

                            // 
                            itemNode.on('keydown', function (e) {
                                if (e.key === 'Enter' || e.key === ' ') {
                                    // itemNode.fireEvent('click');
                                    e.preventDefault();
                                }
                            });
                        }
                    }
                });

                // ARIA
                marks.each(function (mark) {
                    var markNode = ood(mark);
                    markNode.attr({
                        'aria-hidden': 'true',
                        'focusable': 'false'
                    });
                });
            });
        }
    },
    Static
:
{
    _DIRTYKEY:'MARK',
        _ITEMMARKED
:
    true,
        Appearances
:
    {
        ITEM:{
            className: 'ood-radiobox-item'
        }
    ,
        'ITEM-checked'
    :
        {
            className: 'ood-radiobox-item-checked'
        }
    ,
        CAPTION:{
            className: 'ood-radiobox-caption'
        }
    ,
        ITEMS:{
            className: 'ood-radiobox-items'
        }
    ,
        MARK:{
            className: 'ood-radiobox-mark'
        }
    ,

        // 
        'radiobox-mobile ITEM'
    :
        {
            className: 'radiobox-mobile .ood-radiobox-item'
        }
    ,
        'radiobox-mobile MARK'
    :
        {
            className: 'radiobox-mobile .ood-radiobox-mark'
        }
    ,
        'radiobox-mobile CAPTION'
    :
        {
            className: 'radiobox-mobile .ood-radiobox-caption'
        }
    ,
        'radiobox-tiny ICON'
    :
        {
            className: 'radiobox-tiny .ood-radiobox-icon'
        }
    ,
        'radiobox-tiny CAPTION'
    :
        {
            className: 'radiobox-tiny .ood-radiobox-caption'
        }
    ,
        'radiobox-tiny ITEM'
    :
        {
            className: 'radiobox-tiny .ood-radiobox-item'
        }
    }
,
    DataModel:{
        // 
        theme: {
            ini: 'light',
                listbox
        :
            ['light', 'dark', 'high-contrast'],
                action
        :

            function (value) {
                this.boxing().setTheme(value);
            }
        }
    ,
        responsive: {
            ini: true,
                action
        :

            function (value) {
                if (value) {
                    this.boxing().adjustLayout();
                }
            }
        }
    ,

        expression:{
            ini:'',
                action
        :

            function () {
            }
        }
    ,
        tagCmds:null,
            borderType
    :
        {
            ini:'none'
        }
    ,
        checkBox:{
            ini:false,
                action
        :

            function (v) {
                this.getSubNode('MARK', true).replaceClass(v ? /(uicmd-radio)|(\s+uicmd-radio)/g : /(^uicmd-check)|(\s+uicmd-check)/g, v ? ' ood-uicmd-check' : ' ood-uicmd-radio');
            }
        }
    }
,
    Behaviors:{
        HoverEffected:{
            ITEM:null, MARK
        :
            'MARK'
        }
    ,
        ClickEffected:{
            ITEM:null, MARK
        :
            'MARK'
        }
    }
,
    EventHandlers:{
        onCmd:null
    }
,
    _prepareItem:function (profile, item) {
        item._fi_markcls = profile.properties.checkBox ? 'ood-uicmd-check' : 'ood-uicmd-radio';
        item._itemRow = profile.properties.itemRow ? 'ood-item-row' : '';
    }
,

    RenderTrigger: function () {
        // 
        var self = this;
        ood.asyRun(function () {
            self.boxing().RadioBoxTrigger();
        });
    }


}
})
;
ood.Class("ood.UI.StatusButtons", ["ood.UI.List"], {
    Instance: {
        //  iniProp 
        iniProp: {
            items: [{id: 'a', caption: 'status 1'}, {id: 'b', caption: 'status 2'}, {
                id: 'c',
                caption: 'status 3'
            }, {id: 'd', caption: 'status 4'}],
            borderType: 'none',
            itemMargin: '2px 4px',
            itemWidth: '4em',
            width: '30em',
            value: 'a'
        },

        // 
        setTheme: function (theme) {
            return this.each(function (profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();

                // 
                root.removeClass('statusbuttons-dark statusbuttons-hc');

                // 
                if (theme === 'dark') {
                    root.addClass('statusbuttons-dark');
                } else if (theme === 'high-contrast') {
                    root.addClass('statusbuttons-hc');
                } else {
                    root.removeClass('statusbuttons-dark statusbuttons-hc');
                }

                // 
                localStorage.setItem('statusbuttons-theme', theme);
            });
        },

        // 
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('statusbuttons-theme') || 'light';
        },

        // 
        toggleTheme: function () {
            var current = this.getTheme();
            var next = current === 'light' ? 'dark' :
                current === 'dark' ? 'high-contrast' : 'light';
            this.setTheme(next);
            return this;
        },

        // 
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('statusbuttons-theme') || 'light';
        },


        StatusButtonsTrigger: function () {
            var profile = this.get(0);
            var prop = profile.properties;
            var boxing = this;

            // 
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('statusbuttons-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                boxing.adjustLayout();
            }

            // 
            boxing.enhanceAccessibility();
        },


        // 
        toggleDarkMode: function () {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },

        // 
        adjustLayout: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    items = profile.getSubNode('ITEM', true),
                    icons = profile.getSubNode('ICON', true),
                    captions = profile.getSubNode('CAPTION', true),
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('statusbuttons-mobile');

                    // 
                    items.css({
                        'min-height': '2.2em',
                        'font-size': '0.9em',
                        'padding': '0.4em 0.6em'
                    });

                    // 
                    icons.css({
                        'font-size': '1.1em'
                    });

                    // 
                    captions.css({
                        'font-size': '0.9em'
                    });
                } else {
                    root.removeClass('statusbuttons-mobile');

                    // 
                    items.css({
                        'min-height': '',
                        'font-size': '',
                        'padding': ''
                    });

                    icons.css({
                        'font-size': ''
                    });

                    captions.css({
                        'font-size': ''
                    });
                }

                // 
                if (width < 480) {
                    root.addClass('statusbuttons-tiny');

                    // 
                    captions.each(function (caption) {
                        var captionElement = ood(caption);
                        var text = captionElement.text();
                        if (text && text.length > 4) {
                            captionElement.css('display', 'none');
                        }
                    });
                } else {
                    root.removeClass('statusbuttons-tiny');

                    // 
                    captions.css('display', '');
                }
            });
        },

        // 
        enhanceAccessibility: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    items = profile.getSubNode('ITEMS', true),
                    icons = profile.getSubNode('ICON', true),
                    captions = profile.getSubNode('CAPTION', true),
                    flags = profile.getSubNode('FLAG', true),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'toolbar',
                    'aria-label': '',
                    'aria-orientation': 'horizontal'
                });

                // ARIA
                items.each(function (item) {
                    var itemElement = ood(item),
                        itemIndex = ood.arr.indexOf(items, item),
                        itemData = profile.properties.items && profile.properties.items[itemIndex],
                        itemText = itemData && itemData.caption || '';

                    if (itemElement.hasClass('ood-ui-btn')) {
                        itemElement.attr({
                            'role': 'button',
                            'aria-label': itemText,
                            'aria-pressed': itemElement.hasClass('ITEM-checked') ? 'true' : 'false',
                            'tabindex': properties.disabled ? '-1' : '0'
                        });
                    } else {
                        itemElement.attr({
                            'role': 'menuitemradio',
                            'aria-label': itemText,
                            'aria-checked': itemElement.hasClass('ITEM-checked') ? 'true' : 'false',
                            'tabindex': properties.disabled ? '-1' : '0'
                        });
                    }
                });

                // ARIA
                icons.each(function (icon) {
                    var iconElement = ood(icon);
                    iconElement.attr({
                        'aria-hidden': 'true'
                    });
                });

                // ARIA
                flags.each(function (flag) {
                    var flagElement = ood(flag),
                        flagText = flagElement.text();

                    if (flagText) {
                        flagElement.attr({
                            'role': 'status',
                            'aria-label': ': ' + flagText
                        });
                    }
                });
            });
        }
    },
    Initialize: function () {
        //modify default template fro shell
        var t = this.getTemplate();

        t.className = '{_className}';
        t.ITEMS.className = '{_bordertype }';
        t.ITEMS.style = '{_align}';
        t.$submap = {
            items: {
                ITEM: {
                    className: '{_itemClass} {itemClass} {disabled} {readonly} ',
                    style: '{itemPadding};{itemMargin};{itemWidth};{itemAlign};{itemStyle};{_display} {_itemColor}',
                    tabindex: '{_tabindex}',
                    ICON: {
                        $order: 10,
                        className: 'oodcon {imageClass} {picClass}',
                        style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{imageDisplay}{iconStyle}{_iconColor}',
                        text: '{iconFontCode}'
                    },
                    CAPTION: {
                        $order: 11,
                        style: '{_fontColor}',
                        text: '{caption}'
                    },
                    DROP: {
                        $order: 12,
                        className: 'oodfont',
                        $fonticon: 'ood-uicmd-arrowdrop',
                        style: '{_dropDisplay}'
                    },
                    FLAG: {
                        $order: 13,
                        className: 'ood-display-none {flagClass}',
                        style: '{_flagStyle};{flagStyle}',
                        text: '{flagText}'
                    }
                }
            }
        };
        this.setTemplate(t);
    },
    Static: {
        Appearances: {
            ITEMS: {
                position: 'relative',
                overflow: 'visible'
                // ,
                // 'text-align': 'center'
            },
            ITEM: {
                'vertical-align': 'middle',
                position: 'relative',
                'padding': 'var(--ood-statusbtn-padding)',
                'margin': '.166667em',
                'cursor': 'pointer',
                'white-space': 'nowrap',
                'border-radius': 'var(--ood-statusbtn-border-radius)',
                'background': 'var(--ood-statusbtn-default-bg)',
                'border': 'var(--ood-statusbtn-default-border)',
                'color': 'var(--ood-statusbtn-default-text)',
                'transition': 'all 0.2s ease'
            },
            'ITEM-hover': {
                'background': 'var(--ood-statusbtn-hover-bg)'
            },
            'ITEM-active, ITEM-checked': {
                'background': 'var(--ood-statusbtn-active-bg)',
                'color': 'var(--ood-statusbtn-active-text)'
            },
            CAPTION: {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie6 ? 1 : null,
                'vertical-align': 'middle',
                margin: "0 0.8em 0 0.3em",
                'font-size': '1.2em'
            },
            DROP: {
                'vertical-align': 'middle'
            },
            FLAG: {
                top: '-.5em',
                right: '-.5em',
                position: 'absolute',
                'z-index': 10
            }
        },
        DataModel: ({
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark'],
                action: function (value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function (value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },

            expression: {
                ini: '',
                action: function () {
                }
            },
            menuType: {
                ini: 'BOTTOMBAR'
            },
            iconColors: null,
            itemColors: null,
            fontColors: {
                ini: '',
                type: "color",
                caption: "",
                action: function (value) {
                    this.getRoot().css('color', value);
                }
            },

            expression: {
                ini: '',
                action: function () {
                }
            },
            autoFontColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoIconColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemColor: {
                ini: true,
                action: function () {
                    this.boxing().refresh();
                }
            },
            maxHeight: null,
            tagCmds: null,
            height: 'auto',
            align: {
                ini: "center",
                listbox: ['', 'left', 'center', 'right'],
                action: function (value) {
                    this.getSubNode('ITEMS', true).css('text-align', value);
                }
            },

            itemMargin: {
                ini: "",
                action: function (value) {
                    this.getSubNode('ITEM', true).css('margin', v);
                }
            },
            itemPadding: {
                ini: "",
                action: function (v) {
                    this.getSubNode('ITEM', true).css('padding', v);
                }
            },
            itemWidth: {
                $spaceunit: 1,
                ini: "auto",
                action: function (v) {
                    this.getSubNode('ITEM', true).width(v || 'auto');
                }
            },
            itemAlign: {
                ini: "",
                listbox: ['', 'left', 'center', 'right'],
                action: function (value) {
                    this.getSubNode('ITEM', true).css('text-align', value);
                }
            },

            itemType: {
                ini: "button",
                listbox: ['text', 'button', 'dropButton'],
                action: function (value) {
                    this.boxing().refresh();
                }
            },
            connected: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            }
        }),
        Behaviors: {
            DroppableKeys: ["ITEMS"]
        },
        EventHandlers: {
            onCmd: null
        },

        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile), t, v;
            var p = profile.properties, ns = this;
            if (p.align) {
                data._align = "text-align:" + p.align;
            }
            ood.arr.each(data.items, function (item) {
                if (!item.index) {
                    item.index = ood.arr.indexOf(data.items, item);
                }
                profile.boxing()._autoColor(item, item.index, p);
            })
            return data;
        },


        _prepareItem: function (profile, item, oitem, pid, index, len) {
            var p = profile.properties, t,
                type = item.type || p.itemType;
            item._tabindex = p.tabindex;

            profile.boxing()._autoColor(item, index, p);

            if (p.connected) item.itemMargin = "margin:" + (index === 0 ? "0" : "0 0 0 -1px");
            else if (t = item.itemMargin || p.itemMargin) item.itemMargin = "margin:" + t;

            if (t = item.itemPadding || p.itemPadding) item.itemPadding = "padding:" + t;

            if (t = item.itemWidth || p.itemWidth) item.itemWidth = "width:" + profile.$forceu(t || 'auto');
            if (t = item.itemAlign || p.itemAlign) item.itemAlign = "text-align:" + t;

            if (item.flagText || item.flagClass) item._flagStyle = 'display:block';
            if (!item.flagClass) item.flagClass = 'ood-uiflag-1';
            if (!item.iconFontSize) item.iconFontSize = 'iconFontSize:1.2em';

            item._itemClass = type == "text" ? "ood-node-a"
                : ("ood-ui-btn ood-uibar ood-uigradient " + (p.connected ? (index == 0 ? "ood-uiborder-radius-tl ood-uiborder-radius-bl ood-uiborder-noradius-r"
                    : index === len - 1 ? "ood-uiborder-radius-tr ood-uiborder-radius-br ood-uiborder-noradius-l"
                        : "ood-uiborder-noradius")
                    : "ood-uiborder-radius"));

            item._dropDisplay = type == "dropButton" ? '' : 'display:none';
            item.hidden ? item._display = 'display:none' : '';


        },

        RenderTrigger: function () {
            // 
            var self = this;
            ood.asyRun(function () {
                self.boxing().StatusButtonsTrigger();
            });
        }
    }
});

ood.Class("ood.UI.TreeBar", ["ood.UI", "ood.absList", "ood.absValue"], {

    Instance: {
        //  iniProp 
        iniProp: {
            items: [
                {
                    id: 'node1', sub: [
                        {id: 'node12', imageClass: "ri-image-line"}
                    ]
                }, {
                    id: 'node2',
                    initFold: false
                }],
            theme: 'dark',
            responsive: true,
            initFold: true,
            animCollapse: true,
            dock: 'fill',
            group: false,
            selMode: 'single',
            noCtrlKey: true,
            singleOpen: false,
            dynDestory: false,
            optBtn: "",
            togglePlaceholder: false,
            tagCmds: [],
            tagCmdsAlign: "right",
            autoItemColor: false,
            autoIconColor: true,
            autoFontColor: false,
            position: 'absolute'
        },

        _setCtrlValue: function (value, flag) {
            return this.each(function (profile) {
                if (!profile.renderId) return;

                var box = profile.boxing(),
                    uiv = box.getUIValue(),
                    properties = profile.properties,
                    fun = function (key, o, b) {
                        profile.getSubNodeByItemId(key, o).tagClass('-checked', b);
                    },
                    selmode = properties.selMode
                ;
                if (selmode == 'single' || selmode == 'singlecheckbox') {
                    var itemId = profile.getSubIdByItemId(uiv);
                    if (uiv && itemId) {
                        fun('BAR', uiv, false);
                        if (selmode == 'singlecheckbox') {
                            fun('MARK', uiv, false);
                        }
                    }


                    itemId = profile.getSubIdByItemId(value);
                    if (itemId) {
                        fun('BAR', value, true);
                        if (selmode == 'singlecheckbox') {
                            fun('MARK', value, true);
                        }
                        //scroll
                        if (!profile._noScroll) {
                            var o = profile.getSubNode('ITEM', itemId);
                            if (o) {
                                var items = profile.getSubNode('BOX'),
                                    offset = o.offset(null, items),
                                    top = offset ? offset.top : 0,
                                    height = o.offsetHeight(),
                                    sh = items.scrollHeight(),
                                    st = items.scrollTop(),
                                    hh = items.height();
                                if (sh > hh)
                                    if (top < st || (top + height) > (st + hh))
                                        items.scrollTop(top);
                            }
                        }
                    }
                } else if (selmode == 'multi' || selmode == 'multibycheckbox') {
                    uiv = uiv ? uiv.split(properties.valueSeparator) : [];
                    value = value ? value.split(properties.valueSeparator) : [];
                    if (flag) {
                        ood.arr.each(value, function (o) {
                            fun('BAR', o);
                            if (selmode == 'multibycheckbox') {
                                fun('MARK', o);
                            }

                        });
                    } else {
                        //check all
                        ood.arr.each(uiv, function (o) {
                            fun('BAR', o, false);
                            if (selmode == 'multibycheckbox') {
                                fun('MARK', o, false);
                            }
                        });
                        ood.arr.each(value, function (o) {
                            fun('BAR', o);
                            if (selmode == 'multibycheckbox') {
                                fun('MARK', o);
                            }
                        });
                    }
                }
            });
        },
        insertItems: function (arr, pid/*true: the current item*/, base/*true: the current item*/, before, toggle) {
            var node, data,
                b = this._afterInsertItems;

            return this.each(function (profile) {
                // prepare properties format
                var tar, r, k, newsub,
                    prop = profile.properties;

                data = profile.box._adjustItems(arr);

                // current
                if (pid === true) {
                    v = prop.$UIvalue || prop.value;
                    if (v) v = (v + '').split(prop.valueSeparator);
                    k = profile.getItemByItemId(v[0]);
                    pid = k ? k.id : null;
                }

                if (pid) {
                    k = profile.getItemByItemId(pid);
                    tar = ood.isArr(k.sub) ? k.sub : (newsub = true, k.sub = []);
                } else {
                    k = prop;
                    tar = k.items || (k.items = [])
                }
                //1
                if (profile.renderId) {
                    if (base === true) {
                        v = prop.$UIvalue || prop.value;
                        if (v) v = (v + '').split(prop.valueSeparator);
                        k = profile.getItemByItemId(v[0]);
                        base = k ? k.id : null;
                    }
                    if (base) {
                        node = profile.getSubNodeByItemId('ITEM', base);
                        if (node) {
                            r = profile._buildItems('items', profile.box._prepareItems(profile, data, pid));
                            if (before)
                                node.addPrev(r);
                            else
                                node.addNext(r);
                        }
                    } else {
                        if (!pid)
                            node = profile.getSubNode('ITEMS');
                        else if (pid) {
                            if (newsub) {
                                profile.getSubNodeByItemId('TOGGLE', pid)
                                    .removeClass('ood-icon-placeholder ood-uicmd-none')
                                    .addClass('ood-uicmd-toggle');
                            }
                            if (k._inited) {
                                node = profile.getSubNodeByItemId('SUB', pid);
                            }
                        }
                        if (node) {
                            r = profile._buildItems('items', profile.box._prepareItems(profile, data, pid));
                            if (before)
                                node.prepend(r);
                            else
                                node.append(r);
                        }
                    }
                }
                //2
                //must be here
                if (!base)
                    ood.arr.insertAny(tar, data, before ? 0 : -1);
                else {
                    var index = ood.arr.subIndexOf(tar, 'id', base);
                    ood.arr.insertAny(tar, data, before ? index : (index + 1));
                }
                //3
                if (profile.renderId && toggle !== false) {
                    // try to open root subs
                    if (!pid) {
                        profile.boxing()._toggleNodes(data, true, true, true);
                    }
                    // try to open parent node
                    else if (profile.getItemByItemId(pid)._inited) {
                        if (!(('initFold' in k) ? k.initFold : profile.properties.initFold))
                            profile.boxing()._toggleNodes(data, true, true, true);
                    }
                }

                if (b && profile.renderId)
                    profile.boxing()._afterInsertItems(profile, data, pid, base, before);

                if (profile.renderId && pid) {
                    profile.box._tofold(profile, k, pid);
                }

            });
        },
        // 
        _toggleNodes: function (items, expand, recursive, init) {
            var self = this, prf = self.get(0), pro = prf.properties;

            // ARIA
            var updateAria = function (nodeId, expanded) {
                var node = prf.getSubNodeByItemId('TOGGLE', nodeId);
                if (node) node.attr('aria-expanded', expanded ? 'true' : 'false');
            };
            f = function (items, expand, recursive, init) {
                if (ood.isArr(items)) {
                    ood.arr.each(items, function (o) {
                        if (init && (ood.isBool(o.initFold) ? o.initFold : pro.initFold)) return;
                        self.toggleNode(o.id, expand, false, recursive);
                        if (recursive && o.sub && ood.isArr(o.sub) && o.sub.length)
                            f(o.sub, expand, true, init);
                    });
                }
            };
            f(items, expand, recursive, init);
            return self;
        },

        /**
         * Recursively remove all child node keys
         * @param {Array} arr - ID array
         * @param {Array} captionarr - Caption array
         * @param {Object} item - 
         * @param {Object} profile - 
         * @returns {Array} 
         */
        _removeAllkeys: function (arr, captionarr, item, profile) {
            ood.each(item.sub, function (subitem) {
                ood.arr.removeValue(arr, subitem.id);
                ood.arr.removeValue(captionarr, subitem.caption);
                if (subitem.sub && subitem.sub.length > 0) {
                    arr = profile.boxing()._removeAllkeys(arr, captionarr, subitem, profile);
                }
            });
            return arr;
        },


        // 
        setTheme: function (theme) {
            return this.each(function (profile) {
                var root = profile.getRoot();

                // CSS
                if (!document.getElementById('treebar-theme-css')) {
                    var link = document.createElement('link');
                    link.id = 'treebar-theme-css';
                    link.rel = 'stylesheet';
                    link.href = 'ood/css/treebar-themes.css';
                    document.head.appendChild(link);
                }

                // 
                root.removeClass('treebar-dark treebar-hc');
                if (theme === 'dark') root.addClass('treebar-dark');
                else if (theme === 'high-contrast') root.addClass('treebar-hc');

                // 
                localStorage.setItem('treebar-theme', theme);
            });
        },

        // 
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('treebar-theme') || 'light';
        },


        /**
         * Recursively add all child node keys
         * @param {Array} arr - ID
         * @param {Array} captionarr - 
         * @param {Object} item - 
         * @param {Object} profile - 
         * @returns {Array} 
         */
        _addAllkeys: function (arr, captionarr, item, profile) {
            ood.each(item.sub, function (subitem) {
                arr.push(subitem.id);
                captionarr.push(subitem.caption);
                if (subitem.sub && subitem.sub.length > 0) {
                    arr = profile.boxing()._addAllkeys(arr, captionarr, subitem, profile);
                }
            });
            return arr;
        },
        /**
         * Toggle node expand/collapse state
         * @param {String} id - ID
         * @param {Boolean} expand - true:expand, false:collapse, undefined:toggle current state
         * @param {Boolean} recursive - Whether to recursively operate on child nodes
         * @param {Boolean} stopanim - Whether to stop animation effects
         * @param {Function} callback - 
         * @returns {Object} 
         */
        toggleNode: function (id, expand, recursive, stopanim, callback) {
            var profile = this.get(0),
                ns = this,
                self = arguments.callee;

            if (id) {
                var o = profile.getItemByItemId(id);

                if (o && o.sub && (expand == true || !ood.isSet(expand) || !!expand !== !!o._checked)) {
                    profile.box._setSub(profile, o, ((ood.isSet(expand) ? !!expand : !o._checked)), recursive, stopanim || recursive, callback);
                }
            } else {
                ood.arr.each(profile.properties.items, function (item) {
                    if (item.sub) self.call(ns, item.id, expand, recursive);
                });
            }
            return this;
        },

        /**
         * Reload node data
         * @param {String} id - ID
         * @param {Boolean} expand - Whether to expand after reloading
         * @param {Boolean} recursive - 
         * @param {Boolean} stopanim - 
         * @param {Function} callback - 
         * @returns {Object} 
         */
        reloadNode: function (id, expand, recursive, stopanim, callback) {
            var profile = this.get(0),
                ns = this,
                self = arguments.callee;

            if (id) {
                var o = profile.getItemByItemId(id);
                if (o && o.sub) {
                    var item = profile.getItemByItemId(id);
                    ood.arr.each(ood.clone(item.sub), function (oo) {
                        ns.removeItems([oo.id]);
                    });

                    o.sub = true;
                    ns.toggleNode(id, false);
                    ood.Thread.abort(profile.key + profile.id);
                    o._inited = false;
                    o._check = true;
                    ns.toggleNode(id, true);
                }
            }
            return this;
        },

        /**
         * Disable specified node(s)
         * @param {String|Array} ids - IDID
         * @param {Boolean} deep - Whether to recursively disable child nodes
         * @returns {Object} 
         */
        disableNode: function (ids, deep) {
            var profile = this.get(0),
                ns = this,
                self = arguments.callee;

            if (ood.isArr(ids)) {
                ood.each(ids, function (id) {
                    ns._disableSingleNode(id, deep);
                });
            } else {
                ns._disableSingleNode(ids, deep);
            }
            return this;
        },


        /**
         * Disable single node
         * @private
         * @param {String} id - ID
         * @param {Boolean} deep - 
         */
        _disableSingleNode: function (id, deep) {
            var profile = this.get(0),
                ns = this;

            var o = profile.getItemByItemId(id);
            if (o) {
                o.disabled = true;
                ns.updateItem(o, o.caption);

                // Recursively disable child nodes
                if (deep && o.sub && ood.isArr(o.sub)) {
                    ood.arr.each(o.sub, function (subItem) {
                        ns._disableSingleNode(subItem.id, deep);
                    });
                }
            }
        },

        /**
         * Get callback value
         * @returns {Object} 
         */
        getCallBackValue: function () {
            var profile = this.get(0),
                ns = this,
                data = profile.getModule().getData(),
                callValue = {},
                item = this.getItemByItemId(this.getUIValue()),
                fieldName = data['fieldName'],
                fieldCaption = data['fieldCaption'];

            // Set field value
            if (fieldName && fieldName.value && item) {
                callValue[fieldName.value] = {
                    value: item.id,
                    captionValue: item.caption,
                    items: [ood.clone(item)]
                };
            }

            // Set caption value
            if (fieldCaption && fieldCaption.value &&
                fieldCaption.value != (fieldName && fieldName.value)) {
                callValue[fieldCaption.value] = this.getUICationValue();
            }

            return callValue;
        },
        /**
         * Expand to specified node
         * @param {String} id - ID
         * @param {Boolean} triggerEvent - Whether to trigger click event
         * @returns {Object} 
         */
        openToNode: function (id, triggerEvent) {
            return this.each(function (profile) {
                var res = false,
                    nodePath = [],
                    // Recursively find node path
                    findNodePath = function (arr, targetId, layer) {
                        layer = layer || 0;
                        var self = findNodePath;

                        for (var i = 0; i < arr.length; i++) {
                            var node = arr[i];

                            // Found target node
                            if (node.id == targetId) {
                                nodePath.push(node);
                                res = true;
                                return true;
                            }

                            // Recursively find child nodes
                            if (node.sub && ood.isArr(node.sub)) {
                                if (self(node.sub, targetId, layer + 1)) {
                                    nodePath.push(node);
                                    return true;
                                }
                            }
                        }

                        return false;
                    };

                // Find node path
                findNodePath(profile.properties.items, id);

                // If node found, expand all nodes on path
                if (res) {
                    nodePath.reverse();
                    ood.arr.each(nodePath, function (node, index) {
                        var isLastNode = (index == nodePath.length - 1);
                        var isGroupNode = node.hasOwnProperty('group') ? node.group : profile.properties.group;

                        if (node.sub) {
                            // Expand node
                            profile.boxing().toggleNode(node.id, true);

                            // For last node, trigger click event
                            if (triggerEvent !== false && isLastNode && !isGroupNode) {
                                profile.boxing().fireItemClickEvent(node.id);
                            }
                        } else if (triggerEvent !== false) {
                            profile.boxing().fireItemClickEvent(node.id);
                        }
                    });
                }
            });
        },


        /**
         * Adjust layout based on screen size and current theme
         * @returns {Object} 
         */
        adjustLayout: function () {
            var profile = this.get(0);
            if (!profile) return this;

            var box = profile.getRoot(),
                width = box.width(),
                currentTheme = this.getTheme();

            // Remove responsive classes
            box.removeClass('ood-treebar-mobile ood-treebar-tiny');

            // 
            if (width < 320) {
                box.addClass('ood-treebar-mobile ood-treebar-tiny');
            } else if (width < 480) {
                box.addClass('ood-treebar-mobile');
            }

            // CSS
            var cssVars = {};

            // 
            if (width < 480) { // 
                switch (currentTheme) {
                    case 'dark':
                        cssVars = {
                            '--item-height': '2.2em',
                            '--font-size': '0.9em',
                            '--icon-size': '1.2em',
                            '--padding': '0.5em'
                        };
                        break;
                    case 'high-contrast':
                        cssVars = {
                            '--item-height': '2.4em',
                            '--font-size': '1em',
                            '--icon-size': '1.4em',
                            '--padding': '0.6em'
                        };
                        break;
                    default: // light
                        cssVars = {
                            '--item-height': '2.2em',
                            '--font-size': '0.9em',
                            '--icon-size': '1.2em',
                            '--padding': '0.5em'
                        };
                }
            } else { // 
                switch (currentTheme) {
                    case 'dark':
                        cssVars = {
                            '--item-height': '2em',
                            '--font-size': '1em',
                            '--icon-size': '1.4em',
                            '--padding': '0.4em'
                        };
                        break;
                    case 'high-contrast':
                        cssVars = {
                            '--item-height': '2.2em',
                            '--font-size': '1.1em',
                            '--icon-size': '1.6em',
                            '--padding': '0.5em'
                        };
                        break;
                    default: // light
                        cssVars = {
                            '--item-height': '2em',
                            '--font-size': '1em',
                            '--icon-size': '1.4em',
                            '--padding': '0.4em'
                        };
                }
            }

            // CSS
            for (var prop in cssVars) {
                if (cssVars.hasOwnProperty(prop)) {
                    box.css(prop, cssVars[prop]);
                }
            }

            return this;
        },

        /**
         * Enhance accessibility
         * @returns {Object} 
         */
        enhanceAccessibility: function () {
            var profile = this.get(0);
            if (!profile) return this;

            // Add ARIA attributes to all nodes
            profile.boxing().getSubNode('ITEMS', true).each(function (item) {
                var itemNode = ood(item);
                if (itemNode) {
                    // Set role
                    itemNode.attr({'role': 'treeitem'});

                    // If has child nodes, add expanded state
                    if (item.children) {
                        var isExpanded = !itemNode.hasClass('ood-ui-item-fold');
                        itemNode.attr({
                            'aria-expanded': isExpanded ? 'true' : 'false',
                            'aria-level': (item._deep || 0) + 1
                        });
                    }
                }
            });

            // ARIA
            profile.boxing().getSubNode('TOGGLE', true).each(function (toggle) {
                var toggleNode = ood(toggle);
                toggleNode.attr({
                    'role': 'button',
                    'aria-label': 'Expand/collapse node',
                    'tabindex': '0'
                });
            });

            // 
            profile.boxing().getSubNode('BAR', true).each(function (bar) {
                var barNode = ood(bar);
                barNode.attr({
                    'tabindex': '0',
                    'role': 'treeitem'
                });
            });

            return this;
        },

        /**
         * Export tree structure data
         * @returns {Array} 
         */
        exportData: function () {
            var profile = this.get(0);
            if (!profile) return [];

            return ood.clone(profile.properties.items);
        },

        /**
         * Import tree structure data
         * @param {Array} data - 
         * @returns {Object} 
         */
        importData: function (data) {
            if (!ood.isArr(data)) return this;

            this.clearItems();
            this.insertItems(data);
            return this;
        }
    },
    Static: {
        _focusNodeKey: 'BAR',
        // Cache all instances for global operations
        _cache: {},
        Templates: {
            tagName: 'div',
            style: '{_style}',
            className: '{_className} ood-treebar',
            BORDER: {
                tagName: 'div',
                className: "ood-uibase",
                BOX: {
                    tagName: 'div',
                    ITEMS: {
                        tagName: 'div',
                        className: '{_cmdsalign}',
                        text: "{items}"
                    }
                }
            },
            $submap: {
                items: {
                    ITEM: {
                        className: 'ood-tree-item',
                        style: '{_itemDisplay}',
                        tagName: 'div',
                        BAR: {
                            $order: 0,
                            tabindex: '{_tabindex}',

                            className: 'ood-uitembg   ood-uiborder-radius ood-uiborder-radius ood-showfocus {itemClass} {cls_group} {cls_fold} {_split} {disabled} {readonly}',
                            style: '{itemStyle};{_splitstyle} {_itemColor}',
                            RULER: {
                                $order: 2,
                                style: '{_ruleDisplay};{rulerStyle}',
                                text: '{innerIcons}'
                            },
                            TOGGLE: {
                                $order: 3,
                                style: '{_tglDisplay}',
                                className: 'oodfont',
                                $fonticon: '{_fi_togglemark}'
                            },
                            LTAGCMDS: {
                                $order: 4,
                                tagName: 'span',
                                style: '{_ltagDisplay}',
                                text: "{ltagCmds}"
                            },
                            MARK: {
                                $order: 5,
                                className: 'oodfont',
                                $fonticon: '{_fi_check}',
                                style: '{mark2Display}'
                            },
                            ITEMICON: {
                                $order: 6,
                                className: 'ood-icon {imageClass} {picClass}',
                                style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{imageDisplay}{iconStyle} {_iconColor}',
                                text: '{iconFontCode}'
                            },
                            ITEMCAPTION: {
                                text: '{caption}',
                                style: '{_capDisplay} {_fontColor}',
                                className: "ood-item-caption {disabled} {readonly}",
                                $order: 7
                            },
                            EXTRA: {
                                style: '{_extraDisplay}',
                                text: '{ext}',
                                className: "ood-item-extra",
                                $order: 8
                            },
                            RTAGCMDS: {
                                $order: 9,
                                tagName: 'span',
                                style: '{_rtagDisplay}',
                                text: "{rtagCmds}"
                            },
                            OPT: {
                                $order: 10,
                                style: '{_optDisplay}',
                                className: 'oodfont',
                                $fonticon: '{_fi_optClass}'
                            }
                        },
                        SUB: {
                            $order: 1,
                            tagName: 'div',
                            text: ood.UI.$childTag
                        }
                    }
                },
                'items.ltagCmds': function (profile, template, v, tag, result) {
                    var me = arguments.callee,
                        map = me._m || (me._m = {'text': '.text', 'button': '.button', 'image': '.image'});
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, 'items.tagCmds' + (map[buttonType] || '.button'), result)
                },
                'items.rtagCmds': function (profile, template, v, tag, result) {
                    var me = arguments.callee,
                        map = me._m || (me._m = {'text': '.text', 'button': '.button', 'image': '.image'});
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, 'items.tagCmds' + (map[buttonType] || '.button'), result)
                },
                'items.tagCmds.text': ood.UI.$getTagCmdsTpl('text'),
                'items.tagCmds.button': ood.UI.$getTagCmdsTpl('button'),
                'items.tagCmds.image': ood.UI.$getTagCmdsTpl('image')
            }
        },
        Appearances: {
            KEY: {
                'border': 0
            },
            EXTRA: {
                display: 'none'
            },
            BOX: {
                left: '0em',
                overflow: 'auto',
                'overflow-x': 'hidden',
                position: 'relative',
                clear: "both",
                'border-radius': '8px',
                'box-shadow': '0 2px 8px rgba(0,0,0,0.08)',
                transition: 'all 0.3s ease'
            },

            ITEMS: {
                overflow: 'hidden',
                transition: 'all 0.3s ease',
                'padding': '.25em'
            },
            ITEM: {
                'white-space': 'nowrap',
                position: 'relative',
                'line-height': 1.5,
                overflow: 'hidden',
                transition: 'all 0.2s ease'
            },
            BAR: {
                zoom: ood.browser.ie ? 1 : null,
                position: 'relative',
                height: "2em",
                display: 'block',
                'outline-offset': '-1px',
                '-moz-outline-offset': (ood.browser.gek && ood.browser.ver < 3) ? '-1px !important' : null,
                'background': 'var(--bg-card, var(--bg-secondary, #ffffff))',
                'border-radius': 'var(--radius-md, 4px)',
                'margin': '1px 0',
                transition: 'all var(--ood-transition-fast)',
                cursor: 'pointer'
            },
            'BAR:hover': {
                'background': 'var(--bg-hover, #f0f0f0)',
                'color': 'var(--text-secondary, #666666)',
                'box-shadow': 'var(--shadow-md, 0 2px 4px rgba(0,0,0,0.1))'
            },

            'BAR-checked:hover, BAR-active:hover': {
                'background': 'var(--primary-active, #0078d4)',
                'box-shadow': 'var(--shadow-lg, 0 4px 8px rgba(0,0,0,0.15))'
            },
            'BAR-disabled': {
                'opacity': '0.6',
                'cursor': 'not-allowed',
                'transform': 'none !important',
                'box-shadow': 'none !important',
                'filter': 'grayscale(0.5)'
            },
            SUB: {
                zoom: ood.browser.ie ? 1 : null,
                height: 0,
                'font-size': ood.browser.ie68 ? '1px' : null,
                'line-height': ood.browser.ie68 ? '1px' : null,
                position: 'relative',
                overflow: 'hidden',
                'margin-left': '0.75em',
                transition: 'height var(--transition-normal)'
            },
            MARK: {
                cursor: 'pointer',
                'vertical-align': 'middle',
                'color': 'var(--mark-color, #1890ff)'
            },
            'BAR-group': {
                $order: 4,
                border: 'none',
                'font-weight': '500',
                'background': 'var(--group-bg, rgba(0,0,0,0.02))'
            },
            ITEMCAPTION: {
                'vertical-align': 'middle',
                padding: '.25em',
                //  'white-space': 'normal',
                'font-size': '0.95em',
                transition: 'color 0.2s ease'
            },
            OPT: {
                $order: 10,
                position: 'absolute',
                left: 'auto',
                top: '50%',
                'margin-top': '-0.5em',
                right: '.5em',
                display: 'none',
                opacity: '0.7',
                transition: 'opacity 0.2s ease'
            },
            'BAR:hover OPT': {
                display: 'inline-block',
                opacity: '1'
            },
            'LTAGCMDS, RTAGCMDS': {
                padding: 0,
                margin: 0,
                'vertical-align': 'middle'
            },
            'ITEMS-tagcmdleft RTAGCMDS': {
                "padding-right": '.333em',
                "float": "left"
            },
            'ITEMS-tagcmdfloatright RTAGCMDS': {
                "padding-right": '.333em',
                "float": "right"
            },
            TOGGLE: {
                padding: '0 .334em 0 0',
                transition: 'transform 0.2s ease'
            },
            'TOGGLE:hover': {
                'transform': 'scale(1.1)'
            },
            ITEMICON: {
                transition: 'all 0.2s ease',
                "padding": '.25em',
                'vertical-align': 'middle'
            },


            // Mobile styles
            'treebar-mobile BAR': {
                'height': '2.2em',
                'font-size': '0.9em',
                'padding': '.3em .6em'
            },
            'treebar-mobile ITEMCAPTION': {
                'font-size': '0.9em'
            },
            // Small screen styles
            'treebar-tiny ITEMICON': {
                'display': 'none'
            }
        },
        Behaviors: {
            HoverEffected: {TOGGLE: 'TOGGLE', BAR: 'BAR', OPT: 'OPT', CMD: 'CMD'},
            ClickEffected: {TOGGLE: 'TOGGLE', BAR: 'BAR', OPT: 'OPT', CMD: 'CMD'},
            DraggableKeys: ["BAR"],
            NoDraggableKeys: ['TOGGLE'],
            DroppableKeys: ["BAR", "TOGGLE", "BOX"],
            TOGGLE: {
                onClick: function (profile, e, src) {
                    var properties = profile.properties,
                        domId = ood.use(src).id(),
                        item = profile.getItemByDom(domId);

                    if (properties.disabled || item.disabled) return false;
                    if (!('sub' in item)) return false;
                    profile.box._setSub(profile, item, !item._checked);

                    // not to fire BAR's onclick event;
                    return false;
                }
            },
            BAR: {
                onDblclick: function (profile, e, src) {
                    var properties = profile.properties,
                        item = profile.getItemByDom(src),
                        rtn = profile.onDblclick && profile.boxing().onDblclick(profile, item, e, src);
                    if (item.sub && rtn !== false) {
                        profile.getSubNode('TOGGLE', profile.getSubId(src)).onClick();
                    }
                },
                onClick: function (profile, e, src) {
                    return profile.box._onclickbar(profile, e, src);
                },
                onKeydown: function (profile, e, src) {
                    return profile.box._onkeydownbar(profile, e, src);
                },
                onContextmenu: function (profile, e, src) {
                    if (profile.onContextmenu)
                        return profile.boxing().onContextmenu(profile, e, src, profile.getItemByDom(src), ood.Event.getPos(e)) !== false;
                },
                onMouseover: function (profile, e, src) {
                    if (ood.browser.fakeTouch || ood.browser.deviceType == 'touchOnly') return;
                    var item = profile.getItemByDom(src);
                    if (!item) return;
                    if (!profile.properties.optBtn && !item.optBtn) return;
                    profile.getSubNode('OPT', profile.getSubId(src)).setInlineBlock();
                },
                onMouseout: function (profile, e, src) {
                    if (ood.browser.fakeTouch || ood.browser.deviceType == 'touchOnly') return;
                    var item = profile.getItemByDom(src);
                    if (!item) return;
                    if (!profile.properties.optBtn && !item.optBtn) return;
                    profile.getSubNode('OPT', profile.getSubId(src)).css('display', 'none');
                }
            },
            OPT: {
                onClick: function (profile, e, src) {
                    if (profile.onShowOptions) {
                        var item = profile.getItemByDom(src);
                        if (!item) return;
                        if (!profile.properties.optBtn && !item.optBtn) return;
                        profile.boxing().onShowOptions(profile, item, e, src);
                    }
                    return false;
                },
                onDblclick: function (profile, e, src) {
                    return false;
                }
            },
            CMD: {
                onClick: function (profile, e, src) {
                    var prop = profile.properties,
                        item = profile.getItemByDom(ood.use(src).parent().get(0));
                    if (!item) return false;

                    if (prop.disabled || item.disabled || item.type == 'split') return false;
                    if (profile.onCmd)
                        profile.boxing().onCmd(profile, item, ood.use(src).id().split('_')[1], e, src);
                    return false;
                }
            },
            BOX: {
                onScroll: function (profile, e, src) {
                    //for ie 'href focus' will scroll view
                    if ((e = ood.use(src)).scrollLeft() !== 0)
                        e.scrollLeft(0);
                }
            }
        },
        EventHandlers: {
            onShowOptions: function (profile, item, e, src) {
            },
            beforeClick: function (profile, item, e, src) {
            },
            onClick: function (profile, item, e, src) {
            },
            afterClick: function (profile, item, e, src) {
            },
            onCmd: function (profile, item, cmdkey, e, src) {
            },
            onDblclick: function (profile, item, e, src) {
            },

            onGetContent: function (profile, item, callback) {
            },
            onItemSelected: function (profile, item, e, src, type) {
            },

            beforeFold: function (profile, item) {
            },
            beforeExpand: function (profile, item) {
            },
            afterFold: function (profile, item) {
            },
            afterExpand: function (profile, item) {
            }
        },
        DataModel: {

            // Modern properties
            theme: {
                ini: 'dark',
                listbox: ['light', 'dark', 'high-contrast'],
                caption: ood.getResText("DataModel.theme") || "",
                action: function (value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                caption: ood.getResText("DataModel.responsive") || "",
                action: function (value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            expression: {
                ini: '',
                caption: ood.getResText("DataModel.expression") || "",
                action: function () {
                }
            },
            enumClass: {},
            listKey: null,
            isFormField: {
                hidden: true,
                ini: false
            },

            autoFontColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoIconColor: {
                ini: true,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            iconColors: null,
            itemColors: null,
            fontColors: null,

            width: {
                $spaceunit: 1,
                ini: 'auto'
            },
            height: {
                $spaceunit: 1,
                ini: 'auto'
            },
            initFold: true,
            animCollapse: true,
            dock: 'fill',
            group: {
                ini: false,
                action: function (v) {
                    var self = this,
                        items = self.properties.items,
                        results = self.queryItems(items, function (o) {
                            return o.sub && o.group === undefined
                        }),
                        nodes = ood();
                    ood.arr.each(results, function (o) {
                        nodes.merge(self.getSubNodeByItemId('BAR', o.id));
                    });
                    if (v)
                        nodes.addClass('ood-uigradient ood-uibar ' + self.getClass('BAR', '-group'));
                    else
                        nodes.removeClass('ood-uigradient ood-uibar ' + self.getClass('BAR', '-group'));
                }
            },
            selMode: {
                ini: 'single',
                listbox: ['single', 'none', 'multi', 'singlecheckbox', 'multibycheckbox'],
                action: function (value) {
                    var ns = this, p = this.properties, sels = [];
                    ood.each(this.SubSerialIdMapItem, function (o) {
                        if (!(o.sub && (o.hasOwnProperty('group') ? o.group : p.group)))
                            sels.push(ns.getSubNodeByItemId('MARK', o.id).get(0));
                    });
                    ood(sels).css('display', (value == 'singlecheckbox' || value == 'multibycheckbox') ? '' : 'none');
                }
            },
            noCtrlKey: true,
            singleOpen: false,
            dynDestory: false,
            position: 'absolute',
            optBtn: {
                ini: "",
                combobox: ood.toArr("ood-uicmd-opt,ood-icon-singleright"),
                action: function () {
                    this.boxing().refresh();
                }
            },
            togglePlaceholder: false,
            tagCmds: {
                ini: [],
                action: function () {
                    this.boxing().refresh();
                }
            },
            tagCmdsAlign: {
                ini: "right",
                listbox: ['left', 'right', 'floatright'],
                action: function (v) {
                    var profile = this, box = profile.getSubNode("ITEMS"),
                        cls = profile.getClass('ITEMS', '-tagcmd');
                    box.removeClass(new RegExp(cls + '[\w]*')).addClass(profile.getClass('ITEMS', '-tagcmd' + v));
                }
            }
        },
        RenderTrigger: function () {
            this.boxing()._toggleNodes(this.properties.items, true, true, true);
        },


        _onclickbar: function (profile, e, src) {
            var properties = profile.properties,
                domId = ood.use(src).id(),
                item = profile.getItemByDom(domId),
                itemId = profile.getSubId(domId),
                box = profile.boxing(),
                ks = ood.Event.getKey(e),
                sk = profile.getKey(ood.Event.getSrc(e).id || ""),
                ignoreClick = sk == profile.keys.TOGGLE || sk == profile.keys.MARK;

            if (!ignoreClick && profile.beforeClick && false === box.beforeClick(profile, item, e, src)) return false;

            if (properties.disabled || item.disabled || item.type == 'split') return false;

            if (!ignoreClick && profile.onClick)
                box.onClick(profile, item, e, src);

            //group not fire event
            if (item.sub && (item.hasOwnProperty('group') ? item.group : properties.group)) {
                profile.getSubNode('TOGGLE', itemId).onClick();
                return;
            }

            profile.getSubNode(profile.box._focusNodeKey, itemId).focus(true);

            switch (properties.selMode) {
                case 'none':
                    box.onItemSelected(profile, item, e, src, 0);
                    break;
                case 'multibycheckbox':
                    if (properties.readonly || item.readonly) return false;
                    var captionvalue = box.getCaptionValue();
                    var value = box.getUIValue(),
                        cationarr = captionvalue ? captionvalue.split(properties.valueSeparator) : [],
                        arr = value ? value.split(properties.valueSeparator) : [],
                        checktype = 1;
                    var items = properties.items;
                    if (ks.shiftKey) {
                        if (profile.$firstV._pid != item._pid) return;
                        var items = properties.items;
                        if (item._pid) {
                            var pitem = profile.getItemByItemId(item._pid);
                            if (pitem) items = pitem.sub;
                        }
                        var i1 = ood.arr.subIndexOf(items, 'id', profile.$firstV.id),
                            i2 = ood.arr.subIndexOf(items, 'id', item.id),
                            i;
                        arr.length = 0;
                        for (i = Math.min(i1, i2); i <= Math.max(i1, i2); i++)
                            arr.push(items[i].id);
                    } else {

                        if (ood.arr.indexOf(arr, item.id) != -1) {
                            ood.arr.removeValue(arr, item.id);
                            ood.arr.removeValue(cationarr, item.caption);
                            profile.boxing()._removeAllkeys(arr, cationarr, item, profile);
                            checktype = -1;
                        } else {
                            arr.push(item.id);
                            cationarr.push(item.caption);
                            profile.boxing()._addAllkeys(arr, cationarr, item, profile);

                        }

                    }
                    arr.sort();
                    cationarr.sort();
                    value = arr.join(properties.valueSeparator);
                    captionvalue = cationarr.join(properties.valueSeparator);

                    //update string value only for _setCtrlValue
                    if (box.getUIValue() != captionvalue) {
                        profile._noScroll = 1;
                        box.setUIValue(value, null, null, 'click');
                        box.setCaptionValue(captionvalue);
                        delete profile._noScroll;
                        if (box.get(0) && box.getUIValue() == value)
                            box.onItemSelected(profile, item, e, src, checktype);
                    }
                    break;

                case 'multi':
                    if (properties.readonly || item.readonly) return false;
                    var value = box.getUIValue(),
                        arr = value ? value.split(properties.valueSeparator) : [],
                        checktype = 1;
                    if (arr.length && (ks.ctrlKey || ks.shiftKey || properties.noCtrlKey)) {
                        if (ks.shiftKey) {
                            if (profile.$firstV._pid != item._pid) return;
                            var items = properties.items;
                            if (item._pid) {
                                var pitem = profile.getItemByItemId(item._pid);
                                if (pitem) items = pitem.sub;
                            }
                            var i1 = ood.arr.subIndexOf(items, 'id', profile.$firstV.id),
                                i2 = ood.arr.subIndexOf(items, 'id', item.id),
                                i;
                            arr.length = 0;
                            for (i = Math.min(i1, i2); i <= Math.max(i1, i2); i++)
                                arr.push(items[i].id);
                        } else {
                            if (ood.arr.indexOf(arr, item.id) != -1) {
                                ood.arr.removeValue(arr, item.id);
                                checktype = -1;
                            } else
                                arr.push(item.id);
                        }
                        arr.sort();
                        value = arr.join(properties.valueSeparator);

                        //update string value only for _setCtrlValue
                        if (box.getUIValue() != value) {
                            profile._noScroll = 1;
                            box.setUIValue(value, null, null, 'click');
                            delete profile._noScroll;
                            if (box.get(0) && box.getUIValue() == value)
                                box.onItemSelected(profile, item, e, src, checktype);
                        }
                        break;
                    }
                case 'single':
                    if (box.getUIValue() != item.id) {
                        profile.$firstV = item;
                        profile._noScroll = 1;
                        box.setUIValue(item.id, null, null, 'click');
                        delete profile._noScroll;
                        if (box.get(0) && box.getUIValue() == item.id)
                            box.onItemSelected(profile, item, e, src, 1);
                    }
                    break;

                case 'singlecheckbox':
                    if (box.getUIValue() != item.id) {
                        profile.$firstV = item;
                        profile._noScroll = 1;
                        box.setUIValue(item.id, null, null, 'click');
                        delete profile._noScroll;
                        if (box.get(0) && box.getUIValue() == item.id)
                            box.onItemSelected(profile, item, e, src, 1);
                    }
                    break;


            }
            if (!ignoreClick && profile.afterClick) box.afterClick(profile, item, e, src);
            return !ignoreClick;
        },
        _onkeydownbar: function (profile, e, src) {
            var keys = ood.Event.getKey(e), key = keys.key, shift = keys.shiftKey, ctrl = keys.ctrlKey,
                cur = profile.getSubNode(profile.box._focusNodeKey, profile.getSubId(src)),
                root = profile.getRoot(),
                first = root.nextFocus(true, true, false),
                last = root.nextFocus(false, true, false);

            switch (key) {
                case 'enter':
                    cur.onClick();
                    break;
                case 'tab':
                    if (shift) {
                        if (cur.get(0) != first.get(0)) {
                            first.focus(true);
                            return false;
                        }
                    } else {
                        if (cur.get(0) != last.get(0)) {
                            last.focus(true);
                            return false;
                        }
                    }
                    break;
                case 'up':
                    if (ctrl) {
                        profile.getSubNode('TOGGLE', profile.getSubId(src)).onClick();
                        return false;
                    }
                    if (cur.get(0) == first.get(0))
                        last.focus(true);
                    else
                        cur.nextFocus(false, true, false).focus(true);
                    return false;
                    break;
                case 'down':
                    if (ctrl) {
                        profile.getSubNode('TOGGLE', profile.getSubId(src)).onClick();
                        return false;
                    }
                    if (cur.get(0) == last.get(0))
                        first.focus(true);
                    else
                        cur.nextFocus(true, false, false).focus(true);
                    return false;
                    break;
                case 'right':
                case 'left':
                    profile.getSubNode('TOGGLE', profile.getSubId(src)).onClick();
                    return false;
            }
        },
        _onStartDrag: function (profile, e, src, pos) {
            var pos = ood.Event.getPos(e);
            ood.use(src).startDrag(e, {
                dragSource: profile.$xid,
                dragType: 'icon',
                shadowFrom: src,
                targetLeft: pos.left + 12,
                targetTop: pos.top + 12,
                dragCursor: 'pointer',
                dragDefer: 2,
                dragKey: profile.box.getDragKey(profile, src),
                dragData: profile.box.getDragData(profile, e, src)
            });
            return false;
        },
        _onDropTest: function (profile, e, src, key, data, item) {
            var fid = data && data.domId;
            if (fid) {
                var tid = ood.use(src).id();
                if (fid == tid) return false;

                if (ood.get(ood.use(src).get(0), ['parentNode', 'previousSibling', 'firstChild', 'id']) == fid) return false;

                var oitem = profile.getItemByDom(fid);

                // stop self
                if (oitem && item && oitem._pid == item.id) return false;

                var p = ood.use(src).get(0),
                    rn = profile.getRootNode();
                // stop children
                while ((p = p.parentNode)) {
                    if (profile.getSubId(p.id) == profile.getSubId(fid)) {
                        return false;
                    }
                    if (p.id == ood.get(rn, ["parentNode", "id"])) {
                        break;
                    }
                }
            }
        },
        _onDrop: function (profile, e, src, key, data, item) {
            var k = profile.getKey(ood.use(src).id()),
                po = data.profile,
                ps = data.domId,
                oitem,
                ks = profile.keys,
                t = ood.absObj.$specialChars,
                b = profile.boxing(),
                arr = ood.copy(b.getUIValue(true));
            //remove
            oitem = ood.clone(po.getItemByDom(ps), function (o, i) {
                return !t[(i + '').charAt(0)]
            });
            po.boxing().removeItems([oitem.id]);

            //add
            if (k == ks.BOX)
                b.insertItems([oitem], null, null, false);
            else if (k == ks.BAR)
                b.insertItems([oitem], item._pid, item.id, true);
            else if (k == ks.TOGGLE)
                b.insertItems([oitem], item.id, null, false);

            if (arr && arr.length) {
                if (ood.arr.indexOf(arr, oitem.id) != -1) {
                    //set checked items
                    profile._noScroll = 1;
                    b.setUIValue(arr, true, null, 'drop');
                    delete profile._noScroll;
                }
            }
            data._new = oitem;
            return false;
        },
        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile),
                ns = this,
                p = profile.properties;

            data._cmdsalign = profile.getClass('ITEMS', '-tagcmd' + profile.properties.tagCmdsAlign);
            ood.arr.each(data.items, function (item) {
                var index = item.index;
                if (!index) {
                    index = ood.arr.indexOf(data.items, item);
                }
                profile.boxing()._autoColor(item, index, p);
            })

            // Enhance accessibility
            // setTimeout(function () {
            //     profile.boxing().enhanceAccessibility();
            // }, 0);

            return data;
        },

        _prepareItem: function (profile, item, oitem, pid, index, len) {
            var p = profile.properties,
                map1 = profile.ItemIdMapSubSerialId,
                map2 = profile.SubSerialIdMapItem,
                pitem;

            item._fi_check = item.ficheck ? item.ficheck : 'ood-uicmd-check';
            if (pid)
                oitem._pid = pid;

            profile.boxing()._autoColor(item, index, p);


            // set 'visible' will show when parent call .height()
            item._fi_togglemark = item.sub ? ('ood-uicmd-toggle' + (item._checked ? " oodfont-checked ood-uicmd-toggle-checked" : "")) : (p.togglePlaceholder ? 'ood-icon-placeholder' : 'ood-uicmd-none');
            item.disabled = item.disabled ? 'ood-ui-disabled' : '';
            item.mark2Display = ('showMark' in item) ? (item.showMark ? '' : 'display:none;') : (p.selMode == 'multi' || p.selMode == 'multibycheckbox') ? '' : 'display:none;';
            item._tabindex = p.tabindex;
            item._fi_optClass = p.optBtn;

            //change css class
            if (item.sub && (item.hasOwnProperty('group') ? item.group : p.group)) {
                item.cls_group = "ood-uigradient ood-uibar " + profile.getClass('BAR', '-group');
                item.mark2Display = 'display:none';
            }
            this._prepareCmds(profile, item);

            if (ood.browser.fakeTouch || ood.browser.deviceType == 'mouseOnly') {
                item._optDisplay = p.optBtn ? 'display:block;' : '';
            }

            item.imageClass = item.icon ? item.icon : item.imageClass;

            if (item.tglDisplay && item.sub) {
                item._tglDisplay = 'display:none;';
                item._optDisplay = 'display:block;'
            }

            if (item.type == 'split') {
                item._split = 'ood-uitem-split';
                item._ruleDisplay = item._ltagDisplay = item._tglDisplay = item._rtagDisplay = item.imageDisplay = item.mark2Display = item._capDisplay = item._extraDisplay = item._optDisplay = 'display:none;';
            }
        },
        _setSub: function (profile, item, flag, recursive, stopanim, cb) {
            var id = profile.domId,
                ins = profile.boxing(),
                prop = profile.properties,
                itemId = profile.getSubIdByItemId(item.id),
                markNode = profile.getSubNode('TOGGLE', itemId),
                subNs = profile.getSubNode('SUB', itemId),

                barNode = profile.getSubNode('BAR', itemId),
                icon = profile.getSubNode('ITEMICON', itemId);

            if (ood.Thread.isAlive(profile.key + profile.id)) return;
            //close
            if (!flag) {
                if (item._checked) {
                    if (ins.beforeFold && false === ins.beforeFold(profile, item)) {
                        return;
                    }
                    var onend = function () {
                        subNs.css({display: 'none', height: 0});
                        markNode.tagClass('-checked', false);
                        barNode.tagClass('-expand', false).tagClass('-fold');
                        icon.tagClass('-expand', false).tagClass('-fold');
                        item._checked = false;
                        if (prop.dynDestory || item.dynDestory) {
                            var s = item.sub, arr = [];
                            for (var i = 0, l = s.length; i < l; i++)
                                arr.push(s[i].id);
                            profile.boxing().removeItems(arr);
                            item.sub = true;
                            delete item._inited;
                        }
                        if (ins.afterFold)
                            ins.afterFold(profile, item);
                        ood.resetRun(id, function (cb) {
                            if (cb) ood.tryF(cb, [profile, item], ins);
                        }, 0, [cb]);
                    };
                    if (!stopanim) {
                        if (prop.animCollapse) {
                            subNs.animate({'height': [subNs.height(), 0]}, null, onend, 200, null, 'expoOut', profile.key + profile.id).start();
                        } else onend();
                    } else onend();
                }
                if (recursive && item.sub && !prop.dynDestory && !item.dynDestory) {
                    ood.arr.each(item.sub, function (o) {
                        if (o.sub && o.sub.length)
                            profile.box._setSub(profile, o, flag, recursive, true, cb);
                    });
                }
            } else {
                //open
                if (!item._checked) {
                    if (ins.beforeExpand && false === ins.beforeExpand(profile, item)) {
                        return;
                    }
                    var onend = function (empty) {
                            subNs.css({display: '', height: 'auto'});
                            //markNode.css('background','');
                            // compitable with IE<8
                            if (ood.browser.ie && ood.browser.ver <= 8) {
                                markNode.css({
                                    backgroundImage: '',
                                    backgroundRepeat: '',
                                    backgroundPositionX: '',
                                    backgroundPositionY: '',
                                    backgroundColor: '',
                                    backgroundAttachment: ''
                                });
                            } else {
                                markNode.removeClass('ood-icon-loading');
                            }
                            if (!empty) {
                                item._checked = true;
                                if (ins.afterExpand)
                                    ins.afterExpand(profile, item);
                            }
                            ood.resetRun(id, function (cb) {
                                if (cb) ood.tryF(cb, [profile, item], ins);
                            }, 0, [cb]);
                        },
                        openSub = function (profile, item, id, markNode, subNs, barNode, icon, sub) {
                            var b = profile.boxing(),
                                p = profile.properties,
                                empty = sub === false;
                            //created
                            if (!empty && !item._inited) {
                                delete item.sub;
                                //before insertRows
                                item._inited = true;
                                if (sub) {
                                    if (typeof sub == 'string')
                                        subNs.html(item.sub = sub, false);
                                    else if (sub['ood.Template'] || sub['ood.UI']) {
                                        subNs.append(item.sub = sub.render(true));
                                    } else if (ood.isArr(sub)) {
                                        b.insertItems(sub, item.id);
                                        // for []
                                        if (!item.sub) item.sub = sub;
                                    }
                                    var s = 0, arr = b.getUIValue(true);
                                    if (arr && arr.length) {
                                        ood.arr.each(sub, function (o) {
                                            if (ood.arr.indexOf(arr, o.id || o) != -1) {
                                                s = 1;
                                                return false;
                                            }
                                        });
                                        if (s) {
                                            //set checked items
                                            profile._noScroll = 1;
                                            b._setCtrlValue(b.getUIValue());
                                            delete profile._noScroll;
                                        }
                                    }
                                }
                            }

                            if (p.singleOpen)
                                b._toggleNodes(item._pid ? profile.getItemByItemId(item._pid).sub : p.items, false)

                            if (!empty) {
                                markNode.tagClass('-checked');
                                barNode.tagClass('-expand').tagClass('-fold', false);
                                icon.tagClass('-fold', false).tagClass('-expand');
                            }

                            if (!stopanim) {
                                subNs.css("height", "0px").css("display", '');

                                if (p.animCollapse) {
                                    var h = 0;
                                    subNs.children().each(function (o) {
                                        h += o.offsetHeight;
                                    });
                                    subNs.animate({'height': [0, h]}, null, function () {
                                        onend(empty);
                                    }, 200, null, 'expoIn', profile.key + profile.id).start();
                                } else onend(empty);
                            } else onend(empty);
                        },
                        sub = item.sub,
                        callback = function (sub) {
                            var ns = this, nns = profile.boxing(), rep = ns._response, ids = rep ? rep.ids : [];
                            if (sub && sub.data) {
                                sub = sub.data;
                            }
                            openSub(profile, item, id, markNode, subNs, barNode, icon, sub);

                            if (ids && ood.isArr(ids)) {
                                ood.arr.each(ids, function (id) {
                                    // nns.fireItemClickEvent(id)
                                })
                            }

                        }, t;

                    if ((t = typeof sub) == 'string' || (t == 'object' && ((ood.isArr(sub) && sub.length > 0))))
                        callback(sub);
                    else if (profile.onGetContent) {
                        if (ood.browser.ie && ood.browser.ver <= 8) {
                            markNode.css('background', 'url(' + ood.ini.img_busy + ') no-repeat');
                        } else {
                            markNode.addClass('ood-icon-loading');
                        }
                        var r = profile.boxing().onGetContent(profile, item, callback);
                        if (r || r === false) {
                            //return true: toggle icon will be checked
                            if (r === true)
                                item._inited = true;
                            callback(r);
                        }
                    }
                }
                if (recursive && item.sub) {
                    ood.arr.each(item.sub, function (o) {
                        if (o.sub && o.sub.length && !o._checked)
                            profile.box._setSub(profile, o, flag, recursive, true, cb);
                    });
                }
            }
        },
        _tofold: function (profile, item, pid) {
            profile.getSubNodeByItemId('BAR', pid).addClass(profile.getClass('BAR', '-fold'));
            profile.getSubNodeByItemId('TOGGLE', pid).replaceClass(new RegExp("\\buicmd-(none|empty)\\b"), "ood-uicmd-toggle");
        },
        _onresize: function (profile, width, height) {
            profile.getSubNode('BORDER').cssSize({width: width ? width : null, height: height ? height : null});
            profile.getSubNode('BOX').cssSize({width: width ? width : null, height: height ? height : null});
        },
    }

});
ood.Class("ood.UI.TreeView", "ood.UI.TreeBar", {
    Initialize: function () {
        this.addTemplateKeys(['IMAGE']);
        var t = this.getTemplate();
        var n = t.$submap.items.ITEM.BAR.ITEMICON;
        n.$fonticon = '{_fi_cls_file}';
        this.setTemplate(t);
    },

    Instance: {

        iniProp: {
            animCollapse: true,
            items: [
                {
                    id: 'node1', sub: [
                        {id: 'node12', imageClass: "ri-image-line"}
                    ]
                }, {
                    id: 'node2',
                    initFold: false
                }]
        },

        // Modern feature: Set theme
        setTheme: function (theme) {
            return this.each(function (profile) {
                var p = profile.properties;
                p.theme = theme;
                if (!p.autoItemColor) {

                    var root = profile.getRoot();
                    // Save theme to properties
                    profile.properties.theme = theme;

                    root.attr('data-theme', theme);

                }

                // Save theme settings
                localStorage.setItem('treeview-theme', theme);
            });
        },

        // Get current theme
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('treeview-theme') || 'light';
        },


        // Modern initialization trigger
        TreeViewTrigger: function () {
            var profile = this.get(0);
            var prop = profile.properties


            // Initialize theme
            if (prop.theme) {
                this.setTheme(prop.theme);
            } else {
                // Restore theme from local storage
                var savedTheme = localStorage.getItem('treeview-theme');
                if (savedTheme) {
                    this.setTheme(savedTheme);
                }
            }

            // Initialize responsive design
            if (prop.responsive !== false) {
                this.adjustLayout();
                // Note: Window resize listeners need to be handled at application level
                // OOD framework has its own event handling mechanism
            }

            // Initialize accessibility
            this.enhanceAccessibility();
        },
        // Toggle dark mode
        toggleDarkMode: function () {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
        },

        // Responsive layout adjustment with theme awareness
        adjustLayout: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    prop = profile.properties;

                // Remove responsive classes
                root.removeClass('treeview-mobile treeview-tiny');

                // Apply responsive classes based on screen size
                if (width < 768) {
                    root.addClass('treeview-mobile');
                }
                if (width < 480) {
                    root.addClass('treeview-tiny');
                }

                // Special handling for high contrast mode in tiny screens
                if (width < 480 && profile.boxing().getTheme() === 'high-contrast') {
                    profile.getSubNode('BOX').css('--sub-margin', '1em');
                }
            });
        },

        // Enhanced accessibility support with keyboard navigation
        enhanceAccessibility: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    items = profile.getSubNode('ITEM', true),
                    bars = profile.getSubNode('BAR', true),
                    toggles = profile.getSubNode('TOGGLE', true);

                // Add ARIA attributes to container
                root.attr({
                    'role': 'tree',
                    'aria-label': ood.getRes('UI.treeview'),
                    'aria-multiselectable': profile.properties.selMode === 'multi' ? 'true' : 'false'
                });

                // Add ARIA attributes to tree nodes
                items.each(function (item) {
                    var itemNode = ood(item);
                    var itemId = itemNode.id();
                    if (itemId) {
                        var itemData = profile.getItemByDom(item);
                        var isSelected = itemNode.hasClass('ood-ui-item-checked');

                        itemNode.attr({
                            'role': 'treeitem',
                            'aria-label': ood.getRes('UI.treeview.node') + ': ' + (itemData ? itemData.caption : itemId),
                            'aria-selected': isSelected ? 'true' : 'false',
                            'aria-disabled': itemData && itemData.disabled ? 'true' : 'false'
                        });

                        // If has child nodes, add expanded state
                        if (itemData && itemData.sub && itemData.sub.map) {
                            var isExpanded = !itemNode.hasClass('ood-ui-item-fold');
                            itemNode.attr({
                                'aria-expanded': isExpanded ? 'true' : 'false',
                                'aria-level': (itemData._deep || 0) + 1,
                                'aria-owns': itemData.sub.map(sub => sub.id).join(' ')
                            });
                        }
                    }
                });

                // Enhanced ARIA attributes for toggle buttons
                toggles.each(function (toggle) {
                    var toggleNode = ood(toggle);
                    var parentItem = toggleNode.parent().parent();
                    var isExpanded = !parentItem.hasClass('ood-ui-item-fold');

                    toggleNode.attr({
                        'role': 'button',
                        'aria-label': isExpanded ?
                            ood.getRes('UI.treeview.collapse') :
                            ood.getRes('UI.treeview.expand'),
                        'aria-controls': parentItem.id(),
                        'tabindex': '0',
                        'aria-expanded': isExpanded ? 'true' : 'false'
                    });
                });

                // Enhanced keyboard navigation for bars
                bars.each(function (bar) {
                    var barNode = ood(bar);
                    var itemId = barNode.parent().id();
                    var itemData = profile.getItemByDom(barNode.parent().get(0));

                    barNode.attr({
                        'tabindex': '0',
                        'role': 'treeitem',
                        'aria-label': itemData ? itemData.caption : itemId,
                        'aria-selected': barNode.hasClass('ood-ui-item-checked') ? 'true' : 'false'
                    });

                    // Add keyboard event handlers
                    barNode.on('keydown', function (e) {
                        var key = e.key;
                        var currentItem = ood(this).parent();
                        var nextItem, prevItem, parentItem, firstChild;

                        switch (key) {
                            case 'ArrowDown':
                                nextItem = currentItem.next();
                                if (nextItem.length) {
                                    nextItem.find('[role="treeitem"]').focus();
                                }
                                break;
                            case 'ArrowUp':
                                prevItem = currentItem.prev();
                                if (prevItem.length) {
                                    prevItem.find('[role="treeitem"]').focus();
                                }
                                break;
                            case 'ArrowRight':
                                if (currentItem.hasClass('ood-ui-item-fold') && itemData.sub) {
                                    // Expand if collapsed
                                    profile.box._onclickbar(profile, e, itemId);
                                } else if (itemData.sub) {
                                    // Move to first child
                                    firstChild = currentItem.children('.ood-ui-submap').children().first();
                                    if (firstChild.length) {
                                        firstChild.find('[role="treeitem"]').focus();
                                    }
                                }
                                break;
                            case 'ArrowLeft':
                                if (!currentItem.hasClass('ood-ui-item-fold') && itemData.sub) {
                                    // Collapse if expanded
                                    profile.box._onclickbar(profile, e, itemId);
                                } else {
                                    // Move to parent
                                    parentItem = profile.getItemByItemId(itemData._pid);
                                    if (parentItem) {
                                        ood('#' + parentItem.id).find('[role="treeitem"]').focus();
                                    }
                                }
                                break;
                            case 'Enter':
                            case 'Space':
                                profile.box._onclickbar(profile, e, itemId);
                                break;
                            case 'Home':
                                root.find('[role="treeitem"]').first().focus();
                                break;
                            case 'End':
                                root.find('[role="treeitem"]').last().focus();
                                break;
                        }
                    });
                });
            });
        }
    },

    Static: {
        Appearances: {
            ITEMS: {
                'padding': '0',
                transition: 'all var(--transition-normal)'
            },
            ITEM: {
                'white-space': 'nowrap',
                position: 'relative',
                'line-height': 1.22,
                overflow: 'hidden',
                transition: 'all 0.2s ease',
                'color': 'var(--ood-treeview-text)',
                'padding-left': 'var(--ood-treeview-indent)'
            },


            BOX: {
                left: '0em',
                overflow: 'auto',
                position: 'relative',
                'background-color': 'var(--ood-treeview-bg)',
                'border': 'var(--ood-treeview-border)',
                'border-radius': '0.25rem',
                transition: 'all 0.3s ease'
            },


            // Mobile styles
            'treeview-mobile BAR': {
                'height': '2.2em',
                'font-size': '0.9em',
                'background': 'var(--ood-treeview-item-hover)'
            },
            'treeview-mobile CAPTION': {
                'font-size': '0.9em',
                'color': 'var(--ood-treeview-text)'
            },

            // Small screen styles
            'treeview-tiny ITEMICON': {
                'display': 'none'
            },

            // Hover and selected states
            'ITEM-hover': {
                'background-color': 'var(--ood-treeview-item-hover)'
            },
            'ITEM-checked': {
                'background-color': 'var(--ood-treeview-item-selected)'
            },
            'treeview-tiny BAR': {
                'padding': '0.5em',
                'background': 'var(--ood-treeview-item-selected)'
            }
        },
        Behaviors: {
            MARK: {
                onClick: function (profile, e, src) {
                    profile.box._onclickbar(profile, e, ood.use(src).parent().xid());
                    return false;
                }
            },
            ITEMICON: {
                onClick: function (profile, e, src) {
                    profile.box._onclickbar(profile, e, ood.use(src).parent().xid());
                    return false;
                }
            }
        },
        DataModel: {
            // Modern properties
            theme: {
                ini: 'dark',
                caption: ood.getResText("DataModel.theme") || "",
                listbox: ['light', 'dark', 'high-contrast'],
                action: function (value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                caption: ood.getResText("DataModel.responsive") || "",
                action: function (value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },

            expression: {
                ini: '',
                caption: ood.getResText("DataModel.expression") || "",
                action: function () {
                }
            },
            $subMargin: {
                ini: 1.8,
                caption: ood.getResText("DataModel.subMargin") || ""
            },
            group: {
                ini: null,
                caption: ood.getResText("DataModel.group") || ""
            },
            noIcon: {
                ini: false,
                caption: ood.getResText("DataModel.noIcon") || "",
                action: function (v) {
                    this.getSubNode("ITEMICON", true).css('display', v ? 'none' : '');
                }
            },
            iconColors: {
                ini: null,
                caption: ood.getResText("DataModel.iconColors") || ""
            },
            fontColors: {
                ini: null,
                caption: ood.getResText("DataModel.fontColors") || ""
            },
            itemColors: {
                ini: null,
                caption: ood.getResText("DataModel.itemColors") || ""
            },
            autoFontColor: {
                ini: false,
                caption: ood.getResText("DataModel.autoFontColor") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoIconColor: {
                ini: false,
                caption: ood.getResText("DataModel.autoIconColor") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemColor: {
                ini: false,
                caption: ood.getResText("DataModel.autoItemColor") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            tabindex: {
                ini: 0,
                caption: ood.getResText("DataModel.tabindex") || "Tab"
            }
        },
        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile), ns = this, p = profile.properties;
            return data;
        },

        _prepareItem: function (profile, item, oitem, pid, index, len) {
            var p = profile.properties,
                map1 = profile.ItemIdMapSubSerialId,
                map2 = profile.SubSerialIdMapItem,
                pnode = profile.getItemByItemId(pid),
                prop = {},
                pitem;
            if (item.fiCheck) {
                item._fi_check = item.fiCheck;
            } else {
                item._fi_check = 'ood-uicmd-check';
            }

            if (pnode) {
                prop.autoIconColor = pnode.autoIconColor ? pnode.autoIconColor : p.autoIconColor;
                prop.autoFontColor = pnode.autoFontColor ? pnode.autoFontColor : p.autoFontColor;
                prop.autoItemColor = pnode.autoItemColor ? pnode.autoItemColor : p.autoItemColor;
            }
            profile.boxing()._autoColor(item, index, prop);
            if (pid) {
                oitem._pid = pid;
                if (pitem = map2[map1[pid]]) {
                    oitem._deep = pitem._deep + 1;
                    item.rulerStyle = 'width:' + (oitem._deep * p.$subMargin) + 'em;';
                    // for the last one
                    item._fi_togglemark = item.sub ? ('ood-uicmd-toggle' + (item._checked ? '-checked' : '')) : (p.togglePlaceholder ? 'ood-uicmd-empty' : 'ood-uicmd-none');
                }
            } else {
                oitem._deep = 0;
                item.rulerStyle = '';
                item.innerIcons = '';
                item._fi_togglemark = item.sub ? ('ood-uicmd-toggle' + (item._checked ? '-checked' : '')) : (p.togglePlaceholder ? 'ood-uicmd-empty' : 'ood-uicmd-none');
            }
            // show image
            item.imageDisplay = (item.noIcon || p.noIcon) ? "display:none;" : "";
            //
            item.cls_fold = item.sub ? profile.getClass('BAR', '-fold') : '';

            if (!(item.imageClass || item.image || item.iconFontCode))
                item._fi_cls_file = 'ood-icon-file' + (item.sub ? ' ood-icon-file-fold' : '');

            item._fi_optClass = p.optBtn;

            item.disabled = item.disabled ? 'ood-ui-disabled' : '';
            item._itemDisplay = item.hidden ? 'display:none;' : '';

            item.mark2Display = ('showMark' in item) ? (item.showMark ? '' : 'display:none;') : ((p.selMode == 'singlecheckbox' && !item.sub) || p.selMode == 'multibycheckbox') ? '' : 'display:none;';
            //          item.mark2Display = ('showMark' in item)?(item.showMark?'':'display:none;'):(p.selMode=='multi'||p.selMode == 'single'||p.selMode=='multibycheckbox')?'':'display:none;';

            item._tabindex = p.tabindex;
            this._prepareCmds(profile, item);

            if (item.type == 'split') {
                item._split = 'ood-uitem-split';
                item._splitstyle = 'margin-left:' + (oitem._deep * p.$subMargin) + 'em;';
                item._ruleDisplay = item._ltagDisplay = item._tglDisplay = item._rtagDisplay = item.imageDisplay = item.mark2Display = item._capDisplay = item._extraDisplay = item._optDisplay = 'display:none;';
            }
        },
        _tofold: function (profile, item, pid) {
            var cls = profile.getClass('IMAGE');
            profile.getSubNodeByItemId('BAR', pid).addClass(profile.getClass('BAR', '-fold'));
            profile.getSubNodeByItemId('TOGGLE', pid).replaceClass(new RegExp("\\b" + cls + "-path([-\\w]+)\\b"), cls + '-fold$1');
        },


        RenderTrigger: function () {
            // Modern feature initialization
            var self = this;
            ood.asyRun(function () {
                if (self.boxing() && self.boxing().TreeViewTrigger) {
                    self.boxing().TreeViewTrigger();
                }

            });
        }

    }
});
ood.Class("ood.UI.MTreeView", "ood.UI.TreeBar", {
    Initialize: function () {
        this.addTemplateKeys(['IMAGE']);
        var t = this.getTemplate();
        // 
        if(!t){
            t = {};
        }
        // $submap
        if(!t.$submap) t.$submap = {};
        if(!t.$submap.items) t.$submap.items = {};
        if(!t.$submap.items.ITEM) t.$submap.items.ITEM = {};
        if(!t.$submap.items.ITEM.BAR) t.$submap.items.ITEM.BAR = {};
        if(!t.$submap.items.ITEM.BAR.ITEMICON) t.$submap.items.ITEM.BAR.ITEMICON = {};
        
        t.$submap.items.ITEM.BAR.className = 'ood-uitembg ood-uiborder-radius ood-showfocus {cls_group} {cls_fold} {_split} {disabled} {readonly}';
        var n = t.$submap.items.ITEM.BAR.ITEMICON;
        n.$fonticon = '{_fi_cls_file}';
        this.setTemplate(t);
    },
    
    Instance: {
        //  iniProp 
        iniProp: {
            animCollapse: true,
            items: [
                {
                    id: 'node1', sub: [
                        {id: 'node12', imageClass: "ri-image-line"}
                    ]
                }, {
                    id: 'node2',
                    initFold: false
                }]
        }
    },
    
    Static: {

        Appearances: {
            ITEMS: {
                //overflow: 'visible'
                'padding': '.0em'
            },
            ITEM: {
                'white-space': 'nowrap',
                position: 'relative',
                'line-height': 1.22,
                //  padding: '0.25em 0 0.25em 0',
                'border-width': '1px',
                'border-bottom-style': 'solid',
                'border-color': 'var(--ood-border-light)',
                overflow: 'hidden'
            },
            MARK: {
                position: 'absolute',
                left: 'auto',
                top: '50%',
                'margin-top': '-0.5em',
                right: '.167em',
                $order: 12,
                color: "var(--ood-success)",
                cursor: 'pointer',
                'vertical-align': 'middle'
            },
            BAR: {
                zoom: ood.browser.ie ? 1 : null,
                position: 'relative',
                height: "2em",
                'border-width': '1px',
                'border-top-style': 'solid',
                'border-color': '#DDDDDD',
                display: 'block',
                'outline-offset': '-1px',
                '-moz-outline-offset': (ood.browser.gek && ood.browser.ver < 3) ? '-1px !important' : null
            },
            SUB: {
                zoom: ood.browser.ie ? 1 : null,
                height: 0,
                'font-size': ood.browser.ie68 ? '1px' : null,
                //1px for ie8
                'line-height': ood.browser.ie68 ? '1px' : null,
                position: 'relative',
                overflow: 'hidden'
            },
            BOX: {
                left: '0em',
                overflow: 'auto',
                position: 'relative'
            }
        },
        Behaviors: {
            MARK: {
                onClick: function (profile, e, src) {
                    profile.box._onclickbar(profile, e, ood.use(src).parent().xid());
                    return false;
                }
            },
            ITEMICON: {
                onClick: function (profile, e, src) {
                    profile.box._onclickbar(profile, e, ood.use(src).parent().xid());
                    return false;
                }
            }
        },
        DataModel: {
            expression: {
                ini: '',
                action: function () {
                }
            },
            $subMargin: 1.8,
            group: null,
            noIcon: {
                ini: true,
                action: function (v) {
                    this.getSubNode("ITEMICON", true).css('display', v ? 'none' : '');
                }
            }
        },


        _prepareItem: function (profile, item, oitem, pid, index, len) {
            var p = profile.properties,
                map1 = profile.ItemIdMapSubSerialId,
                map2 = profile.SubSerialIdMapItem,
                pitem;

            profile.boxing()._autoColor(item, index, p);

            if (item.fiCheck) {
                item._fi_check = item.fiCheck;
            } else {
                item._fi_check = 'ood-uimcmd-check';
            }

            if (pid) {
                oitem._pid = pid;
                if (pitem = map2[map1[pid]]) {
                    oitem._deep = pitem._deep + 1;
                    item.rulerStyle = 'width:' + (oitem._deep * p.$subMargin) + 'em;';
                    // for the last one
                    item._fi_togglemark = item.sub ? ('ood-uimcmd-toggle' + (item._checked ? '-checked' : '')) : (p.togglePlaceholder ? 'ood-uicmd-empty' : 'ood-uicmd-none');
                }
            } else {
                oitem._deep = 0;
                item.rulerStyle = '';
                item.innerIcons = '';
                item._fi_togglemark = item.sub ? ('ood-uimcmd-toggle' + (item._checked ? '-checked' : '')) : (p.togglePlaceholder ? 'ood-uicmd-empty' : 'ood-uicmd-none');
            }
            // show image
            item.imageDisplay = (item.noIcon || p.noIcon) ? "display:none;" : "";
            //
            item.cls_fold = item.sub ? profile.getClass('BAR', '-fold') : '';

            if (!(item.imageClass || item.image || item.iconFontCode))
                item._fi_cls_file = 'ood-icon-file' + (item.sub ? ' ood-icon-file-fold' : '');

            item._fi_optClass = p.optBtn;

            item.disabled = item.disabled ? 'ood-ui-disabled' : '';
            item._itemDisplay = item.hidden ? 'display:none;' : '';

            item.mark2Display = ('showMark' in item) ? (item.showMark ? '' : 'display:none;') : ((p.selMode == 'singlecheckbox' && !item.sub) || p.selMode == 'multibycheckbox') ? '' : 'display:none;';
            //          item.mark2Display = ('showMark' in item)?(item.showMark?'':'display:none;'):(p.selMode=='multi'||p.selMode == 'single'||p.selMode=='multibycheckbox')?'':'display:none;';

            item._tabindex = p.tabindex;
            this._prepareCmds(profile, item);

            if (item.type == 'split') {
                item._split = 'ood-uitem-split';
                item._splitstyle = 'margin-left:' + (oitem._deep * p.$subMargin) + 'em;';
                item._ruleDisplay = item._ltagDisplay = item._tglDisplay = item._rtagDisplay = item.imageDisplay = item.mark2Display = item._capDisplay = item._extraDisplay = item._optDisplay = 'display:none;';
            }
        },
        _tofold: function (profile, item, pid) {
            var cls = profile.getClass('IMAGE');
            profile.getSubNodeByItemId('BAR', pid).addClass(profile.getClass('BAR', '-fold'));
            profile.getSubNodeByItemId('TOGGLE', pid).replaceClass(new RegExp("\\b" + cls + "-path([-\\w]+)\\b"), cls + '-fold$1');
        }
    }
});
ood.Class("ood.UI.PopMenu", ["ood.UI.Widget", "ood.absList"], {
    Instance: {
        //  iniProp 
        iniProp: {
            items: [{id: 'a', caption: 'item 1', imageClass: 'ri-number-1'}, {
                id: 'b',
                caption: 'item 2',
                imageClass: 'ri-number-2'
            }, {id: 'c', caption: 'item 3', imageClass: 'ri-number-3'}, {
                id: 'd',
                caption: 'item 4',
                imageClass: 'ri-number-4',
                disabled: true
            }]
        },

        adjustSize: function () {
            this.each(function (profile) {
                if (profile.renderId) {
                    var root = profile.getRoot();
                    var border = profile.getSubNode('BORDER'),
                        box = profile.getSubNode('BOX'),
                        bg = profile.getSubNode('BOXBGBAR'),
                        items = profile.getSubNode('ITEMS'),
                        nodes = profile.getSubNode('ITEM', true),
                        prop = profile.properties,
                        us = ood.$us(profile),
                        cb = border.contentBox(),
                        adjustunit = function (v, emRate) {
                            return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                        },
                        ww = 0, hh = 0;

                    items.cssSize({width: 'auto', height: 'auto'});

                    hh = items.height() + (cb ? 0 : border._borderH());
                    if (ood.browser.ie67 && hh % 2 == 1) hh += 1;
                    items.addClass(profile.getClass('ITEMS', '-inline'));
                    nodes.each(function (n) {
                        ww = Math.max(ww, n.offsetWidth);
                    });

                    if (ww % 2 == 1) ww += 1;
                    items.removeClass(profile.getClass('ITEMS', '-inline'));
                    ww = ww < 120 ? 120 : ww;
                    hh = hh + 10;
                    // for IE7
                    items.cssSize({
                        width: adjustunit(ww),
                        height: adjustunit(hh)
                    });
                    bg.height(adjustunit(hh));

                    var h = adjustunit(Math.min(prop._maxHeight, hh)),
                        w = adjustunit(Math.min(prop._maxWidth, ww)),
                        size = {
                            width: w,
                            height: h
                        };
                    prop.width = w;
                    prop.height = h;

                    root.cssSize(size);
                    border.cssSize(size);
                    box.cssSize({
                        width: adjustunit(Math.min(prop._maxWidth, ww) + ood.Dom.getScrollBarSize()),
                        height: size.height
                    });
                }
            });
            return this._setScroll();
        },
        _setScroll: function () {
            return this.each(function (profile) {
                if (profile.renderId) {
                    var o = profile.getSubNode('BOX'),
                        t = o.scrollTop(),
                        h = o.scrollHeight(),
                        b = profile.getRoot(),
                        hh = b.offsetHeight();
                    profile.getSubNode('TOP').css('display', t === 0 ? 'none' : 'block');
                    profile.getSubNode('BOTTOM').css('display', (hh >= h - t) ? 'none' : 'block');
                }
            })
        },
        _scrollToBottom: function () {
            var profile = this.get(0),
                o = profile.getSubNode('BOX'),
                border = profile.getSubNode('BORDER'),
                y = o.scrollTop(),
                b = false,
                offset,
                h = o.scrollHeight(),
                bh = border.height();
            if (bh < h - y) {
                y += (profile.$scrollStep = Math.max(5, (profile.$scrollStep || 1) * 1.005));
                if (bh >= h - y) {
                    y = h - bh;
                    b = true;
                }
                o.scrollTop(y);
                if (b) {
                    profile.getSubNode('BOTTOM').css('display', 'none');
                    profile.$scrollTobottom = false;
                    profile.$scrollStep = 1;
                } else {
                    profile.getSubNode('TOP').css('display', 'block');
                    if (profile.$scrollTobottom)
                        ood.asyRun(this._scrollToBottom, 0, [], this);
                }
            }
        },
        _scrollToTop: function () {
            var profile = this.get(0),
                o = profile.getSubNode('BOX'),
                y = o.scrollTop(),
                b = false;
            if (y > 0) {
                y -= (profile.$scrollStep = Math.max(5, (profile.$scrollStep || 1) * 1.005));
                if (y < 0) {
                    y = 0;
                    b = true;
                }
                o.scrollTop(y);
                if (b) {
                    profile.getSubNode('TOP').css('display', 'none');
                    profile.$scrollToTop = false;
                    profile.$scrollStep = 1;
                } else {
                    profile.getSubNode('BOTTOM').css('display', 'block');
                    if (profile.$scrollToTop)
                        ood.asyRun(this._scrollToTop, 0, [], this);
                }
            }
        },
        _initGrp: function () {
            var profile = this.get(0), root;
            if (!profile.$popGrp || !profile.$popGrp.length) {
                root = profile.getRoot();
                profile.$popGrp = [root._get(0)];
                //group blur trigger
                root.setBlurTrigger(profile.$xid, null);
                root.setBlurTrigger(profile.$xid, function () {
                    if (profile.box) {
                        profile.boxing().hide();
                        if (profile.$popGrp)
                            profile.$popGrp.length = 0;
                    }
                }, profile.$popGrp);
            }
        },
        setTagVar: function (tagVar) {
            var ns = this, profile = ns.get(0);
            if (!profile.tagVar) {
                profile.tagVar = tagVar
            } else {
                ood.merge(profile.tagVar, tagVar, 'all')
            }
        },
        pop: function (pos, type, parent, ignoreEffects) {
            var ns = this,
                profile = ns.get(0),
                p = profile.properties,
                pid = p.parentID || ood.ini.$rootContainer,
                sms = '$subPopMenuShowed',
                hl = '$highLight',
                cm = '$childPopMenu';
            //ensure rendered
            if (!profile.renderId) {
                //use empty idv for LayoutTrigger
                ood.Dom.getEmptyDiv().append(ns.render(true));
            }

            //clear highLight first
            if (profile.$highLight)
                ood([profile.$highLight]).tagClass('-hover', false);

            // set container
            profile._conainer = pid ? ood.get(profile, ["host", pid]) ? profile.host[pid].getContainer() : ood(pid) : parent || null;

            profile.getRoot().popToTop(pos, type, profile._conainer);

            ns._setScroll();
            ns.adjustSize();

            ns._initGrp();
            profile[cm] = profile[sms] = profile[hl] = null;
            return ns;
        },
        hide: function (triggerEvent, ignoreEffects, e) {
            var t,
                profile = this.get(0),
                p = profile.properties,
                root = profile.getRoot(),
                sms = '$subPopMenuShowed',
                hl = '$highLight',
                cm = '$childPopMenu',
                fun = function () {
                    if (false !== triggerEvent)
                        if (false === profile.boxing().beforeHide(profile, ignoreEffects, e))
                            return this;

                    if (!root || root.css('display') == 'none') return;

                    if (ood.get(profile, ['$hideMenuPool', '_nodes', 0]))
                        profile.$hideMenuPool.append(root);
                    else
                        root.css('display', 'none');

                    if (t = profile[hl])
                        ood([t]).tagClass('-hover', false);

                    //hide all parent pop
                    var p = profile[cm], q;
                    if (t = profile[sms]) t.hide(triggerEvent, ignoreEffects);
                    while (p) {
                        p.boxing().hide(triggerEvent, ignoreEffects);
                        p = (q = p)[cm];
                        q[cm] = q[sms] = q[hl] = null;
                    }
                    profile[cm] = profile[sms] = profile[hl] = null;
                    if (t = profile.$parentPopMenu) t[sms] = null;

                    if (profile.$popGrp)
                        ood.arr.removeValue(profile.$popGrp, root._get(0));

                    //remove trigger
                    if (!profile.$popGrp || !profile.$popGrp.length)
                        root.setBlurTrigger(profile.$xid, null);

                    if (false !== triggerEvent)
                        profile.boxing().onHide(profile);
                };
            root.hide(fun, null, ignoreEffects);
            return this;
        },
        _afterInsertItems: function (profile) {
            if (!profile.renderId) return;
            profile.boxing().adjustSize();
        },
        _afterRemoveItems: function (profile) {
            if (!profile.renderId) return;
            profile.boxing().adjustSize();
        },

        // 
        setTheme: function (theme) {
            return this.each(function (profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot(),
                    border = profile.getSubNode('BORDER'),
                    box = profile.getSubNode('BOX'),
                    items = profile.getSubNode('ITEM', true),
                    captions = profile.getSubNode('CAPTION', true),
                    icons = profile.getSubNode('ICON', true),
                    bg = profile.getSubNode('BOXBGBAR');

                if (theme === 'dark') {
                    // 
                    root.addClass('popmenu-dark');
                    border.css({
                        'background-color': 'var(--dark-bg-card)',
                        'border-color': 'var(--dark-border)',
                        'color': 'var(--dark-text)'
                    });
                    box.css({
                        'background-color': 'var(--dark-bg)',
                        'color': 'var(--dark-text)'
                    });
                    items.css({
                        'color': 'var(--dark-text)'
                    });
                    // // 
                    // items.filter('.ood-ui-item-hover, .ood-ui-item-checked').css({
                    //     'background-color': 'var(--dark-bg-hover)',
                    //     'color': 'var(--dark-text-heading)'
                    // });
                    captions.css({
                        'color': 'var(--dark-text)'
                    });
                    icons.css({
                        'color': 'var(--dark-text-muted)'
                    });
                    bg.css({
                        'background-color': 'var(--dark-bg-card)'
                    });
                } else {
                    // 
                    root.removeClass('popmenu-dark');
                    border.css({
                        'background-color': '',
                        'border-color': '',
                        'color': ''
                    });
                    box.css({
                        'background-color': '',
                        'color': ''
                    });
                    items.css({
                        'color': ''
                    });
                    captions.css({
                        'color': ''
                    });
                    icons.css({
                        'color': ''
                    });
                    bg.css({
                        'background-color': ''
                    });
                }

                // 
                localStorage.setItem('popmenu-theme', theme);
            });
        },

        // 
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('popmenu-theme') || 'light';
        },

        PopMenuTrigger: function () {
            var profile = this.get(0);
            var prop = profile.properties;

            // 
            // 
            if (prop.theme) {
                this.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('popmenu-theme');
                if (savedTheme) {
                    this.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                this.adjustLayout();
            }

            // 
            this.enhanceAccessibility();
        },

        // 
        toggleDarkMode: function () {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
            return this;
        },

        // 
        adjustLayout: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    items = profile.getSubNode('ITEM', true),
                    captions = profile.getSubNode('CAPTION', true),
                    icons = profile.getSubNode('ICON', true),
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('popmenu-mobile');

                    // 
                    items.css({
                        'padding': '0.5em 0.8em',
                        'min-height': '44px' // 
                    });
                    captions.css({
                        'font-size': '0.9em'
                    });
                    icons.css({
                        'font-size': '1.1em'
                    });

                    // 
                    prop._maxWidth = Math.min(prop._maxWidth || 460, width - 40);
                } else {
                    root.removeClass('popmenu-mobile');

                    // 
                    items.css({
                        'padding': '',
                        'min-height': ''
                    });
                    captions.css({
                        'font-size': ''
                    });
                    icons.css({
                        'font-size': ''
                    });
                }

                // 
                if (width < 480) {
                    root.addClass('popmenu-tiny');

                    // 
                    captions.css({
                        'font-size': '0.8em'
                    });
                    // 
                    if (width < 320) {
                        icons.css({
                            'display': 'none'
                        });
                    }
                } else {
                    root.removeClass('popmenu-tiny');
                }

                // 
                profile.boxing().adjustSize();
            });
        },

        // 
        enhanceAccessibility: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    items = profile.getSubNode('ITEM', true),
                    icons = profile.getSubNode('ICON', true),
                    captions = profile.getSubNode('CAPTION', true),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'menu',
                    'aria-label': ''
                });

                // ARIA
                items.each(function (item, index) {
                    var itemNode = ood(item);
                    var itemData = profile.getItemByDom(item);

                    // ARIA
                    itemNode.attr({
                        'role': itemData.type === 'split' ? 'separator' : 'menuitem',
                        'tabindex': itemData.disabled ? '-1' : '0',
                        'aria-label': itemData.caption || '',
                        'aria-disabled': itemData.disabled ? 'true' : 'false'
                    });

                    // 
                    if (itemData.sub && itemData.sub.length > 0) {
                        itemNode.attr({
                            'aria-haspopup': 'true',
                            'aria-expanded': 'false'
                        });
                    }

                    // 
                    if (itemData.type === 'checkbox') {
                        itemNode.attr({
                            'role': 'menuitemcheckbox',
                            'aria-checked': itemData.value ? 'true' : 'false'
                        });
                    }

                    // 
                    if (itemData.type === 'radiobox') {
                        itemNode.attr({
                            'role': 'menuitemradio',
                            'aria-checked': itemData.value ? 'true' : 'false'
                        });
                    }
                });

                // ARIA
                icons.each(function (icon) {
                    ood(icon).attr({
                        'aria-hidden': 'true' // 
                    });
                });
            });
        }
    },
    Initialize: function () {
        //modify default template fro shell
        var t = this.getTemplate();
        ood.merge(t.FRAME.BORDER, {
            className: "ood-uiborder-outset ood-uiborder-radius",
            TOP: {
                className: 'oodfont ood-uibar ood-uiborder-b',
                $fonticon: 'ood-icon-circleup'
            },
            BOTTOM: {
                className: 'oodfont ood-uibar ood-uiborder-t',
                $fonticon: 'ood-icon-circledown'
            },
            BOX: {
                tagName: 'div',
                className: "ood-uibase",
                BOXBGBAR: {
                    tabName: 'div',
                    className: 'ood-uibar',
                    style: '{_iconDisplay}'
                },
                ITEMS: {
                    tagName: 'div',
                    text: "{items}"
                }
            },
            POOL: {}
        }, 'all');
        t.$submap = {
            'items': function (profile, template, v, tag, result) {
                var t;
                tag = tag + '.' + v.type;
                //for ood.UI or ood.Template
                if (t = v.object) {
                    //[v] is for ood.Template
                    result[result.length] = t.build(v);
                } else {
                    if (template[tag])
                        ood.UI.$doTemplate(profile, template, v, tag, result);
                }
            },
            'items.split': {
                ITEMSPLIT: {
                    style: "{_itemDisplay}",
                    className: 'ood-uiborder-b'
                }
            },
            'items.button': {
                ITEM: {
                    tabindex: -1,
                    className: ' ood-uimenu {itemClass} {disabled}',
                    style: '{itemStyle}{_itemDisplay}{_itemColor}',
                    ICON: {
                        $order: 0,
                        className: ' {imageClass}  {picClass}',
                        style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{_iconDisplay}{iconStyle} {_iconColor}',
                        text: '{iconFontCode}'
                    },
                    CAPTION: {
                        text: '{caption}',
                        style: '{_fontColor}',
                        $order: 1
                    },
                    RULER: {
                        style: '{displayAdd}',
                        $order: 2
                    },
                    ADD: {
                        tagName: 'div',
                        style: '{displayAdd}',
                        text: '{add}',
                        $order: 2
                    },
                    SUB: {
                        className: 'oodfont',
                        $fonticon: 'ood-icon-singleright',
                        style: '{displaySub}'
                    }
                }
            },
            'items.checkbox': {
                ITEM: {
                    tabindex: -1,
                    className: '  ood-uimenu {itemClass} {disabled}',
                    style: '{itemStyle}{_itemDisplay}',
                    CHECKBOX: {
                        $order: 0,
                        className: 'oodfont',
                        $fonticon: '{_fi_checkboxCls1} {_fi_checkboxCls2}  {_iconDisplay}'
                    },
                    CAPTION: {
                        text: '{caption}',
                        $order: 1
                    },
                    RULER: {
                        style: '{displayAdd}',
                        $order: 2
                    },
                    ADD: {
                        tagName: 'div',
                        style: '{displayAdd}',
                        text: '{add}',
                        $order: 2
                    }
                }
            },
            'items.radiobox': {
                ITEM: {
                    tabindex: -1,
                    className: '  ood-uimenu {itemClass} {disabled}',
                    style: '{itemStyle}{_itemDisplay}',
                    RADIOBOX: {
                        $order: 0,
                        className: 'oodfont',
                        $fonticon: '{_fi_radioboxCls1} {_fi_radioboxCls2}  {_iconDisplay}'
                    },
                    CAPTION: {
                        text: '{caption}',
                        $order: 1
                    },
                    RULER: {
                        style: '{displayAdd}',
                        $order: 2
                    },
                    ADD: {
                        tagName: 'div',
                        style: '{displayAdd}',
                        text: '{add}',
                        $order: 2
                    }
                }
            }
        };
        this.setTemplate(t);

        this.prototype.popUp = this.prototype.pop;
    },
    Static: {
        $initRootHidden: true,
        Appearances: {
            KEY: {
                visibility: 'hidden'
            },
            POOL: {
                position: 'absolute',
                display: 'none'
            },
            BOX: {
                overflow: 'hidden',
                position: 'relative',
                overflow: 'hidden',
                'overflow-y': 'auto',
                'z-index': '3',
                'background-color': 'var(--bg-primary)',
                'border-radius': 'var(--radius-md)',
                'box-shadow': 'var(--shadow-lg)'
            },
            BORDER: {
                position: 'relative',
                overflow: 'hidden',
                'background-color': 'var(--bg-primary)',
                'border': '1px solid var(--border)'
            },
            ITEMS: {
                position: 'relative',
                top: 0,
                left: 0,
                overflow: 'hidden',
                'white-space': 'nowrap'
            },
            BOXBGBAR: {
                'z-index': -1,
                position: 'absolute',
                left: 0,
                top: 0,
                width: '2em',
                height: '100%',
                'background-color': 'rgba(0,0,0,0.15)'
            },
            'ITEMS-inline ITEM': {
                $order: 5,
                display: ood.$inlineBlock
            },
            ITEM: {
                display: 'block',
                position: 'relative',
                overflow: 'visible',
                'white-space': 'nowrap',
                cursor: 'pointer',
                padding: 'var(--spacing-xs) var(--spacing-lg) var(--spacing-xs) var(--spacing-sm)',
                outline: 0,
                'background-color': 'transparent',
                'transition': 'background-color var(--transition-fast)',
                'color': 'var(--text)'
            },
            'ITEM:hover': {
                'background-color': 'var(--bg-hover)',
                'color': 'var(--text-heading)'
            },
            ITEMSPLIT: {
                display: 'block',
                position: 'relative',
                overflow: 'visible',
                'white-space': 'nowrap',
                margin: 'var(--spacing-xs) var(--spacing-xs) var(--spacing-xs) var(--spacing-md)',
                'border-top': '1px solid var(--border)'
            },
            ICON: {
                margin: 0,
                'font-size': '1.25em !important',
                'color': 'var(--text-primary)'
            },
            TOP: {
                cursor: 'pointer',
                display: 'none',
                position: 'absolute',
                'z-index': '10',
                top: 0,
                'text-align': 'center',
                width: '100%',
                'background-color': 'var(--bg-header)'
            },
            BOTTOM: {
                cursor: 'pointer',
                display: 'none',
                position: 'absolute',
                bottom: 0,
                'z-index': '10',
                'text-align': 'center',
                width: '100%',
                'background-color': 'var(--bg-header)'
            },
            'RADIOBOX, CHECKBOX, RADIOBOX-checked, CHECKBOX-checked': {
                cursor: 'pointer',
                'vertical-align': 'middle'
            },
            CAPTION: {
                'vertical-align': ood.browser.ie6 ? 'baseline' : 'middle',
                'padding-left': 'var(--spacing-sm)',
                'font-size': 'var(--font-size-md)',
                'color': 'var(--text)'
            },
            RULER: {
                width: '12em'
            },
            ADD: {
                position: 'absolute',
                top: 'var(--spacing-xs)',
                right: 0,
                width: '7em',
                'padding-right': 'var(--spacing-lg)',
                'text-align': 'right',
                'z-index': '10',
                zoom: ood.browser.ie ? 1 : null,
                'color': 'var(--text-muted)'
            },
            SUB: {
                position: 'absolute',
                top: '0.15em',
                right: '0.15em',
                'color': 'var(--text-muted)'
            },

            // 
            'popmenu-dark BOX': {
                'background-color': 'var(--dark-bg) !important',
                'box-shadow': 'var(--dark-shadow-lg) !important'
            },
            'popmenu-dark BORDER': {
                'background-color': 'var(--dark-bg-card) !important',
                'border-color': 'var(--dark-border) !important'
            },
            'popmenu-dark BOXBGBAR': {
                'background-color': 'var(--dark-bg-card) !important'
            },
            'popmenu-dark ITEM': {
                'color': 'var(--dark-text) !important'
            },
            'popmenu-dark ITEM:hover': {
                'background-color': 'var(--dark-bg-hover) !important',
                'color': 'var(--dark-text-heading) !important'
            },
            'popmenu-dark ITEMSPLIT': {
                'border-top-color': 'var(--dark-border) !important'
            },
            'popmenu-dark ICON': {
                'color': 'var(--dark-text-muted) !important'
            },
            'popmenu-dark CAPTION': {
                'color': 'var(--dark-text) !important'
            },
            'popmenu-dark ADD': {
                'color': 'var(--dark-text-muted) !important'
            },
            'popmenu-dark SUB': {
                'color': 'var(--dark-text-muted) !important'
            },

            // 
            'popmenu-mobile ITEM': {
                'padding': 'var(--spacing-sm) var(--spacing-md)',
                'min-height': '44px'
            },
            'popmenu-mobile CAPTION': {
                'font-size': 'var(--font-size-sm)'
            },
            'popmenu-mobile ICON': {
                'font-size': '1.1em !important'
            },

            // 
            'popmenu-tiny CAPTION': {
                'font-size': 'var(--font-size-xs)'
            },
            'popmenu-tiny ICON': {
                'display': 'none !important'
            }
        },
        Behaviors: {
            HoverEffected: {TOP: 'TOP', BOTTOM: 'BOTTOM'},
            BOX: {
                onScroll: function (profile, e, src) {
                    profile.boxing()._setScroll();
                }
            },
            ITEM: {
                onMouseover: function (profile, e, src) {
                    var sms = '$subPopMenuShowed',
                        all = '$allPops',
                        hl = '$highLight',
                        showp = '$showpops',
                        popgrp = '$popGrp';
                    //for stop second trigger by focus event
                    if (profile[hl] == src) return;
                    profile[all] = profile[all] || {};

                    var properties = profile.properties,
                        item = profile.getItemByDom(src),
                        itemId = item.id,
                        Cancel = false,
                        pop, popp, t;
                    //if sub pop menu showed
                    if (t = profile[sms]) {
                        //if the showed menu is self
                        if (t == ood.get(profile, [all, itemId]))
                            Cancel = true;
                        else {
                            t.hide();
                            profile[sms] = null;
                        }
                    }
                    if (!Cancel) {
                        if (t = profile[hl])
                            ood([t]).tagClass('-hover', false);
                        profile[hl] = src;
                        ood.use(src).tagClass('-hover');
                        //don't fire events here
                        try {
                            ood.use(src).get(0).focus()
                        } catch (e) {
                        }
                    }

                    if (!Cancel && item.sub) {
                        // if no sub arrays
                        if (!(ood.isArr(item.sub) && item.sub.length)) {
                            if (profile.onShowSubMenu) {
                                var r = profile[all][itemId];
                                if (r && r['ood.UI'] && !r.isEmpty()) {
                                }
                                else
                                    r = profile.boxing().onShowSubMenu(profile, item, src);

                                // return UI control
                                if (r && r['ood.UI'] && !r.isEmpty()) {
                                    // keep it
                                    profile[all][itemId] = profile[sms] = r;

                                    r = r.reBoxing();
                                    r.onMouseout(function (p, e, src) {
                                        profile.box._mouseout(profile, e, src);
                                    }, null, -1);

                                    profile.boxing()._initGrp();
                                    profile[popgrp].push(r._get(0));

                                    r.popToTop(src, 2, profile._conainer);

                                    return;
                                }
                                // return items array
                                else if (r && ood.isArr(r) && r.length) {
                                    item.sub = r;
                                }
                            }
                        }

                        // show items
                        if (ood.isArr(item.sub) && item.sub.length) {
                            //no create
                            if (!(pop = profile[all][itemId])) {
                                var pro = profile.properties;
                                pop = (new ood.UI.PopMenu({
                                    position: 'absolute',
                                    items: item.sub,
                                    autoHide: pro.autoHide,
                                    showEffects: pro.showEffects,
                                    hideEffects: pro.hideEffects
                                })).render(true);
                                pop.onShowSubMenu(function (pro, item, src) {
                                    return profile.boxing().onShowSubMenu(profile, item, src);
                                });
                                pop.onMenuSelected(function (pro, item, src) {
                                    return profile.boxing().onMenuSelected(profile, item, src);
                                });
                                popp = pop.get(0);
                                //set pool to parent
                                popp.$hideMenuPool = ood.get(profile, ['$hideMenuPool', '_nodes', 0]) || profile.getSubNode('POOL');

                                profile[all][itemId] = pop;

                                //collect
                                profile[showp] = profile[showp] || [profile];
                                popp[showp] = profile[showp];
                                profile[showp].push(popp);
                            } else popp = pop.get(0);

                            //input a copy of root for group trigger
                            profile.boxing()._initGrp();
                            profile[popgrp].push(popp.getRoot()._get(0));
                            popp[popgrp] = profile[popgrp];

                            //set parent pop
                            popp.$parentPopMenu = profile;
                            profile.$childPopMenu = popp;

                            pop.pop(src, 2, profile._conainer);
                            profile[sms] = pop;
                        }
                    }
                },
                onMouseout: function (profile, e, src) {
                    var properties = profile.properties,
                        item = profile.getItemByDom(src),
                        itemId = item.id,
                        action = true,
                        hl = '$highLight',
                        t;
                    if (profile[hl] == src) return;

                    //if cursor move to submenu, keep the hover face
                    if (t = profile.$subPopMenuShowed) {
                        var node = e.toElement || e.relatedTarget,
                            target = t.get(0).getRootNode();
                        try {
                            do {
                                if (node == target)
                                    return;
                            } while ((node && (node = node.parentNode)))
                        } catch (a) {
                        }
                    }
                    ood.use(src).tagClass('-hover', false);
                    profile[hl] = null;
                },
                onClick: function (profile, e, src) {
                    var prop = profile.properties,
                        item = profile.getItemByDom(src),
                        itemId = item.id;
                    if (prop.disabled || item.disabled) return false;

                    // give a change to click an item with sub popmenu
                    if (!item.group) {
                        if (item.type == 'checkbox')
                            profile.getSubNodeByItemId('CHECKBOX', item.id).tagClass('-checked', item.value = !item.value);
                        else if (item.type == 'radiobox') {
                            profile.getSubNode('RADIOBOX', true).tagClass('-checked', false);
                            ood.arr.each(prop.items, function (o) {
                                if (o.type == 'radiobox')
                                    o.value = false;
                            });
                            profile.getSubNodeByItemId('RADIOBOX', item.id).tagClass('-checked', item.value = true);
                        }

                        if (profile.onMenuSelected) profile.boxing().onMenuSelected(profile, item, src);

                        if (prop.hideAfterClick) {
                            ood.use(src).tagClass('-hover', false);
                            //hide all parent pop
                            ood.asyRun(function () {
                                var p = profile, q;
                                if (!p.renderId) return;
                                while (p) {
                                    p.boxing().hide();
                                    p = (q = p).$parentPopMenu;
                                    q.$parentPopMenu = q.$subPopMenuShowed = null;
                                }
                                //reset
                                profile.$subPopMenuShowed = null;
                                if (profile.$popGrp)
                                    profile.$popGrp.length = 0;
                            }, 100);
                        }
                    }
                },
                onFocus: function (profile, e, src) {
                    var box = profile.getSubNode('BOX'),
                        top = box.scrollTop(), h = box.scrollHeight(),
                        n = ood.use(src).offsetTop();

                    if (n < top || n > top + h)
                        ood.use(src).offsetTop(top);

                    ood.use(src).onMouseover();
                },
                onKeydown: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        items = profile.properties.items,
                        key = ood.Event.getKey(e).key,
                        itemId = item.id,
                        flag, r, tid, node, t;

                    switch (key) {
                        case 'enter':
                            ood(src).onClick();
                            break;
                        case 'up':
                            r = true;
                            flag = false;
                            ood.arr.each(items, function (o, i) {
                                if (o.type == 'split') return;
                                if (flag) {
                                    tid = o.id;
                                    return r = false;
                                }
                                if (o.id == itemId) flag = true;
                            }, null, true);
                            //last
                            if (r) tid = items[items.length - 1].id;
                            node = profile.getSubNodeByItemId('ITEM', tid).get(0);
                            break;
                        case 'down':
                            r = true;
                            flag = false;
                            ood.arr.each(items, function (o, i) {
                                if (o.type == 'split') return;
                                if (flag) {
                                    tid = o.id;
                                    return r = false;
                                }
                                if (o.id == itemId) flag = true;
                            });
                            //first
                            if (r) tid = items[0].id;
                            node = profile.getSubNodeByItemId('ITEM', tid).get(0);
                            break;
                        case 'left':
                            if (t = profile.$parentPopMenu) {
                                if (t = profile.$parentPopMenu.$highLight)
                                    node = t;
                            }
                            break;
                        case 'right':
                            if ((t = profile.$subPopMenuShowed) && t == profile.$allPops[itemId])
                                t.activate();
                            break;
                    }
                    if (node && node.tagName) try {
                        node.focus()
                    } catch (e) {
                    }
                }
            },
            TOP: {
                onMouseover: function (profile) {
                    profile.$scrollToTop = true;
                    profile.$scrollStep = 1;
                    profile.boxing()._scrollToTop();
                },
                onMouseout: function (profile) {
                    profile.$scrollToTop = false;
                    profile.$scrollStep = 1;
                },
                onClick: function (profile) {
                    profile.$scrollStep *= 2;
                }
            },
            BOTTOM: {
                onMouseover: function (profile) {
                    profile.$scrollTobottom = true;
                    profile.$scrollStep = 1;
                    profile.boxing()._scrollToBottom();
                },
                onMouseout: function (profile) {
                    profile.$scrollTobottom = false;
                    profile.$scrollStep = 1;
                },
                onClick: function (profile) {
                    profile.$scrollStep *= 2;
                }
            },
            ITEMS: {
                afterKeydown: function (profile, e) {
                    var key = ood.Event.getKey(e).key;
                    if (key == 'tab' || key == 'enter')
                        return true;
                    else if (key == 'esc') {
                        //top
                        do {
                            profile.boxing().hide();
                        } while (profile = profile.$parentPopMenu)

                        return false;
                    } else return false;
                }
            },
            BORDER: {
                onMouseout: function (profile, e, src) {
                    profile.box._mouseout(profile, e, src);
                }
            }
        },
        DataModel: ({
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark'],
                action: function (value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function (value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },

            expression: {
                ini: '',
                action: function () {
                }
            },

            autoFontColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoIconColor: {
                ini: true,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            iconColors: null,
            itemColors: null,
            fontColors: null,
            dock: null,
            tabindex: null,
            tips: null,
            border: null,
            resizer: null,
            dragSortable: null,
            showEffects: "Blur",
            hideEffects: "",
            autoTips: false,
            shadow: true,
            _maxHeight: 360,
            _maxWidth: 460,
            left: -10000,
            parentID: '',
            hideAfterClick: true,

            autoHide: false,

            height: {
                $spaceunit: 1,
                ini: 'auto'
            },
            //opera needs more space for initialize
            width: {
                $spaceunit: 1,
                ini: 'auto'
            },
            position: 'absolute',
            noIcon: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            $hborder: 0,
            $vborder: 0
        }),
        EventHandlers: {
            onShowSubMenu: function (profile, item, src) {
            },
            beforeHide: function (profile, e) {
            },
            onHide: function (profile) {
            },
            onMenuSelected: function (profile, item, src) {
            }
        },


        RenderTrigger: function () {
            var prf = this;
            prf.boxing().adjustSize();

            // 
            prf.boxing().PopMenuTrigger();

            (prf.$beforeDestroy = (prf.$beforeDestroy || {}))["sub-pops"] = function (t) {
                ood.each(prf.$allPops, function (pop) {
                    if (pop && !pop.$noDestroyByParentMenu) {
                        if (pop['ood.UI'] && !pop.isEmpty() && !pop.isDestroyed()) {
                            pop.destroy();
                        } else if (pop['ood.UIProfile'] && !pop.destroyed) {
                            pop.__gc();
                        } else if (pop['ood.Dom'] && !pop.isEmpty()) {
                            pop.remove();
                        }
                    }
                });
            };
        },


        _beforeSerialized: function (profile) {
            var o = arguments.callee.upper.call(this, profile),
                op = o.properties;
            delete op.left;
            delete op.top;
            delete op.right;
            delete op.bottom;
            delete op.width;
            delete op.height;
            return o;
        },
        _mouseout: function (profile, e) {
            if (profile.properties.autoHide) {
                var p1 = ood.Event.getPos(e),
                    size, p2, b;
                ood.arr.each(profile.$popGrp, function (o) {
                    o = ood([o]);
                    p2 = o.offset();
                    size = o.cssSize();
                    if (p1.left >= p2.left && p1.top >= p2.top && p1.left <= p2.left + size.width && p1.top <= p2.top + size.height) {
                        b = 1;
                        return false;
                    }
                });
                if (!b) {
                    while (b = profile.$parentPopMenu) profile = b;
                    profile.boxing().hide(true, null, e);
                    if (profile.$popGrp)
                        profile.$popGrp.length = 0;
                }
            }
        },
        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile),
                NONE = 'display:none', ns = this,
                prop = profile.properties;
            if (prop.noIcon) data._iconDisplay = NONE;

            ood.arr.each(data.items, function (item) {
                var index = item.index;
                if (!index) {
                    index = ood.arr.indexOf(data.items, item);
                }
                profile.boxing()._autoColor(item, index, prop);
            })

            return data;
        },
        _prepareItem: function (profile, item, oitem, pid, index, len) {
            var p = profile.properties, NONE = 'display:none;',
                prop = profile.properties;

            item.add = item.add || '';
            item.displayAdd = item.add ? '' : NONE;
            item.displaySub = item.sub ? '' : NONE;
            item._itemDisplay = item.hidden ? NONE : '';
            profile.boxing()._autoColor(item, index, p);
            if (!item.image) {
                item.imageClass = item.imageClass ? item.imageClass : 'oodcon ood-icon-placeholder';
                if (ood.str.startWith("ood-")) {
                    item.imageClass = "oodcon " + item.imageClass;
                }
            } else {
                item.imageClass = "oodcon ood-icon-placeholder "
            }


            item._iconDisplay = prop.noIcon ? NONE : '';

            item.type = item.type || 'button';
            if (item.type == 'checkbox') {
                item._fi_checkboxCls1 = 'ood-uicmd-check';
                item._fi_checkboxCls2 = item.value ? 'oodcon-checked ood-uicmd-check-checked' : '';
            }
            else if (item.type == 'radiobox') {
                item._fi_radioboxCls1 = 'ood-uicmd-radio';
                item._fi_radioboxCls2 = item.value ? 'oodcon-checked ood-uicmd-radio-checked' : '';
            }
        },
        _onresize: null
    }
});ood.Class("ood.UI.MenuBar", ["ood.UI", "ood.absList"], {
    Instance: {
        //  iniProp 
        iniProp: {
            items: [
                {
                    "id": "menu1",
                    "sub": [{"id": "normal", "caption": "normal"},
                        {"id": "disabled", "caption": "disabled", "disabled": true},
                        {"id": "image", "caption": "image", imageClass: "ri-image-line"},
                        {"type": "split"},
                        {"id": "checkbox 1", "caption": "checkbox 1", "type": "checkbox"},
                        {"id": "checkbox 2", "caption": "checkbox 2", "type": "checkbox"}],
                    "caption": "menu1"
                }
            ],
            theme: 'light',
            responsive: true,
            handler: true,
            hAlign: 'left',
            vAlign: 'middle',
            dock: 'top',
            border: 'outset',
            autoShowTime: 200,
            value: '',
            autoItemColor: false,
            autoIconColor: false,
            autoFontColor: false
        },

        // 
        setTheme: function(theme) {
            return this.each(function(profile) {
                var root = profile.getRoot();
                
                // 
                profile.properties.theme = theme;
                
                // 
                root.removeClass('menubar-dark menubar-moonify menubar-lightblue menubar-darkblue menubar-hc');
                
                // 
                if (theme === 'dark') {
                    root.addClass('menubar-dark');
                } else if (theme === 'high-contrast') {
                    root.addClass('menubar-hc');
                } else if (theme === 'moonify') {
                    root.addClass('menubar-moonify');
                } else if (theme === 'lightblue') {
                    root.addClass('menubar-lightblue');
                } else if (theme === 'darkblue') {
                    root.addClass('menubar-darkblue');
                } else {
                    // 
                    root.removeClass('menubar-dark menubar-moonify menubar-lightblue menubar-darkblue menubar-hc');
                }
                
                // 
                localStorage.setItem('menubar-theme', theme);
            });
        },
        
        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('menubar-theme') || 'light';
        },
        
        // 
        toggleTheme: function(nextTheme) {
            var currentTheme = this.getTheme();
            var themes = ['light', 'dark', 'moonify', 'lightblue', 'darkblue'];
            
            if (nextTheme && themes.indexOf(nextTheme) !== -1) {
                this.setTheme(nextTheme);
            } else {
                // 
                var currentIndex = themes.indexOf(currentTheme);
                var nextIndex = (currentIndex + 1) % themes.length;
                this.setTheme(themes[nextIndex]);
            }
        },
        
        // 
        adjustLayout: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    items = profile.getSubNode('ITEM', true),
                    captions = profile.getSubNode('CAPTION', true),
                    icons = profile.getSubNode('ICON', true),
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('menubar-mobile');
                    
                    // 
                    items.css({
                        'margin': '0 0.125em',
                        'padding': '0.3em 0.6em'
                    });
                    captions.css({
                        'font-size': '0.9em'
                    });
                } else {
                    root.removeClass('menubar-mobile');
                    
                    // 
                    items.css({
                        'margin': '',
                        'padding': ''
                    });
                    captions.css({
                        'font-size': ''
                    });
                }

                // 
                if (width < 480) {
                    root.addClass('menubar-tiny');
                    // 
                    icons.css('display', 'none');
                    captions.css({
                        'font-size': '0.8em'
                    });
                } else {
                    root.removeClass('menubar-tiny');
                    
                    // 
                    icons.css('display', '');
                    if (width >= 768) {
                        captions.css('font-size', '');
                    }
                }
            });
        },
        
        // 
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    border = profile.getSubNode('BORDER'),
                    items = profile.getSubNode('ITEM', true);

                // ARIA
                root.attr({
                    'role': 'application'
                });
                
                border.attr({
                    'role': 'menubar',
                    'aria-label': ''
                });
                
                // ARIA
                items.each(function(item) {
                    var itemNode = ood(item);
                    var itemId = itemNode.id();
                    if (itemId) {
                        var subId = itemId.split('_').pop();
                        var itemData = profile.getItemByDom(item);
                        
                        itemNode.attr({
                            'role': 'menuitem',
                            'aria-label': ': ' + (itemData ? itemData.caption : subId),
                            'tabindex': '0'
                        });
                        
                        // 
                        if (itemData && itemData.sub) {
                            itemNode.attr({
                                'aria-haspopup': 'true',
                                'aria-expanded': 'false'
                            });
                        }
                    }
                });

                // 
                // OODDOMAPI
            });
        },
        updateItem: function (subId, options) {
            var self = this,
                profile = self.get(0),
                items = profile.properties.items;
            //the root
            if (ood.arr.subIndexOf(items, "id", subId) != -1)
                arguments.callee.upper.call(self, subId, options);
            //try each sub popmenu
            else {
                var ok = 0;
                ood.each(profile.$allPops, function (o) {
                    o.updateItem(subId, options);
                    ok = 1;
                });
                if (!ok)
                    arguments.callee.upper.call(self, subId, options);
            }
            return self;
        },
        _pop: function (item, src) {
            var self = this,
                profile = self.get(0);
            //hide first, ignoreEffects false,true
            if (profile.$curPop) self.hide();

            if (!item.sub) return;

            if (profile.beforePopMenu && false == profile.boxing().beforePopMenu(profile, item, src)) {
                return;
            } else {
                ood.use(src).tagClass('-active');
                var menu,
                    id = item.id,
                    pro = profile.properties,
                    pid = pro.parentID || ood.ini.$rootContainer,
                    all = '$allPops';

                profile.$curPop = id;
                profile.$curElem = src;
                profile.$menuPop = id;

                profile[all] = profile[all] || {};
                if (!profile[all][id]) {
                    var callback = function (sub) {
                        var hash = {
                            position: 'absolute',
                            items: sub,
                            autoHide: !!pro.autoShowTime,
                            minWidth: '200px',  // 
                            padding: '0.5em 0', // 
                            itemSpacing: '0.5em' // 
                        };
                        if (pro.showEffects) hash.showEffects = pro.showEffects;
                        if (pro.hideEffects) hash.hideEffects = pro.hideEffects;
                        var menu = ood.create('PopMenu', hash);
                        // 
                        menu.getRoot().css({
                            'min-width': '200px',
                            'padding': '0.5em 0',
                            'border-radius': '6px',
                            'box-shadow': '0 4px 12px rgba(0,0,0,0.15)'
                        });
                        // 
                        menu.getSubNode('ITEM').css({
                            'padding': '0.5em 1em',
                            'margin': '0.25em 0',
                            'line-height': '1.5'
                        });
                        profile.getSubNode('POOL').append(menu);
                        menu.onHide(function (pro) {
                            self.hide(false);
                        }).onMenuSelected(function (pro, item, src) {
                            return profile.boxing().onMenuSelected(profile, pro, item, src);
                        }).onShowSubMenu(function (pro, item, src) {
                            return profile.boxing().onShowSubMenu(profile, pro, item, src);
                        });
                        menu.get(0).$hideMenuPool = profile.getSubNode('POOL');
                        menu.get(0)[all] = profile[all];
                        profile[all][id] = menu;
                    }

                    if (ood.isArr(item.sub) && item.sub.length)
                        callback(item.sub);
                    else if (profile.onGetPopMenu) {
                        var r = profile.boxing().onGetPopMenu(profile, item, callback);
                        if (ood.isArr(r) && r.length)
                            callback(item.sub = r);
                    }
                }
                // popmenu
                if (profile[all][id])
                    profile[all][id].pop(ood(src), 1, pid ? ood.get(profile, ["host", pid]) ? profile.host[pid].getContainer() : ood(pid) : null);

                return false;
            }
        },
        _afterInsertItems: function () {
            this.clearPopCache();
        },
        hide: function (ignoreEffects) {
            var profile = this.get(0), menu,
                id = profile.$curPop,
                node = profile.$curElem;

            if (menu = profile.$allPops[id]) {
                //To avoid trigger recursive call
                if (false !== arguments[0])
                    menu.hide(false, ignoreEffects);
                // collect
                profile.getSubNode('POOL').append(menu.reBoxing());
                ood([node]).tagClass('-active', false);
            }
            profile.$menuPop = profile.$curPop = profile.$curElem = null;
        },
        clearPopCache: function () {
            var profile = this.get(0);
            if (profile.renderId) {
                profile.getSubNode('POOL').empty();
                profile.$allPops = profile.$curPop = profile.$curElem = null;
            }
        }
    },
    Initialize: function () {


    },
    Static: {
        _nocap2tip: true,
        Templates: {
            tagName: 'div',
            className: '{_className};{_vAlign}',
            style: '{_style}',
            POOL: {
                tagName: 'div'
            },
            BORDER: {
                // className: 'ood-uibar ood-uiborder-outset ood-uiborder-radius',
                className: 'ood-uibar ood-uiborder-radius',
                tagName: 'div',
                style: 'border:{borderStyle};{_hAlign}',
                LIST: {
                    tagName: 'div',
                    HANDLER: {
                        className: 'oodfont',
                        $fonticon: 'ood-icon-placeholder',
                        style: '{handler}'
                    },
                    ITEMS: {
                        $order: 1,
                        text: "{items}"
                    }
                }
            },
            $submap: {
                items: {
                    ITEM: {
                        style: '{itemStyle}{_itemDisplay}{_itemColor}',
                        className: 'ood-uimenu',
                        ITEMI: {
                            ITEMC: {
                                ITEMA: {
                                    tabindex: '{_tabindex}',
                                    className: ' {typeCls} {disabled}',
                                    ICON: {
                                        $order: 1,
                                        className: 'oodcon {imageClass}  {picClass}',
                                        style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{imageDisplay}{iconStyle} {_iconColor}',
                                        text: '{iconFontCode}'
                                    },
                                    CAPTION: {
                                        $order: 2,
                                        text: '{caption}',
                                        style: '{captionDisplay}  {_fontColor}'
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        Appearances: {
            KEY: {
                position: 'absolute',
                left: 0,
                top: 0
            },
            POOL: {
                width: 0,
                height: 0,
                visibility: 'hidden',
                position: 'absolute',
                left: '-10000px',
                top: '-10000px'
            },

            BORDER: {
                left: 0,
                top: 0
            },
            HANDLER: {
                height: '100%',
                width: '0.5em',
                background: 'url(' + ood.ini.img_handler + ') repeat-y left top',
                cursor: 'move',
                'vertical-align': 'middle'
            },
            LIST: {
                padding: '.125em'
            },
            ITEMS: {
                'vertical-align': 'middle'
            },
            ITEM: {
                'white-space': 'nowrap',
                'vertical-align': 'top',
                overflow: 'hidden',
               // margin: '0 .25em .5em .25em',  /*  */
                //padding: '0.25em 0.5em',       /*  */
               // 'line-height': '1.5'           /*  */
            },
            'ITEM *': {
                cursor: 'pointer'
            },
            ITEMI: {
                'padding': '0 .5em',          /*  */
                'vertical-align': 'middle',   /*  */
                'line-height': '1.5'          /*  */
            },
            ITEMC: {
                'padding': '.5em 0',         /*  */
                'vertical-align': 'middle',  /*  */
                'min-height': '1.5em'        /*  */
            },
            ITEMA: {
                display: ood.$inlineBlock
            },
            CAPTION: {
                'vertical-align': 'middle',
                'font-size': '1em',
                'font-weight': '500',
                'transition': 'all 0.2s ease',
                'padding': '0 0.5em',        /*  */
                'line-height': '1.5',        /*  */
                'margin': '0.125em 0'        /*  */
            },

            ICON: {
                'transition': 'all 0.2s ease',
                'margin-right': '0.25em'
            },



            

            

            
            // 
            'menubar-mobile ITEM': {
                'margin': '0 0.125em',
                'padding': '0.3em 0.6em'
            },
            'menubar-mobile CAPTION': {
                'font-size': '0.9em'
            },
            
            // 
            'menubar-tiny ICON': {
                'display': 'none'
            },
            'menubar-tiny CAPTION': {
                'font-size': '0.8em'
            }
        },
        Behaviors: {
            ITEM: {
                onMouseover: function (profile, e, src) {
                    var p = profile.properties, ns = src;
                    if (p.disabled) return;
                    var item = profile.getItemByDom(src),
                        itemId = item.id;
                    if (item.disabled) return;
                    ood.use(ns).tagClass('-hover');
                    if (profile.$menuPop) {
                        if (profile.$menuPop != itemId) {
                            //show current popmenu
                            profile.boxing()._pop(item, ns);
                        }
                    } else {
                        if (p.autoShowTime) {
                            ood.resetRun(profile.$xid + ':autoShowTime', function () {
                                profile.boxing()._pop(item, ns);
                            }, p.autoShowTime);
                        }
                    }
                },
                onMouseout: function (profile, e, src) {
                    var p = profile.properties;
                    if (p.disabled) return;
                    var item = profile.getItemByDom(src);
                    if (item.disabled) return;
                    if (item.id != p.value) {
                        ood.use(src).tagClass('-hover', false);
                        ood.use(src).tagClass('-active', false);
                    }


                    if (p.autoShowTime) {
                        var pop = profile.$allPops;
                        if (pop = pop && pop[profile.$curPop]) {
                            var node = pop.get(0).getRoot(),
                                p1 = ood.Event.getPos(e),
                                size = node.cssSize(),
                                add = 3,
                                p2 = node.offset();

                            if (p1.left > p2.left && p1.top > p2.top - add && p1.left < p2.left + size.width && p1.top < p2.top + size.height) {
                            } else
                                pop.hide();
                        }
                        ood.resetRun(profile.$xid + ':autoShowTime', null);
                    }
                },
                onMousedown: function (profile, e, src) {
                    var p = profile.properties;
                    if (p.disabled) return;
                    var item = profile.getItemByDom(src),
                        itemId = item.id;
                    if (item.disabled) return;
                    ood.use(src).tagClass('-active');
                    p.value = item.id;

                    // if poped, stop to trigger document.body's onmousedown event
                    return profile.boxing()._pop(item, src);
                },
                onMouseup: function (profile, e, src) {
                    var item = profile.getItemByDom(src);
                    if (profile.$menuPop != item.id)
                        ood.use(src).tagClass('-active', false);
                },
                onKeydown: function (profile, e, src) {
                    var keys = ood.Event.getKey(e), key = keys.key, shift = keys.shiftKey,
                        cur = ood(src),
                        first = profile.getRoot().nextFocus(true, true, false),
                        last = profile.getRoot().nextFocus(false, true, false);

                    switch (ood.Event.getKey(e).key) {
                        case 'tab':
                            if (shift) {
                                if (cur.get(0) != first.get(0)) {
                                    first.focus(true);
                                    return false;
                                }
                            } else {
                                if (cur.get(0) != last.get(0)) {
                                    last.focus(true);
                                    return false;
                                }
                            }
                            break;
                        case 'left':
                        case 'up':
                            var next = cur.nextFocus(false, true, false);
                            if (cur.get(0) == first.get(0))
                                last.focus(true);
                            else
                                cur.nextFocus(false);
                            return false;
                            break;
                        case 'right':
                        case 'down':
                            var next = cur.nextFocus(true, false, false);
                            if (cur.get(0) == last.get(0))
                                first.focus(true);
                            else
                                cur.nextFocus();
                            return false;
                            break;
                        case 'enter':
                            cur.onMousedown();
                            break;
                    }
                },
                onClick: function (profile, e, src) {
                    var item = profile.getItemByDom(src), p = profile.properties;
                    ood.use(src).tagClass('-active');
                    var ns = profile.boxing();
                    ood.each(ns.getItems(), function (o) {
                        if (o.id != item.id) {
                            ns.getSubNodeByItemId('ITEM', o.id).tagClass('-hover', false);
                            ns.getSubNodeByItemId('ITEM', o.id).tagClass('-active', false);
                        }
                    });
                    p.value = item.id;
                    if (profile.$menuPop != item.id)
                        if (profile.onMenuBtnClick)
                            profile.boxing().onMenuBtnClick(profile, item, src);
                }
            }
        },
        DataModel: {
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark', 'moonify', 'lightblue', 'darkblue'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },
            
            listKey: null,
            dragSortable: null,
            autoTips: false,
            expression: {
                ini: '',
                action: function () {
                }
            },
            autoFontColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoIconColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            iconColors: null,
            itemColors: null,
            fontColors: null,
            value: {
                ini: '',
                action: function () {
                }
            },
            // 
            height: {
                $spaceunit: 1,
                ini: 'auto',
                action: function(value) {
                    this.getSubNode('BORDER').css('height', value);
                    this.getSubNode('LIST').css('height', value);
                }
            },

            width: {
                $spaceunit: 1,
                ini: 'auto'
            },
            border: {
                ini: 'outset',
                listbox: ['none', 'flat', 'inset', 'outset', 'groove', 'ridge'],
                action: function (v) {
                    var ns = this,
                        p = ns.properties;
                    ns.box._borderType(ns, v, p.sideBarStatus, p.sideBarType.split('-'), true);
                }
            },

            parentID: '',

            hAlign: {
                ini: 'left',
                listbox: ['left', 'center', 'right'],
                action: function (v) {
                    this.getSubNode('BORDER').css('textAlign', v);
                }
            },
            vAlign: {
                ini: 'middle',
                listbox: ['top', 'middle', 'bottom'],
                action: function (v) {
                    this.getSubNode('POOL').css('vertical-align:', v);
                }
            },

            $hborder: 1,
            $vborder: 1,
            left: 0,
            top: 0,
            autoShowTime: 200,
            handler: {
                ini: true,
                action: function (v) {
                    this.getSubNode('HANDLER').css('display', v ? '' : 'none');
                }
            },
            position: 'absolute',
            dock: {
                ini: 'top',
                listbox: ['top', 'bottom', 'left', 'right']
            }
            //  items  Instance  iniProp 
        },
        LayoutTrigger: function () {
            var v = this.properties, nd = this.getSubNode("BORDER");
            v.$hborder = v.$vborder = nd._borderW('left');
            
            // 
            var boxing = this.boxing();
            
            // 
            if (v.theme) {
                boxing.setTheme(v.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('menubar-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // 
            if (v.responsive !== false) {
                boxing.adjustLayout();
                // 
                // OOD
            }
            
            // 
            boxing.enhanceAccessibility();
        },
        EventHandlers: {
            onGetPopMenu: function (profile, item, callback) {
            },
            onMenuBtnClick: function (profile, item, src) {
            },
            beforePopMenu: function (profile, item, src) {
            },
            onShowSubMenu: function (profile, popProfile, item, src) {
            },
            onMenuSelected: function (profile, popProfile, item, src) {
            }
        },
        RenderTrigger: function () {
            if (this.properties.disabled) this.boxing().setDisabled(true, true);
        },
        _prepareData: function (profile) {
            var none = 'display:none;';
            var data = arguments.callee.upper.call(this, profile);
            var p = profile.properties, ns = this;
            data._hAlign = p.hAlign != 'left' ? ('text-align:' + p.hAlign + ';') : '';
            data._vAlign = p.vAlign != 'center' ? ('vertical-align:' + p.vAlign + ';') : '';
            data.handler = data.handler ? '' : none;

            ood.arr.each(data.items, function (item) {
                var index = item.index;
                if (!index) {
                    index = ood.arr.indexOf(data.items, item);
                }
                profile.boxing()._autoColor(item,index, p);
            })

            data._itemDisplay = data.hidden ? none : '';
            return data;
        }


    }
});ood.Class("ood.UI.ToolBar", ["ood.UI", "ood.absList"], {
    Instance: {
        //  iniProp 
        iniProp: {
            items: [
                {
                    "id": "common",
                    "sub": [
                        {
                            "id": "new",
                            "caption": "$RAD.widgets.esd.buttonnew",
                            "imageClass": "ri-calendar-event-line"
                        },
                        {
                            "id": "delete",
                            "caption": "$RAD.widgets.esd.buttondelete",
                            "imageClass": "ri-close-line"
                        },
                        {
                            "id": "reload",
                            "caption": "$RAD.widgets.esd.buttonreload",
                            "imageClass": "ri-refresh-line"
                        }]
                }
            ],
            theme: 'light',
            responsive: true,
            handler: true,
            hAlign: 'left',
            dock: 'top',
            autoIconColor: true,
            autoItemColor: false,
            autoFontColor: false
        },

        // Modern feature: Set theme

        setTheme: function (theme) {
            return this.each(function (profile) {
                var root = profile.getRoot();

                // Save theme to properties
                profile.properties.theme = theme;

                // Remove all theme classes first
                root.removeClass('toolbar-dark toolbar-hc');

                // Apply theme class
                if (theme === 'dark') {
                    root.addClass('toolbar-dark');
                } else if (theme === 'high-contrast') {
                    root.addClass('toolbar-hc');
                }

                // Save theme setting
                localStorage.setItem('toolbar-theme', theme);
            });
        },

        // Get current theme
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('toolbar-theme') || 'light';
        },

        // Toggle between all three themes
        toggleTheme: function () {
            var current = this.getTheme();
            var next = current === 'light' ? 'dark' :
                current === 'dark' ? 'high-contrast' : 'light';
            this.setTheme(next);
        },

        // Get current theme
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('toolbar-theme') || 'light';
        },

        // Modern initialization trigger
        ToolBarTrigger: function () {
            var profile = this.get(0);
            var prop = profile.properties
            // Initialize theme
            if (prop.theme) {
                this.setTheme(prop.theme);
            } else {
                // Restore theme from local storage
                var savedTheme = localStorage.getItem('toolbar-theme');
                if (savedTheme) {
                    this.setTheme(savedTheme);
                }
            }

            // Initialize responsive design
            if (prop.responsive !== false) {
                this.adjustLayout();
                // Note: Window resize listeners need to be handled at application level
                // OOD framework has its own event handling mechanism
            }

            // Initialize accessibility
            this.enhanceAccessibility();
        },

        // Toggle dark mode
        toggleDarkMode: function () {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
        },

        // Responsive layout adjustment
        adjustLayout: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    prop = profile.properties;

                // 
                // CSS
                if (width < 768) {
                    root.addClass('toolbar-mobile');
                } else {
                    root.removeClass('toolbar-mobile');
                }

                // 
                if (width < 480) {
                    root.addClass('toolbar-tiny');
                } else {
                    root.removeClass('toolbar-tiny');
                }
            });
        },

        // 
        enhanceAccessibility: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    items = profile.getSubNode('ITEMS'),
                    buttons = profile.getSubNode('BTN', true),
                    groups = profile.getSubNode('GROUP', true);

                // ARIA
                root.attr({
                    'role': 'application',
                    'aria-label': ''
                });

                items.attr({
                    'role': 'toolbar',
                    'aria-label': ood.getRes('UI.toolbar.label') || '',
                    'aria-orientation': 'horizontal'
                });

                // ARIA
                buttons.each(function (button) {
                    var buttonNode = ood(button);
                    var buttonId = buttonNode.id();
                    if (buttonId) {
                        var subId = buttonId.split('_').pop();
                        var itemData = profile.getItemByDom(button);
                        var label = (itemData ? itemData.caption || itemData.label : subId) || '';

                        buttonNode.attr({
                            'role': 'button',
                            'aria-label': label,
                            'tabindex': '0',
                            'aria-disabled': buttonNode.hasClass('ood-ui-itemdisabled') ? 'true' : 'false'
                        });

                        // 
                        if (itemData && (itemData.type === 'toggle' || itemData.value)) {
                            var isPressed = buttonNode.hasClass('ood-ui-item-checked');
                            buttonNode.attr({
                                'aria-pressed': isPressed ? 'true' : 'false'
                            });
                        }

                        // 
                        if (itemData && itemData.sub) {
                            buttonNode.attr({
                                'aria-haspopup': 'menu',
                                'aria-expanded': 'false',
                                'aria-controls': buttonId + '_menu'
                            });
                        }
                    }
                });

                // ARIA
                groups.each(function (group) {
                    var groupNode = ood(group);
                    var groupId = groupNode.id();
                    if (groupId) {
                        var subId = groupId.split('_').pop();
                        var groupData = profile.getItemByItemId(subId);

                        groupNode.attr({
                            'role': 'group',
                            'aria-label': groupData ? groupData.caption : '',
                            'aria-orientation': 'horizontal'
                        });
                    }
                });

                // 
                // OODDOMAPI
            });
        },
        updateItem: function (subId, options) {
            if (options.type) {
                return arguments.callee.upper.call(this, subId, options);
            } else {
                var self = this,
                    profile = self.get(0),
                    box = profile.box,
                    items = profile.properties.items,
                    rst = profile.queryItems(items, function (o) {
                        return typeof o == 'object' ? o.id === subId : o == subId
                    }, true, true, true),
                    nid, item, n1, n2, n3, n4, n5, t;
                if (ood.isStr(options)) options = {caption: options};

                if (rst.length) {
                    rst = rst[0];
                    if (item = rst[0]) {

                        // [[modify id
                        if (ood.isSet(options.id)) options.id += "";
                        if (options.id && subId !== options.id) {
                            nid = options.id;
                            var m2 = profile.ItemIdMapSubSerialId, v;
                            if (!m2[nid]) {
                                if (v = m2[subId]) {
                                    m2[nid] = v;
                                    delete m2[subId];
                                    profile.SubSerialIdMapItem[v].id = nid;
                                } else {
                                    item.id = nid;
                                }
                            }
                        }
                        delete options.id;
                        // modify id only
                        if (ood.isEmpty(options))
                            return self;
                        //]]

                        //in dom already?
                        n1 = profile.getSubNodeByItemId('ICON', nid || subId);
                        n2 = profile.getSubNodeByItemId('CAPTION', nid || subId);
                        n3 = profile.getSubNodeByItemId('ITEM', nid || subId);
                        n4 = profile.getSubNodeByItemId('LABEL', nid || subId);
                        n5 = profile.getSubNodeByItemId('BTN', nid || subId);

                        if ('value' in options && options.value !== item.value)
                            profile.getSubNodeByItemId('BTN', nid || subId).tagClass('-checked', !!options.value);

                        if ('caption' in options && options.caption !== item.caption) {
                            n2.html(options.caption);
                            if (options.caption && !item.caption)
                                n2.css('display', '');
                            if (!options.caption && item.caption)
                                n2.css('display', 'none');
                        }
                        if ('label' in options && options.label !== item.label) {
                            n4.html(options.label);
                            if (options.label && !item.label)
                                n4.css('display', '');
                            if (!options.label && item.label)
                                n4.css('display', 'none');
                        }
                        if ('disabled' in options && options.disabled !== item.disabled) {
                            if (options.disabled)
                                n3.addClass('ood-ui-itemdisabled');
                            else
                                n3.removeClass('ood-ui-itemdisabled');

                            n5.onMouseout(true, {$force: true})
                        }
                        if ('image' in options && options.image !== item.image)
                            n1.css('background-image', options.image);
                        if ('imagePos' in options && options.imagePos !== item.imagePos)
                            n1.css('background-position', options.imagePos);
                        if ('imageClass' in options && options.imageClass !== item.imageClass) {
                            if (item.imageClass)
                                n1.removeClass(item.imageClass);
                            if (options.imageClass)
                                n1.addClass(options.imageClass);
                        }
                        if ('hidden' in options) {
                            var b = !!options.hidden;
                            if (b) {
                                if (item.hidden !== true) {
                                    n3.css('display', 'none');
                                }
                            } else {
                                if (item.hidden === true) {
                                    n3.css('display', '');
                                }
                            }
                        }

                        //merge options
                        ood.merge(item, options, 'all');
                    }
                }
                return self;
            }
        },
        showItem: function (itemId, value) {
            return this.each(function (profile) {
                var item = profile.getItemByItemId(itemId);
                if (item) {
                    item.hidden = value === false;
                    profile.getSubNodeByItemId('ITEM', itemId).css('display', value === false ? 'none' : '');
                }
            });
        },
        showGroup: function (grpId, value) {
            return this.each(function (profile) {
                ood.arr.each(profile.properties.items, function (o) {
                    if (o.id == grpId) {
                        o.hidden = value === false;
                        return false;
                    }
                });
                var n = profile.getSubNodeByItemId('GROUP', grpId);
                n.css('display', value === false ? 'none' : '');

                ood.resetRun(profile.$xid + ':showgrp', function () {
                    if (profile.renderId && profile.getRootNode().offsetWidth) {
                        ood.UI.$dock(profile, true, true);
                    }
                });
            });
        }
    },
    Static: {
        _focusNodeKey: 'BTN',
        _ITEMKEY: 'GROUP',
        Templates: {
            tagName: 'div',
            className: '{_className}',
            style: '{_style}',
            ITEMS: {
                className: 'ood-uibar ood-uiborder-outset ood-uiborder-radius',
                tagName: 'div',
                style: '{mode}',
                text: '{items}'
            },
            $submap: {
                items: {
                    GROUP: {
                        className: '{groupClass}',
                        style: '{grpDisplay} {_groupStyle}',
                        HANDLER: {
                            className: 'oodfont',
                            $fonticon: 'ood-icon-placeholder',
                            style: '{mode2}'
                        },
                        LIST: {
                            $order: 1,
                            tagName: 'text',
                            text: '{sub}'
                        }
                    }
                },
                'items.sub': {
                    ITEM: {
                        style: '{_itemDisplay}',
                        className: " {disabled}",
                        //for firefox2 image in -moz-inline-box cant change height bug
                        IBWRAP: {
                            tagName: 'div',
                            SPLIT: {
                                style: '{splitDisplay}',
                                className: "ood-uiborder-l ood-uiborder-r",
                                // for auto height
                                text: '&nbsp;'
                            },
                            LABEL: {
                                style: '{labelDisplay}',
                                text: '{label}'
                            },

                            BTN: {
                                tagName: 'button',
                                className: 'ood-uiborder-hidden ood-uiborder-radius ood-showfocus {itemClass}{itemcls}',
                                style: '{itemStyle} {_boxDisplay}{_itemColor}',
                                tabindex: '{_tabindex}',
                                BOXWRAP: {
                                    tagName: 'div',
                                    RULER: {},
                                    ICON: {
                                        $order: 1,
                                        className: 'oodcon {imageClass} {picClass}',
                                        style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{_iconFontSize}{imageDisplay}{iconStyle}{_iconColor}',
                                        text: '{iconFontCode}'
                                    },
                                    CAPTION: {
                                        $order: 1,
                                        text: '{caption}',
                                        style: '{_fontSize}{captionDisplay}{_fontColor}'
                                    },
                                    DROP: {
                                        $order: 3,
                                        className: 'oodfont',
                                        $fonticon: 'ood-uicmd-arrowdrop',
                                        style: '{_dropDisplay}'
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        Appearances: {
            KEY: {
                position: 'absolute',
                overflow: 'hidden',
                left: 0,
                top: 0
            },
            RULER: {
                padding: '0',
                margin: '0',
                width: '0'
            },
            ICON: {
                margin: 0,
                'font-size': '1.25em',
                'color': 'var(--icon-color)',
                'transition': 'all 0.2s ease',
                'vertical-align': 'middle'
            },
            'BTN:hover ICON': {
                'color': 'var(--icon-hover)'
            },

            ITEMS: {
                display: 'flex',
                'flex-wrap': 'wrap',
                // 'padding': '0.5em',
                'background-color': 'var(--ood-toolbar-bg)',
                'border': 'var(--ood-toolbar-border)',
                'border-radius': '0.25rem',
                'gap': '0.25em',
                'box-shadow': '0 1px 3px rgba(0,0,0,0.1)'
            },
            HANDLER: {
                height: '100%',
                width: '.75em',
                background: 'url(' + ood.ini.img_handler + ') repeat-y left top',
                cursor: 'move',
                'vertical-align': 'middle'
            },
            GROUP: {
                // crack for: The IE 'non-disappearing content' bug
                position: 'static',
                padding: '.125em .25em 0 .125em',
                'vertical-align': 'middle'
            },
            ITEM: {
                'vertical-align': 'middle',
                padding: '0 .125em',
                margin: '0'
            },
            'SPLIT': {
                $order: 1,
                width: '0',
                'vertical-align': 'middle',
                margin: '0 .25em'
            },
            BTN: {
                'cursor': 'pointer',
                'border-radius': '0.25rem',
                'background-color': 'var(--ood-toolbar-bg)',
                'color': 'var(--ood-toolbar-text)',
                'border': '1px solid transparent',
                'transition': 'all 0.2s ease',
                'display': 'inline-flex',
                'align-items': 'center',
                'justify-content': 'center',
                'gap': '0.5em',
                'padding': '0.5em 0.25em',
                //'min-width': '3em',
                'font-weight': 'normal'
            },
            'BTN:hover': {
                'background-color': 'var(--ood-toolbar-item-hover)',
                'box-shadow': '0 2px 5px rgba(0,0,0,0.1)'
            },
            'BTN:active': {
                'background-color': 'var(--ood-toolbar-item-active)'
            },
            'BTN-disabled': {
                'opacity': '0.6',
                'cursor': 'not-allowed'
            },
            BOX: {
                height: 'auto'
            },
            'LABEL, CAPTION': {
                'vertical-align': 'middle',
                'margin-left': '.25em',
                'margin-right': '.25em',
                'font-size': '1em'
            },
            LABEL: {
                cursor: 'default',
                'padding': '.25em'
            },
            DROP: {
                'vertical-align': 'middle'
            },


            // 
            'toolbar-mobile BTN': {
                'min-width': '2em',
                'padding': '0.2em 0.4em'
            },
            'toolbar-mobile CAPTION': {
                'font-size': '0.9em'
            },
            'toolbar-mobile GROUP': {
                'margin': '0 0.2em'
            },

            // 
            'toolbar-tiny CAPTION': {
                'display': 'none'
            },
            'toolbar-tiny BTN': {
                'min-width': '1.8em',
                'padding': '0.2em'
            }
        },
        Behaviors: {
            NoTips: ["GROUP", "HANDLER"],
            HoverEffected: {BTN: ['BTN']},
            ClickEffected: {BTN: ['BTN']},
            DraggableKeys: ["HANDLER"],
            DroppableKeys: ["GROUP", "ITEMS"],
            BTN: {
                onClick: function (profile, e, src) {
                    if (profile.properties.disabled) return false;
                    var id2 = ood.use(src).parent(3).id(),
                        item2 = profile.getItemByDom(id2);
                    if (item2.disabled) return false;

                    var item = profile.getItemByDom(src);
                    if (item.disabled) return false;

                    ood.use(src).focus(true);
                    if (item.type == "statusButton")
                        ood.use(src).tagClass('-checked', item.value = !item.value);

                    profile.boxing().onClick(profile, item, item2, e, src, item.id);
                    return false;
                }
            }
        },
        DataModel: {
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark'],
                action: function (value) {
                    this.boxing().setTheme(value);
                }
            },
            responsive: {
                ini: true,
                action: function (value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            },

            expression: {
                ini: '',
                action: function () {
                }
            },
            listKey: null,
            iconColors: null,
            itemColors: null,
            fontColors: null,
            autoFontColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoIconColor: {
                ini: true,
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },

            height: {
                ini: 'auto',
                readonly: true
            },
            iconFontSize: {
                ini: '',
                action: function (v) {
                    this.getSubNode('ICON', true).css('font-size', v);
                }
            },
            width: {
                $spaceunit: 1,
                ini: 'auto'
            },

            left: {
                $spaceunit: 1,
                ini: 0
            },
            top: {
                $spaceunit: 1,
                ini: 0
            },

            handler: {
                ini: true,
                action: function (v) {
                    this.getSubNode('HANDLER', true).css('display', v ? '' : 'none');
                }
            },
            position: 'absolute',
            hAlign: {
                ini: 'left',
                listbox: ['left', 'center', 'right'],
                action: function (v) {
                    this.getSubNode('ITEMS', true).css('textAlign', v);
                }
            },
            dock: {
                ini: 'top',
                listbox: ['top', 'bottom', 'left', 'right']
            }
            //  items  Instance  iniProp 
        },
        EventHandlers: {
            onClick: function (profile, item, group, e, src, itemid) {
            }
        },
        _adjustItems: function (arr) {
            if (!arr) arr = [ood.stamp() + ''];
            if (ood.isStr(arr)) arr = [arr];

            var a = ood.copy(arr), m;
            ood.arr.each(a, function (o, i) {
                if (ood.isArr(o)) {
                    o = {
                        id: ood.id(),
                        sub: o
                    };
                }
                if (ood.isHash(o)) {
                    //copy group
                    a[i] = ood.copy(o);
                    a[i].sub = [];
                    //copy sub(tool item)
                    if (o.sub)
                        ood.arr.each(o.sub, function (v) {
                            a[i].sub.push(ood.isHash(v) ? ood.copy(v) : {id: v + ""});
                        });
                }
            });
            return a;
        },


        _onDrop: function (profile, e, src, key, data, item) {
            var k = profile.getKey(ood.use(src).id()),
                po = data.profile,
                ps = data.domId,
                oitem,
                t = ood.absObj.$specialChars;

            //remove
            oitem = ood.clone(po.getItemByDom(ps), function (o, i) {
                return !t[(i + '').charAt(0)]
            });
            po.boxing().removeItems([oitem.id], 'GROUP', true);

            if (k == profile.keys.GROUP)
                profile.boxing().insertItems([oitem], item.id, true);
            else
                profile.boxing().insertItems([oitem]);

            data._new = oitem;
            return false;
        },
        _prepareData: function (profile) {
            var d = arguments.callee.upper.call(this, profile);
            var p = profile.properties, ns = this;
            d.mode = p.hAlign != 'left' ? ('text-align:' + p.hAlign + ';') : '';
            ood.arr.each(d.items, function (item) {
                if (item.sub) {
                    ood.arr.each(item.sub, function (subitem) {
                        var index = subitem.index;
                        if (!index) {
                            index = ood.arr.indexOf(item.sub, subitem);
                        }
                        profile.boxing()._autoColor(subitem, index, p);
                    })
                }

            })
            return d;
        },

        _prepareItem: function (profile, oitem, sitem, pid, index, len, mapCache, serialId) {
            var ns = this, p = profile.properties,
                dn = 'display:none',

                tabindex = profile.properties.tabindex,
                fun = function (profile, dataItem, item, pid, index, len, mapCache, serialId) {
                    var id = dataItem[ood.UI.$tag_subId] = typeof serialId == 'string' ? serialId : ('a_' + profile.pickSubId('aitem')),
                        t;
                    if (typeof item == 'string')
                        item = {caption: item};

                    if (false !== mapCache) {
                        profile.ItemIdMapSubSerialId[item.id] = id;
                        profile.SubSerialIdMapItem[id] = item;
                    }

                    if (item['object']) {
                        dataItem['object'] = ns._prepareInlineObj(profile, item, tabindex);
                    } else {

                        ood.arr.each(ood.toArr('itemWidth,bgimg,position,itemHeight,imgWidth,imgHeight,itemPadding,itemMargin,iconFontSize,fontSize,autoItemSize,autoImgSize'), function (i) {
                            item[i] = ood.isSet(item[i]) ? item[i] : p[i];
                        });


                        // for compitable with older versions
                        if (item.statusButton) {
                            item.type = "statusButton";
                            delete item.statusButton;
                        }
                        else if (item.dropButton) {
                            item.type = "dropButton";
                            delete item.dropButton;
                        }
                        else if (item.split) {
                            item.type = "split";
                            delete item.split;
                        }

                        if (item.type !== "split" && !item.caption) {
                            item.caption = "";
                        }

                        ood.UI.adjustData(profile, item, dataItem);

                        if (item.type == "statusButton" && !!item.value)
                            dataItem.itemcls = " ood-uiborder-hidden-checked " + profile.getClass('BTN', '-checked', !!item.value);


                        dataItem._tabindex = tabindex;
                        dataItem.splitDisplay = dataItem.type == "split" ? '' : dn;
                        dataItem.labelDisplay = dataItem.label ? '' : dn;
                        dataItem._iconFontSize = dataItem.iconFontSize;
                        dataItem._fontSize = dataItem.fontSize;
                        dataItem._boxStyle = dataItem.boxStyle;
                        dataItem.captionDisplay = dataItem.caption ? '' : dn;
                        dataItem._dropDisplay = item.type == "dropButton" ? '' : dn;
                        dataItem._boxDisplay = (dataItem.type !== "split" && (dataItem.caption || dataItem.image || dataItem.imageClass)) ? '' : dn;
                    }
                    dataItem._itemDisplay = item.hidden ? dn : '';
                    item._pid = pid;
                };

            if (oitem.sub) {
                ood.arr.each(oitem.sub, function (subitem) {
                    var subindex = subitem.index;
                    if (!subindex) {
                        subindex = ood.arr.indexOf(oitem.sub, subitem);
                    }
                    profile.boxing()._autoColor(subitem, subindex, p);
                })
            }

            if (pid) {
                fun(profile, oitem, sitem, pid, index, len, mapCache, serialId);
            } else {
                var arr = [],
                    dataItem,
                    a = sitem.sub || [];

                pid = sitem.id;
                oitem.mode2 = ('handler' in sitem) ? (sitem.handler ? '' : dn) : (profile.properties.handler ? '' : dn);
                oitem.grpDisplay = sitem.hidden ? dn : '';
                oitem._groupStyle = sitem.groupStyle ? sitem.groupStyle : "";
                oitem.sub = arr;

                ood.arr.each(a, function (item) {
                    dataItem = {id: item.id, groupStyle: oitem.groupStyle};
                    fun(profile, dataItem, item, pid, index, len, mapCache, serialId);
                    arr.push(dataItem);
                });
            }
        },

        RenderTrigger: function () {
            var self = this, p = self.properties;
            if (p.value)
                self.boxing().setValue(p.value, null, null, 'render');

            // 
            ood.asyRun(function () {
                if (self.boxing() && self.boxing().ToolBarTrigger) {
                    self.boxing().ToolBarTrigger();
                }
            })
        }


    }
});ood.Class("ood.UI.Layout", ["ood.UI", "ood.absList"], {
    Instance: {

        iniProp: {
            caption: ood.getRes('RAD.widgets.menuNav') || '',
            items: [{
                id: 'main',
                "overflow": "auto",
                "transparent": true,
                pos: 'main'
            }, {
                id: 'before',
                "size": 220,
                "cmd": true,
                "locked": false,
                "transparent": true,
                pos: 'before',
                lock: true,
                cmd: false
            }]
        },

        setChildren: function (childrens, prf) {
            var host = this;
            this.removeChildren(true, true, true);
            ood.addChild({children: childrens}, host, host.getModule(), host.getModule());
        },

        getAllFormValues: function (isAll) {
            var a = this.getChildren(),
                elems = ood.absValue.pack(a),
                formValue = {},
                profile = this.get(0);
            ood.arr.each(profile.children, function (o) {
                var oo = o[0].boxing(), name = oo.getProperties().name || o[0].alias;
                if (oo.Class['ood.UI.Tabs']) {
                    formValue[name] = oo.getAllFormValues(isAll);
                } else if (oo.Class['ood.UI.Block'] || oo.Class["ood.UI.Panel"] || oo.Class["ood.UI.Layout"]) {
                    ood.merge(formValue, oo.getAllFormValues(isAll), 'all')
                } else if (oo.getFormValues) {
                    ood.merge(formValue, oo.getFormValues(), 'all')
                } else if (oo.getUIValue) {
                    formValue[name] = oo.getUIValue();
                } else if (oo.getValue) {
                    formValue[name] = oo.getValue();
                }
            });
            return formValue;
        },
        getPanel: function (subId) {
            return this.get(0).getSubNodeByItemId('PANEL', subId);
        },
        append: function (target, subId, pre, base) {
            var pro = this.get(0);
            return arguments.callee.upper.call(this, target, subId || 'main', pre, base);
        },
        insertItems: function (arr, base, before, all) {
            return this._insertItems(arr, base, before, all);
        },
        _insertItems: function (arr, base, before, all) {
            var node, arr2,
                items, index, r,
                data, box,
                pos = "before",
                b = this._afterInsertItems;
            return this.each(function (profile) {
                box = profile.box;
                items = profile.properties.items;
                if (!all) {
                    index = ood.arr.subIndexOf(items, 'id', base);
                    if (index == -1) {
                        pos = before ? 'before' : 'after';
                    } else {
                        if (items[index].id == 'main')
                            pos = before ? 'before' : 'after';
                        else
                            pos = items[index].pos || 'after';
                    }
                    arr2 = box._adjustItems2(arr, pos);
                } else {
                    arr2 = box._adjustItems(arr);
                }

                //must be here
                if (index == -1)
                    ood.arr.insertAny(items, arr2, before ? 0 : -1);
                else
                    ood.arr.insertAny(items, arr2, before ? index : index + 1);

                //if in dom, create it now
                if (profile.renderId) {
                    data = box._prepareItems(profile, arr2, base);
                    r = profile._buildItems('items', data);
                    // try to render inner ood.UI
                    if (profile.$attached) {
                        for (var i = 0, v; v = profile.$attached[i++];) {
                            if (v._render) v._render(true);
                        }
                        delete profile.$attached;
                    }
                    profile.getRoot().prepend(r);
                    profile.adjustSize();
                    t = null;
                }

                if (b)
                    profile.boxing()._afterInsertItems(profile, data, base, before);
            });
        },
        _afterRemoveItems: function (profile) {
            if (profile.renderId)
                profile.adjustSize();
        },
        updateItem: function (subId, options) {
            var self = this,
                profile = self.get(0),
                vertical = profile.properties.type == 'vertical',
                getN = function (key, subId) {
                    return profile.getSubNodeByItemId(key, subId)
                },
                box = profile.box,
                items = profile.properties.items,
                rst = profile.queryItems(items, function (o) {
                    return typeof o == 'object' ? o.id === subId : o == subId
                }, true, true, true),
                nid, item, serialId, node, sub, t;
            if (typeof options != 'object') return;

            if (rst.length) {
                rst = rst[0];
                if (typeof rst[0] != 'object')
                    item = rst[2][rst[1]] = {id: rst[0]};
                else
                    item = rst[0];

                // [[modify id
                if (ood.isSet(options.id)) options.id += "";
                if (options.id && subId !== options.id) {
                    nid = options.id;
                    var m2 = profile.ItemIdMapSubSerialId, v;
                    if (!m2[nid]) {
                        if (v = m2[subId]) {
                            m2[nid] = v;
                            delete m2[subId];
                            profile.SubSerialIdMapItem[v].id = nid;
                        } else {
                            item.id = nid;
                        }
                    }
                }
                delete options.id;
                // modify id only
                if (ood.isEmpty(options))
                    return self;
                //]]

                var bResize = false;
                //in dom already?
                node = getN('ITEM', subId);
                if (!node.isEmpty()) {
                    if (options.hasOwnProperty('size')) {
                        options.size = Math.round(parseFloat('' + options.size));
                        if (options.size != item._size) {
                            item._size = options.size;
                            if (vertical)
                                node.height(options.size);
                            else
                                node.width(options.size);
                            bResize = true;
                        }
                    }
                    if (options.hasOwnProperty('hidden')) {
                        options.hidden = !!options.hidden;
                        if (options.hidden !== item.hidden) {
                            getN('ITEM', subId).css('display', options.hidden ? 'none' : '');
                            bResize = true;
                        }
                    }
                    if (options.hasOwnProperty('locked')) {
                        options.locked = !!options.locked;
                        if (options.locked !== item.locked) {
                            getN('MOVE', subId).css({
                                display: options.locked ? 'none' : '',
                                cursor: options.locked ? 'default' : vertical ? 'n-resize' : 'w-resize'
                            });
                            getN('CMD', subId).css('display', (('cmd' in options) ? options.cmd : item.cmd) && !options.locked ? '' : 'none');
                            bResize = true;
                        }
                    }
                    if (options.hasOwnProperty('folded')) {
                        options.folded = !!options.folded;
                        if (options.folded !== item.folded)
                            profile.boxing().fireCmdClickEvent(subId);
                    }
                    if (options.hasOwnProperty('cmd')) {
                        options.cmd = !!options.cmd;
                        if (options.cmd !== item.cmd)
                            getN('CMD', subId).css('display', options.cmd && !(('locked' in options) ? options.locked : item.locked) ? '' : 'none');
                    }

                    var hash = {};
                    if (options.hasOwnProperty('panelBgClr')) hash["background-color"] = options.panelBgClr;
                    if (options.hasOwnProperty('panelBgImg')) {
                        hash["background-image"] = options.panelBgImg ? ("url(" + ood.adjustRes(options.panelBgImg) + ")") : "";
                    }
                    if (options.hasOwnProperty('panelBgImgPos')) hash["position-color"] = options.panelBgImgPos;
                    if (options.hasOwnProperty('panelBgImgRepeat')) hash["background-repeat"] = options.panelBgImgRepeat;
                    if (options.hasOwnProperty('panelBgImgAttachment')) hash["background-attachment"] = options.panelBgImgAttachment;
                    if (options.hasOwnProperty('overflow')) {
                        var v = options.overflow;
                        if (v) {
                            if (v.indexOf(':') != -1) {
                                ood.arr.each(v.split(/\s*;\s*/g), function (s) {
                                    var a = s.split(/\s*:\s*/g);
                                    if (a.length > 1) {
                                        hash[ood.str.trim(a[0])] = ood.str.trim(a[1] || '');
                                    }
                                });
                            }
                        }
                        hash.overflow = v || "";
                    }
                    if (!ood.isEmpty(hash)) {
                        getN('PANEL', subId).css(hash);
                    }
                }

                //merge options
                ood.merge(item, options, 'all');

                if (bResize)
                    profile.adjustSize();
            }
            return self;
        },
        fireCmdClickEvent: function (subId) {
            this.getSubNodeByItemId('CMD', subId).onMousedown();
            return this;
        },

        // 
        setTheme: function (theme) {
            return this.each(function (profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();

                // 
                root.removeClass('layout-dark');

                // 
                if (theme === 'dark') {
                    root.addClass('layout-dark');
                }

                // 
                localStorage.setItem('layout-theme', theme);
            });
        },

        // 
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('layout-theme') || 'light';
        },

        // 
        toggleDarkMode: function () {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
        },

        // 
        adjustLayout: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    items = profile.getSubNode('ITEM', true),
                    moves = profile.getSubNode('MOVE', true),
                    cmds = profile.getSubNode('CMD', true),
                    prop = profile.properties;

                // 
                if (width < 768) {
                    root.addClass('layout-mobile');

                    // 
                    if (prop.type === 'horizontal') {
                        // moves.css({
                        //     'height': '8px'
                        // });
                        cmds.css({
                            'font-size': '0.9em'
                        });
                    } else {
                        // moves.css({
                        //     'width': '8px'
                        // });
                        cmds.css({
                            'font-size': '0.9em'
                        });
                    }
                } else {
                    root.removeClass('layout-mobile');

                    // 
                    moves.css({
                        'height': '',
                        'width': ''
                    });
                    cmds.css('font-size', '');
                }

                // 
                if (width < 480) {
                    root.addClass('layout-tiny');

                    // 
                    cmds.css('display', 'none');
                } else {
                    root.removeClass('layout-tiny');

                    // 
                    var currentItems = profile.properties.items;
                    ood.arr.each(currentItems, function (item) {
                        if (item.cmd !== false && !item.locked) {
                            profile.getSubNodeByItemId('CMD', item.id).css('display', '');
                        }
                    });
                }

                // 
                if (profile.renderId) {
                    profile.adjustSize();
                }
            });
        },

        // 
        enhanceAccessibility: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    panels = profile.getSubNode('PANEL', true),
                    moves = profile.getSubNode('MOVE', true),
                    cmds = profile.getSubNode('CMD', true);

                // ARIA
                root.attr({
                    'role': 'main',
                    'aria-label': ''
                });

                // ARIA
                panels.each(function (panel) {
                    var panelNode = ood(panel);
                    var panelId = panelNode.id();
                    if (panelId) {
                        var itemId = panelId.split('_').pop(); // IDID
                        panelNode.attr({
                            'role': 'region',
                            'aria-label': ' ' + itemId
                        });
                    }
                });

                // ARIA
                moves.each(function (move) {
                    var moveNode = ood(move);
                    var moveId = moveNode.id();
                    if (moveId) {
                        var itemId = moveId.split('_').pop(); // IDID
                        moveNode.attr({
                            'role': 'separator',
                            'aria-label': ' ' + itemId + ' ',
                            'tabindex': '0',
                            'aria-orientation': profile.properties.type === 'vertical' ? 'horizontal' : 'vertical'
                        });

                        // 
                        // OODDOMAPI
                    }
                });

                // ARIA
                cmds.each(function (cmd) {
                    var cmdNode = ood(cmd);
                    var cmdId = cmdNode.id();
                    if (cmdId) {
                        var itemId = cmdId.split('_').pop(); // IDID
                        cmdNode.attr({
                            'role': 'button',
                            'aria-label': '/ ' + itemId,
                            'tabindex': '0'
                        });

                        // 
                        // OODDOMAPI
                    }
                });
            });
        }
    },
    Static: {
        Templates: {
            tagName: 'div',
            style: '{_style}',
            className: '{_className} {_trans}',
            text: "{items}",
            $submap: {
                items: {
                    ITEM: {
                        tagName: 'div',
                        className: '{cls1} {itemClass}',
                        style: '{itemStyle};{display}',
                        MOVE: {
                            $order: 0,
                            tagName: 'div',
                            // give icon font for em size
                            className: 'ood-ui-unselectable ood-uibar {clsmovebg} {cls2} ',
                            style: '{moveDisplay};cursor:{_cursor}'
                        },
                        CMD: {
                            $order: 1,
                            tagName: 'span',
                            style: '{cmdDisplay}',
                            className: 'ood-node ood-ui-unselectable oodfont {cls3}',
                            $fonticon: '{_fi_cls3} '
                        },
                        PANEL: {
                            tagName: 'div',
                            className: 'ood-uibase ood-uicontainer',
                            style: 'position:absolute;{_bginfo};{_overflow};',
                            text: ood.UI.$childTag
                        }
                    }
                }
            }
        },
        Appearances: {
            KEY: {
                position: 'absolute',
                overflow: 'hidden',
                left: 0,
                top: 0,
                transition: 'all 0.3s ease'
            },
            "KEY-trans, KEY-trans > ITEM, KEY-trans > ITEM > PANEL, KEY-trans > ITEM > MOVE, KEY-trans > ITEM > CMD": {
                $order: 100,
                "background-color": "transparent",
                "border": "none"
            },
            MOVE: {
                $order: 0,
                position: 'absolute',
                'z-index': '10',
                'background': 'var(--border)',
                transition: 'all 0.2s ease'
            },
            'MOVE:hover': {
                'background': 'var(--primary)',
                'transform': 'scale(1.02)'
            },
            CMD: {
                position: 'absolute',
                cursor: 'pointer',
                'z-index': '20',
                'background': 'var(--primary)',
                'color': 'var(--text-inverse)',
                'border': '1px solid var(--primary-dark)',
                'border-radius': '4px',
                transition: 'all 0.2s ease',
                'box-shadow': 'var(--shadow-sm)'
            },
            'CMD:hover': {
                'background': 'var(--primary-dark)',
                'transform': 'scale(1.1)',
                'box-shadow': 'var(--shadow-md)'
            },

            ITEM: {
                position: 'absolute',
                "z-index": 1,
                overflow: 'hidden',
                'border-width': ood.browser.opr ? '0' : null,
                'background-color': 'var(--bg)',
                //  'border': '1px solid var(--border)',
                'border-radius': '4px',
                'box-shadow': 'var(--shadow-sm)',
                transition: 'box-shadow 0.3s ease'
            },
            'ITEM:hover': {
                'box-shadow': 'var(--shadow-md)'
            },
            PANEL: {
                position: 'absolute',
                overflow: 'auto',
                left: 0,
                top: 0,
                'border-width': ood.browser.opr ? '0' : null,
                'background-color': 'var(--bg)',
                transition: 'background-color 0.3s ease'
            },
            'ITEM-MAIN': {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            },
            'ITEM-TOP, ITEM-BOTTOM': {
                left: 0,
                right: 0
            },
            'ITEM-LEFT, ITEM-RIGHT': {
                top: 0,
                bottom: 0
            },
            'MOVE-TOP, MOVE-BOTTOM': {
                width: '100%',
                height: ood.browser.contentBox ? '.2em' : '.22em',
                cursor: 'n-resize'
            },
            'MOVE-LEFT, MOVE-RIGHT': {
                height: '100%',
                width: ood.browser.contentBox ? '.2em' : '.22em',
                cursor: 'w-resize'
            },
            'MOVE-TOP': {
                bottom: 0
            },
            'MOVE-BOTTOM': {
                top: 0
            },
            'MOVE-LEFT': {
                right: '0'
            },
            'MOVE-RIGHT': {
                left: 0
            },
            'CMD-TOP, CMD-BOTTOM, CMD-LEFT, CMD-RIGHT': {
                padding: 0,
                'border-radius': '4px'
            },
            'CMD-TOP': {
                $order: 1,
                left: '50%',
                'margin-left': '-1em',
                bottom: 0,
                width: '2em',
                height: ood.browser.contentBox ? '.36667em' : '.45em',
                'text-align': 'center'
            },
            'CMD-BOTTOM': {
                $order: 1,
                left: '50%',
                'margin-left': '-1em',
                top: 0,
                width: '2em',
                height: ood.browser.contentBox ? '.46667em' : '.45em',
                'text-align': 'center'
            },
            'CMD-LEFT': {
                $order: 1,
                top: '50%',
                'margin-top': '-1em',
                right: 0,
                height: '2em',
                width: ood.browser.contentBox ? '.36667em' : '.45em',
                'line-height': '2em'
            },
            'CMD-RIGHT': {
                $order: 1,
                top: '50%',
                'margin-top': '-1em',
                left: 0,
                height: '2em',
                width: ood.browser.contentBox ? '.36667em' : '.45em',
                'line-height': '2em'
            },
            'MOVE-MAIN': {
                $order: 5,
                display: 'none'
            },
            'CMD-MAIN': {
                $order: 5,
                display: 'none'
            },
            // 
            '.layout-mobile MOVE': {
                //   'background': 'linear-gradient(135deg, #dee2e6 0%, #adb5bd 100%) !important'
            },
            '.layout-mobile CMD': {
                'font-size': '0.9em !important'
            },
            '.layout-tiny CMD': {
                'display': 'none !important'
            },

        },
        Behaviors: {
            DroppableKeys: ['PANEL'],
            PanelKeys: ['PANEL'],
            HoverEffected: {MOVE: 'MOVE', CMD: ['MOVE', 'CMD']},
            ClickEffected: {CMD: 'CMD'},
            MOVE: {
                beforeMousedown: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != "left") return;
                    var itemId = profile.getSubId(src),
                        item = profile.getItemByDom(src);
                    if (item.folded) return;
                    if (item.locked) return;

                    var main = profile.getItemByItemId('main'),
                        o = profile.getSubNode('ITEM', itemId),
                        m = profile.getSubNodeByItemId('ITEM', 'main'),
                        cursor = ood.use(src).css('cursor'),
                        t = profile.properties,
                        h, w, mh, mw, offset1, offset2;

                    profile.pos = item.pos;

                    if (t.type == 'vertical') {
                        h = profile._cur = o.height();
                        mh = m.height();
                        if (item.pos == 'before') {
                            offset1 = h - item.min;
                            offset2 = Math.round(item.max ? Math.min(parseFloat(item.max) - h, (mh - main.min)) : (mh - main.min));
                        } else {
                            offset1 = Math.round(item.max ? Math.min(parseFloat(item.max) - h, (mh - main.min)) : (mh - main.min));
                            offset2 = h - item.min;
                        }

                        ood.use(src).startDrag(e, {
                            dragType: 'copy',
                            targetReposition: false,
                            verticalOnly: true,
                            maxTopOffset: offset1,
                            maxBottomOffset: offset2,
                            dragCursor: cursor,
                            // IE8 bug
                            targetWidth: ood.browser.ie ? ood.use(src).offsetWidth() : null,
                            targetHeight: ood.browser.ie ? ood.use(src).offsetHeight() : null,
                            targetCallback: ood.browser.ie ? function (n) {
                                n.tagClass('-(top|bottom)', false)
                            } : null
                        });
                    } else {
                        w = profile._cur = o.width();
                        mw = m.width();
                        if (item.pos == 'before') {
                            offset1 = w - item.min;
                            offset2 = Math.round(item.max ? Math.min(parseFloat(item.max) - w, (mw - main.min)) : (mw - main.min));
                        } else {
                            offset1 = Math.round(item.max ? Math.min(parseFloat(item.max) - w, (mw - main.min)) : (mw - main.min));
                            offset2 = w - item.min;
                        }

                        ood.use(src).startDrag(e, {
                            dragType: 'copy',
                            targetReposition: false,
                            horizontalOnly: true,
                            maxLeftOffset: offset1,
                            maxRightOffset: offset2,
                            dragCursor: cursor,
                            // IE8 bug
                            targetWidth: ood.browser.ie ? ood.use(src).offsetWidth() : null,
                            targetHeight: ood.browser.ie ? ood.use(src).offsetHeight() : null,
                            targetCallback: ood.browser.ie ? function (n) {
                                n.tagClass('-(left|right)', false)
                            } : null
                        });
                    }

                    profile._limited = 0;
                },
                onDrag: function (profile, e, src) {
                    var t = profile.properties,
                        d = ood.DragDrop,
                        p = ood.DragDrop._profile,
                        b = 0;
                    if (t.type == 'vertical') {
                        if ((p.y <= p.restrictedTop) || (p.y >= p.restrictedBottom)) b = true;
                    } else {
                        if (p.x <= p.restrictedLeft || p.x >= p.restrictedRight) b = true;
                    }

                    if (b) {
                        if (!profile._limited) {
                            p.proxyNode.addClass('ood-alert');
                            profile._limited = true;
                        }
                    } else {
                        if (profile._limited) {
                            p.proxyNode.removeClass('ood-alert');
                            profile._limited = 0;
                        }
                    }

                },
                onDragstop: function (profile, e, src) {
                    var t = profile.properties,
                        height = t.height,
                        width = t.width,
                        o = ood.use(src).parent(),
                        r = profile.getRoot(),
                        item = profile.getItemByDom(src),
                        sum = 0, cur,
                        innerW = null, innerH = null, mainItem;
                    for (var i = 0, l = t.items.length; i < l; i++) {
                        if (!t.items[i].hidden) sum += t.items[i].size || 80;
                        if (t.items[i].id == "main") mainItem = t.items[i];
                    }
                    //add offset and refresh
                    if (t.type == 'vertical') {
                        innerH = r.height();
                        //use size to ignore onresize event once
                        item._size = profile._cur + (profile.pos == 'before' ? 1 : -1) * ood.DragDrop.getProfile().offset.y
                        o.height(profile.$isEm(height) ? profile.$px2em(item._size, o) + 'em' : item._size);
                        cur = sum * item._size / innerH;
                    } else {
                        innerW = r.width();
                        item._size = profile._cur + (profile.pos == 'before' ? 1 : -1) * ood.DragDrop.getProfile().offset.x
                        o.width(profile.$isEm(width) ? profile.$px2em(item._size, o) + 'em' : item._size);
                        cur = sum * item._size / innerW;
                    }
                    // always - main
                    mainItem.size -= cur - item.size;
                    item.size = cur;
                    //use size to ignore onresize event once
                    // use px here,  _onresize handle em things
                    ood.UI.$tryResize(profile, innerW, innerH, true);
                    profile._limited = 0;
                }
            },
            CMD: {
                onMousedown: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != "left") return;
                    var t = profile.properties,
                        itemId = profile.getSubId(src),
                        item = profile.getItemByDom(src),
                        r = profile.getRoot(),
                        main = profile.getItemByItemId('main'),
                        m = profile.getSubNodeByItemId('ITEM', 'main'),
                        o = profile.getSubNode('ITEM', itemId),
                        panel = profile.getSubNode('PANEL', itemId),
                        move = profile.getSubNode('MOVE', itemId),
                        _handlerSize = (item.locked ? 0 : t.type == 'vertical' ? move.offsetHeight() : move.offsetWidth());

                    if (t.type == 'vertical') {
                        // restore resize mode
                        if (item.folded) {
                            // if(item._size <= m.height() - main.min + _handlerSize){
                            //restore h
                            o.height(item._size);
                            panel.show();

                            item.folded = false;
                            //set appearance
                            if (item.pos == 'before')
                                ood.use(src).replaceClass(/bottom/g, 'top');
                            else
                                ood.use(src).replaceClass(/top/g, 'bottom');

                            //hidden 'move'
                            if (!item.locked) move.css('cursor', 'n-resize');
                            profile.getSubNode('MOVE').tagClass('-checked', false);
                            // }else
                            //    ood.message('no enough space!');
                            // to min and fix mode
                        } else {
                            o.height(_handlerSize);
                            panel.hide();

                            item.folded = true;
                            if (item.pos == 'before')
                                ood.use(src).replaceClass(/top/g, 'bottom');
                            else
                                ood.use(src).replaceClass(/bottom/g, 'top');

                            if (!item.locked)
                                move.css('cursor', 'default');
                            profile.getSubNode('MOVE').tagClass('-checked');
                        }
                        ood.UI.$tryResize(profile, null, r.height(), true);
                    } else {
                        if (item.folded) {
                            // if(item._size <= m.width()-main.min + _handlerSize){
                            o.width(item._size);
                            panel.show();
                            item.folded = false;
                            if (item.pos == 'before')
                                ood.use(src).replaceClass(/right/g, 'left');
                            else
                                ood.use(src).replaceClass(/left/g, 'right');

                            if (!item.locked) move.css('cursor', 'w-resize');
                            profile.getSubNode('MOVE').tagClass('-checked', false);
                            //}else
                            //    ood.message('no enough space!');
                        } else {
                            o.width(_handlerSize);
                            panel.hide();
                            item.folded = true;
                            if (item.pos == 'before')
                                ood.use(src).replaceClass(/left/g, 'right');
                            else
                                ood.use(src).replaceClass(/right/g, 'left');


                            if (!item.locked)
                                move.css('cursor', 'default');
                            profile.getSubNode('MOVE').tagClass('-checked');
                        }
                        ood.UI.$tryResize(profile, r.width(), null, true);
                    }

                    return false;
                }
            },
            PANEL: {
                onClick: function (profile, e, src) {
                    var p = profile.properties,
                        item = profile.getItemByDom(src);
                    if (p.disabled || item.disabled) return false;
                    if (profile.onClickPanel)
                        return profile.boxing().onClickPanel(profile, item, e, src);
                }
            }
        },
        DataModel: {
            // 
            theme: {
                caption: ood.getResText("DataModel.theme") || "",
                ini: 'light',
                listbox: ['light', 'dark'],
                action: function (v) {
                    this.boxing().setTheme(v);
                }
            },
            // 
            responsive: {
                caption: ood.getResText("DataModel.responsive") || "",
                ini: true,
                action: function (v) {
                    if (v) {
                        this.boxing().adjustLayout();
                        // resize
                        ood.Event.on(window, 'resize.' + this.get(0).serialId, this.boxing().adjustLayout.bind(this.boxing()));
                    } else {
                        // resize
                        ood.Event.off(window, 'resize.' + this.get(0).serialId);
                    }
                }
            },

            rotate: {
                ini: null,
                caption: ood.getResText("DataModel.rotate") || ""
            },
            selectable: {
                caption: ood.getResText("DataModel.selectable") || "",
                ini: true
            },
            navComboType: {
                caption: ood.getResText("DataModel.navComboType") || "",
                listbox: ['custom', 'galleryNav', 'menuBarNav', 'treeNav', 'foldingNav'],
                ini: 'custom'
            },
            disabled: {
                ini: null,
                caption: ood.getResText("DataModel.disabled") || ""
            },
            position: {
                caption: ood.getResText("DataModel.position") || "",
                ini: 'absolute'
            },
            type: {
                caption: ood.getResText("DataModel.type") || "",
                listbox: ['vertical', 'horizontal'],
                ini: 'horizontal',
                action: function (value, ovalue) {
                    if (value != ovalue) {
                        var self = this, auto = 'auto',
                            nodes2 = self.getSubNode('ITEM', true),
                            nodes1 = self.getSubNode('MOVE', true),
                            nodes3 = self.getSubNode('CMD', true);
                        nodes1.merge(nodes2).merge(nodes3);

                        if (value == 'vertical') {
                            nodes1.replaceClass(/(-left)(\b)/ig, '-top$2');
                            nodes1.replaceClass(/(-right)(\b)/ig, '-bottom$2');
                            nodes2.each(function (o) {
                                ood(o).height(ood(o).width());
                            })
                                .css({left: 0, top: auto, right: auto, bottom: auto})
                            ;
                        } else {
                            nodes1.replaceClass(/(-top)(\b)/ig, '-left$2');
                            nodes1.replaceClass(/(-bottom)(\b)/ig, '-right$2');
                            nodes2.each(function (o) {
                                ood(o).width(ood(o).height());
                            })
                                .css({left: auto, top: 0, right: auto, bottom: auto})
                            ;

                        }

                        self.adjustSize();
                    }
                }
            },
            dock: {
                caption: ood.getResText("DataModel.dock") || "",
                ini: 'fill'
            },
            listKey: null,
            width: {
                caption: ood.getResText("DataModel.width") || "",
                $spaceunit: 1,
                ini: '18em'
            },
            height: {
                caption: ood.getResText("DataModel.height") || "",
                $spaceunit: 1,
                ini: '18em'
            },
            dragSortable: {
                ini: null,
                caption: ood.getResText("DataModel.dragSortable") || ""
            },

            flexSize: {
                caption: ood.getResText("DataModel.flexSize") || "",
                ini: false,
                action: function () {
                    this.adjustSize();
                }
            },


            transparent: {
                caption: ood.getResText("DataModel.transparent") || "",
                ini: false,
                action: function (v) {
                    this.getRoot().tagClass('-trans', !!v);
                }
            },
            items: {
                caption: ood.getResText("DataModel.items") || "",
                ini: []
            }
        },
        EventHandlers: {
            onClickPanel: function (profile, item, e, src) {
            }
        },
        _adjustItems2: function (items, pos) {
            var arr = [];
            //arrage items
            ood.arr.each(items, function (o) {
                if (o.id != 'main') {
                    arr.push(o = ood.isHash(o) ? o : {id: '' + o});
                    o.pos = pos;
                }
            });

            //set the items to default value
            ood.arr.each(arr, function (o) {
                o.id = ood.isStr(o.id) ? o.id : ood.id();
                o.min = o.min || 10;
                o._size = o.size = Math.round(parseFloat(o.size)) || 80;
                o.locked = typeof o.locked == 'boolean' ? o.locked : false;
                o.folded = typeof o.folded == 'boolean' ? o.folded : false;
                o.hidden = typeof o.hidden == 'boolean' ? o.hidden : false;
                o.cmd = typeof o.cmd == 'boolean' ? o.cmd : true;
            });
            return arr;
        },
        _adjustItems: function (items) {
            var main, before = [], after = [], watershed = 0;

            //arrage items
            ood.arr.each(items, function (o, i) {
                o = ood.copy(o);
                if (o.id == 'main') {
                    main = o;
                    watershed = i;
                } else {
                    if (o.pos == 'before') {
                        before.push(o);
                    } else if (o.pos == 'after') {
                        after.push(o);
                    } else if (watershed) {
                        o.pos = 'after';
                        after.push(o);
                    } else {
                        o.pos = 'after';
                        before.push(o);
                    }
                }
            });

            main = main || {};
            main.id = 'main';
            main.min = main.min || 10;
            // no _size in main
            main.size = Math.round(parseFloat(main.size)) || 80;

            //reset items
            items.length = 0;
            ood.arr.insertAny(items, this._adjustItems2(before, 'before'));
            ood.arr.insertAny(items, main);
            ood.arr.insertAny(items, this._adjustItems2(after, 'after'));

            return items;
        },
        _prepareData: function (profile) {
            var prop = profile.properties;
            if (prop.layoutType) {
                prop.type = prop.layoutType;
            }
            if (!prop.items || !ood.isArr(prop.items))
                prop.items = ood.clone([
                    {id: 'before', pos: 'before', locked: false, size: 120, min: 150, max: 600},
                    {id: 'after', pos: 'after', locked: false, size: 120, min: 150, max: 600}
                ]);
            prop.items = this._adjustItems(prop.items);
            var data = arguments.callee.upper.call(this, profile);
            data._trans = data.transparent ? profile.getClass("KEY", "-trans") : "";
            return data;
        },
        _prepareItems: function (profile, items) {
            var data = arguments.callee.upper.apply(this, arguments);
            var p = profile.properties;
            if (p.layoutType) {
                p.type = p.layoutType;
            }
            ood.arr.each(items, function (o) {
                delete o.caption;
            });
            return data;
        },
        _prepareItem: function (profile, data, item) {
            var p = profile.properties,
                width = p.width, height = p.height, t;

            if (data.id == 'main') {
                data.cls1 = profile.getClass('ITEM', '-main');
                data.cls2 = profile.getClass('MOVE', '-main');
                data.cls3 = profile.getClass('CMD', '-main');
            } else {

                var pos;
                if (p.type == 'vertical') {
                    data.clsmovebg = "ood-uiborder-t ood-uiborder-b";
                    if (data.pos == 'before')
                        pos = 'top';
                    else
                        pos = 'bottom';
                } else {
                    data.clsmovebg = "ood-uiborder-l ood-uiborder-r";
                    if (data.pos == 'before')
                        pos = 'left';
                    else
                        pos = 'right';
                }

                data.cls1 = profile.getClass('ITEM', '-' + pos);
                data.cls2 = profile.getClass('MOVE', '-' + pos);
                data.cls3 = profile.getClass('CMD', '-' + pos);
                data._fi_cls3 = "ood-icon-arrow" + pos;

                data.display = data.hidden ? 'display:none' : '';
                data._cursor = data.locked ? 'default' : (p.type == 'vertical') ? 'n-resize' : 'w-resize';
                data.cmdDisplay = (data.cmd && !data.locked) ? '' : 'display:none';
                data.moveDisplay = !data.locked ? '' : 'display:none';
            }
            data._bginfo = "";
            if (t = data.panelBgClr || p.panelBgClr)
                data._bginfo += "background-color:" + t + ";";
            if (t = data.panelBgImg || p.panelBgImg)
                data._bginfo += "background-image:url(" + ood.adjustRes(t) + ");";
            if (t = data.panelBgImgPos || p.panelBgImgPos)
                data._bginfo += "background-position:" + t + ";";
            if (t = data.panelBgImgRepeat || p.panelBgImgRepeat)
                data._bginfo += "background-repeat:" + t + ";";
            if (t = data.panelBgImgAttachment || p.panelBgImgAttachment)
                data._bginfo += "background-attachment:" + t + ";";
            if (ood.isStr(data.overflow))
                data._overflow = data.overflow.indexOf(':') != -1 ? (data.overflow) : (data.overflow ? ("overflow:" + data.overflow) : "");
            else if (ood.isStr(p.overflow))
                data._overflow = p.overflow.indexOf(':') != -1 ? (p.overflow) : (p.overflow ? ("overflow:" + p.overflow) : "");
        },
        RenderTrigger: function () {
            var t, profile = this;
            ood.arr.each(profile.properties.items, function (item) {
                if (item.id != 'main') {
                    if (item.folded && (t = profile.getSubIdByItemId(item.id))) {
                        item.folded = false;
                        profile.getSubNode('CMD', t).onMousedown();
                    }
                }
            });
        },
        _onresize: function (profile, width, height) {
            var t = profile.properties, itemId,
                key = profile.keys.ITEM,
                panel = profile.keys.PANEL,
                main = profile.getItemByItemId('main'),
                mainmin = main.min || 10,
                pct = t.flexSize,
                sum = 0,

                move, _handlerSize,
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                fzrate = profile.getEmSize() / profile.getRoot()._getEmSize();

            if (width) width = profile.$px(width);
            if (height) height = profile.$px(height);

            var obj = {}, obj2 = {};
            // **keep the original size
            //,obj3={};
            ood.arr.each(t.items, function (o) {
                itemId = profile.getSubIdByItemId(o.id);
                obj[itemId] = {};
                obj2[itemId] = {};
//                obj3[itemId] = o;
                if (pct && !o.hidden) sum += o.size || 80;
            });

            var fun = function (prop, w, width, left, right, offset, forceoffset) {
                var _t, m, m1, itemId, temp1 = 0, temp2 = 0, temp = 0, blocknumb = 0, offsetbak = offset;

                ood.arr.each(prop.items, function (o) {
                    if (o.id == 'main') return;
                    if (o.pos == 'before') {
                        itemId = profile.getSubIdByItemId(o.id);
                        move = profile.getSubNode('MOVE', itemId),
                            _handlerSize = (o.locked ? 0 : t.type == 'vertical' ? move.offsetHeight() : move.offsetWidth())
                        if (o.hidden) {
                            m = 0;
                            obj2[itemId][width] = Math.round(pct ? parseFloat(w * Math.min(1, (o.size / sum))) : o._size);
                        } else if (o.folded) {
                            m = obj2[itemId][width] = _handlerSize;
                        } else {
                            blocknumb++;
                            m = m1 = Math.round(pct ? parseFloat(w * Math.min(1, (o.size / sum))) : o._size);
                            if (m > offset + o.min) {
                                m -= offset;
                            } else {
                                offset = m - o.min;
                                m = o.min;
                            }
                            m -= forceoffset;
                            m = Math.max(m, _handlerSize);
                        }
                        obj2[itemId][left] = temp1;
                        temp1 += m;
                        obj[itemId][left] = 0;
                        obj[itemId][width] = m - _handlerSize;
                        obj2[itemId][right] = obj[itemId][right] = 'auto';
                        obj2[itemId][width] = m;
                        mainmin += _handlerSize;
                    }
                });
                ood.arr.each(prop.items, function (o) {
                    if (o.id == 'main') return;
                    if (o.pos == 'after') {
                        itemId = profile.getSubIdByItemId(o.id);
                        move = profile.getSubNode('MOVE', itemId),
                            _handlerSize = (o.locked ? 0 : t.type == 'vertical' ? move.offsetHeight() : move.offsetWidth())
                        if (o.hidden) {
                            m = 0;
                            obj2[itemId][width] = Math.round(pct ? parseFloat(w * Math.min(1, (o.size / sum))) : o._size);
                        } else if (o.folded) {
                            m = obj2[itemId][width] = _handlerSize;
                        } else {
                            blocknumb++;
                            m = m1 = Math.round(pct ? parseFloat(w * Math.min(1, (o.size / sum))) : o._size);
                            if (m > offset + o.min) {
                                m -= offset;
                            } else {
                                offset = m - o.min;
                                m = o.min;
                            }
                            m -= forceoffset;
                            m = Math.max(m, _handlerSize);
                        }
                        obj2[itemId][right] = temp2;
                        temp2 += m;
                        obj[itemId][right] = 0;
                        obj[itemId][width] = m - _handlerSize;
                        obj2[itemId][left] = obj[itemId][left] = 'auto';
                        obj2[itemId][width] = m;
                        mainmin += _handlerSize;
                    }
                }, null, true);
                temp = temp1 + temp2;

                //set main
                if (w - temp >= mainmin || forceoffset) {
                    _t = profile.getSubIdByItemId('main');
                    obj2[_t][width] = obj[_t][width] = w - temp;
                    obj2[_t][left] = temp1;
                } else {
                    var args = ood.toArr(arguments);
                    // second time only
                    if (!offsetbak) {
                        args[args.length - 2] = (mainmin - (w - temp)) / blocknumb;
                    }
                    // third time only
                    else {
                        args[args.length - 2] = offsetbak;
                        args[args.length - 1] = (mainmin - (w - temp)) / blocknumb;
                    }
                    //second time
                    fun.apply(null, args);
                }
            };

            if (t.type != 'vertical') {
                if (!ood.isNull(width)) {
                    //get left
                    fun(t, width, 'width', 'left', 'right', 0, 0);
//                    ood.each(obj2,function(o,i){
//                       if(o.width && !obj3[i].folded)obj3[i]._size=o.width;
//                    });
                }
                if (!ood.isNull(height)) {
                    ood.each(obj, function (o, id) {
                        obj2[id].height = o.height = height;
                    });
                }
            } else {
                if (!ood.isNull(height)) {
                    //get left
                    fun(t, height, 'height', 'top', 'bottom', 0, 0);
//                    ood.each(obj2,function(o,i){
//                        if(o.height  && !obj3[i].folded)obj3[i]._size=o.height;
//                    });
                }
                if (!ood.isNull(width)) {
                    ood.each(obj, function (o, id) {
                        obj2[id].width = o.width = width;
                    });
                }
            }
            var ff_w = function (o, emRate) {
                ood.arr.each("left,width,right".split(','), function (t) {
                    if (t in o) o[t] = profile.$forceu(o[t], 'em', emRate);
                });
            }, ff_h = function (o, emRate) {
                ood.arr.each("top,height,bottom".split(','), function (t) {
                    if (t in o) o[t] = profile.$forceu(o[t], 'em', emRate);
                });
            };
            //collect width/height in size
            ood.each(obj2, function (o, id) {
                var p = profile.getSubNode('PANEL', id),
                    i = profile.getSubNode('ITEM', id);

                if (us > 0) {
                    var pfz = us > 0 ? p._getEmSize(fzrate) : null,
                        ifz = us > 0 ? i._getEmSize(fzrate) : null;
                    ff_w(obj[id], ifz);
                    ff_w(obj2[id], ifz);
                    ff_h(obj[id], pfz);
                    ff_h(obj2[id], pfz);
                }
                p.cssRegion(obj[id], true);

                if (obj[id].width) {
                    ood.UI._adjustConW(profile, p, obj[id].width);
                }

                i.cssRegion(obj2[id]);
            });
        },
        LayoutTrigger: function () {
            var prop = this.properties,
                boxing = this.boxing();

            // 
            // 
            if (prop.theme) {
                boxing.setTheme(prop.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('layout-theme');
                if (savedTheme) {
                    boxing.setTheme(savedTheme);
                }
            }

            // 
            if (prop.responsive !== false) {
                boxing.adjustLayout();
                // 
                // OOD
            }

            // 
            boxing.enhanceAccessibility();
        }
    }
});
//rowMap => row_SerialIdMapItem
//rowMap2 => row_ItemIdMapSerialId
//colMap => header_SerialIdMapItem
//colMap2 => header_ItemIdMapSerialId
//cellMap => cells_SerialIdMapItem
//cellType: label,input,textarea,combobox,listbox,file,getter,helpinput,button,dropbutton,cmdbox,popbox,date,time,datetime,color,spin,counter,currency,number,checkbox,progress

ood.Class("ood.UI.TreeGrid", ["ood.UI", "ood.absValue"], {
    Instance: {
        // 
        setTheme: function (theme) {
            return this.each(function (profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();

                // 
                root.removeClass('treegrid-dark treegrid-hc');

                // 
                root.attr('data-theme', theme);

                // 
                root.addClass('ood-treegrid');

                // 
                localStorage.setItem('treegrid-theme', theme);
            });
        },
        iniProp: {
            rowHandler: true,
            rowNumbered: true,
            header: [
                {caption: 'ID', id: 'id', width: 60},
                {caption: '', id: 'name', width: 120},
                {caption: '', id: 'status', width: 80},
                {caption: '', id: 'createTime', width: 140}
            ],
            rows: [
                {
                    id: '1',
                    cells: [{value: '1'}, {value: '1'}, {value: ''}, {value: '2024-01-01'}]
                },
                {
                    id: '2',
                    cells: [{value: '2'}, {value: '2'}, {value: ''}, {value: '2024-01-02'}]
                },
                {
                    id: '3',
                    cells: [{value: '3'}, {value: '3'}, {value: ''}, {value: '2024-01-03'}]
                }
            ]
        },

        // 
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('treegrid-theme') || 'light';
        },

        // 
        toggleTheme: function () {
            var currentTheme = this.getTheme();
            this.setTheme(currentTheme === 'light' ? 'dark' : (currentTheme === 'dark' ? 'high-contrast' : 'light'));
            return this;
        },
        activate: function () {
            var profile = this.get(0), t;
            if (!profile.renderId) return;
            profile.getSubNode('ROWS22').nextFocus(true, true, true);
            return this;
        },
        _setCtrlValue: function (value) {
            return this.each(function (profile) {
                if (!profile.renderId) return;
                if (profile.properties.activeMode == 'none') return;

                var box = profile.boxing(),
                    uiv = box.getUIValue(),
                    p = profile.properties,
                    rowMap = profile.rowMap,
                    k = p.activeMode == 'row' ? ['CELLS1', 'CELLS2', 'MARK'] : 'CELL',
                    getN = function (k, i) {
                        return profile.getSubNodes(k, i)
                    },
                    getI = function (i) {
                        var map1 = profile.rowMap2;
                        if (p.activeMode == 'row')
                            return map1[i];
                        else {
                            if (!i) return;
                            var r = ('' + i).split('|');
                            return ood.get(profile.rowMap, [map1[r[0]], '_cells', r[1]]);
                        }
                    };

                if (p.selMode == 'single') {
                    var itemId = getI(uiv);
                    if (uiv && itemId)
                        getN(k, itemId).tagClass('-checked', false);

                    itemId = getI(value);
                    if (itemId)
                        getN(k, itemId).tagClass('-checked');

                    /*if(itemId){
                        var o = getN("ROW",itemId);
                        if(o){
                            var top = o.offsetTop(),
                            items = getN('SCROLL'),
                            sh=items.scrollHeight(),
                            st=items.scrollTop(),
                            hh=items.height()
                            ;
                            if(sh > hh)
                                if(top<st || top>st+hh)
                                    items.scrollTop(top);
                        }
                    }*/
                } else if (p.selMode == 'multi' || p.selMode == 'multibycheckbox') {
                    uiv = uiv ? ('' + uiv).split(p.valueSeparator) : [];
                    value = value ? ('' + value).split(p.valueSeparator) : [];
                    //check all
                    ood.arr.each(uiv, function (o, i) {
                        if (o = getI(o)) {
                            if (i = rowMap[o]) delete i._selected;
                            getN(k, o).tagClass('-checked', false);
                        }
                    });
                    ood.arr.each(value, function (o) {
                        if (o = getI(o)) {
                            if (i = rowMap[o]) i._selected = 1;
                            getN(k, o).tagClass('-checked');
                        }
                    });
                    // clear the header's row handler checkbox
                    if (value.length === 0) {
                        getN("HFMARK").tagClass('-checked', false);
                        delete profile._$checkAll;
                    }
                }
            });
        },
        calculateGridValue: function () {
            var profile = this.get(0), prop = profile.properties,
                f = prop.gridValueFormula, value = null,
                refs, coo, v2, cellsMap, xformula = ood.ExcelFormula, tcell, colMax, rowMax;
            if (profile.beforeGridValueCalculated && false !== (v2 = profile.boxing().beforeGridValueCalculated(profile))) {
                value = v2;
            } else {
                if (f) {
                    colMax = prop.header.length;
                    // only for first level
                    rowMax = prop.rows.length;
                    if (xformula.validate(f)) {
                        cellsMap = {};
                        if (refs = xformula.getRefCells(f, colMax, rowMax)) {
                            ood.each(refs, function (v, i) {
                                coo = xformula.toCoordinate(i);
                                tcell = prop.rows[coo.row].cells[coo.col];
                                cellsMap[i] = tcell.value;
                            });
                        }
                        value = xformula.calculate(f, cellsMap, colMax, rowMax);
                    }
                }
            }
            if (profile.afterGridValueCalculated)
                profile.boxing().afterGridValueCalculated(profile, value);

            profile._$gridvalue = value;
            if (prop.excelCellId && profile._$oldgridvalue !== profile._$gridvalue) {
                profile.boxing().notifyExcel(false);
            }
            return profile._$oldgridvalue = value;
        },
        // notify the grid's modification to fake excel ( in module )
        notifyExcel: ood.UI.Input.prototype.notifyExcel,
        // get grid's fake cexcel cell value
        getExcelCellValue: function () {
            var profile = this.get(0), prop = profile.properties, f, refs, coo, value, v2, cellsMap,
                xformula = ood.ExcelFormula, tcell, colMax, rowMax;
            if (prop.excelCellId) {
                value = ('_$gridvalue' in profile) ? profile._$gridvalue : this.caculateGridValue();
                if (ood.isSet(v2 = (profile.onGetExcelCellValue && profile.boxing().onGetExcelCellValue(profile, prop.excelCellId, value))))
                    value = v2;
                return value;
            }
            return null;
        },
        // calculate the cellTo's formula, and apply to the cell
        // only for first level
        applyCellFormula: function (cellTo, dirtyMark, triggerEvent) {
            return this.each(function (prf) {
                var tg = prf.box, formula, j, i, needUpdate, t2, cellsMap = {}, coo,
                    prop = prf.properties,
                    rows = prop.rows,
                    // only for first level
                    colMax = ood.arr.indexOf(prop.header, cellTo._col),
                    rowMax = ood.arr.indexOf(rows, cellTo._row),
                    xformula = ood.ExcelFormula;
                if (formula = tg._getCellFormula(prf, cellTo, xformula.toColumnChr(colMax + 1), rowMax + 1)) {
                    var refs = xformula.getRefCells(formula, colMax, rowMax);
                    if (!refs) return;
                    ood.each(refs, function (v, i) {
                        coo = xformula.toCoordinate(i);
                        tcell = rows[coo.row].cells[coo.col];
                        cellsMap[i] = tcell.value;
                    });
                    t2 = xformula.calculate(formula, cellsMap, colMax, rowMax);
                    if (t2 !== cellTo.value) {
                        needUpdate = [cellTo._serialId, t2, cellTo, formula];
                        if (prf.beforeApplyFormula && false === prf.boxing().beforeApplyFormula(prf, cellTo, t2, formula)) {
                        } else {
                            tg._updCell(prf, needUpdate[0], {value: needUpdate[1]}, dirtyMark, triggerEvent, true);
                        }
                        if (prf.afterApplyFormulas)
                            prf.boxing().afterApplyFormulas(prf, [needUpdate]);
                    }
                }
            });
        },
        // calculate all cells' (or cellFrom's)  formula, and apply to them(it)
        // only for first level
        triggerFormulas: function (cellFrom, dirtyMark, triggerEvent) {
            return this.each(function (prf) {
                var tg = prf.box, cellId,
                    prop = prf.properties,
                    rows = prop.rows,
                    // only for first level
                    rowMax = rows.length,
                    colMax = prop.header.length,
                    xformula = ood.ExcelFormula,
                    formulaCells = {}, formula, tcell;
                //1. collection all formula cells
                ood.arr.each(prop.rows, function (row, i) {
                    ood.arr.each(row.cells, function (c, j) {
                        if (c === cellFrom) cellId = xformula.toCellId(j, i);
                        if (formula = tg._getCellFormula(prf, c, xformula.toColumnChr(j + 1), i + 1)) {
                            formulaCells[xformula.toCellId(j, i)] = [c, formula];
                        }
                    });
                });
                // if input cell, must remove itself;
                if (cellId) delete formulaCells[cellId];
                if (ood.isEmpty(formulaCells)) return;

                //2. collect refs for formulaCells
                var refs = {};
                ood.each(formulaCells, function (a, id) {
                    if (a = xformula.getRefCells(a[1], colMax, rowMax))
                        refs[id] = a;
                });

                //3. loop to calculate non-ref cells
                var count, noFormulaRef, cellsMap = {}, coo, needUpdate = [], t1, t2,
                    changed = {}, needRec;
                if (cellId) {
                    changed[cellId] = 1;
                }
                do {
                    count = 0;
                    ood.filter(refs, function (v, k) {
                        needRec = 0;
                        if (!cellId) needRec = 1;
                        else {
                            for (var i in v) {
                                if (i in changed) {
                                    needRec = 1;
                                    break;
                                }
                            }
                        }
                        // no need to re-calculate
                        if (!needRec) {
                            return false;
                        }

                        noFormulaRef = true;
                        for (var i in v) {
                            if (!cellId && (i in formulaCells)) {
                                noFormulaRef = false;
                            } else {
                                if (!(i in cellsMap)) {
                                    coo = xformula.toCoordinate(i);
                                    tcell = rows[coo.row].cells[coo.col];
                                    cellsMap[i] = tcell.value;
                                }
                            }
                        }
                        if (noFormulaRef) {
                            t1 = formulaCells[k];
                            t2 = xformula.calculate(t1[1], cellsMap, colMax, rowMax);
                            if (t2 !== t1[0].value) {
                                // keep update value
                                needUpdate.push([t1[0], t2, t1[1], t1[0]._serialId]);
                                if (cellId) changed[k] = 1;
                            }
                            // remove from formulaCells
                            delete formulaCells[k];
                            count++;
                            return false;
                        }
                    });
                }
                    // Avoid circular references
                while (!ood.isEmpty(formulaCells) && count > 0);

                // update cell by order
                for (var i = 0, l = needUpdate.length; i < l; i++) {
                    if (prf.beforeApplyFormula && false === prf.boxing().beforeApplyFormula(prf, needUpdate[i][0], needUpdate[i][1], needUpdate[i][2])) {
                    } else {
                        tg._updCell(prf, needUpdate[i][3], {value: needUpdate[i][1]}, dirtyMark, triggerEvent, false);
                    }
                }
                // [[cell servialid, cell value, cell, fomula]]
                if (prf.afterApplyFormulas)
                    prf.boxing().afterApplyFormulas(prf, needUpdate);

                if (prop.gridValueFormula) {
                    prf.boxing().calculateGridValue(false);
                }
            });
        },
        /*insert rows to dom
        arr is formatted properties
        pid,base are item id
        before: insert before?
        */
        _insertRowsToDom: function (profile, arr, pid, base, before, temp) {
            //if parent not open, return
            if (pid) {
                var parent = profile.rowMap[pid];
                if (parent && !parent._inited) return;
            }
            if (!arr)
                arr = [];

            var obj21, obj22, hw,
                box = profile.box,
                prop = profile.properties,
                hw = profile.getSubNode('FHCELL').width();
            if (hw) hw = profile.$forceu(hw);

            //give width at here, and do filter
            ood.arr.each(arr, function (o) {
                o._row0DfW = hw ? ('width:' + hw) : '';
                ood.arr.each(o.cells, function (v, i) {
                    v.width = v._col._colWidth;
                })
            });
            // check freezed row exists?
            if (profile.properties.freezedRow) {
                var t = profile.getSubNode('ROWS12');
                if (!t.isEmpty() && t.query('div', 'id', /-ROWS12\:/).isEmpty())
                    delete profile._passFreezedRow;
            }

            //build dom
            var nodes21 = profile._buildItems('rows21', arr),
                nodes22 = profile._buildItems('rows22', arr);

            //get base dom
            if (!base) {
                //no base add to parent
                if (pid) {
                    obj21 = profile.getSubNode('SUB1', pid);
                    obj22 = profile.getSubNode('SUB2', pid);
                } else {
                    obj21 = profile.getSubNode('ROWS21');
                    obj22 = profile.getSubNode('ROWS22');
                }
                if (before) {
                    obj21.prepend(nodes21);
                    obj22.prepend(nodes22);
                } else {
                    obj21.append(nodes21);
                    obj22.append(nodes22);
                }
            } else {
                //
                obj21 = profile.getSubNode('ROW1', base);
                obj22 = profile.getSubNode('ROW2', base);
                if (before) {
                    obj21.addPrev(nodes21);
                    obj22.addPrev(nodes22);
                } else {
                    obj21.addNext(nodes21);
                    obj22.addNext(nodes22);
                }
            }

            //add sub
            ood.arr.each(arr, function (o) {
                if (o.sub) {
                    o.open = false;
                    if (false === box.getCellOption(profile, o, "initFold"))
                        profile.boxing()._toggleRows([o], true, false, true);
                }
            });

            if (temp && temp.length) {
                var needshowinput = [], arrt = [];
                ood.arr.each(temp, function (o) {
                    if (box.getCellOption(profile, o, "editable") &&
                        (box.getCellOption(profile, o, "editMode") == "inline" || box.getCellOption(profile, o, "type") == 'dropbutton'))
                        needshowinput.push(o);
                });
                temp.length = 0;
                // for performance 25
                if (needshowinput.length) {
                    for (var i = 0, l = needshowinput.length, t; i < l; i++) {
                        t = parseInt(i / 25, 10);
                        if (!arrt[t]) arrt[t] = [];
                        arrt[t].push(needshowinput[i]);
                    }
                    needshowinput.length = 0;
                    var fun = function () {
                        if (arrt.length) {
                            var a = arrt.shift();
                            if (a && a.length) {
                                for (var i = 0, l = a.length; i < l; i++) {
                                    if (profile && profile.box && !profile.destroyed && a[i] && a[i]._row)
                                        profile.box._editCell(profile, a[i], null, true);
                                }
                                ood.asyRun(fun);
                            }
                        } else {
                            arrt = null;
                        }
                    };
                    // for event attached
                    ood.asyRun(fun);
                }
            }

            //clear rows cache
            delete profile.$allrowscache1;
            delete profile.$allrowscache2;

            profile.box._adjustBody(profile, 'addrow');
        },
        _refreshHeader: function (header) {
            var profile = this.get(0),
                prop = profile.properties,
                box = profile.box,
                grpcols = ood.clone(prop.grpCols, false, 2),
                arr, arr2,
                rows = this.getRows("data");

            ood.breakO(profile.colMap, 2);

            header = box._adjustHeader(header || []);
            arr = box._prepareHeader(profile, header);
            prop.header = header;

            this.removeAllRows();

            profile.getSubNodes(['HCELL', 'HSCELL'], true).remove();

            var nodes1, nodes2;
            if (arr.length) {
                nodes1 = profile._buildItems('header1', arr);
                profile.getSubNode('HCELLS1').append(nodes1);
                nodes2 = profile._buildItems('header2', arr);
                profile.getSubNode('LHCELL').addPrev(nodes2);
            }
            if (grpcols && ood.isArr(grpcols) && grpcols.length > 0) {
                grpcols = box._adjustGrpColsData(profile, grpcols);
                prop.grpCols = grpcols;
                arr2 = box._prepareGrpCols(profile, grpcols, arr);
                if (arr2 && arr2.length) {
                    nodes1 = profile._buildItems('grpCols1', arr2);
                    profile.getSubNode('GRPCELLBOX1').append(nodes1);
                    nodes2 = profile._buildItems('grpCols2', arr2);
                    profile.getSubNode('GRPCELLBOX2').append(nodes2);
                }
                box._adjustColsWidth(profile);
                box._adjustColsHeight(profile);

                profile.adjustSize();
            }
            if (rows && rows.length)
                this.setRows(rows);

            box._adjustBody(profile, 'refreshheader');

            //render
            var co = profile.properties.colOptions;
            ood.arr.each(arr, function (o) {
                if (ood.isFun(o.colRenderer || co.colRenderer))
                    (o.colRenderer || co.colRenderer).call(null, profile, o);
            });
            // move it manually
            if (prop.treeMode == 'infirstcell') {
                profile.getSubNode('HCELLA', arr[0]._serialId).prepend(
                    profile.getSubNode('LTAGCMDS')
                ).prepend(
                    profile.getSubNode('HFMARK')
                );
            }

            // clear collist cache
            if (profile.$col_pop) {
                profile.$col_pop.destroy(true);
                delete profile.$col_pop;
            }
            //clear editor cache
            ood.each(profile.$cache_editor, function (o) {
                if (!o.destroyed) o.destroy(true);
            });
            profile.$cache_editor = {};
        },
        _toggleRows: function (rows, expand) {
            var self = this;
            if (rows && rows.length)
                ood.arr.each(rows, function (o) {
                    if (o.id) self.toggleRow(o.id, expand);
                });
        },
        autoRowHeight: function (rowId) {
            return this.each(function (prf) {
                if (prf.renderId) {
                    var ev = ood.Event;
                    if (ev.__realtouch) ev.__simulatedMousedown = 1;
                    if (rowId && prf.rowMap2[rowId])
                        prf.getSubNode('FHANDLER', prf.rowMap2[rowId]).onDblclick(true);
                    else
                        ood.each(prf.rowMap, function (o, i) {
                            prf.getSubNode('FHANDLER', i).onDblclick(true);
                        });
                    if (ev.__realtouch) ev.__simulatedMousedown = 0;
                }
            });
        },
        autoColWidth: function (colId) {
            return this.each(function (prf) {
                if (prf.renderId) {
                    var ev = ood.Event;
                    if (ev.__realtouch) ev.__simulatedMousedown = 1;

                    if (colId && prf.colMap2[colId])
                        prf.getSubNode('HHANDLER', prf.colMap2[colId]).onDblclick(true);
                    else
                        ood.each(prf.colMap, function (o, i) {
                            prf.getSubNode('HHANDLER', i).onDblclick(true);
                        });
                    if (ev.__realtouch) ev.__simulatedMousedown = 0;
                }
            });
        },
        autoColHeight: function () {
            return this.each(function (prf) {
                if (prf.renderId) {
                    var ev = ood.Event;
                    if (ev.__realtouch) ev.__simulatedMousedown = 1;
                    prf.getSubNode('FHANDLER').onDblclick(true);
                    if (ev.__realtouch) ev.__simulatedMousedown = 0;
                }
            });
        },
        addHotRow: function (focusColId) {
            var prf = this.get(0);
            if (prf.renderId)
                prf.box._addTempRow(prf, focusColId || null);
            return this;
        },
        getHotRow: function (type) {
            return this.getRowbyRowId(this.Class._temprowid, type);
        },
        updateHotRow: function (cells, dirtyMark, triggerEvent) {
            return this.updateRow(this.Class._temprowid, {cells: cells}, dirtyMark, triggerEvent);
        },
        removeHotRow: function () {
            var profile = this.get(0);
            profile.box._sethotrowoutterblur(profile, true);
            delete profile.__hastmpRow;
            this.removeRows([profile.box._temprowid], false);
            return this;
        },
        isDirtied: function () {
            var dirty = false, prf = this.get(0);
            // check grid (for delete)
            if (prf._dirty) return true;
            // check row (for new row)
            ood.each(prf.rowMap, function (v) {
                if (v._dirty || v._oValue !== v.value || (('unit' in v) && v._oUnit !== v.unit)) {
                    dirty = true;
                    return false;
                }
            });
            // check cell
            ood.each(prf.cellMap, function (v) {
                if (v._dirty || v._oValue !== v.value || (('unit' in v) && v._oUnit !== v.unit)) {
                    dirty = true;
                    return false;
                }
            });
            return dirty;
        },
        isCellDirtied: function (cell) {
            return cell._dirty || cell._oValue !== cell.value || (('unit' in cell) && cell._oUnit !== cell.unit);
        },
        isRowDirtied: function (row) {
            var ns = this, dirty = row._dirty || row._oValue !== row.value;
            if (prf._dirty) return true;
            for (var i = 0, l = row.cells.length; i < l; i++) {
                if (ns.isCellDirtied(cell))
                    return true;
            }
            return false;
        },
        _getObjByDom: function (src, type) {
            var prf = this.get(0),
                subId = prf.getSubId(typeof src == 'string'
                    ? src.charAt(0) == '!'
                        ? ((src = ood.use(src).get(0)) && src.id)
                        : src
                    : src.id);
            return prf[type == "row" ? "rowMap" : type == "col" ? "colMap" : "cellMap"][subId];
        },
        getRowByDom: function (src, type, splitMixColumn) {
            return this.get(0).box._getRow(this.get(0), this._getObjByDom(src, "row"), type, splitMixColumn);
        },
        getHeaderByDom: function (src) {
            return this._getObjByDom(src, "col");
        },
        getCellByDom: function (src) {
            return this._getObjByDom(src, "cell");
        },
        /*rows related*/
        //type: 'original', 'data', 'map', 'min'
        getRows: function (type, splitMixColumn) {
            var v = this.get(0).properties.rows, a, b, profile = this.get(0);
            if (!ood.isArr(v)) return [];
            if (type == 'data' || type == 'min' || type == 'map' || type == 'value') {
                a = ood.clone(v, true);

                if (a && a.length && a[a.length - 1] && a[a.length - 1].id == this.constructor._temprowid)
                    a.pop();
                if (type == 'value') {

                    var rowValues = [];
                    ood.arr.each(v, function (o, i) {
                        var row = profile.box._getRow(profile, o, type, splitMixColumn);
                        rowValues.push(row)
                    });
                    a = rowValues;

                }
                if (type == 'min') {
                    ood.arr.each(a, function (o, i) {
                        if (a[i].cells) {
                            ood.each(b = a[i] = a[i].cells, function (v, j) {
                                b[j] = v.value;
                            });
                        }
                    });
                } else if (type == 'map') {
                    a = this.getRawData(null, splitMixColumn);
                }
                return a;
            } else
                return v;
        },
        getRowbyRowId: function (rowId, type, splitMixColumn) {
            var profile = this.get(0), v = profile.rowMap2, rows = profile.properties.rows, t;
            if (ood.isNumb(rowId)) rowId = ood.get(rows, [rowId == -1 ? (rows.length - 1) : rowId, "id"]);
            if (v && v[rowId])
                return profile.box._getRow(profile, profile.rowMap[v[rowId]], type, splitMixColumn);
            if ((v = profile.queryItems(rows, function (v, k) {
                return v.id == rowId;
            }, 1, 1)) && v.length)
                return profile.box._getRow(profile, v[0], type, splitMixColumn);
        },
        getRowbyCell: function (cell, type, splitMixColumn) {
            return this.constructor._getRow(this.get(0), cell._row, type, splitMixColumn);
        },
        toggleRow: function (rowId, expand, recursive, stopanim, callback) {
            var ns = this, profile = this.get(0), self = arguments.callee,
                v = profile.rowMap2, rows = profile.properties.rows;
            if (ood.isNumb(rowId)) rowId = ood.get(rows, [rowId == -1 ? (rows.length - 1) : rowId, "id"]);
            if (v && v[rowId]) {
                var row = profile.rowMap[v[rowId]];
                if (row && row.sub && (!ood.isSet(expand) || !!expand !== !!row._checked)) {
                    profile.box._setSub(profile, row, ood.isSet(expand) ? !!expand : !row._checked, recursive, stopanim || recursive, callback);
                }
            } else {
                ood.arr.each(rows, function (row) {
                    if (row.sub)
                        self.call(ns, row.id, expand, recursive, true, callback);
                })
            }
            return this;
        },
        showRows: function (rowId, /*default is the current*/ show) {
            var ns = this,
                profile = ns.get(0),
                showNodes = ood(),
                hideNodes = ood(),
                prop = profile.properties;
            rowId = ood.isHash(rowId) ? rowId.id : ood.isArr(rowId) ? rowId : rowId === 0 ? [0] : rowId ? (rowId + '').split(prop.valueSeparator) : null;
            if (!rowId) {
                rowId = ood.get(ns.getActiveRow(), "id") || ((prop.$UIvalue || prop.value) + "");
                rowId = rowId.split(prop.valueSeparator);
            }
            if (rowId && rowId.length) {
                ood.arr.each(rowId, function (r, row) {
                    if (row = ns.getRowbyRowId(r)) {
                        if (show === false) {
                            if (!row.hidden) hideNodes.merge(ns.getSubNodes(['ROW1', 'ROW2'], row._serialId));
                        } else {
                            if (row.hidden) showNodes.merge(ns.getSubNodes(['ROW1', 'ROW2'], row._serialId));
                        }
                        row.hidden = show === false;
                    }
                });
            }

            // reflect to dom
            if (!showNodes.isEmpty()) showNodes.css('display', '');
            if (!hideNodes.isEmpty()) hideNodes.css('display', 'none');
            return this;
        },
        updateRow: function (rowId/*default is the current*/, options, dirtyMark, triggerEvent) {
            var ns = this,
                profile = ns.get(0),
                box = profile.box,
                prop = profile.properties,
                prforow;

            if (!rowId && rowId !== 0) rowId = ood.get(ns.getActiveRow(), "id") || ((prop.$UIvalue || prop.value) + "").split(prop.valueSeparator)[0];
            orow = ns.getRowbyRowId(rowId);
            if (!orow) return ns;

            var pdm = prop.dirtyMark,
                psdm = pdm && prop.showDirtyMark,
                ishotrow = orow.id == box._temprowid,
                sc = ood.absObj.$specialChars,
                ext;


            if (!ood.isHash(options)) {
                if (ood.isArr(options)) options = {cells: options};
                else options = {value: options};
            }

            options = ood.filter(options, function (o, i, r) {
                r = !sc[i.charAt(0)];
                if (!r) {
                    ext = ext || {};
                    ext[i] = o
                }
                return r;
            });

            if (triggerEvent) {
                if (profile.beforeRowUpdated && false === profile.boxing().beforeRowUpdated(profile, orow, options, ishotrow, ext))
                    return;
            }
            if (!ood.isEmpty(options)) {
                if (orow) {
                    var rid = orow._serialId, t, tt, nid;

                    // [[modify id
                    if (ood.isSet(options.id)) options.id += "";
                    if (options.id && options.id !== rowId) {
                        nid = options.id;
                        var m2 = profile.rowMap2, v;
                        if (!m2[nid]) {
                            if (v = m2[rowId]) {
                                m2[nid] = v;
                                delete m2[rowId];
                                profile.rowMap[v].id = nid;
                                // modify cells link
                                ood.each(profile.colMap, function (o) {
                                    if (o = o._cells) {
                                        o[nid] = o[rowId];
                                        delete o[rowId];
                                    }
                                });
                            }
                        }
                    } else {
                        options.id = rowId;
                    }
                    // modify id only
                    if (ood.isEmpty(options))
                        return ns;
                    //]]

                    // need to refresh
                    if (('group' in options && options.group != orow.group) ||
                        'cells' in options ||
                        ('sub' in options &&
                            // only try to show/hide toggle icon
                            !((options.sub === true && !orow.sub) || (!options.sub && orow.sub === true)))
                    ) {
                        var id = "__special", pid = orow._pid ? profile.rowMap[orow._pid].id : null;
                        // change id in rowMap
                        orow.id = id;
                        // change link in rowMap2
                        profile.rowMap2[id] = profile.rowMap2[nid || rowId];
                        delete profile.rowMap2[nid || rowId];
                        // remove cells link
                        ood.each(profile.colMap, function (o) {
                            if (o = o._cells)
                                delete o[nid || rowId];
                        });
                        // make sure data
                        orow = ood.clone(orow, true);
                        ood.merge(orow, options, 'all');
                        if ('sub' in options && !options.sub) delete orow.sub;

                        ns.insertRows([orow], pid, id, true);
                        ns.removeRows([id]);

                        if (profile.properties.activeMode == 'row') {
                            var uiv = profile.properties.$UIvalue || "",
                                arr = ('' + uiv).split(profile.properties.valueSeparator);
                            if (arr.length && ood.arr.indexOf(arr, rowId) != -1) {
                                if (nid)
                                    ood.arr.removeValue(arr, rowId);
                                ns.setUIValue(arr.join(profile.properties.valueSeparator), true, null, 'sub');
                            }
                        }
                    } else {
                        if ('sub' in options) {
                            t = box._getToggleNode(profile, rid);
                            if (options.sub) {
                                t.addClass('ood-uicmd-toggle');
                                if (orow._layer)
                                    t.removeClass('ood-uicmd-empty');
                            } else {
                                t.removeClass('ood-uicmd-toggle');
                                if (orow._layer)
                                    t.addClass('ood-uicmd-empty');
                            }
                        }
                        //
                        tt = ns.getSubNodes(['CELLS1', 'CELLS2'], rid);
                        if (t = profile.$px(options.height)) profile.box._adjusteditorH(profile, tt.height(orow._rowHeight = profile.$forceu(t)), t);
                        if (t = options.rowStyle) tt.attr('style', tt.attr('style') + ";" + t);
                        if (t = options.rowClass) tt.addClass(t);
                        if (options.hasOwnProperty('disabled')) {
                            var cls = 'ood-uicell-disabled';
                            if (options.disabled)
                                tt.addClass(cls);
                            else
                                tt.removeClass(cls);
                        }
                        if (options.hasOwnProperty('readonly')) {
                            var cls = 'ood-ui-readonly';
                            if (options.readonly)
                                tt.addClass(cls);
                            else
                                tt.removeClass(cls);
                        }
                        //
                        if (t = options.firstCellStyle) (tt = ns.getSubNode('FCELL', rid)).first().attr('style', tt.attr('style') + ";" + t);
                        if (t = options.firstCellClass) ns.getSubNode('FCELL', rid).first().addClass(t);

                        if (options.hasOwnProperty('value') && !ood.isSet(options.caption)) {
                            options.caption = options.value + "";
                        }
                        if (options.hasOwnProperty('caption'))
                            ns.getSubNode('FCELLCAPTION', rid).get(0).innerHTML = options.caption || "";

                        if (options.hasOwnProperty('rowResizer')) {
                            t = !!options.rowResizer;
                            ns.getSubNode('FHANDLER', rid).css('display', (options.rowResizer = t) ? "block" : 'none');
                        }

                        if (options.hasOwnProperty('hidden')) {
                            var b = !!options.hidden;
                            if (b) {
                                if (orow.hidden !== true) {
                                    ns.getSubNodes(['ROW1', 'ROW2'], rid).css('display', 'none');
                                }
                            } else {
                                if (orow.hidden === true) {
                                    ns.getSubNodes(['ROW1', 'ROW2'], rid).css('display', '');
                                }
                            }
                        }

                        ood.merge(orow, options, 'all');

                        //if update value
                        if (options.hasOwnProperty('value')) {
                            var node = profile.getSubNode('CELLA', rid);
                            if (!pdm || dirtyMark === false)
                                orow._oValue = orow.value;
                            else {
                                if (orow.value === orow._oValue) {
                                    if (psdm)
                                        node.removeClass('ood-ui-dirty');
                                } else {
                                    if (psdm)
                                        node.addClass('ood-ui-dirty');
                                }
                            }
                            if (orow._editor) orow._editor.setValue(options.value, true, 'editorini');
                        }
                    }
                } else {
                    var rst = ns.get(0).queryItems(ns.getRows(), function (o) {
                        return typeof o == 'object' ? o.id === rowId : o == rowId
                    }, true, true, true);
                    if (rst.length)
                        ood.merge(orow = rst[0][0], options, 'all');
                }
                orow._dirty = true;
            }
            if (triggerEvent) {
                if (profile.afterRowUpdated)
                    profile.boxing().afterRowUpdated(profile, orow, options, ishotrow, ext);
            }
            return ns;
        },
        //pid,base are id
        insertRows: function (arr, pid/*true: the current item*/, base/*true: the current item*/, before, ignoreMixColumn) {
            var affectUI = arguments[4],
                ns = this,
                c = ns.constructor,
                profile = ns.get(0);
            if (ood.isHash(arr)) arr = [arr];
            if (arr && ood.isArr(arr) && arr.length > 0) {
                var prop = profile.properties,
                    row_m = profile.rowMap2,
                    ro = prop.rowOptions,
                    b = profile.rowMap, temp,
                    tar, t, k;
                // current
                if (pid === true) {
                    v = prop.$UIvalue || prop.value;
                    if (v) v = (v + '').split(prop.valueSeparator);
                    pid = v[0];
                }

                pid = row_m && row_m[pid];
                if (base === true) {
                    v = prop.$UIvalue || prop.value;
                    if (v) v = (v + '').split(prop.valueSeparator);
                    base = v[0];
                }
                base = row_m && row_m[base];
                if (base) {
                    t = profile.rowMap[base];
                    if (t) pid = t._pid;
                }
                arr = c._adjustRows(profile, arr, ignoreMixColumn);
                if (!pid)
                    tar = ood.isArr(prop.rows) ? prop.rows : (prop.rows = []);
                else {
                    k = b && b[pid];
                    tar = ood.isArr(k.sub) ? k.sub : (k.sub = []);
                }

                //1
                var rows;
                if (profile.renderId) {
                    // if insert to root, or the parent node is inited
                    if (!pid || k._inited) {
                        //prepareData(add links)
                        temp = [];
                        rows = c._prepareItems(profile, arr, pid, temp);
                        ns._insertRowsToDom(profile, rows, pid, base, before, temp);

                        //render
                        ood.arr.each(arr, function (o) {
                            if (ood.isFun(o.rowRenderer || ro.rowRenderer))
                                (o.rowRenderer || ro.rowRenderer).call(null, profile, o);
                        });
                    }
                    // normal row to tree row
                    else if (pid && !k.inited) {
                        profile.box._getToggleNode(profile, pid)
                            .removeClass('ood-icon-placeholder ood-uicmd-none')
                            .addClass('ood-uicmd-toggle');
                    }
                }
                //2
                //must be here
                if (!base)
                    ood.arr.insertAny(tar, arr, before ? 0 : -1);
                else {
                    var index = ood.arr.subIndexOf(tar, '_serialId', base);
                    ood.arr.insertAny(tar, arr, before ? index : (index + 1));
                }
                //3
                if (profile.renderId) {
                    profile.box._asy(profile);
                }

                if (rows && rows.length) {
                    ood.breakO(rows, 2);
                    rows.length = 0;
                }
            }
            if (affectUI !== false && profile.renderId && profile.__hastmpRow) {
                profile.box.__ensurehotrow(profile, null);
            }

            // try to hide ui-no-children row
            // logic must same to doFilter
            if (profile.$itemFilter) {
                var hideRows = [];
                ood.arr.each(arr, function (row) {
                    if (row.sub && !row.hidden) {
                        //  if(!row._checked && row.id)
                        //      ns.toggleRow(row.id, true, false, true);
                        if (true !== profile.$itemFilter(row, 'checkSub', profile)) {
                            var flag;
                            for (var i = 0, l = row.sub.length; i < l; i++) {
                                if (!row.sub[i].hidden) {
                                    flag = 1;
                                    break;
                                }
                            }
                            if (!flag) hideRows.push(row.id);
                        } else {
                            hideRows.push(row.id);
                        }
                    }
                });
                if (hideRows.length) ns.showRows(hideRows, false);
            }
            return ns;
        },
        doFilter: ood.absList.prototype.doFilter,
        //delete row according to id
        //ood.UI.TreeGrid.getAll().removeRows(['2','5'])
        removeRows: function (ids/*default is the current*/) {
            var affectUI = arguments[1],
                self = this,
                profile = self.get(0);
            if (!profile.rowMap2) return;

            var p = profile.properties,
                cell = profile.cellMap,
                nodes = [], v, count = 0;

            //get array
            ids = ood.isHash(ids) ? [ids.id] : ood.isArr(ids) ? ids : ids === 0 ? [0] : ids ? (ids + "").split(p.valueSeparator) : null;
            if (!ids) {
                ids = ood.get(self.getActiveRow(), "id") || ((p.$UIvalue || p.value) + "");
                ids = ids.split(p.valueSeparator);
            }
            if (!ids || !ids.length) return self;

            ood.arr.each(ids, function (o, i) {
                if (ood.isNumb(o))
                    o = p.rows[o] && p.rows[o].id;
                ids[i] = '' + o;
            });
            ood.arr.each(ids, function (id) {
                //get item id
                if (id = profile.rowMap2[id]) {
                    count++;
                    //get row
                    var row;
                    if (row = profile.rowMap[id]) {
                        var tdids = row._cells,
                            rowid = row.id,
                            temp;
                        //for sub delete
                        if (row.sub && ood.isArr(row.sub)) {
                            var arr = [];
                            ood.arr.each(row.sub, function (o) {
                                arr.push(o.id)
                            });
                            self.removeRows(arr);
                        }

                        ////delete and clear links
                        ood.each(tdids, function (o, i) {
                            //clear colMap/properties.header
                            delete cell[o]._col._cells[rowid];
                            ood.breakO(cell[o]);
                            //clear cellMap
                            delete cell[o];
                            profile.reclaimSubId(o.slice(3), 'cell');
                        });

                        //clear properties.row array
                        if (temp = row._pid ? (temp = profile.rowMap[row._pid]) ? temp.sub : null : profile.properties.rows)
                            if (ood.isArr(temp))
                                ood.filter(temp, function (o) {
                                    return o._serialId != id;
                                });

                        //clear profile.rowMap2
                        delete profile.rowMap2[rowid];

                        //clear rowMap
                        ood.breakO(profile.rowMap[id]);
                        delete profile.rowMap[id];

                        nodes.push(profile.getSubNode('ROW1', id).get(0));
                        nodes.push(profile.getSubNode('ROW2', id).get(0));
                    }
                    profile.reclaimSubId(id.slice(3), 'row');
                } else {
                    var f = function (rows) {
                        var index = ood.arr.subIndexOf(rows, "id", id);
                        if (index !== -1) {
                            count++;
                            ood.arr.removeFrom(rows, index);
                        }
                        ood.arr.each(rows, function (row) {
                            if (row.sub) f(row.sub);
                        });
                    };
                    f(p.rows);
                }
            });
            if (count > 0) {
                // clear UI value
                if (v = p.$UIvalue) {
                    if ((v = ('' + v).split(p.valueSeparator)).length > 1) {
                        ood.filter(v, function (o) {
                            return ood.arr.indexOf(ids, o) == -1;
                        });
                        p.$UIvalue = v.join(p.valueSeparator);
                    } else {
                        if (ood.arr.indexOf(ids, p.$UIvalue) != -1)
                            p.$UIvalue = null;
                    }
                }
                ood(nodes).remove();

                // remove activerow/cell
                if (profile.$activeCell && !ood.Dom.byId(profile.$activeCell))
                    delete profile.$activeCell;
                if (profile.$activeRow && !ood.Dom.byId(profile.$activeRow))
                    delete profile.$activeRow;

                //clear rows cache
                delete profile.$allrowscache1;
                delete profile.$allrowscache2;

                profile.box._asy(profile);
                profile.box._adjustBody(profile, 'delrow');
            }
            if (affectUI !== false && profile.renderId && profile.__hastmpRow) {
                profile.box.__ensurehotrow(profile, null);
            }
            profile._dirty = 1;
            return self;
        },
        insertCol: function (col, cells, pos) {
            var profile = this.get(0),
                prop = profile.properties,
                box = profile.box,
                rows = prop.rows,
                cell, base, colResult, cellResult;

            //// handle header
            // position
            pos = ood.isNumb(pos) ? pos : -1;
            if (pos === -1 || prop.header.length < pos) pos = prop.header.length;
            if (pos < 0) pos = 0;
            if (prop.treeMode == 'infirstcell' && pos === 0) return false;

            var leftRegion = pos <= prop.freezedColumn - 1;

            var arr = prop.grpCols;
            if (arr && ood.isArr(arr) && arr.length) {
                for (var j = 0, m = arr.length, grp; j < m; j++) {
                    grp = arr[j];
                    if (grp.from > pos) {
                        grp.from++;
                        grp['to']++;
                    } else if (pos >= grp.from && pos <= grp['to']) {
                        grp['to']++;
                    }
                }
            }

            if (profile.renderId) {
                colResult = box._parepareCol(profile, col, prop.header);
                col = colResult[0];

                // insert header
                ood.arr.insertAny(prop.header, col, pos);
                // insert dom node
                base = profile.getSubNode(leftRegion ? 'HCELLS1' : 'HCELLS2').children().get(pos - 1/*must be before LCELL*/);
                if (base)
                    ood(base).addNext(profile._buildItems(leftRegion ? 'header1' : 'header2', [colResult[1]]));

                // render
                var co = profile.properties.colOptions;
                if (ood.isFun(col.colRenderer || co.colRenderer))
                    (col.colRenderer || co.colRenderer).call(null, profile, col);

                // for adjust UI
                prop.grpCols = box._adjustGrpColsData(profile, arr);
                box._adjustColsWidth(profile);
                box._adjustColsHeight(profile);
                box._adjustBody(profile, 'addcol');
            } else {
                // insert header dir
                ood.arr.insertAny(prop.header, col, pos);
            }

            //// handle cells
            cells = ood.isArr(cells) ? cells : [];
            var k = 0, applaycell = function (rows) {
                var temp = [];
                ood.arr.each(rows, function (row, i) {
                    if (row.group) {
                        applaycell(row.sub);
                    } else {
                        cell = cells[k];
                        // this row was rendered
                        base = profile.getSubNode(leftRegion ? 'CELLS1' : 'CELLS2', row._serialId).children().get(pos - 1/*must be before LCELL*/);
                        if (base) {
                            cellResult = box._prepareCell(profile, cell, row, col, temp);

                            // original cell only
                            ood.arr.insertAny(row.cells, cellResult[0], pos);
                            // insert dom node
                            ood(base).addNext(profile._buildItems(leftRegion ? 'rows1.cells' : 'rows2.cells', [cellResult[1]]));
                        } else {
                            // insert cell dir
                            ood.arr.insertAny(row.cells, cell || {}, pos);
                        }
                    }
                    k++;
                });
                if (temp.length) {
                    ood.arr.each(temp, function (o) {
                        if (box.getCellOption(profile, o, "editable") &&
                            (box.getCellOption(profile, o, "editMode") == "inline" || box.getCellOption(profile, o, "type") == "dropbutton"))
                            box._editCell(profile, o);
                    });
                    temp.length = 0;
                }
            };
            if (rows && ood.isArr(rows)) {
                applaycell(rows);
            }
            profile._dirty = 1;
        },
        removeCols: function (ids) {
            var affectUI = arguments[1],
                self = this,
                profile = self.get(0),
                box = profile.box,
                p = profile.properties,
                cell = profile.cellMap,
                SubID = ood.UI.$tag_subId,
                nodes = [], count = 0;

            //get array
            ids = ood.isArr(ids) ? ids : (ids + "").split(p.valueSeparator);
            ood.arr.each(ids, function (o, i) {
                ids[i] = '' + o
            });
            if (ids && ids.length > 1) {
                ids.sort(function (x, y) {
                    var xx = ood.arr.indexOf(p.header, x);
                    if (xx == -1) xx = ood.arr.subIndexOf(p.header, "id", x);
                    var yy = ood.arr.indexOf(p.header, y);
                    if (yy == -1) yy = ood.arr.subIndexOf(p.header, "id", y);
                    return xx > yy ? 1 : xx === yy ? 0 : -1;
                });
            }

            var arr = p.grpCols;
            if (arr && ood.isArr(arr) && arr.length) {
                ood.arr.each(ids, function (id) {
                    var pos = ood.arr.indexOf(p.header, id);
                    if (pos == -1) pos = ood.arr.subIndexOf(p.header, "id", id);
                    if (pos == -1) return;
                    for (var j = 0, m = arr.length, grp; j < m; j++) {
                        grp = arr[j];
                        if (grp.from > pos) {
                            grp.from--;
                            grp['to']--;
                        } else if (pos >= grp.from && pos <= grp['to']) {
                            grp['to']--;
                        }
                    }
                }, null, true);

                ood.filter(arr, function (o) {
                    var r = o['to'] >= o.from;
                    if (!r && profile.renderId) {
                        profile.getSubNode(["HCELL", "HSCELL"], o[SubID]).remove();
                        delete profile.colMap[o[SubID]];
                        delete profile.colMap2[o.id];
                    }
                    return r;
                });
            }

            ood.arr.each(ids, function (id) {
                var index = ood.arr.indexOf(p.header, id);
                if (index == -1) index = ood.arr.subIndexOf(p.header, "id", id);
                if (index == -1) return;

                // clear UI and links
                if (profile.colMap2 && (id = profile.colMap2[id])) {
                    count++;
                    //get row
                    var col;
                    if (col = profile.colMap[id]) {
                        var tdids = col._cells,
                            colid = col.id;

                        ////delete and clear links
                        ood.each(tdids, function (o, i) {
                            nodes.push(profile.getSubNode('CELL', o).get(0));
                            //clear colMap/properties.header
                            delete cell[o]._row._cells[colid];
                            ood.breakO(cell[o]);
                            //clear cellMap
                            delete cell[o];
                            profile.reclaimSubId(o.slice(3), 'cell');
                        });

                        //clear profile.rowMap2
                        delete profile.colMap2[colid];

                        //clear rowMap
                        ood.breakO(profile.colMap[id]);
                        delete profile.colMap[id];
                        var t;
                        t = profile.getSubNode('HCELL', id).get(0);
                        if (t) nodes.push(t);
                        t = profile.getSubNode('HSCELL', id).get(0);
                        if (t) nodes.push(t);
                    }
                    profile.reclaimSubId(id.slice(3), 'header');
                }

                var applaycell = function (rows) {
                    ood.arr.each(rows, function (row) {
                        if (row.cells) ood.arr.removeFrom(row.cells, index);
                        if (row.sub) {
                            applaycell(row.sub);
                        }
                    });
                };
                applaycell(p.rows);

                ood.arr.removeFrom(p.header, index);
            }, null, true);
            if (count > 0) {
                ood(nodes).remove();

                // remove activerow/cell
                if (profile.$activeCell && !ood.Dom.byId(profile.$activeCell))
                    delete profile.$activeCell;

                p.grpCols = box._adjustGrpColsData(profile, arr);
                box._adjustColsWidth(profile);
                box._adjustColsHeight(profile);
                box._adjustBody(profile, 'delcol');
            }
            profile._dirty = 1;
            return self;
        },
        removeAllRows: function () {
            var affectUI = arguments[0],
                profile = this.get(0),
                box = profile.box,
                prop = profile.properties;
            if (!prop.rows || prop.rows.length < 0)
                return this;

            for (var i in profile.cellMap)
                profile.reclaimSubId(i.slice(3), 'cell');
            for (var i in profile.rowMap)
                profile.reclaimSubId(i.slice(3), 'row');

            //remove links
            ood.each(profile.colMap, function (o) {
                o._cells = {};
            });
            ood.breakO([profile.rowMap, profile.cellMap], 3);

            profile.rowMap = {};
            profile.cellMap = {};
            profile.rowMap2 = {};

            // remove activerow/cell
            delete profile.$activeCell;
            delete profile.$activeRow;

            profile.properties.rows.length = 0;
            if (profile.renderId) {
                // ensure the column header scroll to zero
                // code must same to the SCROLL->onScroll event
                if (profile.$sl != 0)
                    profile.getSubNode('HEADER2').get(0).scrollLeft = profile.$sl = 0;
                profile.getSubNodes(['SCROLL21', 'SCROLL22']).scrollTop(0).scrollLeft(0);
                profile.getSubNodes(['ROWS21', 'ROWS22']).empty();
            }
            //clear rows cache
            delete profile.$allrowscache1;
            delete profile.$allrowscache2;
            profile.properties.$UIvalue = null;

            if (affectUI !== false && profile.renderId && profile.__hastmpRow) {
                box.__ensurehotrow(profile, null);
            }

            box._adjustBody(profile, 'delrow');

            return this;
        },

        // reset all cells' value, and clear all dirty mark
        updateGridValue: function () {
            return this.each(function (profile) {
                var prop = profile.properties;
                delete profile._dirty;
                ood.each(profile.rowMap, function (v) {
                    v._oValue = v.value;
                    if ('unit' in v) v._oUnit = v.unit;
                    delete v._dirty;
                });
                ood.each(profile.cellMap, function (v) {
                    v._oValue = v.value;
                    if ('unit' in v) v._oUnit = v.unit;
                    delete v._dirty;
                });
                if (prop.dirtyMark && prop.showDirtyMark)
                    profile.getSubNode('CELLA', true).removeClass('ood-ui-dirty');
            })
        },
        updateRowValue: function (rowId) {
            var profile = this.get(0), row = this.getRowbyRowId(rowId), arr = [], prop = profile.properties;
            // for cells
            ood.arr.each(row.cells, function (o) {
                if (o._oValue !== o.value || (('unit' in o) && o._oUnit !== o.unit)) {
                    o._oValue = o.value;
                    if ('unit' in o) o._oUnit = o.unit;
                    delete o._dirty;
                    if (prop.dirtyMark)
                        arr.push(profile.getSubNode('CELLA', o._serialId).get(0));
                }
            });
            // for row
            row._oValue = row.value;
            delete row._dirty;
            if (prop.dirtyMark)
                arr.push(profile.getSubNode('CELLA', row._serialId).get(0));

            if (prop.dirtyMark && prop.showDirtyMark)
                ood(arr).removeClass('ood-ui-dirty');
        },
        updateColValue: function (colId) {
            var profile = this.get(0), col = this.getHeaderByColId(colId), arr = [], prop = profile.properties;
            ood.arr.each(col.cells, function (o) {
                if (o._oValue !== o.value || (('unit' in o) && o._oUnit !== o.unit)) {
                    o._oValue = o.value;
                    if ('unit' in o) o._oUnit = o.unit;
                    delete o._dirty;
                    if (prop.dirtyMark)
                        arr.push(profile.getSubNode('CELLA', o._serialId).get(0));
                }
            });
            if (prop.dirtyMark && prop.showDirtyMark)
                ood(arr).removeClass('ood-ui-dirty');
        },
        updateCellValue: function (cell) {
            var ns = this, profile = ns.get(0), prop = profile.properties;
            if (typeof cell == 'string') cell = ns.getCell(cell);
            if (cell._oValue !== cell.value || (('unit' in cell) && cell._oUnit !== cell.unit)) {
                cell._oValue = cell.value;
                if ('unit' in cell) cell._oUnit = cell.unit;
                delete cell._dirty;
                if (prop.dirtyMark)
                    profile.getSubNode('CELLA', cell._serialId).removeClass('ood-ui-dirty');
            }
            return ns;
        },
        //resetGridValue
        //resetRow
        //resetCol
        resetCellValue: function (cell) {
            var ns = this, profile = ns.get(0), prop = profile.properties;
            if (typeof cell == 'string') cell = ns.getCell(cell);
            if (cell._oValue !== cell.value || (('unit' in cell) && cell._oUnit !== cell.unit)) {
                cell.value = cell._oValue;
                if ('unit' in cell) cell.unit = cell._oUnit;
                delete cell._dirty;
                profile.box._renderCell(profile, cell, {}, profile.getSubNode('CELLA', cell._serialId));
            }
            return ns;
        },
        getActiveRow: function (type, splitMixColumn) {
            var ar, profile = this.get(0);
            if (profile.properties.activeMode != 'row') return;
            if (!(ar = profile.$activeRow)) return;
            ar = profile.rowMap[profile.getSubId(ar)];
            //   if(ar && ar.id && ar.id==profile.box._temprowid){
            //       ar=null;
            //  }
            return profile.box._getRow(profile, ar, type, splitMixColumn);
        },
        setActiveRow: function (rowId, disabelScroll) {
            var dr, row, profile = this.get(0);
            if (profile.properties.activeMode != 'row') return;
            // deative first
            profile.box._activeRow(profile, false);

            if (!(row = this.getRowbyRowId(rowId))) return;
            if (!(dr = profile.getSubNodes(['CELLS1', 'CELLS2'], row._serialId)).isEmpty()) {
                profile.box._activeRow(profile, dr.get(0).id);
                if (!disabelScroll) {
                    dr.scrollIntoView();
                }

            }
            return this;
        },
        getRowMap: function (rowId) {
            var prf = this.get(0), ins = prf.boxing(), p = prf.properties, t, hash;
            if (ood.isHash(rowId)) rowId = rowId.id;
            if (!ood.isSet(rowId) && prf.renderId && !prf.destroyed) {
                if (p.activeMode = "row") {
                    if (t = ins.getActiveRow()) rowId = t.id;
                } else if (p.activeMode = "cell") {
                    if (t = ins.getActiveCell()) rowId = t._row.id;
                }
            }
            return ins.getRowbyRowId(rowId, "map");
        },
        setRowMap: function (rowId, hash, dirtyMark, triggerEvent) {
            if (ood.isHash(rowId)) rowId = rowId.id;
            return this.each(function (prf) {
                var ins = prf.boxing(), p = prf.properties, t;
                if (!rowId && prf.renderId && !prf.destroyed) {
                    if (p.activeMode = "row") {
                        if (t = ins.getActiveRow()) rowId = t.id;
                    } else if (p.activeMode = "cell") {
                        if (t = ins.getActiveCell()) rowId = t._row.id;
                    }
                }
                if (rowId) {
                    var row = ins.getRowbyRowId(rowId),
                        header = ins.getHeader('min');
                    rowId = row.id;
                    // must adjust it first
                    var rows = prf.box._adjustRows(prf, [hash]),
                        cells = rows[0].cells;
                    ood.arr.each(row.cells, function (t, j) {
                        ood.isDefined(cells[j] && cells[j].value) && ins.updateCellByRowCol(rowId, header[j], cells[j], dirtyMark, triggerEvent);
                    });
                }
                p.rowMap = hash;
            });
        },
        /*column and header related*/
        //type: 'original', 'data', 'min'
        getHeader: function (type) {
            var v = this.get(0).properties.header;
            if (!ood.isArr(v)) return [];
            if (type == 'data')
                return ood.clone(v, true);
            else if (type == 'min') {
                var a = ood.clone(v, true), b;
                ood.arr.each(a, function (o, i) {
                    a[i] = o.id;
                });
                return a;
            } else
                return v;
        },
        getHeaderByColId: function (colId, type) {
            var v = this.get(0).properties.header, i;
            if (ood.isNumb(colId)) colId = ood.get(profile.properties.header, [colId, "id"]);
            i = ood.arr.subIndexOf(v, "id", colId);
            return i == -1 ? null :
                type == 'data' ? ood.clone(v[i], true) :
                    type == 'min' ? v[i].id :
                        v[i];
        },
        getHeaderByCell: function (cell, type) {
            var v = cell._col;
            return !v ? null :
                type == 'data' ? ood.clone(v, true) :
                    type == 'min' ? v.id :
                        v;
        },

        updateHeader: function (colId, options) {
            var ns = this,
                profile = ns.get(0),
                prop = profile.properties,
                colh = ns.getHeaderByColId(colId), isGroup;
            if (!colh) {
                var grpCols = prop.grpCols,
                    index = ood.arr.subIndexOf(grpCols, "id", colId);
                colh = grpCols[index];
                isGroup = true;
            }
            if (colh) {
                if (typeof options != 'object') options = {caption: options + ''};
                else ood.filter(options, true);
                delete options.id;

                if (profile.renderId) {
                    var hid = colh._serialId, t, tt, nd;
                    if (!isGroup) {
                        if (t = options.width) {
                            t = profile.$px(t);
                            var n = [];
                            nd = ns.getSubNode('HCELL', hid).get(0);
                            if (nd) n.push(nd);
                            nd = ns.getSubNode('HSCELL', hid).get(0);
                            if (nd) n.push(nd);
                            ood.each(colh._cells, function (o) {
                                n.push(ns.getSubNode('CELL', o).get(0));
                            });
                            profile.box._adjusteditorW(profile, ood(n).width(colh._colWidth = profile.$forceu(t)), t);

                            ns.getSubNode('SCROLL22').onScroll();
                            ns.constructor._adjustColsWidth(ns.get(0));
                            ns.constructor._adjustBody(ns.get(0), 'setcol');
                        }

                        //  Forward-compatible with 'visibility'
                        if (options.hasOwnProperty('visibility') && !options.hasOwnProperty('hidden'))
                            options.hidden = !options.visibility;

                        if (options.hasOwnProperty('hidden')) {
                            var b = !!options.hidden;
                            if (b) {
                                if (colh.hidden !== true) {
                                    ns.showColumn(colId, false);
                                }
                            } else {
                                if (colh.hidden === true) {
                                    ns.showColumn(colId, true);
                                }
                            }
                        }
                        if ('type' in options) {
                            delete colh.editorCacheKey;
                        }
                    }

                    if (t = options.headerStyle || options.colStyle)
                        (tt = ns.getSubNodes(['HCELLA', 'HSCELLA'], hid)).attr('style', tt.attr('style') + ";" + t);
                    if (t = options.headerClass)
                        ns.getSubNodes(['HCELLA', 'HSCELLA'], hid).addClass(t);
                    if (options.hasOwnProperty('caption'))
                        ns.getSubNodes(['HCELLCAPTION', 'HSCELLCAPTION'], hid).get(0).innerHTML = options.caption;
                    if ('colResizer' in options) {
                        t = !!options.colResizer;
                        ns.getSubNode('HHANDLER', hid).css('display', (options.colResizer = t) ? "block" : 'none');
                    }
                }

                ood.merge(colh, options, 'all');

                if ('flexSize' in options)
                    profile.adjustSize();
            }
        },
        showColumn: function (colId, flag) {
            var profile = this.get(0),
                map = profile.colMap2,
                cols = profile.colMap,
                col,
                sid,
                cells,
                nd,
                n = [];
            if (col = cols[sid = map[colId]]) {
                if (profile.beforeColShowHide && false === profile.boxing().beforeColShowHide(profile, colId, flag))
                    return false;
                nd = profile.getSubNode('HCELL', sid).get(0);
                if (nd) n.push(nd);
                nd = profile.getSubNode('HSCELL', sid).get(0);
                if (nd) n.push(nd);
                ood.each(col._cells, function (id) {
                    n.push(profile.getSubNode('CELL', id).get(0));
                });
                ood(n).css('display', (col.hidden = (flag === false ? true : false)) ? 'none' : '');

                if (profile.afterColShowHide)
                    profile.boxing().afterColShowHide(profile, colId, flag);
            }

            profile.box._adjustColsWidth(profile);
            profile.box._adjustBody(profile, 'setcol');
            return true;
        },
        sortColumn: function (colId, desc, sortby) {
            var prf = this.get(0), sId = prf.colMap2[colId], col = prf.colMap[sId];
            if (sId && col) {
                if (ood.isBool(desc))
                    col._order = !desc;
                if (ood.isFun(sortby))
                    col.sortby = sortby;
                prf.getSubNode("HCELLA", sId).onClick();
            }
            return this;
        },
        /*cell realted*/
        getCell: function (cellId, type) {
            var self = this, profile = this.get(0), v, m;
            ood.each(profile.cellMap, function (o) {
                if (o.id && o.id === cellId) {
                    cellId = o._serialId;
                    return false;
                }
            });
            v = profile.cellMap[cellId];
            return !v ? null :
                type == 'data' ? ood.merge({rowId: v._row.id, colId: v._col.id}, ood.clone(v, true)) :
                    type == 'min' ? v.value :
                        type == 'map' ? ((m = {}) && ((m[v._col.id] = v.value) || 1) && m) :
                            v;
        },
        getCellbyRowCol: function (rowId, colId, type) {
            var self = this, profile = self.get(0), v, m;
            if (ood.isNumb(rowId)) rowId = ood.get(profile.properties.rows, [rowId, "id"]);
            if (ood.isNumb(colId)) colId = ood.get(profile.properties.header, [colId, "id"]);
            v = ood.get(profile.rowMap, [profile.rowMap2[rowId], '_cells', colId]);
            v = v && profile.cellMap[v];
            if (!v) {
                var row = self.getRowbyRowId(rowId), header = self.getHeader('min'), col;
                if (row && row.cells) {
                    col = ood.arr.indexOf(header, colId);
                    if (col != -1) v = row.cells[col];
                }
            }
            return !v ? null :
                type == 'data' ? ood.merge({rowId: rowId, colId: colId}, ood.clone(v, true)) :
                    type == 'min' ? v.value :
                        type == 'map' ? ((m = {}) && ((m[colId] = v.value) || 1) && m) :
                            v;
        },
        getCells: function (rowId, colId, type) {
            var map = {};
            ood.each(this.get(0).cellMap, function (v) {
                if ((rowId ? (rowId == v._row.id) : 1) && (colId ? (colId == v._col.id) : 1)) {
                    map[v.id] = type == 'data' ? ood.merge({rowId: v._row.id, colId: v._col.id}, ood.clone(v, true)) :
                        type == 'min' ? v.value :
                            v;
                }
            });
            //dont return inner value
            return map;
        },

        updateCellByRowCol: function (rowId, colId, options, dirtyMark, triggerEvent, triggerFormula) {
            var t, self = this, con = self.constructor;
            if (t = con._getCellId(self.get(0), rowId, colId))
                con._updCell(self.get(0), t, options, dirtyMark, triggerEvent, triggerFormula);
            else {
                var row = self.getRowbyRowId(rowId), header = self.getHeader('min'), col;
                if (row && row.cells) {
                    col = ood.arr.indexOf(header, colId);
                    if (col != -1) {
                        if (!ood.isHash(row.cells[col])) row.cells[col] = {value: row.cells[col]};
                        ood.merge(row.cells[col], options);
                    }
                }
            }
            return self;
        },
        getCellPos: function (cell, excelType) {
            if (!cell || !cell._row || !cell._col) return null;
            var prf = this.get(0),
                col = ood.arr.indexOf(cell._row.cells, cell),
                row = ood.arr.indexOf(prf.properties.rows, cell._row);
            return col == -1 || row == -1 ? null : excelType ? ood.ExcelFormula.toCellId(col, row) : {
                row: row,
                col: col
            };
        },
        // 0:2 => row:0, col:2
        // A3 => row:0, col:2
        updateCellByRowCol2: function (mixedId, options, dirtyMark, triggerEvent) {
            var arr = mixedId.indexOf(":") != -1 ? mixedId.split(":") : ood.ExcelFormula.toCoordinate("A3", true),
                row = parseInt(arr[0], 10),
                col = parseInt(arr[1], 10);
            return this.updateCellByRowCol(row, col, options, dirtyMark, triggerEvent);
        },
        updateCell: function (cellId, options, dirtyMark, triggerEvent, triggerFormula) {
            var self = this, profile = this.get(0);
            ood.each(profile.cellMap, function (o) {
                if (o.id && o.id === cellId) {
                    cellId = o._serialId;
                    return false;
                }
            });
            self.constructor._updCell(profile, cellId, options, dirtyMark, triggerEvent, triggerFormula);
            return self;
        },
        editCellbyRowCol: function (rowId, colId) {
            var profile = this.get(0), con = profile.box;
            con._editCell(profile, con._getCellId(profile, rowId, colId));
            return this;
        },
        editCell: function (cell/*default is the active cell*/) {
            if (cell = cell ? cell : this.get(0).getSubId(this.get(0).$activeCell + ''))
                this.constructor._editCell(this.get(0), cell);
            return this;
        },
        // only support single line text input
        editFirstCell: function (rowId) {
            var profile = this.get(0),
                getPro = function (key) {
                    return profile.box.getCellOption(profile, row, key)
                },
                row = typeof rowId == 'string' ? (profile.rowMap[profile.rowMap2[rowId]]) : rowId,
                editor;

            if (!profile.properties.firstCellEditable || !row) return;
            if (getPro(profile, row, 'disabled') || getPro(profile, row, 'readonly')) return;
            if (!(profile && profile.renderId) || profile.destroyed) return;

            var cellNode = profile.getSubNode('FCELLCAPTION', row._serialId);
            if (!cellNode.isEmpty()) {
                if (profile.beforeIniEditor) {
                    editor = profile.boxing().beforeIniEditor(profile, row, cellNode, pp, 'row');
                    if (editor === false)
                        return;
                }

                var pp = cellNode.parent(),
                    size2 = pp.cssSize(),
                    baseNode = profile.getSubNode('BORDER'),
                    borderW = baseNode.contentBox() ? 2 : 0,
                    absPos = cellNode.offset(null, pp),
                    absPos2 = pp.offset(null, baseNode);
                // too small
                if (absPos2.left > size2.width - 8) return;

                // try to get from cache
                editor = profile.$cache_editor['firstCellEditor'];
                if (!editor || !editor['ood.UI'] || editor.isDestroyed()) {
                    editor = new ood.UI.ComboInput({type: "input", zIndex: 100});
                    profile.$cache_editor['firstCellEditor'] = editor;
                }
                editor.setWidth(size2.width - absPos.left + borderW)
                    .setHeight(size2.height + borderW)
                    .setValue(row.value || row.value || "");

                if (profile.onBeginEdit) profile.boxing().onBeginEdit(profile, row, editor, 'row');

                editor.undo = function () {
                    var editor = this, row = editor.get(0) && editor.get(0).$row;
                    // execute once
                    editor.undo = null;
                    // row dirty alert
                    if (profile.box) {
                        if (row && row._oValue !== row.value && row.id != profile.box._temprowid && profile.onRowDirtied)
                            profile.boxing().onRowDirtied(profile, row);
                    }
                    if (editor.get(0) && editor.get(0).box) {
                        // for ie's setBlurTrigger doesn't trigger onchange event
                        editor.getSubNode('INPUT').onBlur(true);
                        editor.getRoot().setBlurTrigger("tg_editor_blur:" + profile.$xid);

                        if (profile.properties) {
                            editor.beforeUnitUpdated(null).afterUIValueSet(null).beforeNextFocus(null).onCancel(null).onFileDlgOpen(null);
                            editor.setValue('', true, 'editorreset');
                        }
                        delete editor.get(0).$row;
                        delete editor.get(0)._smartnav;
                        delete editor.get(0).$editMode;
                        //don't use disply:none, firfox has many bugs about Caret or renderer
                        editor.hide();
                    }
                    if (row) delete row._editor;
                    profile.$curEditor = null;
                    if (profile.onEndEdit)
                        profile.boxing().onEndEdit(profile, row, editor, 'row');

                    // don't cache it
                    if (editor.get(0)) {
                        editor.destroy(true);
                    }

                    editor = null;
                };
                editor.afterUIValueSet(function (prf, ov, nv, force, tag) {
                    var options = {value: nv}, t;
                    if (prf.properties.hasOwnProperty("tagVar") && !ood.isEmpty(t = prf.properties.tagVar))
                        options.tagVar = t;
                    if (false !== (profile.beforeEditApply && profile.boxing().beforeEditApply(profile, row, options, editor, tag, 'row'))) {
                        profile.boxing().updateRow(row.id, {value: nv, caption: nv + ""});
                        ood.tryF(editor.undo, [], editor);
                    }
                })
                    .beforeNextFocus(function (prop, e) {
                        ood.tryF(editor.undo, [true], editor);
                        var hash = ood.Event.getEventPara(e);
                        if (hash.key == 'enter') hash.$key = 'right';
                        profile.getSubNode('CELLA', row._serialId).onKeydown(true, hash);
                        //prevent
                        return false;
                    })
                    .onCancel(function () {
                        ood.tryF(editor.undo, [], editor);
                    });

                baseNode.append(editor);

                //show editor
                editor.reBoxing().show((absPos.left + absPos2.left - 1) + 'px', (absPos2.top - 1) + 'px');

                var root = editor.getRoot();
                // For scroll to undo
                root.setBlurTrigger("tg_editor_blur:" + profile.$xid, function () {
                    ood.tryF(editor.undo, [], editor);
                    return false;
                });

                //give reference
                editor.get(0).$row = row;
                editor.get(0)._smartnav = true;
                row._editor = editor;
                profile.$curEditor = editor;

                editor.activate();
            }

            return this;
        },
        focusCellbyRowCol: function (rowId, colId) {
            var profile = this.get(0), con = profile.box,
                cellId = con._getCellId(profile, rowId, colId),
                node = profile.getSubNode('CELLA', cellId);
            if (node && node.get(0)) node.focus(true);
            return this;
        },
        focusCell: function (cell) {
            var cellId = cell._serialId;
            this.get(0).getSubNode('CELLA', cellId).focus(true);
            return this;
        },
        getActiveCell: function (type) {
            var ar, profile = this.get(0), m, v;
            if (profile.properties.activeMode != 'cell') return;
            if (!(ar = profile.$activeCell)) return;
            v = profile.cellMap[profile.getSubId(ar)];
            return !v ? null :
                type == 'data' ? ood.merge({rowId: v._row.id, colId: v._col.id}, ood.clone(v, true)) :
                    type == 'min' ? v.value :
                        type == 'map' ? ((m = {}) && ((m[v._col.id] = v.value) || 1) && m) :
                            v;
        },
        setActiveCell: function (rowId, colId) {
            var dr, cell, profile = this.get(0);
            if (profile.properties.activeMode != 'cell') return;
            // deative first
            profile.box._activeCell(profile, false);

            if (typeof rowId == 'object')
                cell = rowId;
            else
                cell = this.getCellbyRowCol(rowId, colId);

            if (!cell)
                return;

            if (!(dr = profile.getSubNode('CELL', cell._serialId)).isEmpty())
                profile.box._activeCell(profile, dr.get(0).id);
            return this;
        },

        /*others*/
        getDirtied: function (rowId, colId) {
            var map = {};
            ood.each(this.get(0).cellMap, function (v) {
                if ((v._oValue !== v.value || (('unit' in v) && v._oUnit !== v.unit)) && (rowId ? (rowId == v._row.id) : 1) && (colId ? (colId == v._col.id) : 1)) {
                    map[v.id] = {rowId: v._row.id, colId: v._col.id, value: v.value, _oValue: v._oValue};
                    if ('unit' in v) map[v.id]._oUnit = v._oUnit;
                }
            });
            //dont return inner value
            return map;
        },
        getSubNodeInGrid: function (key, rowId, colId) {
            var ns = this,
                t = (ood.isSet(rowId) && ood.isSet(colId)) ? ns.getCellbyRowCol(rowId, colId) :
                    colId ? ns.getHeaderByColId(colId) :
                        rowId ? ns.getRowbyRowId(rowId) : null;
            return ns.getSubNode(key, (t && t._serialId) || true);
        },
        getInlineEditors: function (rowId, colId) {
            var map = {};
            ood.each(this.getCells(rowId, colId), function (cell, id) {
                map[id] = cell._editor;
            });
            return map;
        },
        getEditor: function () {
            return ood.get(this.get(0), ["$curEditor"]);
        },
        updateEditor: function (value, caption, prop) {
            var editor = this.getEditor();
            if (editor) {
                if (ood.isHash(prop)) editor.setProperties(prop, true);
                if (ood.isDefined(caption)) editor.setCaption(caption, true);
                // last one
                if (ood.isDefined(value)) editor.setUIValue(value, true);
            }
            return this;
        },
        getEditCell: function () {
            return ood.get(this.get(0), ["$cellInEditor"]);
        },
        offEditor: function (refresh, ignoreInline) {
            var profile = this.get(0), editor;
            if (!profile) return;
            if (editor = profile.$curEditor) {
                ood.tryF(editor.undo, [], editor);
            }
            if (!ignoreInline)
                ood.each(profile.cellMap, function (cell) {
                    if (editor = cell._editor) {
                        editor.destroy();
                        delete cell._editor;
                    }
                });

            if (refresh) {
                var getPro = profile.box.getCellOption;
                ood.each(profile.cellMap, function (o) {
                    if (getPro(profile, o, "editable") &&
                        (getPro(profile, o, "editMode") == "inline" || getPro(profile, o, "type") == 'dropbutton'))
                        profile.box._editCell(profile, o, null, true);
                });
            }
        },
        adjustEditor: function (adjustFun) {
            var ns = this, prf = this.get(0), borderW = this.getRoot().contentBox();
            if (prf && prf.$curEditor) {
                var editor = prf.$curEditor,
                    cell = prf.$cellInEditor;
                if (typeof adjustFun == 'function') {
                    adjustFun.apply(ns, [editor, cell]);
                } else if (editor.KEY == "ood.UI.ComboInput") {
                    var cellNode = prf.getSubNode('CELL', cell.id),
                        absPos = cellNode.offset(null, prf.getSubNode('SCROLL22')),
                        size = cellNode.cssSize();
                    editor.setLeft(absPos.left - 1).setTop(absPos.top - 1)
                        .setWidth(size.width + borderW + 1).setHeight(size.height + borderW)
                        .reLayout(true);
                }
            }
            return ns;
        }
    },
    Before: function (key, parent_key, o) {
        if (key == 'ood.UI.TreeGrid') {
            this.Behaviors.CELLS1 = this.Behaviors.CELLS2;
            this.Behaviors.GCELLA = this.Behaviors.CELLA;
        }
        return arguments.callee.upper.apply(this, arguments);
    },
    Initialize: function () {
        this.addTemplateKeys(['ALT', 'PROGRESS']);
        this.getCellPro = this.getCellOption;

        var p = this.prototype;

        p.getColumn = p.getHeader;
        p.updateColumn = p.updateHeader;

        p.getColByDom = p.getHeaderByDom;
        p.getColByColId = p.getHeaderByColId;
        p.getColByCell = p.getHeaderByCell;
    },
    Static: {
        HasHtmlTableNode: 1,
        DIRYMARKICON: "DIRTYMARK",
        Templates: {
            tagName: 'div',
            style: '{_style}',
            className: '{_className} ood-treegrid',
            BORDER: {
                tagName: 'div',
                BOX: {
                    tagName: 'table',
                    cellspacing: '0',
                    cellpadding: '0',
                    className: 'ood-uibase',
                    TBODY: {
                        tagName: 'tbody',
                        TRHEADER: {
                            tagName: 'tr',
                            TDHEADER1: {
                                tagName: 'td',
                                HEADER1: {
                                    tagName: 'div',
                                    style: "{showHeader}",
                                    HI1: {
                                        tagName: 'div',
                                        HCELLS1: {
                                            tagName: 'div',
                                            style: '{headerHeight}',
                                            /*the first col (row handler) in table header*/
                                            FHCELL: {
                                                $order: 0,
                                                style: '{rowHandlerDisplay};{_row0DfW};height:{_hcellheight};',
                                                className: 'ood-uiborder-noradius ood-uibar ood-uiborder-outset {cellCls}',
                                                tabindex: '{_tabindex}',
                                                HCELLA: {
                                                    style: '{firstCellStyle};',
                                                    className: 'ood-v-wrapper ood-showfocus {firstCellClass}',
                                                    HHANDLER: {
                                                        tagName: 'div',
                                                        style: '{colDDDisplay}'
                                                    },
                                                    FHANDLER: {
                                                        tagName: 'div',
                                                        style: '{rowDDDisplay}'
                                                    },
                                                    HFMARK: {
                                                        $order: 1,
                                                        className: "ood-font",
                                                        $fonticon: "ood-font ood-uicmd-check",
                                                        style: '{_rowMarkDisplay}'
                                                    },
                                                    LTAGCMDS: {
                                                        $order: 2,
                                                        tagName: 'span',
                                                        className: 'ood-ltag-cmds',
                                                        text: "{ltagCmds}"
                                                    },
                                                    GRIDCAPTION: {
                                                        $order: 5,
                                                        text: '{gridHandlerCaption}'
                                                    },
                                                    SORT: {
                                                        className: 'oodfont',
                                                        $fonticon: 'oodfont ood-uicmd-sort',
                                                        style: '{sortDisplay}'
                                                    }
                                                }
                                            },
                                            OTHERHCELLS: {
                                                $order: 1,
                                                tagName: 'text',
                                                text: '{header1}'
                                            }
                                        },
                                        GRPCELLBOX1: {
                                            tagName: 'div',
                                            style: '{headerHeight};',
                                            GRPCELLS: {
                                                $order: 3,
                                                tagName: 'text',
                                                text: '{grpCols1}'
                                            }
                                        }
                                    }
                                }
                            },
                            TDHEADER2: {
                                tagName: 'td',
                                HEADER2: {
                                    $order: 0,
                                    tagName: 'div',
                                    className: 'ood-uibar',
                                    style: "{showHeader}",
                                    //for scroll performance
                                    HI2: {
                                        tagName: 'div',
                                        HCELLS2: {
                                            tagName: 'div',
                                            style: '{headerHeight};',
                                            OTHERHCELLS: {
                                                $order: 1,
                                                tagName: 'text',
                                                text: '{header2}'
                                            },
                                            LHCELL: {
                                                $order: 2,
                                                className: 'ood-v-wrapper ood-uibar',
                                                style: 'width:{tagCmdWidth}em;height:100%;text-align: center',
                                                LHCELLINNER: {
                                                    $order: 1,
                                                    text: '{headerTail}'
                                                },
                                                RTAGCMDS: {
                                                    $order: 1,
                                                    tagName: 'span',
                                                    className: 'ood-rtag-cmds',
                                                    text: "{rtagCmds}"
                                                }
                                            }
                                        },
                                        GRPCELLBOX2: {
                                            tagName: 'div',
                                            style: '{headerHeight};',
                                            GRPCELLS: {
                                                $order: 3,
                                                tagName: 'text',
                                                text: '{grpCols2}'
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        TRLOCKED1: {
                            tagName: 'tr',
                            TDBODY11: {
                                tagName: 'td',
                                SCROLL11: {
                                    $order: 1,
                                    tagName: 'div',
                                    className: '',
                                    BODY11: {
                                        tagName: 'div',
                                        ROWS11: {
                                            $order: 1,
                                            tagName: 'div',
                                            text: '{rows11}'
                                        }
                                    }
                                }
                            },
                            TDBODY12: {
                                tagName: 'td',
                                SCROLL12: {
                                    $order: 1,
                                    tagName: 'div',
                                    className: '{_rowfreezed}',
                                    BODY12: {
                                        tagName: 'div',
                                        ROWS12: {
                                            $order: 1,
                                            tagName: 'div',
                                            text: '{rows12}'
                                        }
                                    }
                                }
                            }
                        },
                        TRBODY: {
                            tagName: 'tr',
                            TDBODY21: {
                                tagName: 'td',
                                SCROLL21: {
                                    $order: 1,
                                    tagName: 'div',
                                    className: '{_columnfreezed}',
                                    BODY21: {
                                        tagName: 'div',
                                        ROWS21: {
                                            $order: 1,
                                            tagName: 'div',
                                            text: '{rows21}'
                                        }
                                    }
                                }
                            },
                            TDBODY22: {
                                tagName: 'td',
                                SCROLL22: {
                                    $order: 1,
                                    tagName: 'div',
                                    BODY22: {
                                        tagName: 'div',
                                        ROWS22: {
                                            $order: 1,
                                            tagName: 'div',
                                            text: '{rows22}'
                                        }
                                    }
                                }
                            }
                        },
                        TRTAIL: {
                            tagName: 'tr',
                            TDTAIL1: {
                                tagName: 'td'
                            },
                            TDTAIL2: {
                                tagName: 'td'
                            }
                        }
                    }
                },
                COLLIST: {
                    tagName: 'div',
                    COLLISTDROP: {
                        className: 'ood-font ood-special-icon',
                        $fonticon: 'ood-icon-triangle-down'
                    }
                },
                ARROW: {
                    className: 'ood-font ood-special-icon',
                    $fonticon: 'ood-icon-bigup',
                    text: '&nbsp;'
                }
            },
            DIRTYMARK: {},
            $submap: {
                /*the other header in table header*/
                header1: function (profile, template, v, tag, result, index) {
                    if (index > profile.properties.freezedColumn) return;
                    profile.colMap[v._serialId]._region = 1;
                    tag = "header";
                    ood.UI.$doTemplate(profile, template, v, tag, result);
                    return tag;
                },
                header2: function (profile, template, v, tag, result, index) {
                    if (index > profile.properties.freezedColumn) {
                        profile.colMap[v._serialId]._region = 2;
                        tag = "header";
                        ood.UI.$doTemplate(profile, template, v, tag, result);
                        return tag;
                    }
                },


                header: {
                    HCELL: {
                        style: "width:{_cellWidth};height:{_hcellheight};{colDisplay};",
                        className: 'ood-uiborder-noradius ood-uibar ood-uiborder-outset {cellCls}',
                        HCELLA: {
                            className: 'ood-v-wrapper ood-showfocus {headerClass}',
                            style: "{headerStyle};{colStyle}",
                            tabindex: '{_tabindex}',
                            HCELLCAPTION: {
                                $order: 5,
                                className: 'ood-v-node',
                                text: "{caption}"
                            },
                            SORT: {
                                className: 'ood-font',
                                $fonticon: 'ood-font ood-uicmd-sort',
                                style: '{sortDisplay}'
                            },
                            HHANDLER: {
                                $order: 2,
                                tagName: 'div',
                                style: '{colDDDisplay}'
                            }
                        }
                    }
                },
                grpCols1: function (profile, template, v, tag, result, index) {
                    var index = profile.properties.freezedColumn - 1,
                        map = profile.colMap;
                    if (v.from > index) return;
                    if (v['to'] > index) {
                        map[v._serialId]._region = 2;
                        map[v._serialId]._shadow = 1;
                        tag = "grpColsShadow";
                        ood.UI.$doTemplate(profile, template, v, tag, result);
                    } else {
                        map[v._serialId]._region = 1;
                        tag = "grpCols";
                        ood.UI.$doTemplate(profile, template, v, tag, result);
                    }
                    return tag;
                },
                grpCols2: function (profile, template, v, tag, result, index) {
                    var index = profile.properties.freezedColumn - 1;
                    if (v['to'] > index) {
                        profile.colMap[v._serialId]._region = 2;
                        tag = "grpCols";
                        ood.UI.$doTemplate(profile, template, v, tag, result);
                        return tag;
                    }
                },
                grpCols: {
                    HCELL: {
                        style: "position:absolute;width:{_cellWidth};height:{_hcellheight};top:{_hcelltop};left:{_hcellleft};",
                        className: 'ood-uiborder-noradius ood-uibar ood-uiborder-outset {cellCls}',
                        HCELLA: {
                            className: 'ood-v-wrapper ood-showfocus {headerClass}',
                            style: "{headerStyle};{colStyle}",
                            tabindex: '{_tabindex}',
                            HCELLCAPTION: {
                                $order: 5,
                                className: "ood-v-node",
                                text: "{caption}"
                            },
                            HHANDLER: {
                                $order: 2,
                                tagName: 'div',
                                style: '{colDDDisplay}'
                            }
                        }
                    }
                },
                grpColsShadow: {
                    HSCELL: {
                        style: "position:absolute;width:{_cellWidth};height:{_hcellheight};top:{_hcelltop};left:{_hcellleft};",
                        className: 'ood-uiborder-noradius ood-uibar ood-uiborder-outset {cellCls}',
                        HSCELLA: {
                            className: 'ood-v-wrapper ood-showfocus {headerClass}',
                            style: "{headerStyle};{colStyle}",
                            tabindex: '{_tabindex}',
                            HSCELLCAPTION: {
                                className: "ood-v-node",
                                text: "{caption}"
                            }
                        }
                    }
                },
                grpCols: {
                    HCELL: {
                        style: "position:absolute;width:{_cellWidth};height:{_hcellheight};top:{_hcelltop};left:{_hcellleft};",
                        className: 'ood-uiborder-noradius ood-uibar ood-uiborder-outset {cellCls}',
                        HCELLA: {
                            className: 'ood-v-wrapper ood-showfocus {headerClass}',
                            style: "{headerStyle};{colStyle}",
                            tabindex: '{_tabindex}',
                            HCELLCAPTION: {
                                $order: 5,
                                className: "ood-v-node",
                                text: "{caption}"
                            },
                            HHANDLER: {
                                $order: 2,
                                tagName: 'div',
                                style: '{colDDDisplay}'
                            }
                        }
                    }
                },
                rows11: function (profile, template, v, tag, result, index) {
                    if (profile._passFreezedRow) return false;
                    if (index > profile.properties.freezedRow) return false;
                    profile.rowMap[v._serialId]._region = 1;
                    // keep realtag for real data
                    ood.UI.$doTemplate(profile, template, v, "row1", result, index, 'rows1');
                },
                rows12: function (profile, template, v, tag, result, index) {
                    if (profile._passFreezedRow) return false;
                    if (index > profile.properties.freezedRow) return false;
                    profile.rowMap[v._serialId]._region = 1;
                    // keep realtag for real data
                    ood.UI.$doTemplate(profile, template, v, "row2", result, index, 'rows2');
                },
                rows21: function (profile, template, v, tag, result, index) {
                    if (!profile._passFreezedRow && index <= profile.properties.freezedRow) return;
                    profile.rowMap[v._serialId]._region = 2;
                    // keep realtag for real data
                    ood.UI.$doTemplate(profile, template, v, "row1", result, index, 'rows1');
                },
                rows22: function (profile, template, v, tag, result, index) {
                    if (!profile._passFreezedRow && index <= profile.properties.freezedRow) return;
                    // *** dont calculate freeeze rows again
                    profile._passFreezedRow = 1;
                    profile.rowMap[v._serialId]._region = 2;
                    // keep realtag for real data
                    ood.UI.$doTemplate(profile, template, v, "row2", result, index, 'rows2');
                },
                row1: {
                    ROW1: {
                        tagName: 'div',
                        style: '{rowDisplay}',
                        CELLS1: {
                            $order: 2,
                            tagName: 'div',
                            className: 'ood-uirowbg ood-uiborder-b {themeMode === "dark" ? "ood-uiborder-dark" : "ood-uiborder-light"} {rowCls} {rowClass}',
                            style: '{_rowHeight};{rowStyle}',
                            CELLHANDLER: {
                                tagName: 'text',
                                text: '{_handler_cell}'
                            },
                            GRPCELL2: {
                                tagName: 'text',
                                text: '{_firstcell_grp}'
                            },
                            OTHERCELLS: {
                                tagName: 'text',
                                $order: 2,
                                text: '{cells}'
                            }
                        },
                        SUB1: {
                            $order: 3,
                            tagName: 'div'
                        }
                    }
                },
                row2: {
                    ROW2: {
                        tagName: 'div',
                        style: '{rowDisplay}',
                        CELLS2: {
                            $order: 2,
                            tagName: 'div',
                            className: 'ood-uirowbg ood-uiborder-b {themeMode === "dark" ? "ood-uiborder-dark" : "ood-uiborder-light"} {rowCls} {rowClass}',
                            style: '{_rowHeight};{rowStyle}',
                            GRPCELL2: {
                                tagName: 'text',
                                text: '{_firstcell_grp}'
                            },
                            OTHERCELLS: {
                                tagName: 'text',
                                $order: 2,
                                text: '{cells}'
                            },
                            LCELL: {
                                $order: 3,
                                className: 'ood-v-wrapper',
                                LCELLINNER: {
                                    $order: 1,
                                    text: '{rowTail}'
                                },
                                RTAGCMDS: {
                                    $order: 2,
                                    tagName: 'span',
                                    className: 'ood-rtag-cmds',
                                    text: "{rtagCmds}"
                                }
                            }
                        },
                        SUB2: {
                            $order: 3,
                            tagName: 'div'
                        }
                    }
                },
                'rows1._handler_cell': function (profile, template, v, tag, result, index) {
                    ood.UI.$doTemplate(profile, template, v, profile.properties.treeMode == "infirstcell" ? "rows1._handler_cell2" : "rows1._handler_cell1", result);
                },
                'rows1._handler_cell1': {
                    FCELL: {
                        $order: 0,
                        style: '{rowHandlerDisplay};{_row0DfW};',
                        className: 'ood-uiborder-r {themeMode === "dark" ? "ood-uiborder-dark" : "ood-uiborder-light"} {cellCls}',
                        CELLA: {
                            tabindex: '{_tabindex}',
                            style: '{cellStyle}{firstCellStyle}',
                            className: 'ood-v-wrapper ood-showfocus {cellClass}{firstCellClass}',
                            MARK: {
                                $order: 1,
                                className: 'oodfont',
                                $fonticon: 'oodfont ood-uicmd-check',
                                style: '{_rowMarkDisplay}'
                            },
                            ROWLRULER: {
                                $order: 2,
                                style: '{_treeMode};{_rulerW}'
                            },
                            ROWNUM: {
                                $order: 3,
                                className: 'ood-ui-readonly',
                                style: '{_rowNumbDisplay}'
                            },
                            ROWTOGGLE: {
                                $order: 4,
                                style: '{_treeMode};',
                                className: 'oodfont',
                                $fonticon: '{_fi_togglemark}'
                            },
                            LTAGCMDS: {
                                $order: 1,
                                tagName: 'span',
                                className: 'ood-ltag-cmds',
                                style: '{_ltagDisplay}',
                                text: "{ltagCmds}"
                            },
                            FCELLCAPTION: {
                                $order: 5,
                                className: "ood-v-node",
                                text: ""
                                //  text: "{caption}"
                            },
                            FHANDLER: {
                                $order: 0,
                                tagName: 'div',
                                style: '{rowDDDisplay}'
                            }
                        }
                    }
                },
                'rows1._handler_cell2': {
                    FCELL: {
                        $order: 0,
                        style: '{rowHandlerDisplay};{_row0DfW};',
                        className: 'ood-uiborder-r ood-uiborder-light {cellCls}',
                        CELLA: {
                            tabindex: '{_tabindex}',
                            style: '{cellStyle}{firstCellStyle}',
                            className: 'ood-v-wrapper ood-showfocus {cellClass}{firstCellClass}',
                            FHANDLER: {
                                $order: 6,
                                tagName: 'div',
                                style: '{rowDDDisplay}'
                            }
                        }
                    }
                },
                'rows1._firstcell_grp': function (profile, template, v, tag, result, index) {
                    if (profile.properties.treeMode != "infirstcell") return;
                    if (!profile.properties.freezedColumn) return;
                    ood.UI.$doTemplate(profile, template, v, "rows._firstcell_grp", result);
                },
                'rows2._firstcell_grp': function (profile, template, v, tag, result, index) {
                    if (profile.properties.treeMode != "infirstcell") return;
                    if (profile.properties.freezedColumn) return;
                    ood.UI.$doTemplate(profile, template, v, "rows._firstcell_grp", result);
                },

                'rows._firstcell_grp': {
                    GCELL: {
                        $order: 0,
                        className: '{cellCls}',
                        GCELLA: {
                            tabindex: '{_tabindex}',
                            style: '{cellStyle}{firstCellStyle}',
                            className: 'ood-v-wrapper ood-showfocus {cellClass}{firstCellClass}',
                            MARK: {
                                $order: 1,
                                $customId: 1,
                                className: 'oodfont',
                                $fonticon: 'oodfont ood-uicmd-check',
                                style: '{_rowMarkDisplay}'
                            },
                            ROWLRULER: {
                                $order: 2,
                                $customId: 1,
                                style: '{_treeMode};{_rulerW}'
                            },
                            ROWNUM: {
                                $order: 3,
                                $customId: 1,
                                className: 'ood-ui-readonly',
                                style: '{_rowNumbDisplay}'
                            },
                            ROWTOGGLE: {
                                $order: 4,
                                $customId: 1,
                                style: '{_treeMode};',
                                className: 'oodfont',
                                $fonticon: '{_fi_togglemark}'
                            },
                            LTAGCMDS: {
                                $order: 1,
                                $customId: 1,
                                tagName: 'span',
                                style: '{_ltagDisplay}',
                                text: "{ltagCmds}"
                            },
                            FCELLCAPTION: {
                                $order: 5,
                                $customId: 1,
                                className: "ood-v-node",
                                text: "{caption}"
                            }
                        }
                    }
                },
                'rows1.cells': function (profile, template, v, tag, result, index) {
                    if (index > profile.properties.freezedColumn) return;
                    tag = 'rows.cells';

                    var t = profile.box._tplMap2[v.type] || '.input';
                    if (profile.properties.treeMode == 'infirstcell' && index == 1 && t == '.input') {
                        t = '._first_cell';
                    }
                    ood.UI.$doTemplate(profile, template, v, tag + t, result);

                    return tag;
                },
                'rows2.cells': function (profile, template, v, tag, result, index) {
                    if (index <= profile.properties.freezedColumn) return;
                    tag = 'rows.cells';

                    var t = profile.box._tplMap2[v.type] || '.input';
                    if (profile.properties.treeMode == 'infirstcell' && index == 1 && t == '.input') {
                        t = '._first_cell';
                    }
                    ood.UI.$doTemplate(profile, template, v, tag + t, result);

                    return tag;
                },
                'rows.cells._first_cell': {
                    CELL: {
                        style: 'width:{_cellWidth};{cellDisplay};',
                        className: 'ood-uiborder-r ood-uiborder-light ood-treegrid-fcell {cellCls}',
                        CELLA: {
                            className: 'ood-v-wrapper ood-showfocus {cellClass}',
                            style: '{bgcolor};{cellStyle}',
                            tabindex: '{_tabindex}',
                            MARK: {
                                $order: 1,
                                $customId: 1,
                                className: 'oodfont',
                                $fonticon: 'oodfont ood-uicmd-check',
                                style: '{_rowMarkDisplay}'
                            },
                            ROWLRULER: {
                                $order: 2,
                                $customId: 1,
                                style: '{_treeMode};{_rulerW}'
                            },
                            ROWNUM: {
                                $order: 3,
                                $customId: 1,
                                className: 'ood-ui-readonly',
                                style: '{_rowNumbDisplay}'
                            },
                            ROWTOGGLE: {
                                $order: 4,
                                $customId: 1,
                                style: '{_treeMode};',
                                className: 'oodfont',
                                $fonticon: '{_fi_togglemark}'
                            },
                            LTAGCMDS: {
                                $order: 1,
                                $customId: 1,
                                tagName: 'span',
                                style: '{_ltagDisplay}',
                                text: "{ltagCmds}"
                            },
                            CELLCAPTION: {
                                $order: 5,
                                style: '{color}',
                                className: 'ood-v-node ood-treegrid-fcellcaption',
                                text: "{_caption}"
                            }
                        }
                    }
                },
                'rows.cells.input': {
                    CELL: {
                        style: 'width:{_cellWidth};{cellDisplay};',
                        className: 'ood-uiborder-r ood-uiborder-light {cellCls}',
                        CELLA: {
                            className: 'ood-v-wrapper ood-showfocus {cellClass}',
                            style: '{bgcolor};{cellStyle}',
                            tabindex: '{_tabindex}',
                            CELLCAPTION: {
                                className: 'ood-v-node',
                                style: '{color}',
                                text: "{_caption}"
                            }
                        }
                    }
                },
                'rows.cells.textarea': {
                    CELL: {
                        style: 'width:{_cellWidth};{cellDisplay};',
                        className: 'ood-uiborder-r ood-uiborder-light {cellCls}',
                        CELLA: {
                            className: 'ood-v-wrapper ood-showfocus ood-cls-wordwrap {cellClass}',
                            style: '{bgcolor};{cellStyle}',
                            tabindex: '{_tabindex}',
                            CELLCAPTION: {
                                className: 'ood-v-node',
                                style: '{color}',
                                text: "{_caption}"
                            }
                        }
                    }
                },
                'rows.cells.button': {
                    CELL: {
                        style: 'width:{_cellWidth};{cellDisplay};',
                        className: 'ood-uiborder-r ood-uiborder-light {cellCls}',
                        CELLA: {
                            tagName: 'button',
                            className: 'ood-node ood-showfocus ood-wrapper ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius ood-treegrid-tgbtn {cellClass}',
                            style: '{cellStyle}',
                            tabindex: '{_tabindex}',
                            CELLCAPTION: {
                                className: 'ood-v-node',
                                text: "{_caption}"
                            }
                        }
                    }
                },
                'rows.cells.checkbox': {
                    CELL: {
                        style: 'width:{_cellWidth};{cellDisplay}',
                        className: 'ood-uiborder-r ood-uiborder-light {cellCls}',
                        CELLA: {
                            className: 'ood-v-wrapper ood-showfocus {cellClass}',
                            style: '{cellStyle}',
                            tabindex: '{_tabindex}',
                            CHECKBOX: {
                                className: 'oodfont ood-uicmd-check',
                                $fonticon: '{_fi_checkboxCls}'
                            }
                        }
                    }
                },
                'rows.cells.progress': {
                    CELL: {
                        style: 'width:{_cellWidth};{cellDisplay}',
                        className: 'ood-uiborder-r ood-uiborder-light {cellCls}',
                        CELLA: {
                            className: 'ood-showfocus {cellClass}',
                            style: '{cellStyle}',
                            tabindex: '{_tabindex}',
                            PROGRESS: {
                                $order: 2,
                                tagName: 'div',
                                className: 'ood-v-wrapper ood-uibar',
                                style: 'width:{progress};',
                                CELLCAPTION: {
                                    className: 'ood-v-node',
                                    text: "{_caption}"
                                }
                            }
                        }
                    }
                },
                'rows1._handler_cell1.ltagCmds': function (profile, template, v, tag, result) {
                    if (v.id == profile.box._temprowid) return;
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, 'rows.tagCmds' + (profile.box._tplMap[buttonType] || '.button'), result)
                },
                'rows._firstcell_grp.ltagCmds': function (profile, template, v, tag, result) {
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, 'rows.tagCmds' + (profile.box._tplMap[buttonType] || '.button'), result)
                },
                'rows.cells._first_cell.ltagCmds': function (profile, template, v, tag, result) {
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, 'rows.tagCmds' + (profile.box._tplMap[buttonType] || '.button'), result)
                },
                'rows2.rtagCmds': function (profile, template, v, tag, result) {
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, 'rows.tagCmds' + (profile.box._tplMap[buttonType] || '.button'), result)
                },
                'ltagCmds': function (profile, template, v, tag, result) {
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, "rows.tagCmds" + (profile.box._tplMap[buttonType] || '.button'), result)
                },
                'rtagCmds': function (profile, template, v, tag, result) {
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, "rows.tagCmds" + (profile.box._tplMap[buttonType] || '.button'), result)
                },
                'rows.tagCmds.text': ood.UI.$getTagCmdsTpl('text'),
                'rows.tagCmds.button': ood.UI.$getTagCmdsTpl('button'),
                'rows.tagCmds.image': ood.UI.$getTagCmdsTpl('image')
            }
        },
        Appearances: {
            KEY: {
                //in firefox, a can focused with display:block
                display: 'block',
                position: 'absolute',
                overflow: 'hidden'
            },
            'BORDER': {
                //   "border-top": "solid 1px",
                "border-bottom": "solid 1px",
                "margin": "1px 0px 1px 0px"
            },
            'LTAGCMDS, RTAGCMDS': {
                padding: 0,
                margin: 0,
                'vertical-align': 'middle'
            },
            'HFMARK, MARK': {
                'margin-left': '.5em'
            },
            DIRTYMARK: {
                position: 'absolute',
                width: "1em",
                height: "1em",
                left: "1px",
                top: "1px",
                "z-index": 10
            },
            BOX: {
                'border-collapse': 'collapse',
                height: '100%',
                width: '100%'
            },
            'HEADER1, HEADER2': {
                // 'background-color': '#EDEDED',
                position: 'relative',
                overflow: 'hidden',
                'text-align': 'left'
            },
            'HI1, HI2': {
                position: 'relative'
            },
            'GRPCELLBOX1, GRPCELLBOX2': {
                position: 'absolute',
                overflow: 'visible',
                left: 0,
                top: 0,
                width: 0,
                height: 0
            },
            'SCROLL11, SCROLL12, SCROLL21, SCROLL22': {
                position: 'relative',
                'text-align': 'left'
            },
            'SCROLL11, SCROLL12, SCROLL21': {
                overflow: 'hidden'
            },
            SCROLL22: {
                overflow: 'auto'
            },
            ARROW: {
                position: 'absolute',
                'z-index': '20',
                left: 0,
                top: 0,
                display: 'none',
                width: 'auto',
                height: 'auto',
                'font-weight': 'bold',
                'text-align': 'center',
                'font-size': '2em'
            },
            'ARROW:before': {
                'margin-left': '-50%'
            },
            COLLIST: {
                position: 'absolute',
                'z-index': '10',
                left: 0,
                top: 0,
                cursor: 'pointer',
                visibility: 'hidden'
            },
            COLLISTDROP: {
                position: 'absolute',
                left: 0,
                bottom: 0,
                cursor: 'pointer'
            },
            'BODY11, BODY12, BODY21, BODY22': {
                overflow: 'visible',
                position: 'absolute',
                left: 0,
                top: 0
            },
            SORT: {
                position: 'absolute',
                right: '.25em',
                bottom: '.25em'
            },
            HHANDLER: {
                position: 'absolute',
                //if set z-index, disappearing in opera
                //'z-index':'10',
                background: ood.browser.ie ? 'url(' + ood.ini.img_bg + ')' : null,
                width: '.5em',
                top: '0',
                right: '0',
                height: '100%',
                cursor: 'e-resize'
            },
            'HCELLS1, HCELLS2, CELLS1, CELLS2': {
                //for ie height change trigger
                'overflow-y': ood.browser.ie ? 'hidden' : '',
                position: 'relative',
                //b background: 'transparent',
                'white-space': 'nowrap'
            },
            'HCELLS1, HCELLS2, GRPCELLBOX1, GRPCELLBOX2': {
                overflow: 'visible'
            },
            'CELLS1, CELLS2': {
                overflow: 'visible'
            },
            'CELLS1-group FCELL, CELLS2-group FCELL': {
                'border-right': 0,
                'padding-right': '1px',
                overflow: 'visible'
            },
            'CELLS1-group FCELLCAPTION, CELLS1-group CELLA,  CELLS1-group GCELLA, CELLS1-group ROWNUM, CELLS2-group FCELLCAPTION, CELLS2-group CELLA, CELLS2-group GCELLA': {
                'font-weight': 'bold',
                overflow: 'visible'
            },
            'CELLS1-active, CELLS2-active, CELL-active, CELL-active CELLA': {
                $order: 5,
                color: "var(--ood-text-primary)",
                'background-color': 'var(--ood-bg-light)'
            },
            "CELLS1-hot, CELLS2-hot": {
                $order: 6,
                'background-color': 'var(--ood-warning-light)'
            },
            // hot always use CELLS2
            "CELLS2-hot LTAGCMDS, CELLS2-hot RTAGCMDS": {
                $order: 6,
                'display': 'none'
            },
            'CELLS1-checked, CELLS2-checked, CELLS1-checked .ood-node, CELLS2-checked .ood-node, CELL-checked, CELL-checked .ood-node': {
                $order: 6,
                'background-color': 'var(--ood-bg-medium)',
                color: 'var(--ood-text-inverse)'
            },
            "FCELL CELLA, GCELL GCELLA": {
                'text-align': 'left'
            },
            "FHCELL HCELLA, HSCELLA": {
                'text-align': 'center'
            },
            'CELLCAPTION,HCELLCAPTION,HSCELLCAPTION,SORT,HHANDLER': {
                'vertical-align': 'middle'
            },
            'CELLCAPTION,HCELLCAPTION,HSCELLCAPTION,FCELLCAPTION,GRIDCAPTION': {
                "max-width": "100%",
                "text-overflow": "ellipsis",
                "white-space": "nowrap",
                "overflow": "hidden",
                'font-size': '1em'
            },
            // for "text-overflow": "ellipsis",
            'FCELL FCELLCAPTION, FHCELL GRIDCAPTION': {
                display: "inline"
            },
            'CELL-textarea CELLCAPTION': {
                $order: 10,
                "white-space": "normal"
            },
            FHANDLER: {
                position: 'absolute',
                'height': '.5em',
                left: '0',
                width: '100%',
                bottom: '0',
                cursor: 'n-resize',
                'z-index': 10
            },
            'FCELLCAPTION, ROWNUM': {
                'vertical-align': 'middle',
                overflow: 'hidden'
            },
            'FHCELL, HCELL, HSCELL': {
                padding: 0,
                'vertical-align': 'middle'
            },
            'ROW1, ROW2': {
                position: 'relative',
                zoom: ood.browser.ie ? 1 : null,
                width: ood.browser.ie ? '100%' : null
            },
            ROWNUM: {
                'padding-right': '.5em'
            },
            'FCELL, CELL': {
                height: '100%',
                //firefox:height:100% without overflow:hidden
                'padding-left': '1px',
                position: 'relative',
                overflow: ood.browser.ie6 ? 'hidden' : '',
                'vertical-align': 'top',
                display: ood.$inlineBlock
            },
            'GCELL': {
                height: '100%',
                width: '100%',
                //firefox:height:100% without overflow:hidden
                'padding-left': '1px',
                position: 'relative',
                overflow: ood.browser.ie6 ? 'hidden' : '',
                'vertical-align': 'top',
                display: ood.$inlineBlock
            },
            "LHCELL, LCELL": {
                height: '100%',
                position: 'relative',
                'vertical-align': 'top'
            },
            'CELLS1-alt, CELLS2-alt': {
                $order: 1
                // 'background-color': 'var(--ood-info-light)'
            },
            //
            'CELL-input': {},
            'CELL-number, CELL-spin, CELL-currency': {
                'text-align': 'right'
            },
            'CELL-counter': {
                'text-align': 'center'
            },
            'CELL-checkbox': {
                'text-align': 'center'
            },
            'KEY-tgbtn': {
                $order: 100,
                width: '100%',
                padding: 0,
                'vertical-align': 'text-bottom',
                'line-height': '100%',
                height: '100%'
            },
            'CELLS1-hover, CELLS2-hover': {
                $order: 4,
                color: "#000000",
                'background-color': 'var(--ood-bg-lighter)'

            },
            'CELL-hover, CELL-hover .ood-node[class*="ood-treegrid-"]': {
                $order: 5,
                'background-color': 'var(--ood-bg-medium) '
            },
            'FCELL CELLA, GCELL GCELLA, HCELLA, HSCELLA': {
                position: 'relative',
                "text-overflow": "ellipsis"
            },
            'HCELLA, HSCELLA': {
                $order: 3,
                'text-align': 'center',
                'vertical-align': 'middle',
                'line-height': 'inherit'
            },
            'HCELLA, HSCELLA, CELLA, GCELLA': {
                display: 'block',
                overflow: 'hidden',
                '-moz-box-flex': '1',
                'outline-offset': '-1px',
                '-moz-outline-offset': (ood.browser.gek && ood.browser.ver < 3) ? '-1px !important' : null,
                height: '100%',
                //ie need this
                width: ood.browser.ie ? '100%' : '',
                // depends on parent
                'line-height': 'inherit'
            },
            'CELLA-inline': {
                $order: 5,
                display: ood.$inlineBlock,
                width: 'auto',
                '-moz-box-flex': 0
            },
            PROGRESS: {
                border: 'none',
                height: '100%',
                'line-height': '1.83333em',
                overflow: 'visible',
                opacity: 0.7,
                '*filter': 'alpha(opacity=70)'
            },
            'PROGRESS CELLCAPTION': {
                overflow: 'visible'
            },
            'CHECKBOX, MARK': {
                cursor: 'pointer',
                'vertical-align': 'middle'
            },
            'SUB1, SUM22': {
                //for ie bug: relative , height='auto' will disppear
                zoom: ood.browser.ie ? 1 : null,
                height: 0,
                position: 'relative',
                overflow: 'visible'
            },
            ROWTOGGLE: {
                padding: '0 .334em 0 0'
            }
        },
        _objectProp: {rowOptions: 1, colOptions: 1},
        Behaviors: {
            //don't add cell in HoverEffected, for 'hover' editMode
            HoverEffected: {
                ROWTOGGLE: 'ROWTOGGLE',
                GCELL: 'GCELL',
                CELL: 'CELL',
                HCELL: ['HCELL', 'HSCELL'],
                HSCELL: ['HCELL', 'HSCELL'],
                FHCELL: 'FHCELL',
                FCELL: 'FHCELL',
                CMD: 'CMD',
                SCROLL22: "SCROLL22",
                BODY11: "BODY11",
                BODY12: "BODY12",
                BODY21: "BODY22",
                BODY11: "BODY22",
                HEADER1: "HEADER1",
                HEADER2: "HEADER2"
            },
            ClickEffected: {
                ROWTOGGLE: 'ROWTOGGLE',
                GCELL: 'GCELL',
                CELL: 'CELL',
                HCELL: ['HCELL', 'HSCELL'],
                HSCELL: ['HCELL', 'HSCELL'],
                CMD: 'CMD'
            },
            DraggableKeys: ['FCELL'],
            DroppableKeys: ['SCROLL21', 'SCROLL22', 'CELLS1', 'CELLS2', 'FCELL'],
            HFMARK: {
                onClick: function (profile, e, src) {
                    if (profile.properties.selMode != 'multi' && profile.properties.selMode != 'multibycheckbox') return;

                    var rows = [];
                    ood.each(profile.rowMap, function (o) {
                        rows.push(o.id);
                    });

                    if (profile._$checkAll) {
                        delete profile._$checkAll;
                        profile.boxing().setUIValue("", null, null, 'checkbox');
                        ood.use(src).tagClass('-checked', false);
                        profile.boxing().onRowSelected(profile, "allrows", e, src, -1);
                    } else {
                        profile._$checkAll = true;
                        ood.use(src).tagClass('-checked');
                        profile.boxing().setUIValue(rows.join(profile.properties.valueSeparator), null, null, 'click');
                        profile.boxing().onRowSelected(profile, "allrows", e, src, 1);
                    }
                    return false;
                }
            },
            TRLOCKED1: {
                onMouseover: function (profile, e, src) {
                    profile.box.$cancelHoverEditor(profile);
                }
            },
            TRTAIL: {
                onMouseover: function (profile, e, src) {
                    profile.box.$cancelHoverEditor(profile);
                }
            },
            TDBODY21: {
                onMouseover: function (profile, e, src) {
                    profile.box.$cancelHoverEditor(profile);
                }
            },
            TRHEADER: {
                onMouseover: function (profile, e, src) {
                    profile.box.$cancelHoverEditor(profile);
                }
            },
            SCROLL22: {
                onScroll: function (profile, e, src) {
                    var node = ood.use(src).get(0),
                        l = node.scrollLeft || 0,
                        t = node.scrollTop || 0;
                    if (profile.$sl != l) {
                        profile.getSubNodes(['HEADER2', 'SCROLL12']).scrollLeft(profile.$sl = l);
                    }
                    if (profile.$st != t) {
                        profile.getSubNode('SCROLL21').get(0).scrollTop = profile.$st = t;
                        //for IE11's scrollbar bug
                        if ((t = profile.getSubNode('SCROLL21').get(0).scrollTop) && t != profile.$st) {
                            node.scrollTop = profile.$st = t;
                        }
                    }
                }
            },
            SCROLL21: {
                onScroll: function (profile, e, src) {
                    var node = ood.use(src).get(0),
                        t = node.scrollTop || 0;
                    if (profile.$st != t)
                        profile.getSubNode('SCROLL22').get(0).scrollTop = profile.$st = t;
                }
            },
            HEADER2: {
                onScroll: function (profile, e, src) {
                    var node = ood.use(src).get(0),
                        l = node.scrollLeft || 0;
                    if (profile.$sl != l)
                        profile.getSubNodes(['SCROLL12', 'SCROLL22']).scrollLeft(profile.$sl = l);
                }
            },
            SCROLL12: {
                onScroll: function (profile, e, src) {
                    var node = ood.use(src).get(0),
                        l = node.scrollLeft || 0;
                    if (profile.$sl != l)
                        profile.getSubNodes(['HEADER2', 'SCROLL22']).scrollLeft(profile.$sl = l);
                }
            },
            //colomn resizer
            HHANDLER: {
                beforeMousedown: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != 'left') return;
                    var p = profile.properties,
                        id = profile.getSubId(src),
                        col = profile.colMap[id], o;
                    if (col && col._isgroup) {
                        o = profile.getSubNode("HHANDLER", profile.properties.header[col["to"]]._serialId);
                    } else {
                        o = ood(src);
                    }
                    var minW = o.parent(2).width() - profile.$px(p._minColW),
                        scroll = profile.getSubNode('SCROLL22'),
                        maxW = scroll.offset().left + scroll.width() - ood.Event.getPos(e).left - 4;

                    if (p.disabled) return false;
                    if (col && col.disabled) return false;

                    o.startDrag(e, {
                        horizontalOnly: true,
                        dragType: 'blank',
                        dragDefer: 2,
                        maxLeftOffset: minW,
                        maxRightOffset: maxW,
                        targetReposition: false
                    });
                    ood.use(src).parent(2).onMouseout(true, {$force: true}).onMouseup(true);
                },
                onDragbegin: function (profile, e, src) {
                    ood.DragDrop.getProfile().proxyNode
                        .css({
                            height: profile.getRoot().height() + 'px',
                            width: '4px',
                            backgroundColor: 'var(--ood-bg-light)',
                            cursor: 'e-resize'
                        });
                },
                onDrag: function (profile, e, src) {
                    var d = ood.DragDrop, p = d.getProfile(), b = 0;
                    if (p.x <= p.restrictedLeft || p.x >= p.restrictedRight) b = true;
                    if (b) {
                        if (!profile._limited) {
                            p.proxyNode.css('backgroundColor', 'var(--ood-warning)');
                            profile._limited = true;
                        }
                    } else {
                        if (profile._limited) {
                            p.proxyNode.css('backgroundColor', 'var(--ood-bg-light)');
                            profile._limited = 0;
                        }
                    }
                },
                onDragstop: function (profile, e, src) {
                    var p = profile.properties,
                        o = ood(src).parent(2),
                        ks = profile.keys,
                        col = profile.colMap[profile.getSubId(src)],
                        oldw = o.width(),
                        w = oldw + ood.DragDrop.getProfile().offset.x,
                        emw;
                    if (col) {
                        if (col && col._isgroup) {
                            col = profile.properties.header[col['to']];
                            o = profile.getSubNode("HCELL", col._serialId);
                        }
                        if (col.hasOwnProperty('maxWidth')) w = Math.min(profile.$px(col.maxWidth), w);
                        if (col.hasOwnProperty('minWidth')) w = Math.max(profile.$px(col.minWidth), w);
                    }

                    if (profile.beforeColResized && false === profile.boxing().beforeColResized(profile, col ? col.id : null, w)) {
                        profile._limited = 0;
                        return;
                    }
                    emw = profile.$forceu(w);
                    o.width(emw);
                    if (col) {
                        if (col.flexSize) {
                            var emw = parseFloat(col.width),
                                percent = w / profile._relAvailable,
                                oldPercent = oldw / profile._relAvailable;
                            col.width = (emw / oldPercent - emw) * percent / (1 - percent) + profile.$picku(col.width);
                        } else {
                            col.width = emw;
                        }
                        col._colWidth = emw;
                    }

                    //collect cell id
                    var ids = [], ws = [];
                    if (profile.getKey(ood.use(src).parent(2).id()) == ks.FHCELL) {
                        profile.box._setRowHanderW(profile, w);
                    } else {
                        var cells = col._cells, t;
                        ood.each(cells, function (o) {
                            if (!(t = profile.getSubNode(ks.CELL, o)).isEmpty()) ids.push(t.id());
                        });
                        profile.box._adjusteditorW(profile, ood(ids).width(emw), w);
                    }

                    if (profile.afterColResized)
                        profile.boxing().afterColResized(profile, col ? col.id : null, w);

                    profile.getSubNode('SCROLL22').onScroll();
                    profile.box._adjustColsWidth(profile);
                    profile.box._adjustBody(profile, 'setcol');
                    profile._limited = 0;
                },
                onClick: function () {
                    return false
                },
                onDblclick: function (profile, e, src) {
                    var p = profile.properties,
                        o = ood.use(src).parent(2),
                        id = profile.getSubId(src);
                    col = profile.colMap[id];

                    if (col && col._isgroup) {
                        col = profile.properties.header[col['to']];
                        o = profile.getSubNode("HCELL", col._serialId);
                    }

                    if (col && col.flexSize) return;
                    if (profile.getRootNode().clientHeight <= 0) return;

                    //for row0
                    if (profile.getKey(ood.use(src).parent(2).id()) == profile.keys.FHCELL) {
                        profile.box._setRowHanderW(profile, true);
                        return;
                    }

                    //for other rows
                    var cells = col._cells,
                        cls = profile.getClass('CELLA', '-inline'),
                        n, nodes = [], ws = [], w, emw;
                    ood.each(cells, function (o) {
                        n = profile.getSubNode('CELLA', o);
                        if (n._nodes.length) {
                            nodes.push(n.get(0));
                            ws.push(n.addClass(cls).width());
                        }
                    });
                    // for group in the first column
                    if (p.treeMode == 'infirstcell' && p.header[0] == col) {
                        profile.getSubNode("GCELLA", true).each(function (o) {
                            ws.push(ood(o).addClass(cls).width());
                            ood(o).removeClass(cls);
                        });
                    }

                    ws.push(profile.$px(p._minColW));
                    w = parseFloat(Math.max.apply(null, ws));
                    if (w > profile.$px(p._maxColW)) w = profile.$px(p._maxColW);

                    if (profile.beforeColResized && false === profile.boxing().beforeColResized(profile, col ? col.id : null, w))
                        return;

                    if (col) {
                        if (col.hasOwnProperty('maxWidth')) w = Math.min(profile.$px(col.maxWidth), w);
                        if (col.hasOwnProperty('minWidth')) w = Math.max(profile.$px(col.minWidth), w);
                    }
                    w += 2;
                    emw = profile.$forceu(w);

                    profile.box._adjusteditorW(profile, ood(nodes).parent().width(emw), w);
                    o.width(col.width = col._colWidth = emw);

                    ood(nodes).removeClass(cls);
                    if (profile.afterColResized)
                        profile.boxing().afterColResized(profile, col.id, w);

                    profile.box._adjustColsWidth(profile);
                    profile.box._adjustBody(profile, 'setcol');
                    return false;
                }
            },
            //row resizer
            FHANDLER: {
                beforeMousedown: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != 'left') return;
                    var p = profile.properties,
                        row = profile.rowMap[profile.getSubId(src)],
                        o = ood(src),
                        minH = o.parent(3).height() - profile.$px(p._minRowH),
                        scroll = profile.getSubNode('SCROLL21'),
                        maxH = scroll.offset().top + scroll.height() - ood.Event.getPos(e).top - 4;

                    if (p.disabled || (row && row.disabled)) return false;
                    o.startDrag(e, {
                        verticalOnly: true,
                        dragType: 'blank',
                        dragDefer: 2,
                        maxTopOffset: minH,
                        maxBottomOffset: maxH,
                        targetReposition: false
                    });
                    ood.use(src).parent(2).onMouseout(true, {$force: true}).onMouseup(true);
                    if (!row)
                        profile.getSubNode('COLLIST').css('visibility', 'hidden');
                },
                onDragbegin: function (profile, e, src) {
                    ood.DragDrop.getProfile().proxyNode
                        .css({
                            width: profile.getRoot().width() + 'px',
                            height: '4px',
                            backgroundColor: 'var(--ood-bg-light)',
                            cursor: 'n-resize'
                        });
                },
                onDrag: function (profile, e, src) {
                    var d = ood.DragDrop, p = d.getProfile(), b = 0;
                    if (p.y <= p.restrictedTop || p.y >= p.restrictedBottom) b = true;
                    if (b) {
                        if (!profile._limited) {
                            p.proxyNode.css('backgroundColor', 'var(--ood-warning)');
                            profile._limited = true;
                        }
                    } else {
                        if (profile._limited) {
                            p.proxyNode.css('backgroundColor', '#DDDDDD');
                            profile._limited = 0;
                        }
                    }
                },
                onDragstop: function (profile, e, src) {
                    var subId = profile.getSubId(src),
                        o = ood(src).parent(3),
                        h = o.height() + ood.DragDrop.getProfile().offset.y,
                        row = profile.rowMap[profile.getSubId(src)],
                        prop = profile.properties,
                        header = prop.header,
                        headerHeight = prop.headerHeight;

                    //for ie's weird bug
                    if (ood.browser.ie && ood.browser.ver <= 8 && h % 2 == 1) h += 1;

                    if (profile.beforeRowResized && false === profile.boxing().beforeRowResized(profile, row ? row.id : null, h)) {
                        profile._limited = 0;
                        return;
                    }
                    // use em
                    if (profile.getKey(ood.use(src).parent(2).id()) == profile.keys.FHCELL) {
                        prop.headerHeight = profile.$forceu(h);
                        profile.box._adjustColsHeight(profile);
                        profile.adjustSize();
                    } else {
                        row.height = profile.$forceu(h);
                        profile.getSubNode("CELLS2", subId).height(row.height);
                        o.height(row._rowHeight = row.height);
                        profile.box._adjusteditorH(profile, o, row._rowHeight);
                    }

                    if (profile.afterRowResized)
                        profile.boxing().afterRowResized(profile, row ? row.id : null, h);

                    profile.box._adjustBody(profile, 'setrow');

                    profile._limited = 0;
                },
                onDblclick: function (profile, e, src) {
                    var prop = profile.properties,
                        sid = profile.getSubId(src),
                        row, cells;
                    if (profile.getRootNode().clientHeight <= 0) return;

                    if (sid) {
                        row = profile.rowMap[sid];
                        cells = profile.getSubNodes(['CELLS2', 'CELLS1'], sid);
                        var h = cells.height('auto').height();

                        if (profile.beforeRowResized && false === profile.boxing().beforeRowResized(profile, row.id, h))
                            return;
                        cells.height(row.height = row._rowHeight = profile.$forceu(h));
                        profile.box._adjusteditorH(profile, cells, h);
                    } else {
                        // fake
                        var h = (profile._headerLayers || 0 + 1) * profile.$px(profile.box.$DataStruct.headerHeight);
                        if (profile.beforeRowResized && false === profile.boxing().beforeRowResized(profile, null, h))
                            return;
                        profile.box._adjustColsHeight(profile, true);

                        prop.headerHeight = profile.$forceu(h, profile.$picku(prop.headerHeight));
                        profile.adjustSize();
                    }

                    if (profile.afterRowResized)
                        profile.boxing().afterRowResized(profile, row ? row.id : null, h);

                    profile.box._adjustBody(profile, 'setrow');

                    return false;
                },
                onClick: function () {
                    return false
                }
            },
            //mark click for tree build
            ROWTOGGLE: {
                onClick: function (profile, e, src) {
                    var p = profile.properties, cell,
                        row = profile.rowMap[profile.getSubId(src)];
                    if (!row) {
                        cell = profile.cellMap[profile.getSubId(src)];
                        if (cell) row = cell._row;
                    }
                    if (!row) return;
                    if (p.disabled || row.disabled) return false;
                    //for selection click
                    if (!row.sub) return;

                    profile.box._setSub(profile, row, !row._checked);

                    return false;
                },
                beforeMousedown: function () {
                    return false;
                }
            },
            //HCELLA handler dragdrop
            HSCELLA: {
                onClick: function (profile, e, src) {
                    profile.getSubNode("HCELLA", profile.getSubId(src)).onClick(true);
                }
            },
            HCELLA: {
                onClick: function (profile, e, src) {
                    var p = profile.properties,
                        id = profile.getSubId(src),
                        col = profile.colMap[id];

                    if (!col) {
                        if (profile.onClickGridHandler)
                            profile.boxing().onClickGridHandler(profile, e, src);

                        if (p.disabled) return false;
                        if (!p.colSortable) return;
                    } else {
                        if (profile.onClickHeader)
                            profile.boxing().onClickHeader(profile, col, e, src);

                        if (p.disabled || col.disabled) return false;
                        if (!(col.hasOwnProperty('colSortable') ? col.colSortable : p.colSortable)) return;
                    }

                    if (col && col._isgroup) {
                        col = profile.properties.header[col.from];
                    }
                    if (profile.beforeColSorted && false === profile.boxing().beforeColSorted(profile, col))
                        return false;

                    var order = (col ? col._order : profile._order) || false,
                        type = (col ? col.type : null) || 'input',
                        sortby = col ? col.sortby : null,
                        index = col ? ood.arr.indexOf(p.header, col) : -1,
                        me = arguments.callee,
                        fun = me.fun || (me.fun = function (profile, subNode, index, type, sortby, order, lastrownode1, lastrownode2) {
                            var rows, parent1, parent2, self = arguments.callee;
                            if (subNode) {
                                rows = subNode.sub;
                                parent1 = profile.getSubNode('SUB1', subNode._serialId).get(0);
                                parent2 = profile.getSubNode('SUB2', subNode._serialId).get(0);
                            } else {
                                subNode = {_inited: true};
                                rows = profile.properties.rows;
                                parent1 = profile.getSubNode('ROWS21').get(0);
                                parent2 = profile.getSubNode('ROWS22').get(0);
                            }
                            //sor sub first
                            var a1 = [], a2 = [], a4 = [], t, ff;
                            var a11 = [], a12 = [], a31 = [], a32 = [];
                            ood.arr.each(rows, function (row) {
                                if (row._region == 1) return;

                                if (row.sub && row.sub.length > 1)
                                    self(profile, row, index, type, sortby, order, null);
                                //for short input
                                a1[a1.length] = index == -1
                                    ? row.caption
                                    : (t = row.cells) ? (t = t[index]) ? t.value : '' : row[index];
                                a4[a4.length] = index == -1
                                    ? row
                                    : (t = row.cells) ? t[index] : row[index];
                                a2[a2.length] = a2.length;
                            });
                            var sortf;
                            if (typeof sortby != 'function') {
                                switch (type) {
                                    case 'number':
                                    case 'spin':
                                    case 'counter':
                                    case 'currency':
                                        ff = function (n) {
                                            return parseFloat(n) || 0
                                        };
                                        break;
                                    case 'datetime':
                                    case 'date':
                                        ff = function (n) {
                                            return ood.isDate(n) ? n.getTime() : ood.isFinite(n) ? parseInt(n, 10) : 0
                                        };
                                        break;
                                    default:
                                        ff = function (n) {
                                            return n || ''
                                        };
                                }
                                sortf = function (x, y) {
                                    var xx = ff(a1[x]), yy = ff(a1[y]);
                                    return (xx > yy ? (order ? 1 : -1) : xx === yy ? (x > y ? -1 : 1) : (order ? -1 : 1));
                                };
                            } else {
                                sortf = function (x, y) {
                                    return sortby.apply(profile, [x, y, a1, order, index, a4]);
                                };
                            }
                            a2.sort(sortf);

                            //sort memory array
                            //sort dom node
                            var b = subNode._inited, bak = ood.copy(rows), c;
                            if (b) {
                                a11 = parent1.childNodes;
                                a12 = parent2.childNodes;
                            }
                            ood.arr.each(a2, function (o, i) {
                                rows[i] = bak[o];
                                if (b) {
                                    a31[i] = a11[o];
                                    a32[i] = a12[o];
                                }
                            });
                            if (b) {
                                var fragment1 = document.createDocumentFragment(),
                                    fragment2 = document.createDocumentFragment();
                                for (var i = 0; t = a31[i]; i++) fragment1.appendChild(t);
                                for (var i = 0; t = a32[i]; i++) fragment2.appendChild(t);

                                if (lastrownode1) {
                                    parent1.insertBefore(fragment1, lastrownode1);
                                    parent2.insertBefore(fragment2, lastrownode2);
                                } else {
                                    parent1.appendChild(fragment1);
                                    parent2.appendChild(fragment2);
                                }
                            }
                        });

                    var lastrow, lastrownode1, lastrownode2;
                    if (profile.__hastmpRow) {
                        lastrow = profile.properties.rows.pop();
                        lastrownode1 = profile.getSubNode('ROWS21').get(0).lastChild;
                        lastrownode2 = profile.getSubNode('ROWS22').get(0).lastChild;
                    }

                    fun(profile, null, index, type, sortby, order, lastrownode1, lastrownode2);

                    if (profile.__hastmpRow)
                        profile.properties.rows.push(lastrow);

                    //show sort mark
                    profile.getSubNode('SORT', true).css('display', 'none');
                    var node = (col ? profile.getSubNode('SORT', col._serialId) : profile.getSubNode('SORT')).css('display', '');
                    node.tagClass('-checked', col ? (!(col._order = !col._order)) : (!(profile._order = !profile._order)));

                    profile.box._asy(profile);

                    //clear rows cache
                    delete profile.$allrowscache1;
                    delete profile.$allrowscache2;

                    if (profile.afterColSorted)
                        profile.boxing().afterColSorted(profile, col);
                },
                beforeMousedown: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != 'left') return;

                    var p = profile.properties;
                    if (p.disabled) return;

                    var col = profile.colMap[profile.getSubId(src)];
                    if (!col || col._isgroup) return;
                    if (p.disabled || col.disabled) return false;
                    if (p.treeMode == 'infirstcell' && p.header[0] == col) return false;
                    if (!(col.hasOwnProperty('colMovable') ? col.colMovable : p.colMovable)) return;

                    //fire before event
                    if (false === profile.boxing().beforeColDrag(profile, col.id)) return;

                    var pos = ood.Event.getPos(e),
                        o = ood(src),
                        itemId = profile.getSubId(src);

                    o.startDrag(e, {
                        dragType: 'icon',
                        shadowFrom: o.parent(),
                        dragCursor: 'pointer',
                        targetLeft: pos.left + 12,
                        targetTop: pos.top + 12,
                        targetReposition: false,
                        dragDefer: 2,
                        dragKey: profile.$xid + ":col",
                        dragData: o.parent().id(),
                        tagVar: col._region
                    });
                },
                onDragbegin: function (profile, e, src) {
                    ood(src).parent().onMouseout(true, {$force: true});
                    ood(src).onMouseup(true);
                },
                beforeMouseover: function (profile, e, src) {
                    var p = profile.properties,
                        id = profile.getSubId(src),
                        col = profile.colMap[id];
                    if (!col || col._isgroup) return;
                    if (p.disabled || col.disabled) return false;

                    var dp = ood.DragDrop.getProfile();
                    if (!dp.dragData || dp.dragKey != profile.$xid + ":col") return;
                    if (dp.tagVar != col._region) return;

                    var psrc = ood.use(src).parent().xid();
                    if (false === profile.box._colDragCheck(profile, psrc)) return;
                    ood.DragDrop.setDropElement(src).setDropFace(src, 'move');
                    var nn = ood.use(psrc).get(0), left = nn.offsetLeft + (col._region == 2 ? profile._leftregionw : 0),
                        top = nn.offsetTop + nn.offsetHeight;
                    profile.getSubNode("ARROW")
                        .left(left)
                        .top(top)
                        .css("display", "block");
                },
                beforeMouseout: function (profile, e, src) {
                    var p = profile.properties,
                        id = profile.getSubId(src),
                        col = profile.colMap[id];
                    if (!col) return;
                    if (p.disabled || col.disabled) return false;

                    var dp = ood.DragDrop.getProfile();
                    if (!dp.dragData || dp.dragKey != profile.$xid + ":col") return;

                    var psrc = ood.use(src).parent().xid();
                    ood.DragDrop.setDropElement(null).setDropFace(null, 'none');
                    if (false === profile.box._colDragCheck(profile, psrc)) return;
                    profile.getSubNode("ARROW").css("display", "none");
                },
                onDrop: function (profile, e, src) {
                    var p = profile.properties,
                        box = profile.box,
                        id = profile.getSubId(src),
                        SubID = ood.UI.$tag_subId,
                        col = profile.colMap[id];
                    if (!col) return;
                    if (p.disabled || col.disabled) return false;

                    var psrc = ood.use(src).parent().xid();
                    profile.getSubNode("ARROW").css("display", "none");
                    if (false === box._colDragCheck(profile, psrc)) return;

                    //check dragData
                    var data = ood.DragDrop.getProfile().dragData,
                        fromId = data && profile.getSubId(data),
                        toId = profile.getSubId(psrc),
                        //get properties
                        map = profile.colMap,
                        fromTh = map[fromId],
                        toTh = map[toId];

                    //fire before event
                    if (false === profile.boxing().beforeColMoved(profile, fromTh.id, toTh.id)) return;

                    //remove dragover appearance
                    ood.DragDrop.setDropFace(psrc, 'none');

                    //get index in HCELL array
                    var fromIndex = ood.arr.subIndexOf(p.header, '_serialId', fromId),
                        toIndex = ood.arr.subIndexOf(p.header, '_serialId', toId);

                    //if same or same position, return
                    if (fromIndex === toIndex || fromIndex === toIndex - 1) return;

                    //reposition header dom node
                    profile.getSubNode('HCELL', toId).addPrev(ood(ood.DragDrop.getProfile().dragData));
                    //reposition cell dom nodes
                    ood.each(toTh._cells, function (o, i) {
                        profile.getSubNode('CELL', o).addPrev(profile.getSubNode('CELL', fromTh._cells[i]));
                    });

                    //update memory
                    //HCELL position
                    //keep refrence, and remove
                    var temp = p.header[fromIndex];
                    // 1. insert to right pos
                    ood.arr.insertAny(p.header, temp, toIndex);
                    // 2. then, remove
                    ood.arr.removeFrom(p.header, fromIndex + (fromIndex > toIndex ? 1 : 0));
                    //cell position rowMap
                    var allitems = profile.queryItems(p.rows, true, true);
                    ood.arr.each(allitems, function (o) {
                        //for those non-prepared data
                        o = o.cells ? o.cells : o;
                        if (!o || !ood.isArr(o)) return;
                        temp = o[fromIndex];
                        ood.arr.removeFrom(o, fromIndex);
                        ood.arr.insertAny(o, temp, toIndex);
                    });

                    // group columns
                    var arr = p.grpCols;
                    if (arr && ood.isArr(arr) && arr.length) {
                        for (var j = 0, m = arr.length, grp; j < m; j++) {
                            grp = arr[j];
                            if (grp.from > toIndex) {
                                grp.from++;
                                grp['to']++;
                            } else if (toIndex >= grp.from && toIndex <= grp['to']) {
                                grp['to']++;
                            }
                        }
                        for (var j = 0, m = arr.length, grp; j < m; j++) {
                            grp = arr[j];
                            if (grp.from > fromIndex) {
                                grp.from--;
                                grp['to']--;
                            } else if (fromIndex >= grp.from && fromIndex <= grp['to']) {
                                grp['to']--;
                            }
                        }
                        ood.filter(arr, function (o) {
                            var r = o['to'] >= o.from;
                            if (!r && profile.renderId) {
                                profile.getSubNodes(["HCELL", "HSCELL"], o[SubID]).remove();
                                delete profile.colMap[o[SubID]];
                                delete profile.colMap2[o.id];
                            }
                            return r;
                        });
                        p.grpCols = box._adjustGrpColsData(profile, arr);
                        box._adjustColsWidth(profile);
                        box._adjustColsHeight(profile);
                    }

                    //fire after event
                    profile.boxing().afterColMoved(profile, fromTh.id, toTh.id);

                    //clear rows cache
                    delete profile.$allrowscache1;
                    delete profile.$allrowscache2;
                },
                onMouseover: function (profile, e, src) {
                    var p = profile.properties,
                        id = profile.getSubId(src),
                        col = profile.colMap[id];

                    if (col) {
                        if (p.disabled || col.disabled) return false;
                        if (!(col.hasOwnProperty('colHidable') ? col.colHidable : p.colHidable)) return;
                        if (!(col.hasOwnProperty('colDroppable') ? col.colDroppable : p.colDroppable)) return;
                    } else {
                        if (p.disabled) return false;
                        if (!p.colHidable) return;
                    }

                    ood.resetRun(profile.$xid + ':collist', null);
                    var region = {},
                        pos = ood.use(src).parent().offset(null, profile.getSubNode('BOX')),
                        size = ood.use(src).parent().cssSize();
                    if (size.width < 16) return;

                    region.height = profile.$forceu(size.height);
                    region.left = profile.$forceu(pos.left);
                    region.top = profile.$forceu(pos.top);

                    profile.getSubNode('COLLIST').cssRegion(region).css('visibility', 'visible');
                },
                onMouseout: function (profile, e, src) {
                    var p = profile.properties,
                        id = profile.getSubId(src),
                        col = profile.colMap[id];

                    if (col) {
                        if (p.disabled || col.disabled) return false;
                        if (!(col.hasOwnProperty('colHidable') ? col.colHidable : p.colHidable)) return;
                    } else {
                        if (p.disabled) return false;
                        if (!p.colHidable) return;
                    }

                    ood.resetRun(profile.$xid + ':collist', function () {
                        // destroyed
                        if (!profile.box) return;
                        profile.getSubNode('COLLIST').css({
                            visibility: 'hidden',
                            left: 0 + profile.$picku(),
                            top: 0 + profile.$picku()
                        });
                    });
                },
                onContextmenu: function (profile, e, src) {
                    if (profile.onContextmenu) {
                        var sid = profile.getSubId(src);
                        return profile.boxing().onContextmenu(profile, e, src, sid ? profile.colMap[sid] : null, ood.Event.getPos(e)) !== false;
                    }
                }
            },
            COLLIST: {
                onMouseover: function (profile, e, src) {
                    ood.resetRun(profile.$xid + ':collist', null);
                },
                onMouseout: function (profile, e, src) {
                    ood.resetRun(profile.$xid + ':collist', function () {
                        // destroyed
                        if (!profile.box) return;
                        ood.use(src).css('visibility', 'hidden');
                    });
                },
                onClick: function (profile, e, src) {
                    var p = profile.properties;
                    if (!profile.$col_pop) {
                        var items = [], pop;
                        ood.arr.each(profile.properties.header, function (o) {
                            if (o.hasOwnProperty('colHidable') ? o.colHidable : p.colHidable)
                                items.push({id: o.id, caption: o.caption, type: 'checkbox', value: o.hidden !== true});
                        });
                        if (items.length) {
                            pop = profile.$col_pop = new ood.UI.PopMenu({
                                hideAfterClick: false,
                                items: items
                            }).render(true);
                            pop.onMenuSelected(function (p, i, s) {
                                var b = 1;
                                ood.arr.each(p.properties.items, function (o) {
                                    if (o.value !== false)
                                        return b = false;
                                });
                                if (!b) {
                                    profile.boxing().showColumn(i.id, i.value);
                                } else {
                                    p.getSubNodeByItemId('CHECKBOX', i.id).tagClass('-checked');
                                    i.value = true;
                                }
                            })
                        }
                    }
                    if (profile.$col_pop)
                        profile.$col_pop.pop(src);
                }
            },
            CELLS2: {
                afterMouseover: function (profile, e, src) {
                    var p = profile.properties;
                    if (p.disabled) return;
                    if (p.disableHoverEffect === true) return;
                    if (p.disableHoverEffect && /\bCELLS2\b/.test(p.disableHoverEffect || "")) return;
                    //if(p.activeMode=='row'){
                    var subid = profile.getSubId(src);
                    profile.getSubNodes(['CELLS1', 'CELLS2'], subid).tagClass('-hover');
                    if (profile.onRowHover) {
                        var row = profile.rowMap[subid];
                        profile.boxing().onRowHover(profile, row, true, e, src);
                    }
                    //}
                },
                afterMouseout: function (profile, e, src) {
                    var p = profile.properties;
                    if (p.disabled) return;
                    if (p.disableHoverEffect === true) return;
                    if (p.disableHoverEffect && /\bCELLS2\b/.test(p.disableHoverEffect || "")) return;
                    //if(p.activeMode=='row'){
                    var subid = profile.getSubId(src);
                    profile.getSubNodes(['CELLS1', 'CELLS2'], subid).tagClass('-hover', false);
                    if (profile.onRowHover) {
                        var row = profile.rowMap[subid];
                        profile.boxing().onRowHover(profile, row, false, e, src);
                    }
                    //}
                },
                onDblclick: function (profile, e, src) {
                    var p = profile.properties,
                        row = profile.rowMap[profile.getSubId(src)],
                        nn = ood.Event.getSrc(e),
                        eid = nn && (nn.id || ""),
                        ks = profile.keys,
                        ck = profile.getKey(eid);
                    while (!ck) {
                        nn = nn.offsetParent;
                        ck = profile.getKey(eid = nn.id);
                    }
                    if (!row || p.disabled || row.disabled) return false;
                    if (eid && ood.UIProfile.getFromDom(eid) != profile) return false;
                    if (ck == ks.ROWTOGGLE || ck == ks.MARK) return false;
                    if (profile.onDblclickRow) {
                        if (row) {
                            profile.box._activeRow(profile, false);
                            profile.boxing().setActiveRow(row.id, true);
                        }
                        profile.boxing().onDblclickRow(profile, row, e, src);
                    }
                    return false;
                },
                onClick: function (profile, e, src) {
                    var p = profile.properties,
                        subid = profile.getSubId(src),
                        ks = profile.keys,
                        row = profile.rowMap[subid],
                        eid = ood.Event.getSrc(e).id || "";
                    if (p.disabled || row.disabled) return false;
                    if (eid && ood.UIProfile.getFromDom(eid) != profile) return false;
                    if (profile.onClickRow) {
                        if (row) {
                            profile.boxing().setActiveRow(row.id, true);
                        }
                        profile.boxing().onClickRow(profile, row, e, src);
                        profile.boxing().swiperight(profile, row, e, src);
                    }

                }
            },
            CELL: {
                onMouseover: function (profile, e, src) {
                    if (false == profile.box.$cancelHoverEditor(profile)) return;

                    var box = profile.box, p = profile.properties, i = ood.use(src).id(), editor;
                    if (p.disableHoverEffect === true) return;
                    if (p.disableHoverEffect && /\bCELL\b/.test(p.disableHoverEffect || "")) return;
                    i = i.split(":")[2];
                    if (!i) return;
                    i = profile.cellMap[i];
                    if (!i) return;

                    if (box.getCellOption(profile, i, "disabled")) return;

                    var editMode = box.getCellOption(profile, i, "editMode");
                    if (box.getCellOption(profile, i, "editable") && ood.str.startWith(editMode, "hover")) {
                        if (editMode == 'hoversharp' && box.getCellOption(profile, i, "type") == 'file') {
                            //    profile.box.$cancelHoverEditor(profile);
                        } else {
                            //    profile.box.$cancelHoverEditor(profile);
                            ood.resetRun(profile.key + ":" + profile.$xid + ":hovereditor", function () {
                                if (profile.destroyed) return;
                                profile.box._editCell(profile, profile.getSubId(src), true);
                            });
                            return false;
                        }
                    }//else{
                     //   profile.box.$cancelHoverEditor(profile);
                    //}
                }
            },
            GCELL: {
                onMouseover: function (profile, e, src) {
                    profile.box.$cancelHoverEditor(profile);
                }
            },
            CELLA: {
                onDblclick: function (profile, e, src) {
                    var cell = profile.cellMap[profile.getSubId(src)];
                    if (!cell) return;
                    if (profile.properties.disabled) return;
                    var box = profile.box,
                        getPro = box.getCellOption,
                        type = getPro(profile, cell, 'type'),
                        disabled = getPro(profile, cell, 'disabled'),
                        editable = getPro(profile, cell, 'editable');

                    if (!disabled && (!editable || (type == 'button' || type == 'label'))) {
                        profile.boxing().onDblclickCell(profile, cell, e, src);
                        // stop to trigger row's onDblclick event
                        if (type == 'button')
                            return false;
                    }
                },
                afterMousedown: function (profile, e, src) {
                    ood.setNodeData(src, '_tmp_forcefocus');
                },
                onClick: function (profile, e, src) {
                    var p = profile.properties,
                        box = profile.box,
                        getPro = box.getCellOption,
                        cell = profile.cellMap[profile.getSubId(src)],
                        id;
                    if (cell) {
                        if (profile.properties.disabled) return false;
                        var type = getPro(profile, cell, 'type'),
                            disabled = getPro(profile, cell, 'disabled'),
                            readonly = getPro(profile, cell, 'readonly'),
                            event = getPro(profile, cell, 'event'),
                            mode = p.activeMode,
                            editable = getPro(profile, cell, 'editable');

                        if (!disabled && (!editable || (type == 'button' || type == 'label'))) {
                            if (typeof event == 'function' && false === event.call(profile._host || profile, profile, cell, null, null, e, src)) {
                            }
                            else if (profile.onClickCell)
                                profile.boxing().onClickCell(profile, cell, e, src);
                            if (type == 'button')
                                return false;
                        }
                        // checkbox is special for editor
                        if (!disabled && !readonly && type == 'checkbox')
                            if (editable) {
                                box._updCell(profile, cell, !cell.value, p.dirtyMark, true, true);

                                profile.box._trycheckrowdirty(profile, cell);

                                var ishotrow = cell._row.id == profile.box._temprowid;
                                if (ishotrow) {
                                    profile.__needchecktmprow = true;
                                    profile.box._sethotrowoutterblur(profile);
                                }
                            }

                        if (!p.editable) {
                            if (mode == 'cell') {
                                if (getPro(profile, cell, 'disabled'))
                                    return false;
                                id = ood(src).parent().id();
                                box._sel(profile, 'cell', src, id, e);
                            } else if (mode == 'row') {
                                if (p.disabled || cell._row.disabled)
                                    return false;
                                id = ood(src).parent(3).id();
                                box._sel(profile, 'row', src, id, e);
                            }
                        } else {
                            if (p.activeMode == 'row') {
                                id = ood(src).parent(3).id();
                                box._sel(profile, 'row', src, id, e);
                            }
                        }
                        // handler CELL
                    } else {
                        var row = profile.rowMap[profile.getSubId(src)];
                        if (p.disabled || row.disabled)
                            return false;
                        if (profile.keys.MARK) {
                            var ck = profile.getKey(ood.Event.getSrc(e).id || ""),
                                clickMark = ck == profile.keys.MARK;
                        }
                        if (!clickMark) {
                            if (typeof event == 'function' && false === event.call(profile._host || profile, profile, row, null, null, e, src)) {
                            }
                            else if (profile.onClickRowHandler) {
                                if (row) {
                                    profile.boxing().setActiveRow(row.id);
                                }
                                profile.boxing().onClickRowHandler(profile, row, e, src);
                            }

                            // toggle
                            if (row.group) profile.box._getToggleNode(profile, row._serialId).onClick();
                        }

                        if (p.activeMode == 'row') {
                            id = ood(src).parent(3).id();
                            box._sel(profile, 'row', src, id, e);
                        }
                    }
                    if (profile.box) {
                        if (ood.use(src).get(0)) {
                            //in some browsers: if CELLA has a child 'span', you click 'span' will not tigger to focus CELLA
                            if (!ood.getNodeData(src, '_tmp_forcefocus'))
                                profile.box._focusEvent(profile, e, src);
                        }
                    }
                },
                onFocus: function (profile, e, src) {
                    ood.setNodeData(src, '_tmp_forcefocus', 1);
                    profile.box._focusEvent(profile, e, src);
                },
                onKeydown: function (profile, e, src) {
                    var akeys = {"tab": 1, "left": 1, "right": 1, "up": 1, "down": 1},
                        keys = ood.Event.getKey(e),
                        key = keys.key;

                    if (key == 'enter') {
                        ood(src).onClick();
                        return;
                    }

                    if (!akeys[key]) return;

                    var cell = profile.cellMap[profile.getSubId(src)];
                    if (profile.beforeCellKeydown && false === profile.boxing().beforeCellKeydown(profile, cell, keys)) {
                        return false;
                    }

                    // for navigation
                    var p = profile.properties,
                        shift = keys.shiftKey,
                        ctrl = keys.ctrlKey,
                        cur = ood(src),
                        body11 = profile.getSubNode('SCROLL11'),
                        body12 = profile.getSubNode('SCROLL12'),
                        body21 = profile.getSubNode('SCROLL21'),
                        body22 = profile.getSubNode('SCROLL22'),
                        keyid = new RegExp("^" + profile.box.$Keys.CELLA + ":" + profile.serialId + ":"),
                        hasBody12 = !!body12.offsetWidth(),
                        hasBody21 = !!body21.offsetWidth(),
                        hasBody22 = !!body22.offsetHeight(),
                        first11 = body11.nextFocus(true, true, false, keyid),
                        first12 = body12.nextFocus(true, true, false, keyid),
                        first21 = body21.nextFocus(true, true, false, keyid),
                        first22 = body22.nextFocus(true, true, false, keyid),
                        last11 = body11.nextFocus(false, true, false, keyid),
                        last12 = body12.nextFocus(false, true, false, keyid),
                        last21 = body21.nextFocus(false, true, false, keyid),
                        last22 = body22.nextFocus(false, true, false, keyid),
                        first = hasBody12 ? hasBody21 ? first11 : first12 : hasBody21 ? first21 : first22,
                        last = body22 ? last22 : body12 ? last12 : body21 ? last21 : last11,

                        cellNode = cur.parent(),
                        cellsid = cellNode.parent().id(),
                        subId = profile.getSubId(cellsid),
                        row = cell ? cell._row : profile.rowMap[profile.getSubId(src)],
                        ishotrow = row && row.id == profile.box._temprowid,
                        region = cell ? (cell._row._region + "" + cell._col._region) : (row._region + "1"),
                        t;

                    var toLeft = function (inner) {
                            if (src != first.xid()) {
                                var ok;
                                if (!cellNode.get(0).previousSibling || !cellNode.get(0).previousSibling.clientWidth) {
                                    switch (region) {
                                        case '11':
                                        case '21':
                                            // has right region
                                            if (hasBody22) {
                                                if (src == first21.xid()) {
                                                    last12.focus(true);
                                                    ok = 1;
                                                } else {
                                                    var prev = profile.getSubNode("ROW2", subId).prev();
                                                    if (prev) {
                                                        prev.nextFocus(false, true, true, keyid);
                                                        ok = 1;
                                                    }
                                                }
                                            }
                                            break;
                                        case '12':
                                        case '22':
                                            // has left region
                                            if (hasBody21) {
                                                profile.getSubNode("CELLS1", subId).last(2).focus(true);
                                                ok = 1;
                                            }
                                            break;
                                    }
                                }
                                if (!ok) {
                                    cur.nextFocus(false, false, true, keyid);
                                }
                                return false;
                            } else if (inner) {
                                last.focus(true);
                            }
                        },
                        toRight = function (inner) {
                            if (src != last.xid()) {
                                var ok;
                                if (region == "11" || region == "21" ? !cellNode.get(0).nextSibling : (!(t = cellNode.get(0).nextSibling) || !t.clientWidth)) {
                                    switch (region) {
                                        case '11':
                                        case '21':
                                            // has right region
                                            if (hasBody22) {
                                                profile.getSubNode("CELLS2", subId).first(2).focus(true);
                                                ok = 1;
                                            }
                                            break;
                                        case '12':
                                        case '22':
                                            // has left region
                                            if (hasBody21) {
                                                if (src == last12.xid()) {
                                                    first21.focus(true);
                                                    ok = 1;
                                                } else {
                                                    var next = profile.getSubNode("ROW1", subId).next();
                                                    if (next) {
                                                        next.nextFocus(true, true, true, keyid);
                                                        ok = 1;
                                                    }
                                                }
                                            }
                                            break;
                                    }
                                }
                                if (!ok) {
                                    cur.nextFocus(true, false, true, keyid);
                                }
                                return false;
                            } else if (inner) {
                                toDown();
                            }
                        },
                        verticalNav = function (up) {
                            //get no.
                            var count = 1,
                                temp = cur.parent().get(0),
                                max = temp.parentNode.childNodes.length;
                            while (temp = temp.previousSibling) count++;

                            //get row
                            temp = cur.parent(2).get(0);

                            //get all rows
                            if (!profile.$allrowscache2)
                                profile.box._cacheRows(profile);

                            //get index
                            var index = ood.arr.indexOf(region == "12" || region == "22" ? profile.$allrowscache2 : profile.$allrowscache1, temp),
                                rowLen = profile.$allrowscache2.length,
                                newLine = 0;

                            //adjust index
                            if (key == 'up') {
                                index--;
                                if (index == -1) {
                                    index = rowLen - 1;
                                    count--;
                                    if (count == 0) count = max;
                                }
                            } else {
                                index++;
                                if (index == rowLen) {
                                    newLine = 1;
                                    index = 0;
                                    count++;
                                    if (count == max + 1) count = 1;
                                }
                            }
                            //get node
                            var node = ood((region == "12" || region == "22" ? profile.$allrowscache2 : profile.$allrowscache1)[index]).first(),
                                node2 = node;
                            // it's normal cell
                            if (count > 1)
                                node2 = node2.next(count - 1);
                            // no normal cell(group)
                            if (node2.isEmpty())
                                node2 = node;
                            // get CELLA
                            if (node2 && !node2.isEmpty())
                                node2 = node2.first();
                            // focus
                            if (!node2.isEmpty())
                                return [node2, newLine];
                            return null;
                        },
                        toUp = function () {
                            var tnode;
                            if (src != first.xid()) {
                                if (cur.get(0) == first12.get(0) || cur.get(0) == first22.get(0)) {
                                    if (hasBody21) {
                                        tnode = last21;
                                    } else {
                                        tnode = last11;
                                    }
                                }
                                if (!tnode) {
                                    tnode = verticalNav(true)[0];
                                }
                            } else {
                                tnode = last;
                            }
                            if (tnode) tnode.focus(true);
                        },
                        toDown = function () {
                            var newLine, tnode;
                            if (src != last.xid()) {
                                if (cur.get(0) == last11.get(0) || cur.get(0) == last21.get(0)) {
                                    if (hasBody12) {
                                        tnode = first12;
                                    } else {
                                        tnode = first22;
                                    }
                                }
                                if (!tnode) {
                                    tnode = verticalNav();
                                    newLine = tnode[1];
                                    tnode = tnode[0];
                                }
                            } else {
                                tnode = first;
                                newLine = 1;
                            }

                            if (newLine && p.hotRowMode != 'none') {
                                var colId;
                                if (!cell) {
                                    var row = profile.rowMap[profile.getSubId(src)];
                                    if (!row) return false;
                                }
                                colId = (p.hotRowRequired || '').split(p.valueSeparator)[0] || (cell && cell._col && cell._col.id);

                                var addhotrow = true;
                                // if it's just the active row
                                if (profile.__hastmpRow) {
                                    // if it's invalid, dont add new row
                                    addhotrow = profile.box._checkNewLine(profile, 'keydown');

                                    if (!profile.$allrowscache2)
                                        profile.box._cacheRows(profile);
                                }

                                if (addhotrow) {
                                    profile.box._addTempRow(profile, colId);
                                    // dont focus to next cell
                                    return false;
                                }
                            } else {
                                if (tnode) tnode.focus(true);
                            }
                        };
                    switch (key) {
                        //tab to next/pre
                        case 'tab':
                            if (shift) {
                                if (false === toLeft(ishotrow)) {
                                    return false;
                                }
                            } else {
                                if (false === toRight(ishotrow)) {
                                    return false;
                                }
                            }
                            break;
                        case 'left':
                            if (false === toLeft(true)) {
                                return false;
                            }
                            break;
                        case 'right':
                            if (false === toRight(true)) {
                                return false;
                            }
                            break;
                        case 'up':
                            if (ctrl) {
                                if (row && !(p.disabled || row.disabled) && (row.group || row.sub)) {
                                    profile.box._getToggleNode(profile, row._serialId).onClick();
                                    return false;
                                }
                            }
                            toUp();
                            return false;
                            break;
                        case 'down':
                            if (ctrl) {
                                if (row && !(p.disabled || row.disabled) && (row.group || row.sub)) {
                                    profile.box._getToggleNode(profile, row._serialId).onClick();
                                    return false;
                                }
                            }
                            toDown();
                            return false;
                            break;
                    }
                },
                onContextmenu: function (profile, e, src) {
                    if (profile.onContextmenu) {
                        var sid = profile.getSubId(src);
                        // cell or row
                        return profile.boxing().onContextmenu(profile, e, src, sid ? (profile.cellMap[sid] || profile.rowMap[sid]) : null, ood.Event.getPos(e)) !== false;
                    }
                }
            },
            CMD: {
                onClick: function (profile, e, src) {
                    var p = profile.properties,
                        id = ood.use(src).id().split('_'),
                        cmdkey = id[id.length - 1];
                    id.pop();
                    var row = profile.rowMap[profile.getSubId(id.join("_"))];
                    if (p.disabled || (row && row.disabled)) return false;

                    if (profile.onCmd) {
                        if (row) {
                            profile.boxing().setActiveRow(row.id, true);
                        }
                        profile.boxing().onCmd(profile, row, cmdkey, e, src);
                    }

                    return false;
                }
            }
        },
        DataModel: {
            expression: {
                ini: '',
                caption: ood.getResText("DataModel.expression") || "",
                action: function () {
                }
            },
            directInput: {
                ini: true,
                caption: ood.getResText("DataModel.directInput") || ""
            },
            listKey: null,
            currencyTpl: {
                ini: "$ *",
                caption: ood.getResText("DataModel.currencyTpl") || ""
            },
            numberTpl: {
                ini: "",
                caption: ood.getResText("DataModel.numberTpl") || ""
            },
            valueSeparator: {
                ini: ";",
                caption: ood.getResText("DataModel.valueSeparator") || ""
            },
            activeRow: {
                hidden: true,
                ini: null
            },
            activeCell: {
                hidden: true,
                ini: null
            },
            rowMap: {
                hidden: true,
                ini: null
            },
            selMode: {
                ini: 'none',
                caption: ood.getResText("DataModel.selMode") || "",
                listbox: ['single', 'none', 'multi', 'multibycheckbox'],
                action: function (value) {
                    this.getSubNodes(['HFMARK', 'MARK'], true).css('display', (value == 'multi' || value == 'multibycheckbox') ? '' : 'none');
                }
            },
            editMode: {
                ini: 'focus',
                caption: ood.getResText("DataModel.editMode") || "",
                listbox: ["focus", "sharp", "hover", "hoversharp", "inline"]
            },
            dock: {
                ini: 'fill',
                caption: ood.getResText("DataModel.dock") || ""
            },
            togglePlaceholder: {
                ini: false,
                caption: ood.getResText("DataModel.togglePlaceholder") || ""

            },
            isFormField: {
                hidden: true,
                ini: false
            },
            altRowsBg: {
                ini: false,
                caption: ood.getResText("DataModel.alternateRowBg") || "",
                action: function (value) {
                    var ns = this;
                    var altCls = ns.getClass('CELLS1', '-alt'),
                        nodes21 = ns.getSubNode('CELLS1', true),
                        nodes22 = ns.getSubNode('CELLS2', true),
                        j, o1, o2;
                    nodes21.removeClass(altCls);
                    nodes22.removeClass(altCls);
                    if (value) {
                        alt = [];
                        j = 0;
                        nodes22.each(function (o2, i) {
                            if (o2.clientHeight) {
                                o2 = ood([o2]);
                                o1 = ood([nodes21.get(i)]);
                                if ((j++) % 2 == 1) {
                                    if (!o1.hasClass(altCls)) o1.addClass(altCls);
                                    if (!o2.hasClass(altCls)) o2.addClass(altCls);
                                } else {
                                    if (o1.hasClass(altCls)) o1.removeClass(altCls);
                                    if (o2.hasClass(altCls)) o2.removeClass(altCls);
                                }
                            }
                        });
                    }
                }
            },
            rowNumbered: {
                ini: false,
                caption: ood.getResText("DataModel.rowNumbering") || "",
                action: function (value) {
                    var ns = this,
                        f = ns.CF.getNumberedStr || function (a) {
                            return a
                        },
                        nodes = ns.getSubNode('ROWNUM', true),
                        i = 0,
                        map = ns.rowMap,
                        row, ol = 0, l = 0, a1 = [], a2 = [], tag = '', temp, t;

                    nodes.css('display', value ? '' : 'none');
                    if (value)
                        nodes.each(function (o) {
// for perfomance: remove this
//                            if(o.parentNode.clientHeight){
                            if (row = map[ns.getSubId(o.id)]) {
                                l = row._layer;
                                if (l > ol) {
                                    a1.push(i);
                                    a2.push(tag);
                                    tag = tag + i + '.';
                                    i = 0;
                                } else if (l < ol) {
                                    while (l < ol--) {
                                        i = a1.pop();
                                        tag = a2.pop();
                                    }
                                }
                                i++;
                                ol = l;
                                //o.innerHTML=''+tag+i;
                                row._autoNumber = f(tag + i);
                                temp = row.rowNumber || row._autoNumber;
                                if (t = o.firstChild) {
                                    if (t.nodeValue != temp)
                                        t.nodeValue = temp;
                                } else
                                    o.appendChild(document.createTextNode(temp));
                            }
//                            }
                        });
                    else
                        nodes.text('');
                }
            },
            editable: {
                ini: false,
                caption: ood.getResText("DataModel.editable") || ""
            },
            firstCellEditable: {
                ini: false,
                caption: ood.getResText("DataModel.firstCellEditable") || ""
            },

            $subMargin: {
                ini: '1.375em',
                caption: ood.getResText("DataModel.childIndent") || ""
            },

            initFold: {
                ini: true,
                caption: ood.getResText("DataModel.initialCollapse") || ""
            },

            animCollapse: {
                ini: false,
                caption: ood.getResText("DataModel.collapseAnimation") || ""
            },

            position: {
                ini: 'absolute',
                caption: ood.getResText("DataModel.position") || ""
            },
            width: {
                ini: '25em',
                caption: ood.getResText("DataModel.width") || ""
            },
            height: {
                ini: '18em',
                caption: ood.getResText("DataModel.height") || ""
            },

            _minColW: {
                ini: '.5em',
                caption: ood.getResText("DataModel.minColW") || ""
            },
            _maxColW: {
                ini: '25em',
                caption: ood.getResText("DataModel.maxColW") || ""
            },
            _minRowH: {
                ini: '1.83333em',
                caption: ood.getResText("DataModel.minRowH") || ""
            },

            gridHandlerCaption: {
                ini: "",
                caption: ood.getResText("DataModel.gridHandlerCaption") || "",
                action: function (v) {
                    v = (ood.isSet(v) ? v : "") + "";
                    this.getSubNode('GRIDCAPTION').html(ood.adjustRes(v, true));
                }
            },

            headerTail: {
                ini: "",
                caption: ood.getResText("DataModel.headerTail") || "",
                action: function (v) {
                    v = (ood.isSet(v) ? v : "") + "";
                    this.getSubNode('LHCELLINNER').html(ood.adjustRes(v, true));
                }
            },

            rowHandlerWidth: {
                $spaceunit: 1,
                ini: '5em',
                caption: ood.getResText("DataModel.rowHandlerWidth") || "",
                set: function (value) {
                    var o = this;
                    if (o.renderId)
                        o.box._setRowHanderW(o, value);
                    else
                        o.properties.rowHandlerWidth = value;
                }
            },

            showHeader: {
                ini: true,
                caption: ood.getResText("DataModel.showHeader") || "",
                action: function (value) {
                    this.getSubNodes(['HEADER1', 'HEADER2']).css('display', value ? '' : 'none');
                }
            },
            headerHeight: {
                $spaceunit: 1,
                ini: '2em',
                caption: ood.getResText("DataModel.headerHeight") || "",
                action: function (v) {
                    var profile = this,
                        prop = profile.properties;
                    profile.box._adjustColsHeight(profile);
                    profile.adjustSize();
                }
            },
            rowHeight: {
                $spaceunit: 1,
                ini: '2em',
                caption: ood.getResText("DataModel.rowHeight") || "",
                action: function (v) {
                    this.box._adjusteditorH(this, this.getSubNodes(['CELLS1', 'CELLS2'], true).height(v), v);
                }
            },
            _colDfWidth: {
                ini: '8em',
                caption: ood.getResText("DataModel.colDfWidth") || ""
            },


            rowHandler: {
                ini: true,
                caption: ood.getResText("DataModel.rowHandler") || "",
                action: function (value) {
                    this.getSubNode('FHCELL').css('display', value ? '' : 'none');
                    this.getSubNode('FCELL', true).css('display', value ? '' : 'none');

                    this.box._adjustColsWidth(this);
                    this.box._adjustBody(this, 'rowhandler');
                }
            },
            rowResizer: {
                ini: false,
                caption: ood.getResText("DataModel.rowResizer") || "",
                action: function (value) {
                    this.getSubNode('FHANDLER', true).css('display', value ? '' : 'none');
                }
            },

            colHidable: {
                ini: false,
                caption: ood.getResText("DataModel.colHidable") || ""
            },
            colResizer: {
                ini: true,
                caption: ood.getResText("DataModel.colResizer") || "",
                action: function (value) {
                    this.getSubNode('HHANDLER', true).css('display', value ? '' : 'none');
                }
            },
            colSortable: {
                ini: true,
                caption: ood.getResText("DataModel.colSortable") || "",
                action: function (value) {
                    if (!value)
                        this.getSubNode('SORT', true).css('display', 'none');
                }
            },
            colMovable: {
                ini: false,
                caption: ood.getResText("DataModel.colMovable") || ""
            },

            header: {
                ini: {},
                caption: ood.getResText("DataModel.header") || "",
                set: function (value) {
                    var o = this;
                    if (o.renderId) {
                        o.boxing()._refreshHeader(value);
                    } else
                        o.properties.header = ood.copy(value);
                }
            },
            uidColumn: {
                ini: '',
                caption: ood.getResText("DataModel.uidColumn") || "UID",
            },
            grpCols: {
                //for default merge
                ini: {},
                caption: ood.getResText("DataModel.grpCols") || "",
                set: function (value) {
                    var o = this;
                    o.properties.grpCols = ood.copy(value);
                    if (o.renderId) {
                        o.boxing()._refreshHeader(ood.clone(o.properties.header, false, 2));
                    }
                }
            },
            rows: {
                //for default merge
                ini: {},
                caption: ood.getResText("DataModel.rows") || "",
                set: function (value) {
                    var o = this;
                    if (o.renderId)
                        o.boxing().removeAllRows(false).insertRows(value);
                    //use copy to avoid outer memory link
                    else
                        o.properties.rows = ood.copy(value);
                }
            },
            // can be se dynamic only
            rawData: {
                ini: [],
                caption: ood.getResText("DataModel.rawData") || "",
                set: function (value) {
                    if (!value || !ood.isArr(value) || !value.length) return;
                    var o = this, cols = {}, header = [], rows = [], i, j, l = value.length, hash;
                    // collect data
                    for (i = 0; i < l; i++) {
                        if (!ood.isHash(hash = value[i])) {
                            return;
                        }
                        for (var k in hash) {
                            if (!(k in cols)) cols[k] = [];
                            cols[k][i] = hash[k];
                        }
                    }
                    //convert to header / rows
                    j = 0;
                    for (var k in cols) {
                        header.push(k);
                        for (i = 0; i < l; i++) {
                            if (!rows[i]) rows[i] = [];
                            rows[i][j] = cols[k][i];
                        }
                        j++;
                    }

                    var ins = o.boxing();
                    if (ins.getHeader('min').join(';') != header.join(';')) {
                        ins.setHeader(header)
                    }
                    ins.setRows(rows);
                },
                get: function (row, splitMixColumn) {
                    var o = this, prop = o.properties, header = prop.header,
                        tid = this.box._temprowid,
                        one = row && row.cells && ood.isArr(row.cells),
                        rows = one ? [row] : ood.isArr(row) && row[0] && row[0].cells && ood.isArr(row[0].cells) ? row : prop.rows,
                        l = header.length, h = rows.length,
                        columns = [], cell, key, keys,
                        data = [];

                    if (h) {
                        for (var i = 0; i < l; i++) {
                            columns.push(header[i].id);
                        }
                        for (var j = 0; j < h; j++) {
                            //ignore temp row for all rows
                            if (!one && rows[j].id == tid) continue;
                            if (rows[j].group || !rows[j].cells) continue;

                            var hash = {};
                            for (var i = 0; i < l; i++) {
                                key = columns[i];
                                cell = rows[j].cells[i];
                                if (splitMixColumn && key.indexOf(":") != -1) {
                                    keys = key.split(':');
                                    hash[keys[0]] = ('value' in cell) ? cell.value : cell;
                                    hash[keys[1]] = ('caption' in cell) ? cell.caption : null;
                                } else {
                                    hash[key.split(':')[0]] = ('value' in cell) ? cell.value : cell;
                                }
                            }
                            data.push(hash);
                        }
                    }
                    return one ? data[0] : data;
                }
            },
            dataset: {
                ini: {},
                caption: ood.getResText("DataModel.dataset") || "",
                get: function () {
                    var prf = this, ins = prf.boxing(), prop = prf.properties;
                    return {
                        name: prop.gridHandlerCaption,
                        dimensions: ins.getHeader('min'),
                        source: ins.getRows('min')
                    };
                },
                set: function (v) {
                    var prf = this, ins = prf.boxing(), prop = prf.properties;
                    var dataset = ood.isFun(v.getDataset) ? v.getDataset() : v;
                    if ((v = prop.tagVar.datasetAdapter) && ood.isFun(v)) dataset = v.call(ins, dataset, prf);
                    if ((v = ins.datasetAdapter) && ood.isFun(v)) dataset = v.call(ins, dataset, prf);
                    if (ins.beforeApplyDataset && false === ins.beforeApplyDataset(prf, dataset)) {
                    } else {
                        if ('name' in dataset) ins.setGridHandlerCaption(dataset.name);
                        if ('dimensions' in dataset) ins.setHeader(dataset.dimensions);
                        if ('source' in dataset) ins.setRows(dataset.source);
                    }
                }
            },
            tagCmds: {
                ini: [],
                caption: ood.getResText("DataModel.tagCmds") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            activeMode: {
                ini: 'row',
                caption: ood.getResText("DataModel.activeMode") || "",
                listbox: ['row', 'cell', 'none'],
                action: function (value) {
                    var profile = this;
                    if (value != 'cell' && profile.$activeCell) {
                        ood(profile.$activeCell).tagClass('-active', false);
                        delete profile.$activeCell;
                    }
                    if (value != 'row' && profile.$activeRow) {
                        ood(profile.$activeRow).tagClass('-active', false);
                        delete profile.$activeRow;
                    }
                }
            },

            rowOptions: {
                ini: {},
                caption: ood.getResText("DataModel.rowOptions") || "",
                action: function (value) {
                    var ins = this.boxing(),
                        rows = ins.getRows('data');
                    ins.removeAllRows();
                    ins.insertRows(rows);
                }
            },
            colOptions: {
                ini: {},
                caption: ood.getResText("DataModel.colOptions") || "",
                action: function (value) {
                    var ins = this.boxing(),
                        rows = ins.getRows('data');
                    ins.removeAllRows();
                    ins.insertRows(rows);
                }
            },
            treeMode: {
                ini: 'inhandler',
                caption: ood.getResText("DataModel.treeMode") || "",
                // compitable: false->'none'; true->inhanlder
                listbox: ['none', 'inhandler', 'infirstcell'],
                action: function (value, ovalue) {
                    if ((ovalue == 'inhandler' && value == 'infirstcell') || (ovalue == 'infirstcell' && value == 'inhandler')) {
                        this.boxing().refresh();
                    } else {
                        this.getSubNodes(['ROWLRULER', 'ROWTOGGLE'], true).css('display', value ? '' : 'none');
                    }
                }
            },
            freezedColumn: {
                ini: 0,
                caption: ood.getResText("DataModel.frozenCols") || "",
                action: function () {
                    this.boxing().refresh();
                    this.box._adjustColsWidth(this);
                }
            },
            freezedRow: {
                ini: 0,
                caption: ood.getResText("DataModel.frozenRows") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            hotRowMode: {
                ini: 'none',
                caption: ood.getResText("DataModel.hotRowMode") || "",
                listbox: ['none', 'show', 'hide', 'auto'],
                action: function (value) {
                    if (this.renderId) {
                        if (value == 'none')
                            this.boxing().removeHotRow();
                        else
                            this.box.__ensurehotrow(this, null);
                    }
                }
            },
            excelCellId: {
                ini: "",
                caption: ood.getResText("DataModel.excelCellId") || "ExcelID",
                action: function () {
                    this.boxing().notifyExcel(false);
                }
            },
            gridValueFormula: {
                ini: "",
                caption: ood.getResText("DataModel.gridValueFormula") || ""
            },
            hotRowNumber: {
                ini: '[*]',
                caption: ood.getResText("DataModel.hotRowNumber") || ""
            },
            hotRowCellCap: {
                ini: '(*)',
                caption: ood.getResText("DataModel.hotRowCellId") || ""
            },
            hotRowRequired: {
                ini: '',
                caption: ood.getResText("DataModel.hotRowRequired") || ""
            },
            noCtrlKey: {
                ini: true,
                caption: ood.getResText("DataModel.noCtrlKey") || "Ctrl"
            }
        },
        EventHandlers: {
            onBodyLayout: function (profile, trigger) {
            },
            beforeApplyDataset: function (profile, dataset) {
            },

            beforeCellKeydown: function (profile, cell, keys) {
            },
            afterCellFocused: function (profile, cell, row) {
            },

            beforeInitHotRow: function (profile) {
            },
            onInitHotRow: function (profile, row) {
            },

            beforeHotRowAdded: function (profile, cellMap, row, leaveGrid) {
            },
            afterHotRowAdded: function (profile, row) {
            },

            onGetContent: function (profile, row, callback) {
            },
            onRowSelected: function (profile, row, e, src, type) {
            },
            onCmd: function (profile, row, cmdkey, e, src) {
            },

            beforeFold: function (profile, item) {
            },
            beforeExpand: function (profile, item) {
            },
            afterFold: function (profile, item) {
            },
            afterExpand: function (profile, item) {
            },

            beforeColDrag: function (profile, colId) {
            },
            beforeColMoved: function (profile, colId, toId) {
            },
            afterColMoved: function (profile, colId, toId) {
            },
            beforeColSorted: function (profile, col) {
            },
            afterColSorted: function (profile, col) {
            },

            beforeColShowHide: function (profile, colId, flag) {
            },
            afterColShowHide: function (profile, colId, flag) {
            },
            beforeColResized: function (profile, colId, width) {
            },
            afterColResized: function (profile, colId, width) {
            },
            beforeRowResized: function (profile, rowId, height) {
            },
            afterRowResized: function (profile, rowId, height) {
            },


            swiperight: function (profile, row, e, src) {
            },
            swipeup: function (profile, item, e, src) {
            },
            swipedown: function (profile, item, e, src) {
            },

            beforePrepareRow: function (profile, row, pid) {
            },
            beforePrepareCol: function (profile, col) {
            },

            beforeRowActive: function (profile, row) {
            },
            afterRowActive: function (profile, row) {
            },
            beforeCellActive: function (profile, cell) {
            },
            afterCellActive: function (profile, cell) {
            },

            beforeCellUpdated: function (profile, cell, options, isHotRow) {
            },
            afterCellUpdated: function (profile, cell, options, isHotRow) {
            },
            beforeRowUpdated: function (profile, obj, options, isHotRow) {
            },
            afterRowUpdated: function (profile, obj, options, isHotRow) {
            },

            onRowDirtied: function (profile, row) {
            },

            onRowHover: function (profile, row, hover, e, src) {
            },
            onClickHeader: function (profile, col, e, src) {
            },
            onClickRow: function (profile, row, e, src) {
            },
            onClickRowHandler: function (profile, row, e, src) {
            },
            onDblclickRow: function (profile, row, e, src) {
            },
            onClickCell: function (profile, cell, e, src) {
            },
            onDblclickCell: function (profile, cell, e, src) {
            },
            onClickGridHandler: function (profile, e, src) {
            },

            beforeIniEditor: function (profile, cell, cellNode, pNode, type) {
            },
            onBeginEdit: function (profile, cell, editor, type) {
            },
            beforeEditApply: function (profile, cell, options, editor, tag, type) {
            },
            onEndEdit: function (profile, cell, editor, type) {
            },

            // Editors' default events
            onFileDlgOpen: function (profile, cell, proEditor, src) {
            },
            beforeComboPop: function (profile, cell, proEditor, pos, e, src) {
            },
            beforePopShow: function (profile, cell, proEditor, popCtl, items) {
            },
            afterPopShow: function (profile, cell, proEditor, popCtl) {
            },
            onCommand: function (profile, cell, proEditor, src, type) {
            },
            onEditorClick: function (profile, cell, proEditor, type, src) {
            },
            beforeUnitUpdated: function (profile, cell, proEditor, type) {
            },

            // beforeApplyGridExcelFormula
            // afterApplyGridExcelFormula
            beforeApplyFormula: function (profile, cell, value, formula) {
            },
            afterApplyFormulas: function (profile, dataArrs) {
            },
            beforeGridValueCalculated: function (profile) {
            },
            afterGridValueCalculated: function (profile, value) {
            },

            onGetExcelCellValue: function (profile, excelCellId, dftValue) {
            }
        },
        RenderTrigger: function () {
            var ns = this,
                box = ns.box,
                prop = ns.properties,
                ins = ns.boxing(),
                getPro = box.getCellOption;

            ns.destroyTrigger = function () {
                var ns = this, prop = ns.properties;
                ood.each(ns.cellMap, function (cell) {
                    if (cell._editor) cell._editor.destroy();
                });
                ood.breakO([ns.colMap, ns.rowMap, ns.cellMap], 3);
                prop.header.length = 0;
                prop.rows.length = 0;
                prop.grpCols.length = 0;
            };
            ns.$cache_editor = {};
            if (!prop.initFold)
                ins._toggleRows(prop.rows, true);
            // trigger render
            ood.arr.each(prop.header, function (o) {
                if (ood.isFun(o.colRenderer || prop.colOptions.colRenderer))
                    (o.colRenderer || prop.colOptions.colRenderer).call(null, ns, o);
            });
            // move it manually
            if (prop.treeMode == 'infirstcell') {
                ns.getSubNode('HCELLA', prop.header[0]._serialId).prepend(
                    ns.getSubNode('LTAGCMDS')
                ).prepend(
                    ns.getSubNode('HFMARK')
                );
            }
            ood.arr.each(prop.rows, function (o) {
                if (ood.isFun(o.rowRenderer || prop.rowOptions.rowRenderer))
                    (o.rowRenderer || prop.rowOptions.rowRenderer).call(null, ns, o);
                if (false === getPro(ns, o, "initFold"))
                    ins._toggleRows([o], true);
            });

            ns.box.__ensurehotrow(ns, null);

            ood.each(ns.cellMap, function (o) {
                if (getPro(ns, o, "editable") &&
                    (getPro(ns, o, "editMode") == "inline" || getPro(ns, o, "type") == 'dropbutton'))
                    box._editCell(ns, o);
            });

            if (prop.excelCellId)
                ns.boxing().calculateGridValue();
        },
        LayoutTrigger: function () {
            var ns = this, box = ns.box, prop = ns.properties, ins = ns.boxing();
            if (ood.isArr(prop.grpCols)) {
                ood.arr.each(prop.grpCols, function (o) {
                    if (ood.isFun(o.colRenderer || prop.colOptions.colRenderer))
                        (o.colRenderer || prop.colOptions.colRenderer).call(null, ns, o);
                });
                box._adjustColsHeight(ns);
            }
            ns.box._asy(ns);
            ns.box._adjustBody(ns, 'render');
        },
        _tplMap: {'text': '.text', 'button': '.button', 'image': '.image'},
        _tplMap2: {'textarea': '.textarea', 'checkbox': '.checkbox', 'button': '.button', 'progress': '.progress'},
        _focusEvent: function (profile, e, src) {
            var ins = profile.boxing(),
                prop = profile.properties,
                cell = profile.cellMap[profile.getSubId(src)],
                row;

            profile.box._focuscell(profile, e, src);

            if (profile.afterCellFocused) {
                if (cell)
                    row = cell._row;
                else
                    row = profile.rowMap[profile.getSubId(src)];
                ins.afterCellFocused(profile, cell, row);
            }
            // to check hot row
            if (prop.hotRowMode != 'none') {
                var cell = profile.cellMap[profile.getSubId(src)], row;
                if (cell)
                    row = cell._row;
                else
                    row = profile.rowMap[profile.getSubId(src)];
                if (profile.__hastmpRow && profile.__needchecktmprow && row.id !== profile.box._temprowid)
                    profile.box._checkNewLine(profile, 'focuscell');
            }
        },

        _tagCmdWidth: function (profile) {
            var prop = profile.properties;
            var tagCmdWidth = 0;
            if (prop.tagCmds) {
                ood.arr.each(prop.tagCmds, function (cmd) {
                    if (cmd.tagCmdsAlign && cmd.tagCmdsAlign != 'left') {
                        switch (cmd.buttonType) {
                            case 'button':
                                tagCmdWidth = tagCmdWidth + 2;
                                break;
                            case 'image':
                                tagCmdWidth = tagCmdWidth + 2;
                                break
                            case 'text':
                                tagCmdWidth = tagCmdWidth + cmd.text ? cmd.text.length : 1;
                                break
                        }
                    }
                });
            }
            return tagCmdWidth
        },

        _haderTail: function (profile) {
            var prop = profile.properties;
            var headerTail = ood.getRes('UI.treegrid.operation');
            if (!prop.tagCmds) {
                var rtag = false;
                ood.arr.each(prop.tagCmds, function (cmd) {
                    if (cmd.tagCmdsAlign && cmd.tagCmdsAlign != 'left') {
                        var rtag = true;
                    }
                });
                if (rtag) {
                    headerTail = prop.headerTail ? prop.headerTail : ood.getRes('UI.treegrid.operation');
                } else {
                    headerTail = "";
                }
            } else {
                headerTail = "";
            }
            return headerTail;
        },
        __ensurehotrow: function (profile, focusColId) {
            var prop = profile.properties,
                box = profile.box,
                need = false;
            if (!box || !profile.renderId || prop.hotRowMode == "none") return;

            if (profile.__hastmpRow) {
                var rows = profile.properties.rows;
                if (rows.length === 0 || rows[rows.length - 1].id != profile.box._temprowid)
                    need = true;
            } else {
                need = true;
            }

            if (need) {
                // add a temp row
                switch (prop.hotRowMode) {
                    case 'auto':
                        if (!prop.rows || prop.rows.length === 0)
                            box._addTempRow(profile, focusColId);
                        break;
                    case 'show':
                        box._addTempRow(profile, focusColId);
                        break;
                }
            }
        },
        _temprowid: '_ r _temp_',
        isHotRow: function (row) {
            return row && (row.id || row) === this._temprowid;
        },
        _addTempRow: function (profile, focusColId) {
            var prop = profile.properties;
            if (prop.readonly || prop.disabled || !prop.header || prop.header.length <= 0)
                return false;

            // clear first, ensure only one
            profile.box._sethotrowoutterblur(profile, true);
            delete profile.__hastmpRow;
            profile.boxing().removeRows([this._temprowid], false);

            if (profile.beforeInitHotRow && false === profile.boxing().beforeInitHotRow(profile))
                return false;

            profile.__needchecktmprow = true;

            var cells = {},
                row = {cells: cells},
                required = (prop.hotRowRequired || "").split(prop.valueSeparator),
                newcell = {caption: prop.hotRowCellCap},
                ins = profile.boxing();
            if (required.length) {
                ood.arr.each(prop.header, function (col, i) {
                    if (ood.arr.indexOf(required, col.id) != -1) {
                        // must hash for mix column
                        cells[col.id] = newcell;
                    } else if (ood.isSet(col.defaultValue)) {
                        cells[col.id] = col.defaultValue;
                    }
                });
            }

            if (profile.onInitHotRow)
                row = ins.onInitHotRow(profile, row) || row;

            if (ood.isArr(row))
                row = {cells: row};
            else if (!ood.isHash(row))
                row = {cells: [row]};

            // gives a special id
            row.id = this._temprowid;
            row.rowNumber = prop.hotRowNumber;
            row.rowClass = profile.getClass('CELLS2', '-hot');

            ins.insertRows([row], null, null, false, false);

            profile.__hastmpRow = true;

            // focus to next cell
            if (focusColId !== null) {
                ins.focusCellbyRowCol(row.id, focusColId || prop.header[0].id);
                profile.box._sethotrowoutterblur(profile);
            }
        },
        _checkNewLine: function (profile, trigger) {
            var prop = profile.properties;
            profile.box._sethotrowoutterblur(profile, true);

            // checked already
            if (!profile.__hastmpRow)
                return;

            delete profile.__needchecktmprow;

            var ins = profile.boxing(),
                rowId = this._temprowid,
                required = prop.hotRowRequired && prop.hotRowRequired.split(prop.valueSeparator),
                // must be map row
                tempRow = ins.getRowbyRowId(rowId, 'map', true),
                result = !!trigger;
            if (!tempRow)
                return;
            if (required && required.length) {
                for (var i = 0, j, cell, l = required.length; i < l; i++) {
                    j = ood.arr.subIndexOf(prop.header, 'id', required[i]);
                    if (j != -1 && !(ood.isHash(cell = tempRow[required[i].split(':')[0]]) ? cell.value : cell)) {
                        result = null;
                        break;
                    }
                }
            }
            var tempRowData = ins.getRowbyRowId(rowId, 'data', true);
            // clear temp data
            delete tempRowData.id;
            delete tempRowData.rowClass;
            delete tempRowData.rowNumber;
            ood.arr.each(tempRowData.cells, function (cell) {
                if (cell.id.indexOf('-c_') == 0) delete cell.id;
                if (cell.caption === prop.hotRowCellCap) delete cell.caption;
            });

            if (profile.beforeHotRowAdded) {
                var result2 = ins.beforeHotRowAdded(profile, tempRow, tempRowData, !trigger);
                if (ood.isDefined(result2))
                    result = result2 === true ? result2 : result2 === false ? result2 : null;
            }

            // do nothing
            if (result === null) {
                if (prop.hotRowMode == 'hide' || prop.hotRowMode == 'auto') {
                    profile.box._sethotrowoutterblur(profile);
                }
                return false;
            }
            // remove the hot row
            else if (result === false) {
                if (prop.hotRowMode == 'hide' || prop.hotRowMode == 'auto') {
                    delete profile.__hastmpRow;
                    ins.removeRows([rowId], false);
                    if (prop.rows.length === 0 && prop.hotRowMode == 'auto')
                        this._addTempRow(profile, null);
                }
                // dont add new hot row
                return false;
            }
            // add a new row
            else if (result === true) {
                delete profile.__hastmpRow;
                ins.removeRows([rowId], false);
                ins.insertRows(tempRowData, null, null, false, true);

                tempRow = prop.rows[prop.rows.length - 1];
                tempRow._dirty = 1;
                if (profile.afterHotRowAdded)
                    ins.afterHotRowAdded(profile, tempRow);
                if (prop.hotRowMode == 'show') {
                    if (!profile.__hastmpRow)
                        this._addTempRow(profile, null);
                }
                return true;
            }
            // focus the invalid cell, and keep this hot row
            else {
                profile.__needchecktmprow = true;
                // if returns cell
                if (ood.isHash(result))
                    ins.focusCell(result);
                // if return cell id
                else
                    ins.focusCell(ins.getCell(result));

                profile.box._sethotrowoutterblur(profile);
                // dont add new hot row
                return false;
            }
        },
        _sethotrowoutterblur: function (profile, clear) {
            var f = function (k) {
                return profile.getSubNode(k).get(0)
            };
            profile.getSubNode('ROWS22').setBlurTrigger(profile.$domId + ':ROWS22', clear ? null : function (pos, e) {
                var node = ood.Event.getSrc(e),
                    trigger = node == f('SCROLL11') || node == f('SCROLL12') || node == f('SCROLL21') || node == f('SCROLL22') ? 'focusin' : 'focusout';
                profile.__tmpRowBlurTrigger = ood.asyRun(function () {
                    // destroyed
                    if (!profile.box) return;
                    profile.box._checkNewLine(profile, trigger);
                });
            }, ood([f('ROWS11'), f('ROWS12'), f('ROWS21'), f('ROWS22')]), null, true);
            if (clear) {
                if (profile.__tmpRowBlurTrigger) {
                    ood.clearTimeout(profile.__tmpRowBlurTrigger);
                    delete profile.__tmpRowBlurTrigger;
                }
            }
        },
        _cacheRows: function (profile) {
            var all1 = profile.getSubNodes('CELLS1', true).get(),
                all2 = profile.getSubNodes('CELLS2', true).get();
            //filter dispaly==none
            ood.filter(all1, function (o) {
                return !!o.clientHeight;
            });
            ood.filter(all2, function (o) {
                return !!o.clientHeight;
            });
            profile.$allrowscache1 = all1;
            profile.$allrowscache2 = all2;
        },
        _asy: function (profile) {
            var prop = profile.properties, b = profile.boxing(), id = profile.$xid;
            if (prop.altRowsBg) ood.resetRun(id + "1", function () {
                if (profile.rowMap) b.setAltRowsBg(true, true)
            });
            if (prop.rowNumbered) ood.resetRun(id + "2", function () {
                if (profile.rowMap) b.setRowNumbered(true, true)
            });
        },
        _setRowHanderW: function (profile, flag) {
            var prop = profile.properties,
                ww = profile._$subMargin || (profile._$subMargin = profile.$px(prop.$subMargin)),
                map = profile.rowMap,
                hcell = profile.getSubNode('FHCELL'),
                n, w;
            if (ood.isFinite(flag) || profile.$isEm(flag) || profile.$isPx(flag))
                w = profile.$forceu(flag);
            else if (flag === true) {
                var ws = [], t;
                profile.getSubNode('FCELLCAPTION', true).each(function (o) {
                    if ((t = o.parentNode).parentNode.offsetHeight > 0 && ood.Dom.getStyle(t, 'overflow') != 'visible')
                        if (n = map[profile.getSubId(o.id)])
                            ws.push(ood([o]).width() + n._layer * ww);
                });
                ws.push(profile.$px(prop._minColW));
                w = profile.$forceu(Math.max.apply(null, ws) + ww * 2);
            } else
                w = profile.$forceu(hcell.width());

            //set width
            if (w) {
                if (profile.$px(w) < profile.$px(prop._minColW)) w = profile.$em(prop._minColW) + 'em';
                if (profile.$px(w) <= 0) return;
                if (prop.rowHandlerWidth != w) {
                    hcell.width(prop.rowHandlerWidth = w);
                    profile.getSubNode('FCELL', true).width(w);
                    profile.getSubNode('GCELL', true).width(w);

                    /*
                    profile.getSubNode('ROWLRULER',true).each(function(o){
                        n=map[profile.getSubId(o.id)];
                        o.style.width=(4 + n._layer*ww)+'px';
                    });
                    */
                    profile.box._adjustColsWidth(profile);
                    profile.box._adjustBody(profile, 'rowhandler');
                }
            }
        },
        _onStartDrag: function (profile, e, src) {
            var row = profile.rowMap[profile.getSubId(src)];
            if (row && row.id == profile.box._temprowid) return false;

            var pos = ood.Event.getPos(e);
            profile.$_ond = src;
            ood.use(src).startDrag(e, {
                dragSource: profile.$xid,
                dragType: 'icon',
                shadowFrom: ood.use(src).parent()._get(0),
                targetLeft: pos.left + 12,
                targetTop: pos.top + 12,
                dragCursor: 'pointer',
                dragDefer: 2,
                dragKey: profile.box.getDragKey(profile, src),
                dragData: profile.box.getDragData(profile, e, src)
            });
            return false;
        },
        _onDropTest: function (profile, e, src, key, data, item) {
            var fid = data && data.domId, tid = src, fp = data && data.profile, t;
            if (tid) {
                var k = profile.getKey(tid),
                    ks = profile.keys,
                    row = profile.rowMap[profile.getSubId(tid)];
                if (k == ks.FCELL && !row.sub)
                    return false;
                if (profile.properties.rowHandler) {
                    if (k == ks.CELLS2 || k == ks.SCROLL22) return false;
                } else {
                    if (k == ks.CELLS1 || k == ks.SCROLL21) return false;
                }
            }
            if (fp && fp.$xid == profile.$xid) {
                if (fid && profile.getSubId(fid) == profile.getSubId(tid))
                    return false;
                t = profile.$_ond;

                src = ood(src).get(0);
                if (ood.get(src, ['parentNode', 'previousSibling']) == t) return false;
                do {
                    if (src == t) {
                        src = t = null;
                        return false;
                    }
                } while (src && (src = src.parentNode) && src !== document && src !== window);
                src = t = null;
            }
        },
        _onDragstop: function (profile, e, src, key, data, item) {
            delete profile.$_ond;
        },
        _onDrop: function (profile, e, src, key, data, item) {
            if (!data.profile || !data.profile[profile.KEY]) return;
            var k = profile.getKey(src),
                po = data.profile,
                ps = data.domId,
                oitem,
                ks = profile.keys,
                t = ood.absObj.$specialChars,
                b = profile.boxing(),
                arr = ood.copy(b.getUIValue(true)),
                orow = po.rowMap[po.getSubId(ps)],
                row = profile.rowMap[profile.getSubId(src)];

            //remove
            orow = ood.clone(orow, function (o, i) {
                return !t[(i + '').charAt(0)]
            });
            po.boxing().removeRows([orow.id]);

            //add
            if (k == ks.SCROLL21 || k == ks.SCROLL22)
                b.insertRows([orow], null, null, false);
            else if ((k == ks.FCELL) && row.sub)
                b.insertRows([orow], row.id, null, false);
            else if (k == ks.CELLS1 || k == ks.CELLS2)
                b.insertRows([orow], row._pid, row.id, true);

            if (arr && arr.length) {
                if (ood.arr.indexOf(arr, orow.id) != -1) {
                    b.setUIValue(arr, true, null, 'drop');
                }
            }
            data._new = orow;
            return false;
        },

        _beforeSerialized: function (profile) {
            var o = arguments.callee.upper.call(this, profile),
                pp = profile.properties,
                map = ood.absObj.$specialChars,
                op = o.properties,
                us = ood.$us(profile),
                unit = us == 2 ? 'em' : us == -2 ? 'px' : null,
                t;
            op.header = ood.clone(pp.header, function (o, i, d, h) {
                if (d === 2 && i === 'width' && o && o != 'auto') {
                    h[i] = profile.$forceu(o, unit);
                    return false;
                } else
                    return !map[((d === 1 ? o.id : i) + '').charAt(0)] && o != undefined
            });
            op.grpCols = ood.clone(pp.grpCols, function (o, i, d) {
                if (d === 2 && i === 'width' && o && o != 'auto') {
                    h[i] = profile.$forceu(o, unit);
                    return false;
                } else
                    return !map[((d === 1 ? o.id : i) + '').charAt(0)] && o != undefined
            });
            op.rows = ood.clone(pp.rows, function (o, i, d) {
                if (d === 2 && i === 'height' && o && o != 'auto') {
                    h[i] = profile.$forceu(o, unit);
                    return false;
                } else
                    return !map[((d === 1 ? o.id : i) + '').charAt(0)] && o != undefined && ((i == "id" && typeof(o) == "string") ? o.charAt(0) != "-" : true);
            });
            if (ood.isEmpty(op.header)) delete op.header;
            if (ood.isEmpty(op.grpCols)) delete op.grpCols;
            if (ood.isEmpty(op.rows)) delete op.rows;

            delete op.activeRow;
            delete op.activeCell;
            delete op.rawData;
            delete op.dataset;
            return o;
        },
        _clsCache: {},

        _colDragCheck: function (profile, src) {
            var p = profile.properties,
                dd = ood.DragDrop.getProfile(), key = dd.dragKey, data = dd.dragData,
                col = profile.colMap[profile.getSubId(src)];
            if (!col || col._isgroup) return false;
            if (p.treeMode == 'infirstcell' && p.header[0] == col) return false;
            if (!(col.hasOwnProperty('colMovable') ? col.colMovable : profile.properties.colMovable)) return false;
            if (!key || !data || key != (profile.$xid + ":col")) return false;
            if (data == ood.use(src).id() || data == ood.use(src).prev().id()) return false;
        },
        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile),
                NONE = 'display:none',
                prop = profile.properties;

            // init row/cell cache
            profile.rowMap2 = {};
            profile.rowMap = {};
            profile.cellMap = {};

            data.showHeader = prop.showHeader ? '' : NONE;
            data.colDDDisplay = prop.colResizer ? '' : NONE;
            data.rowDDDisplay = prop.rowResizer ? '' : NONE;
            data.rowHandlerDisplay = prop.rowHandler ? '' : NONE;
            data.sortDisplay = NONE;
            data._rowMarkDisplay = (prop.selMode == "multi" || prop.selMode == "multibycheckbox") ? "" : "display:none;";

            if (!prop.header || !ood.isArr(prop.header))
                prop.header = [];
            if (!prop.grpCols || !ood.isArr(prop.grpCols))
                prop.grpCols = [];
            if (!prop.rows || !ood.isArr(prop.rows))
                prop.rows = [];
            data.tagCmdWidth = this._tagCmdWidth(profile);
            data.haderTail = this._haderTail(profile);
            prop.header = this._adjustHeader(prop.header);
            data.header = this._prepareHeader(profile, prop.header);
            // for triggerring render
            data.header1 = data.header2 = data.header;
            prop.grpCols = this._adjustGrpColsData(profile, prop.grpCols);
            data.grpCols = this._prepareGrpCols(profile, prop.grpCols, data.header);
            // for triggerring render
            data.grpCols1 = data.grpCols2 = data.grpCols;
            data._row0DfW = data.rowHandlerWidth ? ('width:' + profile.$forceu(data.rowHandlerWidth)) : '';

            // make sure its' size
            if (profile.$isEm(prop.headerHeight)) data.headerHeight = profile.$forceu(profile.$px(prop.headerHeight, 0, true), 'em');
            if (profile.$isEm(prop.rowHeight)) data.rowHeight = profile.$forceu(profile.$px(prop.rowHeight, 0, true), 'em');
            if (profile.$isEm(prop.rowHandlerWidth)) data.headerHeight = profile.$forceu(profile.$px(prop.rowHandlerWidth, 0, true), 'em');

            arguments.callee.upper.call(this, profile);

            prop.rows = this._adjustRows(profile, prop.rows);
            data.rows11 = data.rows12 = data.rows21 = data.rows22 = this._prepareItems(profile, prop.rows);

            data.tagCmds = ood.clone(prop.colOptions.tagCmds || data.tagCmds);
            if (data.tagCmds) {
                this._prepareCmds(profile, data, function (item) {
                    var pos = item.pos || item.tag;
                    return !pos || pos != "row";
                });
            }
            data._columnfreezed = prop.freezedColumn ? 'ood-ui-shadow-r ood-uiborder-r ood-uiborder-dark' : '';
            data._rowfreezed = prop.freezedRow ? 'ood-ui-shadow-b ood-uiborder-b ood-uiborder-dark' : '';

            return data;
        },
        _parepareCol: function (profile, col, cols, index) {
            // build header
            var SubID = ood.UI.$tag_subId,
                prop = profile.properties,
                headerHeight = profile.$px(prop.headerHeight),
                borderH = profile.getRoot().contentBox() ? 2 : 0,
                NONE = 'display:none', iid,
                ii = 1, tt,
                oid, uicol;


            if (!ood.isHash(col)) {
                oid = col + "";
                col = {id: oid};
            } else {
                oid = col.id + "";
            }

            // links
            col._cells = {};
            iid = profile.pickSubId('header');
            col[SubID] = '-h_' + iid;

            col.id = col.id || iid;
            while ((tt = ood.arr.subIndexOf(cols, "id", col.id)) != -1 && tt !== index) {
                col.id = iid + (ii++);
            }

            profile.colMap[col[SubID]] = col;

            var _ww = profile.$px(col.width) || profile.$px(prop._colDfWidth);
            if ('relWidth' in col) {
                col.flexSize = col.relWidth;
                delete col.relWidth;
            }
            // width
            if (!col.flexSize) {
                if (col.hasOwnProperty('minWidth')) _ww = Math.max(_ww, profile.$px(col.minWidth));
                if (col.hasOwnProperty('maxWidth')) _ww = Math.min(_ww, profile.$px(col.minWidth));
            }

            col.width = col._cellWidth = col._colWidth = profile.$forceu(_ww);
            col._hcellheight = profile.$forceu(headerHeight - borderH);

            uicol = {
                sortDisplay: NONE,
                rowHandlerDisplay: prop.rowHandler ? '' : NONE
            };
            uicol[SubID] = col[SubID];
            uicol._tabindex = prop.tabindex;
            uicol.colDDDisplay = (('colResizer' in col) ? col.colResizer : prop.colResizer) ? '' : NONE;

            //if(col.flexSize)uicol.colDDDisplay = NONE;

            //  Forward-compatible with 'visibility'
            if (col.hasOwnProperty('visibility') && !col.hasOwnProperty('hidden'))
                col.hidden = !col.visibility;

            uicol.colDisplay = col.hidden === true ? NONE : '';

            uicol.firstCellStyle = prop.colOptions.firstCellStyle || '';
            uicol.firstCellClass = prop.colOptions.firstCellClass || '';
            uicol.enumClass = col.enumClass;

            if (!col.type) col.type = prop.colOptions.type || 'input';
            if (!(('caption' in col) && ood.isDefined(col.caption))) col.caption = oid;
            ood.UI.adjustData(profile, col, uicol, 'sub');

            // id to dom item id
            profile.colMap2[col.id] = col[SubID];

            return [col, uicol];
        },
        _prepareCell: function (profile, cell, row, col, temp, _row, index) {
            // build header
            var ns = this,
                SubID = ood.UI.$tag_subId,
                prop = profile.properties,
                NONE = 'display:none',
                uicell = {};
            cell = ood.isSet(cell) ? ood.isHash(cell) ? cell : {value: cell} : {};
            //cell/cell link to row
            cell._row = row;
            //cell/cell link to header
            cell._col = col;
            //_serialId
            cell[SubID] = '-c_' + profile.pickSubId('cell');
            // give id
            cell.id = cell.id || cell[SubID];
            // adjust
            ns._adjustCell(profile, cell, uicell);
            // cell only link its' dom item id to properties item
            profile.cellMap[uicell[SubID]] = cell;
            if (temp) temp.push(cell);
            // row link to cell/cell
            row._cells[col.id] = uicell[SubID];
            // header link to cell/cell
            col._cells[row.id] = uicell[SubID];

            // for _first_cell
            if (prop.treeMode == 'infirstcell' && index === 0 && _row) {
                uicell._treeMode = _row._treeMode;
                uicell._rulerW = _row._rulerW;
                uicell._fi_togglemark = _row._fi_togglemark;
                uicell._rowMarkDisplay = _row._rowMarkDisplay;
                uicell._rowNumbDisplay = _row._rowNumbDisplay;
                uicell._ltagDisplay = _row._ltagDisplay;
                uicell.ltagCmds = _row.ltagCmds;
                uicell[ood.UI.$tag_subId_c] = _row[ood.UI.$tag_subId];
            }

            return [cell, uicell];
        },
        _prepareGrpCols: function (profile, arr, _header) {
            var prop = profile.properties;
            if (prop.showHeader && arr && ood.isArr(arr) && arr.length) {
                var header = prop.header,
                    headerHeight = profile.$px(prop.headerHeight),
                    borderH = profile.getRoot().contentBox() ? 2 : 0,
                    SubID = ood.UI.$tag_subId,
                    NONE = 'display:none',
                    _ngrp = [],
                    _grp, w, h, _left, _ww,

                    layer = profile._headerLayers,
                    h = headerHeight / (layer + 1),
                    flag = false;

                for (var j = 0, m = arr.length, grp; j < m; j++) {
                    _grp = {};
                    w = 0;
                    flag = false;
                    _left = 0;//prop.rowHandler?(profile.$px(prop.rowHandlerWidth)+borderH):0;

                    grp = arr[j];
                    ood.UI.adjustData(profile, grp, _grp, 'sub');
                    for (var k = 0, o; k <= grp['to']; k++) {
                        o = header[k];
                        p = _header[k];
                        _ww = profile.$px(p._colWidth);
                        if (k === grp.from) {
                            flag = true;
                            _grp._hcellleft = profile.$forceu(_left);
                        }
                        _left += _ww + borderH;
                        if (flag && !o.hidden) {
                            w += _ww + borderH;
                        }
                    }
                    _grp._colWidth = _grp._cellWidth = profile.$forceu(w - borderH);

                    _grp._hcellheight = profile.$forceu(h - borderH);
                    _grp._hcelltop = profile.$forceu(h * (grp._layer - 1));

                    _grp._tabindex = prop.tabindex;
                    _grp.colDDDisplay = (('colResizer' in grp) ? grp.colResizer : prop.colResizer) ? '' : NONE;

                    _ngrp.push(_grp)
                }

                // adjust base columns' height
                for (var k = 0, n = header.length, o, p; k < n; k++) {
                    o = header[k];
                    p = _header[k];
                    if (o._grp && o._grp.length) {
                        p._hcellheight = profile.$forceu(headerHeight - o._grp.length * h - borderH);
                    }
                }
                return _ngrp;
            }
        },
        _prepareHeader: function (profile, arr) {
            var header = [], colResult, prop = profile.properties;

            // init cols cache
            profile.colMap2 = {};
            profile.colMap = {};


            ood.arr.each(arr, function (o, i) {
                if (profile.beforePrepareCol && false === profile.boxing().beforePrepareCol(profile, o)) {
                    return;
                }
                colResult = profile.box._parepareCol(profile, o, arr, i);
                arr[i] = colResult[0];
                header.push(colResult[1]);
            });

            return header;
        },
        // to set uicell, or set dom node directly
        // uicell and node are not occur at the same time
        _renderCell: function (profile, cell, uicell, node, options) {
            var cellType, defalutTypes = [
                'input', 'password', 'combobox', 'checkbox', 'listbox', 'file', 'getter', 'helpinput', 'button',
                'dropbutton', 'cmdbox', 'cmd', 'popbox', 'textarea', 'label', 'date', 'profile', 'image',
                'text', 'time', 'datetime', 'color', 'spin', 'counter', 'currency', 'number', 'split'
            ];
            if (cell._col && cell._col.type) {
                cellType = cell._col.type;
            }
            var getPro = profile.box.getCellOption,
                type = getPro(profile, cell, 'type');
            if (ood.arr.indexOf(defalutTypes, type) == -1) {
                type = cellType;
            }


            var t1 = '',
                t2 = '',
                caption,
                cellanode = node,
                capOut = uicell && ood.isStr(uicell._caption) ? uicell._caption : uicell && ood.isStr(cell.caption) ? uicell.caption : ood.isStr(cell.caption) ? cell.caption : null,
                reg1 = /</g,
                dcls = 'ood-uicell-disabled',
                rcls = 'ood-ui-readonly',
                ren = function (profile, cell, uicell, fun, o) {
                    return (
                        // 1 renderer in cell
                        (o = cell.renderer || cell._renderer) ? ood.UI._applyRenderer(profile, o, cell, uicell) :
                            // typeof (cell.renderer||cell._renderer)=='function'? (cell.renderer||cell._renderer).call(profile,cell) :
                            // 2 template in cell
                            (uicell && typeof uicell.caption == 'string') ? uicell.caption :
                                // 3 default caption function
                                typeof fun == 'function' ? fun(cell.value, profile, cell) :
                                    // 4 value in cell
                                    (ood.isSet(cell.value) ? ("" + cell.value) :
                                        // 5 empty
                                        "")
                        // default value
                    ) || ""
                },
                f0 = function (v, profile, cell) {
                    return v ? ood.Date.getText(v, getPro(profile, cell, 'dateEditorTpl') || 'ymdhn') : "";
                },
                f1 = function (v, profile, cell) {
                    return v ? ood.Date.getText(v, getPro(profile, cell, 'dateEditorTpl') || 'ymd') : "";
                },
                f2 = function (v) {
                    return v ? (v + '').replace(reg1, '&lt;').replace(/\t/g, '    ')/*.replace(/ /g,' ')*/.replace(/(\r\n|\n|\r)/g, "<br />") : ""
                },
                f3 = function (v) {
                    return (v || v === 0) ? ((v * 100).toFixed(2) + '%') : ""
                },
                f4 = function (v, profile, cell) {
                    if (v || v === 0) {
                        return ood.formatNumeric(
                            parseFloat(v),
                            getPro(profile, cell, 'precision'),
                            getPro(profile, cell, 'groupingSeparator'),
                            getPro(profile, cell, 'decimalSeparator'),
                            getPro(profile, cell, 'forceFillZero'),
                            getPro(profile, cell, 'trimTailZero')
                        );
                    } else
                        return "";
                },
                f5 = function (v, profile, cell) {
                    if (v || v === 0) {
                        var precision = getPro(profile, cell, 'precision');
                        return ood.formatNumeric(
                            parseFloat(v),
                            // currency default precision is 2
                            ood.isSet(precision) ? precision : 2,
                            getPro(profile, cell, 'groupingSeparator'),
                            getPro(profile, cell, 'decimalSeparator'),
                            getPro(profile, cell, 'forceFillZero'),
                            getPro(profile, cell, 'trimTailZero')
                        );
                    } else
                        return "";
                },
                f6 = function (v, profile, cell) {
                    var t = getPro(profile, cell, 'editorListItems');
                    if (!t)
                        if (t = getPro(profile, cell, 'editorListKey'))
                            t = ood.UI.getCachedData(typeof(t) == "function" ? t() : t);
                    if ((typeof(t) == "function" ? (t = t()) : t) && t.length)
                        for (var i = 0, l = t.length; i < l; i++)
                            if (t[i].id === v)
                                return t[i].caption || v;
                    return f7(v, profile, cell);
                },
                f7 = function (v, profile, cell) {
                    if (v) {
                        v = v + "";
                        var t = v.indexOf('=');
                        if (t != -1) {
                            cell.value = v.substr(0, t);
                            return v.substr(t + 1);
                        }
                    }
                    return v;
                },
                unit = function (caption, cell) {
                    return caption + (cell.unit ? " " + cell.unit : "")
                };
            // get caption node
            if (node && node.get(0)) node = node.last();
            switch (type) {
                //  case 'number':
                //   case 'spin':
                case 'counter':
                    var v = parseFloat(cell.value);
                    cell.value = (v || v === 0) ? v : null;
                    caption = unit(capOut || ren(profile, cell, uicell, f4), cell);
                    var tpl = getPro(profile, cell, 'numberTpl');
                    if (tpl && caption)
                        caption = tpl.replace("*", caption);
                    if (node)
                        node.html(caption, false);
                    break;
                case 'currency':
                    var v = parseFloat((cell.value + "").replace(/[^\d.-]/g, ''));
                    cell.value = (v || v === 0) ? v : null;
                    //  Note that cell value has true numeric value, while caption has currency format with commas.
                    caption = unit(capOut || ren(profile, cell, uicell, f5), cell);
                    var tpl = getPro(profile, cell, 'currencyTpl');
                    if (tpl && caption !== "")
                        caption = tpl.replace("*", caption);
                    if (node)
                        node.html(caption, false);
                    break;
                case 'date':
                    cell.value = ood.isDate(cell.value) ? cell.value : ood.isFinite(cell.value) ? new Date(parseInt(cell.value, 10)) : ood.Date.parse(cell.value);
                    caption = unit(capOut || ren(profile, cell, uicell, f1), cell);
                    if (node)
                        node.html(caption, false);
                    break;
                case 'datetime':
                    cell.value = ood.isDate(cell.value) ? cell.value : ood.isFinite(cell.value) ? new Date(parseInt(cell.value, 10)) : ood.Date.parse(cell.value);
                    caption = unit(capOut || ren(profile, cell, uicell, f0), cell);
                    if (node)
                        node.html(caption, false);
                    break;
                case 'input':
                    cell.value = cell.value || "";
                    caption = unit(capOut || ren(profile, cell, uicell), cell);
                    if (node) node.html(caption, false);
                    break;
                case 'textarea':
                    cell.value = cell.value || "";
                    caption = unit(capOut || ren(profile, cell, uicell, f2), cell);
                    if (node) node.html(caption, false);
                    break;
                case 'color':
                    var c = ood.UI.ColorPicker._ensureValue(0, cell.value);
                    cell.value = cell.value ? ((c !== "transparent" ? '#' : '') + c) : "";
                    caption = unit(capOut || ren(profile, cell, uicell), cell);
                    if (cell.value) {
                        t1 = ood.UI.ColorPicker.getTextColor(cell.value);
                        if (node) {
                            node.html(caption, false);
                            node.css('color', t1);
                            node.parent().css('backgroundColor', cell.value);
                        } else {
                            uicell.color = 'color:' + t1 + ';';
                            uicell.bgcolor = 'background-color:' + cell.value + ';';
                        }
                    } else {
                        if (node) {
                            node.html(caption, false);
                            node.css('color', '');
                            node.parent().css('backgroundColor', '');
                        } else {
                            //uicell.color='color:#000;';
                            //uicell.bgcolor='background-color:#fff;';
                        }
                    }
                    break;
                case 'checkbox':
                    cell.value = cell.value === "0" ? false : !!cell.value;
                    caption = unit(cell.value + '', cell);
                    if (node)
                        node.tagClass('-checked', cell.value);
                    else {
                        uicell._fi_checkboxCls = cell.value ? 'oodfont-checked ood-uicmd-check-checked' : '';
                    }
                    break;
                case 'progress':
                    cell.value = parseFloat(cell.value) || 0;
                    cell.value = Math.min(Math.max(cell.value, 0), 1);
                    caption = unit(capOut || ren(profile, cell, uicell, f3), cell);
                    if (node) {
                        node.first().html(caption, false);
                        node.width(caption);
                    } else
                        uicell.progress = caption;
                    break;
                case 'listbox':
                    cell.value = cell.hasOwnProperty("value") ? cell.value : "";
                    try{
                        caption = ood.adjustRes(unit(capOut || ren(profile, cell, uicell, f6), cell));
                    }catch (e) {

                    }

                    if (node) node.html((caption === null || caption === undefined) ? cell.value : caption, false);
                    break;
                case 'dropbox':
                case 'cmdbox':
                    cell.value = cell.hasOwnProperty("value") ? cell.value : "";
                    caption = ood.adjustRes(unit(capOut || ren(profile, cell, uicell, f7), cell));
                    if (node) node.html((caption === null || caption === undefined) ? cell.value : caption, false);
                    break;
                default:
                    cell.value = cell.hasOwnProperty("value") ? cell.value : "";
                    caption = ood.adjustRes(unit(capOut || ren(profile, cell, uicell), cell));
                    if (node) node.html((caption === null || caption === undefined) ? cell.value : caption, false);
            }

            if ('_renderer' in cell) delete cell._renderer;
            cell._caption = cell._$tips = cell._$tmpcap = caption;

            var t2 = getPro(profile, cell, 'disabled'),
                t3 = getPro(profile, cell, 'readonly');
            if (uicell) {
                /*
                    colRenderer
                    rowRenderer

                    cellStyle
                    cellClass
                    cellRenderer

                    renderer
                    type
                    disabled
                    readonly
                    increment
                    min
                    max
                    maxlength
                    precision
                    dateEditorTpl
                    editable
                    value
                    caption
                    sortby [for column only]

                    customEditor -> an object for custom editor. or the below prop

                    editorListKey
                    editorListItems
                    editorFormat
                    editorMask
                    editorReadonly
                    editorDropListWidth
                    editorDropListHeight
                    editorProperties
                    editorCC
                    editorCS
                    editorEvents
                */
                uicell.cellCls = profile.getClass('CELL', '-' + type) + (t2 ? (' ' + dcls) : '') + (t3 ? (' ' + rcls) : '');
                uicell.type = type;
                uicell.value = cell.value;
                uicell._caption = caption;
                uicell.cellStyle = getPro(profile, cell, 'cellStyle');
                uicell.cellClass = getPro(profile, cell, 'cellClass');
            } else {
                if (t2) cellanode.parent().addClass(dcls);
                else cellanode.parent().removeClass(dcls);
                if (t3) cellanode.parent().addClass(rcls);
                else cellanode.parent().removeClass(rcls);

                if (t2 = options.cellStyle)
                    cellanode.attr('style', cellanode.attr('style') + ";" + t2);
                if (t2 = options.cellUnclass)
                    cellanode.removeClass(t2);
                if (t2 = options.cellClass)
                    cellanode.addClass(t2);
            }
            return cell;
        },
        _applyRendererEx: function (profile, prop, events, cell, adjustRenderer, t) {
            // for cell only
            if (cell) {
                if (t = cell._col) {
                    adjustRenderer(t, prop, events);
                    adjustRenderer(t.tagVar, prop, events);
                }
                if (t = cell._row) {
                    adjustRenderer(t, prop, events);
                    adjustRenderer(t.tagVar, prop, events);
                }
            }
        },
        _prepareItems: function (profile, arr, pid, temparr) {
            var self = this,
                prop = profile.properties,
                _treemode = prop.treeMode,
                mm = profile._$subMargin || (profile._$subMargin = profile.$px(prop.$subMargin)),
                a = profile.rowMap2,
                b = profile.rowMap,
                _layer = pid ? b[pid] ? (b[pid]._layer + 1) : 0 : 0,
                SubID = ood.UI.$tag_subId,
                ider = profile._id || (profile._id = new ood.id()),
                rows = [],
                temp, cells, t, row, v, cellResult,
                ro = prop.rowOptions,
                itemFilter = profile.$itemFilter,
                NONE = 'display:none';

            _treemode = !(!_treemode || _treemode == "none");


            if (itemFilter) itemFilter('begin', 'prepareItem', profile);
            for (var i = 0, l = arr.length; i < l; i++) {
                row = arr[i];
                // give id (avoid conflicts)
                if (!row.id || a[row.id]) {
                    while (a[t = ider.next()]) ;
                    row.id = "-" + t;
                } else {
                    row.id += "";
                }
                if (profile.beforePrepareRow && false === profile.boxing().beforePrepareRow(profile, row, pid, temparr)) {
                    continue;
                }

                // give _serialId
                temp = '-r_' + profile.pickSubId('row');
                row[SubID] = temp;
                b[temp] = row;

                //#
                row._pid = pid;
                row._cells = {};
                row._layer = _layer;

                row._tabindex = prop.tabindex;
                row._rowMarkDisplay = (prop.selMode == "multi" || prop.selMode == "multibycheckbox") ? "" : NONE;

                row._treeMode = _treemode ? '' : NONE;

                row._rowNumbDisplay = prop.rowNumbered ? '' : NONE;

                t = {id: row.id};

                t.rowCls = "";
                if (row.disabled)
                    t.rowCls += ' ood-uicell-disabled';
                if (row.readonly)
                    t.rowCls += ' ood-ui-readonly';
                if (row.group) {
                    t.group = 1;
                    t.rowCls += ' ' + profile.getClass('CELLS1', '-group') + " ood-uiborder-r ood-uiborder-light";
                }
                // filter: hidden
                if (itemFilter) row.hidden = !!itemFilter(row, 'prepareItem', profile);

                if (row.hidden)
                    t.rowDisplay = NONE;

                t._row0DfW = prop.rowHandlerWidth ? ('width:' + profile.$forceu(prop.rowHandlerWidth)) : '';
                t._rulerW = 'width:' + (row.rulerWidth || profile.$forceu(4 + _layer * mm));

                // use em for row Height
                t._rowHeight = profile.$forceu(row._rowHeight || row.height || prop.rowHeight, 'em');
                row._rowHeight = t._rowHeight;
                t._rowHeight = "height:" + t._rowHeight;

                t.rowHandlerDisplay = prop.rowHandler ? '' : NONE;
                t.rowDDDisplay = (('rowResizer' in row) ? row.rowResizer : prop.rowResizer) ? '' : NONE;

                t.firstCellStyle = row.firstCellStyle || ro.firstCellStyle || '';
                t.firstCellClass = row.firstCellClass || ro.firstCellClass || '';

                cells = t.cells = [];

                t[SubID] = temp;
                //   t._fi_togglemark = row.sub?'ood-uicmd-toggle':(row._layer?'ood-uicmd-empty':'');
                // t._fi_togglemark = row.sub?'ood-uicmd-toggle':'';
                t._fi_togglemark = row.sub ? ('ood-uicmd-toggle' + (row._checked ? " oodfont-checked ood-uicmd-toggle-checked" : "")) : (prop.togglePlaceholder ? 'ood-icon-placeholder' : 'ood-uicmd-none');

                // id to dom item id
                a[row.id] = temp;

                if (!row.hasOwnProperty('caption') && row.hasOwnProperty('value'))
                    row.caption = '' + row.value;

                row._oValue = row.value;

                if (row.caption && !row.tips)
                    row._$tips = row.caption;

                ood.UI.adjustData(profile, row, t, 'sub');

                t.tagCmds = ood.clone(t.tagCmds || ro.tagCmds || prop.tagCmds);


                if (t.tagCmds) {

                    this._prepareCmds(profile, t, function (item) {
                        var pos = item.pos || item.tag;
                        return !pos || !(pos == 'header' || pos == 'header row' || pos == 'all');
                    });
                }


                // for cells
                if (row.group)
                    row.cells = null;
                if ((v = row.cells)) {
                    ood.arr.each(prop.header, function (col, j) {
                        cellResult = profile.box._prepareCell(profile, v[j], row, col, temparr, t, j);
                        v[j] = cellResult[0];
                        cells.push(cellResult[1]);
                    });
                }

                var hash = {};
                ood.merge(hash, t, function (o, i) {
                    return ood.isNumb(o) || ood.isStr(o) || i == 'ltagCmds';
                });
                hash[ood.UI.$tag_subId_c] = t[ood.UI.$tag_subId];
                t._handler_cell = ood.clone(hash);

                if (prop.treeMode == 'infirstcell') {
                    if (row.group)
                        t._firstcell_grp = ood.clone(hash);

                    t._rulerW = t._fi_togglemark = '';
                    t._treeMode = t.tMarkDisplay = t.tNumbDisplay = t._ltagDisplay = NONE;
                    t.ltagCmds = null;
                }
                rows.push(t);
            }
            if (itemFilter) itemFilter('end', 'prepareItem', profile);
            return rows;
        },
        _adjustCell: function (profile, cell, uicell) {
            var self = this,
                prop = profile.properties,
                col = cell._col,
                renderer = self.getCellOption(profile, cell, 'cellRenderer') || prop.renderer,
                cellCapTpl = self.getCellOption(profile, cell, 'cellCapTpl');

            // allow to set caption dynamically
            if (cellCapTpl)
                cell._caption = cellCapTpl;
            ood.UI.adjustData(profile, cell, uicell, 'sub');

            if (renderer)
                cell._renderer = renderer;
            if (!uicell._cellWidth)
                uicell._cellWidth = col._colWidth;

            uicell._tabindex = prop.tabindex;
            uicell.cellDisplay = col.hidden === true ? 'display:none;' : '';

            self._renderCell(profile, cell, uicell);

            //next
            cell._oValue = cell.value;
            if ('unit' in cell) cell._oUnit = cell.unit;
        },
        _setSub: function (profile, item, flag, recursive, stopanim, cb) {
            var id = profile.domId,
                ins = profile.boxing(),
                prop = profile.properties,
                itemId = profile.rowMap2[item.id],
                markNode = profile.box._getToggleNode(profile, itemId),
                subNs = profile.getSubNodes(['SUB1', 'SUB2'], itemId),

                subNs1 = ood(subNs.get(0)),
                subNs2 = ood(subNs.get(1));

            if (ood.Thread.isAlive(profile.key + profile.id)) return;
            //close
            if (!flag) {
                if (item._checked) {
                    if (ins.beforeFold && false === ins.beforeFold(profile, item)) {
                        return;
                    }
                    var onend = function () {
                        subNs.css({display: 'none', height: 0, overflow: ''});
                        markNode.tagClass('-checked', false);
                        item._checked = false;

                        if (prop.dynDestory || item.dynDestory) {
                            var s = item.sub, arr = [];
                            for (var i = 0, l = s.length; i < l; i++)
                                arr.push(s[i].id);
                            profile.boxing().removeRows(arr);
                            item.sub = true;
                            delete item._inited;
                        }
                        if (ins.afterFold)
                            ins.afterFold(profile, item);

                        ood.resetRun(id, function (cb) {
                            profile.box._asy(profile);
                            //clear rows cache
                            delete profile.$allrowscache1;
                            delete profile.$allrowscache2;
                            profile.box._adjustBody(profile, 'foldrow');
                            if (cb) ood.tryF(cb, [profile, item], ins);
                        }, 0, [cb]);
                    };
                    if (!stopanim) {
                        if (prop.animCollapse) {
                            subNs.css('overflow', 'hidden');
                            subNs.animate({'height': [subNs2.height(), 0]}, null, onend, 200, null, 'expoOut', profile.key + profile.id).start();
                        } else onend();
                    } else onend();
                }
                if (recursive && item.sub && !prop.dynDestory && !item.dynDestory) {
                    ood.arr.each(item.sub, function (o) {
                        if (o.sub && o.sub.length)
                            profile.box._setSub(profile, o, flag, recursive, true, cb);
                    });
                }
            } else {
                //open
                if (!item._checked) {
                    if (ins.beforeExpand && false === ins.beforeExpand(profile, item)) {
                        return;
                    }
                    var onend = function (empty, t) {
                            //markNode.css('background','');
                            // compitable with IE<8
                            if (ood.browser.ie && ood.browser.ver <= 8) {
                                markNode.css({
                                    backgroundImage: '',
                                    backgroundRepeat: '',
                                    backgroundPositionX: '',
                                    backgroundPositionY: '',
                                    backgroundColor: '',
                                    backgroundAttachment: ''
                                });
                            } else {
                                markNode.removeClass('ood-icon-loading');
                            }
                            if (!empty) {
                                item._checked = true;
                                if (ins.afterExpand)
                                    ins.afterExpand(profile, item);
                            }
                            subNs.css({display: '', height: 'auto', overflow: ''});
                            if ((prop.freezedRow || prop.rowHandler) && !subNs1.height() && (t = subNs2.height()))
                                subNs1.height(t);

                            ood.resetRun(id, function (cb) {
                                profile.box._asy(profile);
                                //clear rows cache
                                delete profile.$allrowscache1;
                                delete profile.$allrowscache2;
                                profile.box._adjustBody(profile, 'expandrow');
                                if (cb) ood.tryF(cb, [profile, item], ins);
                            }, 0, [cb]);
                        },
                        openSub = function (profile, item, id, markNode, subNs1, subNs2, subNs, sub) {
                            var b = profile.boxing(),
                                p = profile.properties,
                                empty = sub === false;
                            //created
                            if (!empty && !item._inited) {
                                delete item.sub;
                                //before insertRows
                                item._inited = true;
                                if (sub) {
                                    if (typeof sub == 'string') {
                                        subNs2.html(item.sub = sub, false);
                                        // right-bottom border
                                        subNs.addClass('ood-uiborder-r ood-uiborder-b ood-uiborder-light');
                                    } else if (sub['ood.Template'] || sub['ood.UI']) {
                                        subNs2.append(item.sub = sub.render(true));
                                        // right-bottom border
                                        subNs.addClass('ood-uiborder-r ood-uiborder-b ood-uiborder-light');
                                    } else if (ood.isArr(sub)) {
                                        b.insertRows(sub, item.id);
                                        // for []
                                        if (!item.sub) item.sub = sub;
                                    }
                                    var s = 0, arr = b.getUIValue(true);
                                    if (arr && arr.length) {
                                        ood.arr.each(sub, function (o) {
                                            if (ood.arr.indexOf(arr, o.id || o) != -1) {
                                                s = 1;
                                                return false;
                                            }
                                        });
                                        if (s) {
                                            //set checked items
                                            b._setCtrlValue(b.getUIValue());
                                        }
                                    }
                                }
                            }

                            if (!empty) {
                                markNode.tagClass('-checked');
                            }

                            if (!stopanim) {
                                subNs.css("height", "0px").css("display", '');

                                if (p.animCollapse) {
                                    var h = 0;
                                    subNs2.children().each(function (o) {
                                        h += o.offsetHeight;
                                    });
                                    subNs.css('overflow', 'hidden');
                                    subNs.animate({'height': [0, h]}, null, function () {
                                        onend(empty);
                                    }, 200, null, 'expoIn', profile.key + profile.id).start();
                                } else onend(empty);
                            } else onend(empty);
                        },
                        sub = item.sub,
                        callback = function (sub) {
                            openSub(profile, item, id, markNode, subNs1, subNs2, subNs, sub);
                        }, t;

                    if ((t = typeof sub) == 'string' || t == 'object')
                        callback(sub);
                    else if (profile.onGetContent) {
                        if (ood.browser.ie && ood.browser.ver <= 8) {
                            markNode.css('background', 'url(' + ood.ini.img_busy + ') no-repeat');
                        } else {
                            markNode.addClass('ood-icon-loading');
                        }
                        var r = profile.boxing().onGetContent(profile, item, callback);
                        if (r || r === false) {
                            //return true: toggle icon will be checked
                            if (r === true)
                                item._inited = true;
                            callback(r);
                        }
                    }
                }
                if (recursive && item.sub) {
                    ood.arr.each(item.sub, function (o) {
                        if (o.sub && o.sub.length && !o._checked)
                            profile.box._setSub(profile, o, flag, recursive, true, cb);
                    });
                }
            }
        },
        _getCellId: function (profile, rowId, colId) {
            if (ood.isNumb(rowId)) rowId = ood.get(profile.properties.rows, [rowId, "id"]);
            if (ood.isNumb(colId)) colId = ood.get(profile.properties.header, [colId, "id"]);
            return ood.get(profile.rowMap, [profile.rowMap2[rowId], '_cells', colId]);
        },
        _updCell: function (profile, cellId, options, dirtyMark, triggerEvent, triggerFormula) {
            var box = profile.box,
                prop = profile.properties,
                pdm = prop.dirtyMark,
                psdm = pdm && prop.showDirtyMark,
                sc = ood.absObj.$specialChars,
                cell, node, ishotrow, ext;

            if (typeof cellId == 'string')
                cell = profile.cellMap[cellId];
            else {
                cell = cellId;
                cellId = cell._serialId;
            }
            if (!cell || !cell._row) return;
            ishotrow = cell._row.id == box._temprowid;
            if (ishotrow && cell.caption == prop.hotRowCellCap)
                delete cell.caption;

            if (!ood.isHash(options)) options = {value: options};
            options = ood.filter(options, function (o, i, r) {
                r = !sc[i.charAt(0)];
                if (!r) {
                    ext = ext || {};
                    ext[i] = o
                }
                return r;
            });
            if (triggerEvent) {
                if (profile.beforeCellUpdated && false === profile.boxing().beforeCellUpdated(profile, cell, options, ishotrow, ext))
                    return;
            }
            if (!ood.isEmpty(options)) {
                // * remove cell's special setting first
                delete cell._$tips;
                delete cell._$tmpcap;

                ood.merge(cell, options, 'all');

                node = profile.getSubNode('CELLA', cellId);
                if ('type' in options) {
                    var uicell = {};
                    box._adjustCell(profile, cell, uicell);
                    node.parent().replace(profile._buildItems('rows2.cells', [uicell]));
                    node = profile.getSubNode('CELLA', cellId);
                } else {
                    // allow to set caption dynamically
                    var cellCapTpl = box.getCellOption(profile, cell, 'cellCapTpl');
                    // * : only for cellCapTpl => caption
                    if (cellCapTpl)
                        cell.caption = ood.adjustRes(cellCapTpl, true, false, null, null, cell);
                    cell = box._renderCell(profile, cell, null, node, options);
                }

                var editor = cell._editor;

                //if update value
                if ('value' in options) {
                    if (!pdm || dirtyMark === false)
                        cell._oValue = cell.value;
                    if ('unit' in cell) cell._oUnit = cell.unit;
                    else {
                        if (cell.value === cell._oValue && (!('unit' in cell) || cell._oUnit === cell.unit)) {
                            if (psdm)
                                node.removeClass('ood-ui-dirty');
                        } else {
                            if (psdm)
                                node.addClass('ood-ui-dirty');
                        }
                    }
                    if (editor) editor.setValue(cell.value, true, 'editorini');
                    // formula
                    if (triggerFormula !== false)
                        ood.resetRun(profile.key + ":" + profile.$xid + ":" + cell.id, function () {
                            if (profile && profile.box) profile.boxing().triggerFormulas(cell, 'updatecell');
                        });
                }
                if (('caption' in options) && editor && editor.setCaption) {
                    editor.setCaption(options.caption || null, true);
                }

                cell._dirty = 1;
            }
            if (triggerEvent) {
                if (profile.afterCellUpdated)
                    profile.boxing().afterCellUpdated(profile, cell, options, ishotrow, ext);
            }
        },
        _ensureValue: function (profile, value) {
            if (profile.properties.selMode == 'multi' || profile.properties.selMode == 'multibycheckbox') {
                var arr = ood.isArr(value) ? value : (value ? ('' + value) : '').split(profile.properties.valueSeparator);
                // ignore hot row
                ood.arr.removeValue(arr, this._temprowid);
                arr.sort();
                return arr.join(profile.properties.valueSeparator);
            } else {
                // ignore hot row
                return value == this._temprowid ? null : value;
            }
        },
        _sel: function (profile, type, src, id, e) {
            var properties = profile.properties;
            if (properties.activeMode != type) return;

            var targetId = profile.getSubId(id),
                map = type == 'cell' ? profile.cellMap : profile.rowMap,
                box = profile.boxing(),
                targetItem = map[targetId],
                ks = ood.Event.getKey(e),
                sid = type == 'cell' ? (targetItem._row.id + '|' + targetItem._col.id) : targetItem.id,
                mode = properties.selMode;
            switch (mode) {
                case 'none':
                    box.onRowSelected(profile, targetItem, e, src, 0);
                    break;
                case 'multibycheckbox':
                    if (profile.keys.MARK) {
                        var ck = profile.getKey(ood.Event.getSrc(e).id || ""),
                            clickMark = ck == profile.keys.MARK;
                        if (!clickMark) {
                            box.onRowSelected(profile, targetItem, e, src, 0);
                            break;
                        }
                    }
                case 'multi':
                    var value = box.getUIValue(),
                        arr = value ? ('' + value).split(properties.valueSeparator) : [],
                        checktype = 1;
                    if (arr.length && (ks.ctrlKey || ks.shiftKey || properties.noCtrlKey)) {
                        //todo: give cell multi selection function
                        if (ks.shiftKey && type == 'row') {
                            if (profile.$firstV._pid != targetItem._pid) return false;
                            var items = properties.rows;
                            if (targetItem._pid) {
                                var pitem = map[targetItem._pid];
                                if (pitem) items = pitem.sub;
                            }
                            var i1 = ood.arr.subIndexOf(items, 'id', profile.$firstV.id),
                                i2 = ood.arr.subIndexOf(items, 'id', targetItem.id),
                                i;
                            arr.length = 0;
                            for (i = Math.min(i1, i2); i <= Math.max(i1, i2); i++)
                                arr.push(items[i].id);
                        } else {
                            if (ood.arr.indexOf(arr, sid) != -1) {
                                ood.arr.removeValue(arr, sid);
                                checktype = -1;
                            } else
                                arr.push(sid);
                        }

                        arr.sort();
                        value = arr.join(properties.valueSeparator);

                        //update string value only for setCtrlValue
                        if (box.getUIValue() != value) {
                            box.setUIValue(value, null, null, 'click');
                            if (box.get(0) && box.getUIValue() == value)
                                box.onRowSelected(profile, targetItem, e, src, checktype);
                        }
                        break;
                    }
                case 'single':
                    if (box.getUIValue() != sid) {
                        profile.$firstV = targetItem;
                        box.setUIValue(sid, null, null, 'click');
                        if (box.get(0) && box.getUIValue() == sid)
                            box.onRowSelected(profile, targetItem, e, src, 1);
                    }
                    break;
            }
        },
        _activeCell: function (profile, id) {
            if (profile.properties.activeMode != 'cell') return;
            if (profile.$activeCell == id) return;
            var targetCell = null;
            if (profile.$activeCell) {
                ood(profile.$activeCell).tagClass('-active', false);
                delete profile.$activeCell;
            }
            if (id !== false) {
                var targetId = profile.getSubId(id),
                    map = profile.cellMap;
                targetCell = map[targetId];
                if (profile.beforeCellActive && (false === profile.boxing().beforeCellActive(profile, targetCell))) return;
                ood(profile.$activeCell = id).tagClass('-active');
            }
            if (profile.afterCellActive) profile.boxing().afterCellActive(profile, targetCell);
        },
        _activeRow: function (profile, id) {
            if (profile.properties.activeMode != 'row') return;
            if (profile.$activeRow == id) return;
            var targetRow = null, subId;
            if (profile.$activeRow) {
                subId = profile.getSubId(profile.$activeRow);
                profile.getSubNodes(['CELLS1', 'CELLS2'], subId).tagClass('-active', false);
                delete profile.$activeRow;
            }
            if (id !== false) {
                var targetId = profile.getSubId(id),
                    map = profile.rowMap;
                targetRow = map[targetId];
                //before event
                if (profile.beforeRowActive && (false === profile.boxing().beforeRowActive(profile, targetRow))) return;
                subId = profile.getSubId(profile.$activeRow = id);
                profile.getSubNodes(['CELLS1', 'CELLS2'], subId).tagClass('-active');
            }
            //after event
            if (profile.afterRowActive) profile.boxing().afterRowActive(profile, targetRow);
        },
        _getCellFormula: function (profile, cell, col, row) {
            var t, p = profile.properties, f1 = function (t, col) {
                t = ood.isStr(t) ? t : ('=' + t);
                return t.replace(/(\B)(\?)([0-9]+\b)/g, '$1' + col + '$3').replace(/(\b)(_)([0-9]+\b)/g, '$1' + col + '$3');
            }, f2 = function (t, row) {
                t = ood.isStr(t) ? t : ('=' + t);
                return t.replace(/(\b[A-Z]+)(\?)(\B)/g, '$1' + row + '$3').replace(/(\b[A-Z]+)(_)(\b)/g, '$1' + row + '$3');
            };
            return (cell && (t = cell.formula)) ? t
                : (cell && (t = cell._row) && (t = t.formula)) ? f1(t, col)
                    : ((t = p.rowOptions) && (t = t.formula)) ? f1(t, col)
                        : (cell && (t = cell._col) && (t = t.formula)) ? f2(t, row)
                            : ((t = p.colOptions) && (t = t.formula)) ? f2(t, row)
                                : null;
        },
        getCellOption: function (profile, cell, key) {
            var t = cell, p = profile.properties;


            return (t && t.hasOwnProperty(key) && ood.isSet(t = t[key])) ? t
                //  : (cell && (t = cell._row) && t.hasOwnProperty(key) && ood.isSet(t = t[key])) ? t
                : ((t = p.rowOptions) && t.hasOwnProperty(key) && ood.isSet(t = t[key])) ? t
                    : (cell && (t = cell._col) && t.hasOwnProperty(key) && ood.isSet(t = t[key])) ? t
                        : ((t = p.colOptions) && t.hasOwnProperty(key) && ood.isSet(t = t[key])) ? t
                            : ((t = p) && t.hasOwnProperty(key) && ood.isSet(t = t[key])) ? t : null;
        },
        _trycheckrowdirty: function (profile, cell) {
            if (!cell || !cell._row) return;

            ood.resetRun(profile.key + ":" + profile.$xid + ":" + cell._row.id, function () {
                // destroyed
                if (!profile.box) return;
                var lc = profile.$cellInEditor;
                if (cell._row && (!lc || (lc._row && lc._row != cell._row))) {
                    var dirty = false;
                    ood.arr.each(cell._row.cells, function (v) {
                        if (v._oValue !== v.value || (('unit' in v) && v._oUnit !== v.unit)) {
                            dirty = true;
                            return false;
                        }
                    });
                    if (dirty && cell._row.id != profile.box._temprowid && profile.onRowDirtied)
                        profile.boxing().onRowDirtied(profile, cell._row);
                }
            }, 100);
        },
        _adjusteditorW: function (profile, nodes, width) {
            if (nodes) {
                nodes.each(function (n, i) {
                    if (!(i = n.id)) return;
                    i = i.split(":")[2];
                    if (i = profile.cellMap[i])
                        if (i._editor)
                            i._editor.setWidth(width);
                });
            }
        },
        _adjusteditorH: function (profile, nodes, height) {
            nodes.each(function (n, i) {
                if (!(i = n.id)) return;
                i = i.split(":")[2];
                if (i = profile.rowMap[i]) {
                    i = i.cells;
                    for (var j in i) {
                        j = i[j];
                        if (j._editor)
                            j._editor.setHeight(profile.$addpx(height, 1, j._editor.getRootNode()));
                    }
                }
            });
        },
        _editCell: function (profile, cellId, byhover, inactive) {
            var cell = typeof cellId == 'string' ? (profile.cellMap[cellId] || profile.cellMap[profile.cellMap2[cellId]]) : cellId;
            if (!cell) return;
            // real cellId
            cellId = cell._serialId;

            var box = profile.box,
                getPro = function (key, _cell) {
                    return box.getCellOption(profile, _cell || cell, key)
                };

            if (getPro('disabled') || getPro('readonly') || !getPro('editable')) return;

            var editor,
                grid = this,
                prop = profile.properties,
                cb = profile.getRoot().contentBox(),
                type = getPro('type') || 'input',
                //region = prop.freezedColumn prop.freezedRow
                col = cell._col,
                colId = col.id,
                row = cell._row,
                rowId = row.id,
                ishotrow = rowId == profile.box._temprowid,
                editMode = getPro('editMode'),
                inline = editMode == "inline" || (getPro('type') == 'dropbutton'),
                baseNode = profile.getSubNode('SCROLL' + row._region + col._region),
                //baseNode = profile.getSubNode('BORDER'),
                cellNode = profile.getSubNode('CELL', cellId),
                toggleNode = prop.treeMode == 'infirstcell' && profile.getSubNode('ROWTOGGLE', cellId);

            // only for first cell and, shown toggle
            if (toggleNode && (toggleNode.isEmpty() || !toggleNode.get(0).clientWidth)) {
                toggleNode = null;
            }

            if (!inline) {
                //clear the prev editor
                editor = profile.$curEditor;
                if (editor) ood.tryF(editor.undo, [], editor);
                editor = null;
            }

            // -1. for special type
            if (inline && cell._editor) {
                if (!inactive) cell._editor.activate();
                return;
            } else if (type == 'checkbox' || type == 'button') {
                if (!inactive) profile.getSubNode('CELLA', cellId).focus(true);
                return;
            }

            // 1. customEditor in cell/row or header
            if ((editor = getPro('customEditor')) && typeof editor.iniEditor == 'function') {
                editor.iniEditor(profile, cell, cellNode);
                if (!inactive) ood.tryF(editor.activate, [], editor);
                if (profile.onBeginEdit)
                    profile.boxing().onBeginEdit(profile, cell, editor, 'cell');
            } else {
                // 2. beforeIniEditor
                //      returns an editor(ood.UI object)
                //      or, sets $editorValue
                if (profile.beforeIniEditor) {
                    editor = profile.boxing().beforeIniEditor(profile, cell, cellNode, baseNode, 'cell');
                    // if return false, dont set $curEditor
                    if (editor === false)
                        return;
                }

                // 3. for lable type only, give it an chance to customEditor/beforeIniEditor
                if (type == 'label') {
                    if (!inactive) profile.getSubNode('CELLA', cellId).focus(true);
                    return;
                }

                // if beforeIniEditor doesnt return an editor
                if (!editor || !editor['ood.UI']) {
                    var editorAutoPop = getPro('editorAutoPop'),
                        editorCacheKey = getPro('editorCacheKey'),
                        editorProperties = getPro('editorProperties'),
                        editorCC = getPro('editorCC'),
                        editorCS = getPro('editorCS'),
                        editorEvents = getPro('editorEvents'),
                        editorFormat = getPro('editorFormat'),
                        editorMask = getPro('editorMask'),
                        editorReadonly = getPro('editorReadonly'),
                        editorHAlign = getPro('editorHAlign'),
                        editorDropListWidth = getPro('editorDropListWidth'),
                        editorDropListHeight = getPro('editorDropListHeight'),
                        editorCommandBtn = getPro('editorCommandBtn'),
                        t, oldProp;


                    if (!inline) {
                        // 4. try to get editor from cache
                        if (editorCacheKey && profile.$cache_editor[editorCacheKey])
                            editor = profile.$cache_editor[editorCacheKey];
                        if (editor && (!editor.get(0) || editor.isDestroyed()))
                            editor = nulll;
                    }
                    // 5. else, create a ComboInput Editor, and cache it
                    if (!editor) {
                        var iniprop = {
                            dirtyMark: false,
                            cachePopWnd: false,
                            left: -1000,
                            top: -1000,
                            position: 'absolute',
                            visibility: 'hidden',
                            zIndex: 100
                        };
                        if (inline) {
                            ood.merge(iniprop, {
                                left: -5,
                                top: 0,
                                cachePopWnd: true,
                                width: profile.$px(cell._col._colWidth) + (cb ? 2 : 1) + 5,
                                height: profile.$px(cell._row._rowHeight) + (cb ? 1 : 0),
                                visibility: 'visible',
                                zIndex: 100
                            }, 'all');
                        }

                        editor = new ood.UI.ComboInput(iniprop);
                    }
                    switch (type) {
                        // input
                        // button
                        // checkbox
                        //case 'number':
                        case 'spin':
                        case 'counter':
                        case 'currency':
                            editor.setType(type);
                            ood.each(ood.toArr('precision,increment,min,max,maxlength,currencyTpl,numberTpl,groupingSeparator,decimalSeparator,forceFillZero,trimTailZero,unit,units'), function (key, u) {
                                v = getPro(key);
                                if (type == 'currency') {
                                    if (key == 'precision' && !v) v = 2;
                                } else {
                                    if (key == 'precision' && !v) v = 0;
                                    if (key == 'increment' && !v) v = 1;
                                }

                                if (ood.isSet(v)) editor['set' + ood.str.initial(key)](v);
                            });
                            break;
                        case 'progress':
                            editor.setType('spin').setMax(1).setMin(0).setPrecision(4).setIncrement(0.01);
                            break;
                        case 'input':
                            editor.setType('none');
                            break;
                        case 'checkbox':
                            editor.setType('checkbox');
                            break;
                        case 'textarea':
                            editor.setType('none').setMultiLines(true).setCommandBtn('save').onCommand(function (p) {
                                p.boxing().hide();
                            });
                            if (!inline)
                                ood.tryF(editor.setResizer, [true], editor);
                            break;
                        case 'date':
                        case 'datetime':
                            var dateEditorTpl = getPro('dateEditorTpl');
                            if (dateEditorTpl)
                                editor.setDateEditorTpl(dateEditorTpl);
                        case 'listbox':
                        case 'combobox':
                        case 'helpinput':
                        case 'time':
                        case 'color':
                        case 'getter':
                        case 'popbox':
                        case 'dropbutton':
                        case 'cmdbox':
                            editor.setType(type);
                            if (profile.box.getCellOption(profile, cell, 'disabled')) {
                            } else {
                                editor.beforeComboPop(function (editorprf, pos, e, src) {
                                    var cell = editorprf.$cell,
                                        event = profile.box.getCellOption(profile, cell, 'event');
                                    if (typeof event == 'function')
                                        return event.call(profile._host || profile, profile, cell, editorprf, pos, e, src);
                                    else
                                        return profile.boxing().beforeComboPop(profile, cell, editorprf, pos, e, src);
                                });
                                if (profile.beforePopShow)
                                    editor.beforePopShow(function (editorprf, popCtl, items) {
                                        return profile.boxing().beforePopShow(profile, editorprf.$cell, editorprf, popCtl, items);
                                    });
                                if (profile.afterPopShow)
                                    editor.afterPopShow(function (editorprf, popCtl) {
                                        return profile.boxing().afterPopShow(profile, editorprf.$cell, editorprf, popCtl);
                                    });
                                if (type == 'popbox' || type == 'cmdbox' || type == 'getter' || type == 'dropbutton') {
                                    if (profile.onEditorClick)
                                        editor.onClick(function (prf, e, src, btn) {
                                            return profile.boxing().onEditorClick(profile, prf.$cell, prf, btn, src);
                                        });
                                }
                            }
                            break;
                        case 'file':
                            editor.setType(type);
                            break;
                    }
                    if (profile.onCommand)
                        editor.onCommand(function (editorprf, node, type) {
                            return profile.boxing().onCommand(profile, editorprf.$cell, editorprf, node, type);
                        });

                    cell._editor = editor;
                    if (inline) {
                        cellNode.append(editor);
                    } else {
                        baseNode.append(editor);
                    }
                    //cache the stantdard editor
                    if (!inline && editorCacheKey)
                        profile.$cache_editor[editorCacheKey] = editor;

                    if (editor.setInputReadonly)
                        editor.setInputReadonly(!!editorReadonly);
                    if (editor.setDropListWidth && editorDropListWidth)
                        editor.setDropListWidth(editorDropListWidth);
                    if (editor.setDropListHeight && editorDropListHeight)
                        editor.setDropListHeight(editorDropListHeight);
                    if (editor.setHAlign && editorHAlign)
                        editor.setHAlign(editorHAlign);
                    if (editor.setCommandBtn && editorCommandBtn)
                        editor.setCommandBtn(editorCommandBtn);
                    if (editorFormat) {
                        if (typeof editorFormat == 'function' && editor.beforeFormatCheck)
                            editor.beforeFormatCheck(editorFormat);
                        else if (typeof editorFormat == 'string' && editor.setValueFormat)
                            editor.setValueFormat(editorFormat);
                    }
                    if (editorMask && editor.setMask)
                        editor.setMask(editorMask);
                    if (editorProperties) {
                        oldProp = {};
                        var h = profile.getProperties();
                        ood.each(editorProperties, function (o, i) {
                            oldProp = h[i];
                        });
                        editor.setProperties(editorProperties);
                    }
                    if (editorCC)
                        editor.setCustomClass(ood.clone(editorCC, 2));
                    if (editorCS)
                        editor.setCustomStyle(ood.clone(editorCS, 2));
                    if (editorEvents)
                        editor.setEvents(editorEvents);
                    if (!inline) {
                        // clear for valueFormat, setValue maybe cant set value because of valueFormat
                        editor.resetValue();
                    }
                    //set properities
                    switch (type) {
                        case 'listbox':
                        case 'combobox':
                        case 'helpinput':
                            // set properties
                            if (t = getPro('editorListItems')) {
                                editor.setListKey(null);
                                editor.setItems(typeof(t) == "function" ? t() : t);
                            } else if (t = getPro('editorListKey')) {
                                editor.setItems(null);
                                editor.setListKey(typeof(t) == "function" ? t() : t);
                            }
                            break;
                    }

                    // must set value here, after setItems/setListKey
                    //$editorValue must be set in beforeIniEditor
                    editor.setValue(ood.isSet(cell.$editorValue) ? cell.$editorValue : cell.value, true, 'editorini');
                    delete cell.$editorValue;

                    if (editor.setCaption) {
                        if (editorProperties && ('caption' in editorProperties) && ood.isDefined(editorProperties.caption)) {
                            editor.setCaption(editorProperties.caption, true);
                        } else if (type == "cmdbox" || type == "popbox" || type == "button" || type == "dropbutton") {
                            editor.setCaption(cell._caption || cell._$tmpcap || cell.caption || "", true);
                        }
                    }
                    //$tag for compatible
                    if (cell.$tag) {
                        if (editor.setCaption) editor.setCaption(cell.$tag);
                        else if (editor.setValue) editor.setValue(cell.$tag, null, 'editortag');
                    }
                    //give a reference
                    editor.get(0).$cell = cell;
                    editor.get(0)._smartnav = true;

                    //undo function is a must
                    editor.undo = inline ? null : function (refocus, inactive) {
                        var editor = this;
                        // execute once
                        editor.undo = null;
                        // row dirty alert
                        if (profile.box)
                            profile.box._trycheckrowdirty(profile, profile.$cellInEditor);
                        if (!inactive) {
                            if (editor.get(0) && editor.get(0).box) {
                                // for ie's setBlurTrigger doesn't trigger onchange event
                                editor.getSubNode('INPUT').onBlur(true);

                                if (refocus && ood.str.endWith(editMode, "sharp")) {
                                    cell._ignorefocus = 1;
                                    profile.boxing().focusCell(profile.$cellInEditor);
                                    ood.asyRun(function () {
                                        delete cell._ignorefocus;
                                    });
                                }
                            }
                            editor.getRoot().setBlurTrigger(profile.$xid + ":editor");
                            if (profile.properties && !profile.properties.directInput) {
                                editor.beforeUnitUpdated(null).afterUIValueSet(null).beforeNextFocus(null).onCancel(null).afterPopHide(null);
                                editor.setValue('', true, 'editorreset');
                            }
                            // clear those setting
                            if (editorFormat) {
                                if (editor.beforeFormatCheck) editor.beforeFormatCheck(null);
                                if (editor.setValueFormat) editor.setValueFormat('');
                            }
                            if (editorMask)
                                if (editor.setMask) editor.setMask('');
                            if (editor.setInputReadonly) editor.setInputReadonly(!editorReadonly);
                            if (editorDropListWidth)
                                if (editor.setDropListWidth) editor.setDropListWidth(0);
                            if (editorDropListHeight)
                                if (editor.setDropListHeight) editor.setDropListHeight(0);
                            if (oldProp) {
                                editor.setProperties(oldProp);
                                oldProp = null;
                            }
                            delete editor.get(0).$cell;
                            delete editor.get(0)._smartnav;
                            //don't use disply:none, firfox has many bugs about Caret or renderer
                            editor.hide();

                            if (ood.isFun(editor.collapse)) editor.collapse();
                        }
                        if (editorEvents) {
                            var h = {};
                            ood.each(editorEvents, function (o, i) {
                                h[i] = null;
                            });
                            editor.setEvents(h);
                        }
                        profile.$curEditor = null;
                        profile.$cellInEditor = null;
                        if (profile.onEndEdit)
                            profile.boxing().onEndEdit(profile, cell, editor, 'cell');

                        // don't cache it
                        if (!editorCacheKey && editor.get(0)) {
                            editor.destroy(true);
                        }
                        cell._editor = editor = null;
                    };
                    var g1 = profile.boxing(), pos = g1.getCellPos(cell), cc, nc,
                        _getcell = function (editorPrf) {
                            if (pos) return g1.getCellbyRowCol(pos.row, pos.col);
                            else return editorPrf.$cell;
                        };

                    //editor change value, update cell value
                    editor
                        .beforeUnitUpdated(function (editorPrf, v) {
                            cc = _getcell(editorPrf);
                            if (profile.beforeUnitUpdated && false === g1.beforeUnitUpdated(profile, cc, editorPrf, v))
                                return false;
                            grid._updCell(profile, cc, {
                                value: cc.value,
                                unit: v
                            }, profile.properties.dirtyMark, true, true);
                            if ((nc = _getcell(editorPrf)) && nc !== cc) {
                                editorPrf.$cell = nc;
                                nc._editor = editor;
                                if (!inline) {
                                    profile.$cellInEditor = nc;
                                }
                            }
                        })
                        .afterUIValueSet(function (editorPrf, oV, nV, force, tag) {
                            cc = _getcell(editorPrf);
                            if (!cc) return;

                            var type = getPro('type', cc), caption;
                            switch (type) {
                                case 'number':
                                case 'spin':
                                case 'counter':
                                case 'progress':
                                    nV = parseFloat(nV);
                                    nV = (nV || nV === 0) ? nV : null;
                                    break;
                                case 'currency':
                                    nV = parseFloat(('' + nV).replace(/[^\d.-]/g, ''));
                                    nV = (nV || nV === 0) ? nV : null;
                                    break;
                                case 'cmdbox':
                                case 'button':
                                case 'dropbutton':
                                case 'popbox':
                                case 'combobox':
                                case 'listbox':
                                case 'helpinput':
                                    caption = editorPrf.boxing().getShowValue();
                                    break;
                            }
                            var options = {
                                value: nV
                            };

                            if (ood.isDefined(caption))
                                options.caption = caption;

                            if (editorPrf.properties.hasOwnProperty("tagVar") && !ood.isEmpty(editorPrf.properties.tagVar))
                                options.tagVar = editorPrf.properties.tagVar;

                            if (false !== (profile.beforeEditApply && profile.boxing().beforeEditApply(profile, cc, options, editor, tag, 'cell'))) {
                                grid._updCell(profile, cc, options, profile.properties.dirtyMark, true, true);
                                if ((nc = _getcell(editorPrf)) && nc !== cc) {
                                    editorPrf.$cell = nc;
                                    nc._editor = editor;
                                    if (!inline) {
                                        profile.$cellInEditor = nc;
                                    }
                                }

                                if (ood.str.endWith(editMode, "sharp") && type != 'spin' && type != 'counter') {
                                    ood.tryF(editor.undo, [true], editor);
                                }
                            }
                        })
                        .beforeNextFocus(function (editorPrf, e) {
                            if (editor.undo)
                                ood.tryF(editor.undo, [true], editor);
                            var hash = ood.Event.getEventPara(e);
                            // fake 'right' key
                            if (hash.key == 'enter') hash.$key = 'right';
                            profile.getSubNode('CELLA', cell._serialId).onKeydown(true, hash);
                            //prevent
                            return false;
                        })
                        .onFileDlgOpen(function (editorPrf, src) {
                            if (profile.onFileDlgOpen) profile.boxing().onFileDlgOpen(profile, cell, editorPrf, src);
                        });

                    if (!inline) {
                        editor
                            .onCancel(function () {
                                if (editor)
                                    ood.tryF(editor.undo, [], editor);
                            })
                            .afterPopHide(function (p, r, type) {
                                if (ood.str.endWith(editMode, "sharp"))
                                    ood.tryF(editor.undo, [type != "blur" && type != "call"], editor);
                            })
                            .getRoot().setBlurTrigger(profile.$xid + ":editor", function () {
                            if (editor)
                                ood.tryF(editor.undo, [], editor);
                            return false;
                        });

                        var absPos = cellNode.offset(null, baseNode),
                            size = cellNode.cssSize(),
                            absPos2 = toggleNode ? toggleNode.offset(null, cellNode) : null,
                            w2 = toggleNode ? toggleNode.width() : null;
                        if (absPos2) absPos2.left += w2;
                        // too small
                        if (toggleNode && (absPos2.left > size.width - 8)) return;

                        //show editor
                        if (type == 'textarea') {
                            editor.setWidth(Math.max(200, size.width - (toggleNode ? absPos2.left : 0) + (cb ? 3 : 0))).setHeight(Math.max(100, size.height + (cb ? 2 : 0)))
                                .reLayout(true, true)
                                .reBoxing()
                                .popToTop(cellNode, 4, baseNode);
                        } else {
                            //**toggleNode
                            editor.setWidth(size.width - (toggleNode ? absPos2.left : 0) + (cb ? 3 : 0)).setHeight(size.height + (cb ? 2 : 0)).reLayout(true);
                            editor.reBoxing().show((absPos.left + (toggleNode ? absPos2.left : 0) - (cb ? 1 : 0)) + 'px', (absPos.top - (cb ? 1 : 0)) + 'px');
                        }

                        var expand,
                            noInputType = type == 'cmdbox' || type == 'cmdbox' || type == 'listbox' || type == 'file',
                            insPopType = noInputType || type == 'date' || type == 'time' || type == 'datetime' || type == 'color',
                            inputReadonly = editor.getInputReadonly && editor.getInputReadonly(),
                            issharp = ood.str.endWith(editMode, "sharp") && (editorAutoPop || inputReadonly || insPopType);
                        if (!inactive) {
                            if (ood.isFun(editor.expand)
                                && editorAutoPop !== false
                                && (issharp || ((ood.str.endWith(editMode, "sharp") || editMode == "focus") && (editorAutoPop || noInputType)))
                            ) {
                                expand = 1;
                                editor.expand(cellNode, false, null);
                            }
                        }
                        editor.get(0).$editMode = editMode;

                        if (!inline)
                            editor.setVisibility(issharp ? "hidden" : "visible");
                        //activate editor
                        if (!ood.str.startWith(editMode, "hover") || !byhover) {
                            if (!inactive) {
                                ood.asyRun(function () {
                                    // destroyed
                                    if (!profile.box) return;
                                    var target = editor;
                                    if (target.get(0) && target.get(0).box) {
                                        if (expand && editor.getPopWnd)
                                            target = editor.getPopWnd();
                                        if (target) {
                                            ood.tryF(target && target.activate, [], target);
                                            target.get(0)._stopmouseupcaret = 1;
                                        }
                                    }
                                });
                            }
                        } else {
                            var bfun = function () {
                                if (editor) editor.getRoot().onMouseout(null, "tg-hover-edit");
                            }, cfun = function () {
                                if (editor) editor.getRoot().onMouseout(function () {
                                    if (editor) ood.tryF(editor.undo, [], editor);
                                }, "tg-hover-edit");
                            }, dfun = function () {
                                // if(editor) ood.tryF(editor.undo,[],editor);
                            };
                            editor.onFocus(bfun).beforePopShow(function (editorPrf, popCtl, items) {
                                bfun();
                                editor.onBlur(null);
                                // for compitable
                                if (profile.beforePopShow)
                                    return profile.boxing().beforePopShow(profile, editorPrf.$cell, editorPrf, popCtl, items);
                            }).afterPopHide(function () {
                                cfun();
                                editor.onBlur(dfun);
                            }).onBlur(dfun);

                            if (!inactive && !expand)
                                ood.tryF(editor && editor.activate, [], editor);
                        }
                    }
                    if (profile.onBeginEdit)
                        profile.boxing().onBeginEdit(profile, cell, editor, 'cell');
                }
            }
            if (!inline) {
                //give a reference
                profile.$curEditor = editor;
                profile.$cellInEditor = cell;
            }
            if (ishotrow) {
                profile.__needchecktmprow = true;
                profile.box._sethotrowoutterblur(profile);
            }
        },
        _adjustBody: function (profile, trigger, callback) {
            if (!profile.renderId || profile.destroyed) return;

            ood.resetRun(profile.$xid + '4', function () {
                // destroyed
                if (!profile.renderId || profile.destroyed) return;

                var prop = profile.properties,
                    us = ood.$us(profile),
                    adjustunit = function (v, emRate) {
                        return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                    },
                    size = profile.getSubNode("BORDER").cssSize(),
                    _border = profile.getRoot().contentBox() ? 2 : 0,
                    width = profile.$px(size.width),
                    height = profile.$px(size.height),

                    //left region
                    w1 = prop.rowHandler ? (profile.$px(prop.rowHandlerWidth) + _border) : 0,
                    w2,
                    h1 = profile.getSubNode('HEADER1'),
                    h2 = profile.getSubNode('HEADER2'),
                    b12 = profile.getSubNode('BODY12'),
                    b21 = profile.getSubNode('BODY21'),
                    s11 = profile.getSubNode('SCROLL11'),
                    s12 = profile.getSubNode('SCROLL12'),
                    s21 = profile.getSubNode('SCROLL21'),
                    s22 = profile.getSubNode('SCROLL22'),
                    rh = h2.height(),
                    rr = b12.height();

                // adjust width
                // left region
                if (prop.freezedColumn) {
                    ood.arr.each(prop.header, function (col, i) {
                        if (i == prop.freezedColumn) return false;
                        if (!col.hidden) w1 += profile.$px(col.width) + _border;
                    });
                }
                // for border-bottom
                if (rr && prop.freezedRow) rr -= 1;
                // for border-right
                if (w1 && prop.freezedColumn) w1 -= 1;

                w2 = width - w1;
                profile._leftregionw = w1;

                h1.width(adjustunit(w1));
                s21.width(adjustunit(w1));
                h2.width(adjustunit(w2));
                s22.width(adjustunit(w2));

                // for scroll sync
                ood.asyRun(function () {
                    // separated read/write
                    var b21e = b21.isEmpty(),
                        s21e = s21.isEmpty(),
                        b12e = b12.isEmpty(),
                        s12e = s12.isEmpty(),
                        fr = prop.freezedRow,
                        pb = !s21e ? ((s22.isScrollBarShowed('x') ? ood.Dom.getScrollBarSize() : 0) + 'px') : '',
                        st = !s21e ? s22.scrollTop() : 0,
                        sl = (fr && !s12e) ? s22.scrollLeft() : 0,
                        pr = (fr && !b12e) ? ((s22.isScrollBarShowed('y') ? ood.Dom.getScrollBarSize() : 0) + 'px') : '';

                    if (!b21e) b21.css('padding-bottom', pb);
                    if (fr && !b12e) b12.css('padding-right', pr);
                    if (!s21e) s21.scrollTop(st);
                    if (fr && !s12e) s12.scrollLeft(sl);
                }, 100);

                // adjust height
                s11.height(rr ? adjustunit(rr) : 0);
                s12.height(rr ? adjustunit(rr) : 0);
                s21.height(adjustunit(height - rh - rr));
                s22.height(adjustunit(height - rh - rr));

                // avoid onmouseout of CELLS2 trigger CELLS1 scroll to top
                s11.css('display', rr && profile._leftregionw ? '' : 'none');
                s12.css('display', rr ? '' : 'none');
                s21.css('display', profile._leftregionw ? '' : 'none');

                // others
                s22.css('overflow', 'hidden');
                var overflowX = profile.box._adjustRelWith(profile);

                var body = profile.getSubNode('ROWS22'),
                    header = profile.getSubNode('HCELLS2'),
                    cols = profile.properties.header,
                    scroll = profile.getSubNode('SCROLL22'),
                    t, l, last, keys = profile.keys, ww, bw, hiw, bodyw;

                if (body.get(0).clientHeight) {
                    if (header.get(0).clientHeight) {
                        if (t = header.get(0).childNodes) {
                            l = t.length;
                            while (l) {
                                if (t[l - 1].clientHeight) {
                                    last = t[l - 1];
                                    break;
                                }
                                --l;
                            }
                        }
                        ww = last ? (last.offsetWidth + last.offsetLeft + 100) : 0;
                        hiw = adjustunit(ww);
                        bodyw = adjustunit(bw = ww);
                    } else {
                        if (t = body.get(0).childNodes) {
                            l = t.length;
                            while (l) {
                                if (t[l - 1].clientHeight) {
                                    last = t[l - 1];
                                    break;
                                }
                                --l;
                            }
                            if (last) {
                                var sid = profile.getSubId(last.id);
                                t = profile.getSubNode('CELLS2', sid);
                                if (t = t.get(0).childNodes) {
                                    l = t.length;
                                    while (l) {
                                        if (t[l - 1].clientHeight) {
                                            last = t[l - 1];
                                            break;
                                        }
                                        --l;
                                    }
                                }
                            }
                        }
                    }
                }

                if (last) {
                    bodyw = adjustunit(bw = last.offsetLeft);
                } else {
                    var prop = profile.properties, hd = prop.header, rows = prop.rows,
                        //defult
                        w = 0;
                    ood.arr.each(hd, function (o) {
                        if (o.hidden !== true)
                            w += ('_colWidth' in o) ? profile.$px(o._colWidth) : (profile.$px(o.width) + _border);
                    });
                    bodyw = adjustunit(bw = w);
                }
                t = last = null;

                //HI
                if (hiw) {
                    header.parent().width(hiw);
                    body.width(ww)
                }

               // if (bodyw) body.width(bodyw);

                // must use 'auto' for Android
                scroll.css('overflow', 'auto');

                if (bw > scroll.width() + _border) {
                    overflowX = "auto";
                }

                scroll.css('overflowX', overflowX);

                scroll.onScroll();

                if (profile.onBodyLayout)
                    profile.boxing().onBodyLayout(profile, trigger);

                if (callback) callback();
            });
            // formula
            if (trigger != 'render' && trigger != 'rowhandler' && trigger != 'foldrow' && trigger != 'expandrow' && trigger != 'setcol' && trigger != 'resize')
                ood.resetRun(profile.key + ":" + profile.$xid, function () {
                    if (profile && profile.box) profile.boxing().triggerFormulas(null, trigger);
                });
        },
        _adjustHeader: function (arr) {
            var a = ood.copy(arr), m;

            ood.arr.each(a, function (o, i) {
                //id will be adjusted in _prepareHeader
                a[i] = ood.copy(o);
            });
            return a;
        },
        _adjustGrpColsData: function (profile, arr) {
            if (!ood.isArr(arr)) return ood.copy(arr);

            var prop = profile.properties,
                header = prop.header,
                len = header.length,
                slen = (len + '').length,
                SubID = ood.UI.$tag_subId,
                a = ood.copy(arr, function (o) {
                    o.from = parseInt(o.from, 10) || 0;
                    o['to'] = parseInt(o['to'], 10) || 0;
                    return o.from <= len && o['to'] <= len && o['to'] >= o.from;
                });

            ood.arr.each(a, function (o, i) {
                a[i] = ood.isHash ? ood.copy(o) : {};
            });
            ood.arr.stableSort(a, function (x, y) {
                // desc by from, aesc by to
                return x.from > y.from ? 1 : x.from == y.from ? (x['to'] > y['to'] ? -1 : x['to'] == y['to'] ? 0 : 1) : -1;
            });
            for (var j = 0, m = a.length, grp; j < m; j++) {
                grp = a[j];
                grp[SubID] = grp[SubID] || ('-g_' + profile.pickSubId('grpCol'));
                grp.id = grp.id || grp[SubID];
                if (!grp.caption) grp.caption = grp.id;
                grp._isgroup = 1;
                delete grp._grp;

                profile.colMap[grp[SubID]] = grp;
                profile.colMap2[grp.id] = grp[SubID];
            }
            ood.arr.each(a, function (o, i) {
                for (var j = 0; j < i; j++) {
                    // across
                    if (a[i]['to'] > a[j].from && a[i].from < a[j]['to']) {
                        // cut
                        if (a[i]['to'] > a[j]['to']) a[i]['to'] = a[j]['to'];
                        // record it
                        (a[i]._grp || (a[i]._grp = [])).push(a[j].id);
                    }
                }
            });
            ood.arr.each(header, function (o) {
                delete o._grp;
            });

            var layer = 0;
            // calculate layers
            for (var j = 0, m = a.length, grp, o; j < m; j++) {
                grp = a[j];
                for (var i = grp.from; i <= grp['to']; i++) {
                    o = header[i];
                    (o._grp || (o._grp = [])).push(grp.id);
                    if (!grp._layer) {
                        grp._layer = o._grp.length;
                    }
                    layer = Math.max(layer, grp._layer);
                }
            }
            profile._headerLayers = layer;
            return a;
        },
        _adjustRows: function (profile, arr, ignoreMixColumn) {
            var a, m, h = {}, hvalue = {}, hcap = {}, p = profile.properties, uid = p.uidColumn, key, keys, mixcol,
                rheader = [];
            if (uid) uid = ood.arr.subIndexOf(p.header, 'id', uid);
            else uid = -1;

            ood.arr.each(p.header, function (c, i) {
                key = c.id || c;
                keys = null;
                if (!ignoreMixColumn && key.indexOf(":") != -1) {
                    keys = key.split(':');
                }
                if (keys && keys[0] && keys[1]) {
                    hvalue[keys[0]] = hcap[keys[1]] = i;
                    rheader.push(keys[0], keys[1]);
                    mixcol = 1;
                } else {
                    h[key] = i;
                    rheader.push(key);
                }
            });

            if (ood.isArr(arr) && arr.length && typeof arr[0] != 'object') a = [arr];
            else a = ood.copy(arr);

            ood.arr.each(a, function (o, i) {
                //id will be adjusted in _prepareItems
                if (ood.isArr(o)) a[i] = {cells: ood.copy(o)};
                else a[i] = ood.copy(o);

                // there's mix column
                if (mixcol && ood.isArr(a[i].cells)) {
                    var cells1 = a[i].cells, cells2 = [], col;
                    for (var j = 0, l = rheader.length; j < l; j++) {
                        col = rheader[j];
                        if (col in h) cells2.push(cells1[j]);
                        else {
                            if (col in hvalue) {
                                cells2.push({
                                    value: cells1[j],
                                    caption: cells1[++j]
                                });
                            }
                        }
                    }
                    a[i].cells = cells2;
                }

                // check if it's a map row data
                //1 > {col:value} 2 >{cells:{col:value}}
                var tt = (ood.isHash(a[i]) && (!a[i].cells || !ood.isObj(a[i].cells))) ? 1 : (a[i].cells && ood.isHash(a[i].cells)) ? 2 : 0;
                if (!o.group && tt) {
                    var cells = [], hash;
                    ood.each(tt == 1 ? a[i] : a[i].cells, function (v, i) {
                        if (i in h) cells[h[i]] = ood.isHash(v) ? v : {value: v};
                        else {
                            if (i in hvalue) {
                                hash = cells[hvalue[i]] || {};
                                hash.value = v;
                                cells[hvalue[i]] = hash;
                            }
                            if (i in hcap) {
                                hash = cells[hcap[i]] || {};
                                hash.caption = v;
                                cells[hcap[i]] = hash;
                            }
                        }
                    });
                    a[i].cells = cells;
                }

                ood.arr.each(m = a[i].cells, function (o, i) {
                    if (ood.isDefined(o)) {
                        //It's a hash
                        if (!!o && ood.isHash(o))
                            m[i] = ood.copy(o);
                        // not a hash
                        else
                            m[i] = {value: o};
                    }
                });
                // set uidColumn cell's value to row id
                if (!('id' in a[i]) && uid != -1 && m[uid] && m[uid].value) {
                    a[i].id = m[uid].value;
                }
            });
            return a;
        },

        _adjustColsWidth: function (profile) {
            var prop = profile.properties,
                header = prop.header,
                arr = prop.grpCols,
                border = profile.getRoot().contentBox() ? 2 : 0;


            if (prop.showHeader) {
                if (arr && ood.isArr(arr) && arr.length) {
                    var _left, _l, _w, flag = false, _ww,
                        _l2 = 0;
                    for (var j = 0, m = arr.length, grp, n; j < m; j++) {
                        _l = _w = 0;
                        flag = false;
                        grp = arr[j];
                        _left = 0;
                        for (var k = 0, o; k <= grp['to']; k++) {
                            o = header[k];
                            _ww = profile.$px(o._colWidth, null, true);
                            // for the main region
                            if (prop.freezedColumn && prop.freezedColumn == k && !_l2) {
                                _l2 = _left;
                            }
                            if (k === grp.from) {
                                flag = true;
                                _l = _left;
                            }
                            _left += _ww + border;
                            if (flag && !o.hidden) {
                                _w += _ww + border;
                            }
                        }
                        n = profile.getSubNode("HCELL", grp._serialId);
                        if (_w > border) {
                            n.css({
                                display: '', left: profile.$forceu(_l - (prop.freezedColumn
                                        ? (grp['to'] > prop.freezedColumn - 1
                                                ? _l2
                                                : (prop.rowHandler ? -(profile.$px(prop.rowHandlerWidth) + border) : 0)
                                        )
                                        : 0
                                )
                                ), width: profile.$forceu(_w - border)
                            });
                        } else {
                            n.css({display: 'none'});
                        }
                        if (prop.freezedColumn && prop.rowHandler && grp._shadow) {
                            n = profile.getSubNode("HSCELL", grp._serialId);
                            if (_w > border) {
                                n.css({
                                    display: '',
                                    left: profile.$forceu(_l + (profile.$px(prop.rowHandlerWidth) + border)),
                                    width: profile.$forceu(_w - border)
                                });
                            } else {
                                n.css({display: 'none'});
                            }
                        }
                    }
                }
            }
        },
        // use em here
        _adjustColsHeight: function (profile, force) {
            var map = profile.colMap,
                map2 = profile.colMap2,
                _layers = profile._headerLayers,
                headerh = profile.properties.headerHeight,
                h = profile.$px(headerh, 0, true),
                cacuH = profile.$px(profile.box.$DataModel.headerHeight.ini, 0, true) * (_layers + 1),
                border = profile.getRoot().contentBox() ? 1 : 0,
                tt, l, th, col, rt, rh, upper, grpcolsh, h2;
            // ensure height here
            if (force || h < cacuH) {
                h = cacuH;
            }

            profile.getSubNodes(['HCELLS1', 'HCELLS2', 'GRPCELLBOX1', 'GRPCELLBOX2']).height(profile.$px2em(h) + 'em');
            h2 = profile.$px2em(h - border) + "em";
            profile.getSubNode('FHCELL').css({height: h2});
            if (!_layers) {
                profile.getSubNode('HCELL', true).css({height: h2});
                // if(ood.browser.ie6) // ignore ie6 here
                //    profile.getSubNode('HCELLA',true).css({'line-height':h2});
            } else {
                th = h / (_layers + 1);
                profile.getSubNode('HCELL', true).each(function (o) {
                    col = profile.getSubId(o.id);
                    if (col = map[col]) {
                        // group
                        if (col && col._isgroup) {
                            upper = 0;
                            for (var i in map) {
                                tt = map[i];
                                if (tt._isgroup && tt._layer < col._layer && tt.from <= col['to'] && tt['to'] >= col['from']) {
                                    upper += profile.$px(tt.height || th);
                                }
                            }
                            ood(o).top(profile.$px2em(upper) + 'em');
                            rh = profile.$px(col.height || th);
                        } else {
                            if (col._grp && (l = col._grp.length)) {
                                grpcolsh = 0;
                                for (var i = 0; i < l; i++) {
                                    if (tt = map2[col._grp[i]]) {
                                        grpcolsh += profile.$px(map[tt].height || th);
                                    }
                                }
                                rh = h - grpcolsh;
                            } else
                                rh = h;
                        }
                        ood(o).height(profile.$px2em(rh - border) + 'em');

                        if (col && col._isgroup && col._shadow) {
                            o = profile.getSubNode("HSCELL", col._serialId);
                            ood(o).top(profile.$px2em(upper) + 'em');
                            ood(o).height(profile.$px2em(rh - border) + 'em');
                        }
                    }
                });
            }
        },
        _focuscell: function (profile, e, src) {
            if (profile.properties.disabled || profile.properties.readonly) return;
            if (!ood.use(src).get(0)) return;
            // ensure call _focuscell once when click
            if (!profile.$_ensureOnce) {
                profile.$_ensureOnce = 1;
                ood.asyRun(function () {
                    profile.$_ensureOnce = 0;
                });
            } else return;

            var p = profile.properties,
                box = profile.box,
                getPro = box.getCellOption,
                cell = profile.cellMap[profile.getSubId(src)],
                mode = p.activeMode, id;

            if (cell && cell._ignorefocus) return;

            if (cell) {
                var edit = false, type = getPro(profile, cell, "type");
                if (getPro(profile, cell, 'editable')) {
                    if (getPro(profile, cell, 'disabled') || getPro(profile, cell, 'readonly')) {
                        edit = false;
                    } else {
                        edit = true;
                        if ((getPro(profile, cell, 'editMode') == "inline" && type !== 'label') || type == 'dropbutton') {
                            if (cell._editor) cell._editor.activate();
                        } else {
                            box._editCell(profile, cell._serialId);
                            ood(src).parent().tagClass('-active', false);
                            ood.asyRun(function () {
                                // destroyed
                                if (!profile.box) return;
                                ood.use(src).parent().onMouseout(true, {$force: true})
                                    .parent().onMouseout(true, {$force: true});
                            });
                        }
                    }
                }
                // if not in edit mode
                if (!edit) {
                    if (cell && mode == 'cell') {
                        id = ood.use(src).parent().id();
                        box._activeCell(profile, id);
                    }
                } else {
                    if (cell && mode == 'cell') {
                        box._activeCell(profile, false);
                    }
                }
            } else {
                var row = profile.rowMap[profile.getSubId(src)];
                if (getPro(profile, row, 'editable')) {
                    if (getPro(profile, row, 'disabled') || getPro(profile, row, 'readonly')) {
                    } else {
                        profile.boxing().editFirstCell(row);
                    }
                }
            }
            if (mode == 'row') {
                id = ood.use(src).parent(2).id();
                box._activeRow(profile, id);
            }
        },
        _getToggleNode: function (profile, rowId) {
            return profile.getSubNode('ROWTOGGLE', rowId);
        },
        _showTips: function (profile, node, pos) {
            if (profile.properties.disableTips) return;
            if (profile.onShowTips)
                return profile.boxing().onShowTips(profile, node, pos);
            if (!ood.Tips) return;

            var ks = profile.keys, item, sid, id, pid, ppid;
            if (profile.properties.disabled) return;

            id = node.id;
            pid = ood.get(node, ["parentNode", "id"]) || "";
            ppid = ood.get(node, ["parentNode", "parentNode", "id"]) || "";
            sid = profile.getSubId(id);

            if (id.indexOf(ks.FHCELL) == 0 || pid.indexOf(ks.FHCELL) == 0 || ppid.indexOf(ks.FHCELL) == 0)
                item = {tips: profile.properties.tips};
            else if (id.indexOf(ks.FCELL) == 0 || pid.indexOf(ks.FCELL) == 0)
                item = profile.rowMap[sid];
            else if (id.indexOf(ks.HCELL) == 0 || id.indexOf(ks.HSCELL) == 0 || pid.indexOf(ks.HCELLA) == 0)
                item = profile.colMap[sid];
            else if (id.indexOf(ks.CELL) == 0 || pid.indexOf(ks.CELLA) == 0)
                item = profile.cellMap[sid];

            if (item) {
                ood.Tips.show(pos, ('tips' in item) ? item.tips : (item._$tips || item._caption || item.caption));
                return false;
            } else
                return true;
        },
        _adjustRelWith: function (profile) {
            var prop = profile.properties,
                _ww,
                cols = profile.colMap,
                t2 = profile.getSubNode('SCROLL22'),
                t3 = profile.getSubNode('BODY22'),
                bW = t3.contentBox() ? 2 : 0,
                width = t2.width(),
                borderW = 0,
                borderC = 0;

            profile.getSubNodes('HCELL', true).each(function (hc) {
                if (hc.clientHeight) {
                    borderW = hc.offsetWidth - profile.$px(hc.style.width);
                    return false;
                }
            });

            var fixW = 0, relWTotal = 0, relWCol = [], relWCol2 = [], overflowX;
            //if(prop.rowHandler){
            //borderC++;
            //fixW=profile.$px(prop.rowHandlerWidth);
            //}
            ood.each(profile.colMap, function (col) {
                if (col.hidden || col._isgroup) return;
                // ignore left region columns
                if (col._region == 1) return;

                if (!col.flexSize) {
                    fixW += profile.$px(col.width);
                } else {
                    relWTotal += profile.$px(col.width);
                    relWCol.push(col);
                    relWCol2.push(col);
                }
                borderC++;
            });

            var lcellw = profile.getSubNode("LHCELL").get(0).clientWidth || 0;
            profile.getSubNodes('LCELL', true).each(function (hc) {
                if (hc.children.length) {
                    lcellw = Math.max(lcellw, hc.clientWidth);
                }
            });
            profile.__lcellW = lcellw;

            if (!relWCol.length) {
                overflowX = 'auto';
                profile.box._adjustColsWidth(profile);
                return;
            } else {
                overflowX = 'hidden';
                if (t2.scrollable('y'))
                    width -= ood.Dom.getScrollBarSize();
            }

            width -= profile.__lcellW;
            // all flexSize cols' width
            profile._relWTotal = relWTotal;
            // available room for flexSize cols
            profile._relAvailable = width - (fixW + borderC * borderW);

            while (relWCol.length && width != fixW + borderC * borderW) {
                var fW = profile._relAvailable,
                    fW1 = 0, t,
                    l = relWCol.length,
                    retry = 0;
                for (var i = l - 1; i >= 0; i--) {
                    var col = relWCol[i],
                        w = i === 0 ? (fW - fW1) : Math.round(fW * (profile.$px(col.width) / relWTotal));

                    if (w < 0) w = 0;
                    _ww = w;
                    if (col.hasOwnProperty('minWidth')) {
                        if ((t = profile.$px(col.minWidth)) > w) {
                            fixW += t;
                            _ww = t;
                            ood.arr.removeFrom(relWCol, i);
                            retry++;
                        }
                    }
                    if (col.hasOwnProperty('maxWidth')) {
                        if ((t = profile.$px(col.maxWidth)) < w) {
                            fixW += t;
                            _ww = t;
                            ood.arr.removeFrom(relWCol, i);
                            retry++;
                        }
                    }
                    col._colWidth = profile.$forceu(_ww);
                    fW1 += _ww;
                }
                // break while;
                if (retry === 0 || retry === l)
                    break;
            }
            profile.box._adjustColsWidth(profile);
            if (relWCol2.length) {
                ood.arr.each(relWCol2, function (col) {
                    var n, nodes = [];
                    ood.each(col._cells, function (o) {
                        n = profile.getSubNode('CELL', o);
                        if (n._nodes.length) nodes.push(n.get(0));
                    });
                    n = profile.getSubNode('HCELL', col._serialId);
                    if (n._nodes.length) {
                        nodes.push(n.get(0));
                    }
                    profile.box._adjusteditorW(profile, ood(nodes).width(col._colWidth), profile.$px(col._colWidth) + bW);
                });
            }
            return overflowX;
        },

        _getRow: function (profile, row, type, splitMixColumn) {
            if (row) {
                if (type == 'data') {
                    return ood.clone(row, true);
                } else if (type == 'value') {
                    var data = {};
                    ood.each(row.cells || row, function (cell, j) {
                        data[cell._col.id] = ('value' in cell) ? cell.value : cell;
                    });
                    return data;
                } else if (type == 'min') {
                    var a = [];
                    ood.each(row.cells || row, function (cell, j) {
                        a[j] = ('value' in cell) ? cell.value : cell;
                    });
                    return a;
                } else if (type == 'map') {
                    return profile.boxing().getRawData(row, splitMixColumn);
                } else
                    return row;
            }
        },
        $cancelHoverEditor: function (profile) {
            if (profile.destroyed) return;
            var type = ood.get(profile, ['$curEditor', '_nodes', 0, '$editMode']) || "", t;
            if (ood.str.startWith(type, 'hover')) {
                var editor = profile.$curEditor;
                if (type == "hover" && (t = editor.get(0)) && t.$poplink) return false;
                ood.tryF(editor.undo, [], editor);
            }
        },
        _onresize: function (profile, width, height) {
            var prop = profile.properties,
                f = function (k) {
                    return profile.getSubNode(k)
                },
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                root = profile.getRoot(),
                borderW = root.contentBox() ? 2 : 0,
                w1 = prop.rowHandler ? (profile.$px(prop.rowHandlerWidth) + borderW) : 0,
                w2,
                border = f('BORDER'),
                h1 = f('HEADER1'),
                h2 = f('HEADER2'),
                b12 = f('BODY12'),
                b21 = f('BODY21'),
                s11 = f('SCROLL11'),
                s12 = f('SCROLL12'),
                s21 = f('SCROLL21'),
                s22 = f('SCROLL22'),

                rh = h2.height(),
                rr = b12.height();

            // calculate by px
            width = width ? profile.$px(width, null, true) : width;
            height = height ? profile.$px(height, null, true) : height;

            border.cssSize({
                width: width ? adjustunit(width) : null,
                height: height ? adjustunit(height) : null
            });

            // adjust width
            if (width) {
                // left region
                if (prop.freezedColumn) {
                    ood.arr.each(prop.header, function (col, i) {
                        if (i == prop.freezedColumn) return false;
                        if (!col.hidden) w1 += profile.$px(col.width) + borderW;
                    });
                }
                // for border-bottom
                if (rr && prop.freezedRow) rr -= 1;
                // for border-right
                if (w1 && prop.freezedColumn) w1 -= 1;

                w2 = width - w1;
                profile._leftregionw = w1;

                h1.width(adjustunit(w1));
                h2.width(adjustunit(w2));
                s21.width(adjustunit(w1));
                s22.width(adjustunit(w2));
            }

            // adjust height
            if (height) {
                s11.height(rr ? adjustunit(rr) : 0);
                s12.height(rr ? adjustunit(rr) : 0);
                s21.height(adjustunit(height - rh - rr));
                s22.height(adjustunit(height - rh - rr));
                // avoid onmouseout of CELLS2 trigger CELLS1 scroll to top
                s11.css('display', rr ? '' : 'none');
                s12.css('display', rr ? '' : 'none');
            }
            if (width) {
                // avoid onmouseout of CELLS2 trigger CELLS1 scroll to top
                s11.css('display', profile._leftregionw ? '' : 'none');
                s21.css('display', profile._leftregionw ? '' : 'none');
            }
            // for modify em value
            if (profile.$forceRelayout) {
                this._adjustColsWidth(profile);
                this._adjustColsHeight(profile);
            }

            this._adjustBody(profile, 'resize');
        }
    }
});//rowMap => row_SerialIdMapItem
//rowMap2 => row_ItemIdMapSerialId
//colMap => header_SerialIdMapItem
//colMap2 => header_ItemIdMapSerialId
//cellMap => cells_SerialIdMapItem
//cellType: label,input,textarea,combobox,listbox,file,getter,helpinput,button,dropbutton,cmdbox,popbox,date,time,datetime,color,spin,counter,currency,number,checkbox,progress
ood.Class("ood.UI.MTreeGrid", ["ood.UI", "ood.absValue"], {
    Instance: {
        iniProp: {
            rowHandler: true,
            rowNumbered: true,
            header: [
                {caption: 'ID', id: 'id', width: 60},
                {caption: '', id: 'name', width: 120},
                {caption: '', id: 'status', width: 80},
                {caption: '', id: 'createTime', width: 140}
            ],
            rows: [
                {
                    id: '1',
                    cells: [{value: '1'}, {value: '1'}, {value: ''}, {value: '2024-01-01'}]
                },
                {
                    id: '2',
                    cells: [{value: '2'}, {value: '2'}, {value: ''}, {value: '2024-01-02'}]
                },
                {
                    id: '3',
                    cells: [{value: '3'}, {value: '3'}, {value: ''}, {value: '2024-01-03'}]
                }
            ]
        },

        activate: function () {
            var profile = this.get(0), t;
            if (!profile.renderId) return;
            profile.getSubNode('ROWS22').nextFocus(true, true, true);
            return this;
        },
        _setCtrlValue: function (value) {
            return this.each(function (profile) {
                if (!profile.renderId) return;
                if (profile.properties.activeMode == 'none') return;

                var box = profile.boxing(),
                    uiv = box.getUIValue(),
                    p = profile.properties,
                    rowMap = profile.rowMap,
                    k = p.activeMode == 'row' ? ['CELLS1', 'CELLS2', 'MARK'] : 'CELL',
                    getN = function (k, i) {
                        return profile.getSubNodes(k, i)
                    },
                    getI = function (i) {
                        var map1 = profile.rowMap2;
                        if (p.activeMode == 'row')
                            return map1[i];
                        else {
                            if (!i) return;
                            var r = ('' + i).split('|');
                            return ood.get(profile.rowMap, [map1[r[0]], '_cells', r[1]]);
                        }
                    };

                if (p.selMode == 'single') {
                    var itemId = getI(uiv);
                    if (uiv && itemId)
                        getN(k, itemId).tagClass('-checked', false);

                    itemId = getI(value);
                    if (itemId)
                        getN(k, itemId).tagClass('-checked');

                    /*if(itemId){
                        var o = getN("ROW",itemId);
                        if(o){
                            var top = o.offsetTop(),
                            items = getN('SCROLL'),
                            sh=items.scrollHeight(),
                            st=items.scrollTop(),
                            hh=items.height()
                            ;
                            if(sh > hh)
                                if(top<st || top>st+hh)
                                    items.scrollTop(top);
                        }
                    }*/
                } else if (p.selMode == 'multi' || p.selMode == 'multibycheckbox') {
                    uiv = uiv ? ('' + uiv).split(p.valueSeparator) : [];
                    value = value ? ('' + value).split(p.valueSeparator) : [];
                    //check all
                    ood.arr.each(uiv, function (o, i) {
                        if (o = getI(o)) {
                            if (i = rowMap[o]) delete i._selected;
                            getN(k, o).tagClass('-checked', false);
                        }
                    });
                    ood.arr.each(value, function (o) {
                        if (o = getI(o)) {
                            if (i = rowMap[o]) i._selected = 1;
                            getN(k, o).tagClass('-checked');
                        }
                    });
                    // clear the header's row handler checkbox
                    if (value.length === 0) {
                        getN("HFMARK").tagClass('-checked', false);
                        delete profile._$checkAll;
                    }
                }
            });
        },
        calculateGridValue: function () {
            var profile = this.get(0), prop = profile.properties,
                f = prop.gridValueFormula, value = null,
                refs, coo, v2, cellsMap, xformula = ood.ExcelFormula, tcell, colMax, rowMax;
            if (profile.beforeGridValueCalculated && false !== (v2 = profile.boxing().beforeGridValueCalculated(profile))) {
                value = v2;
            } else {
                if (f) {
                    colMax = prop.header.length;
                    // only for first level
                    rowMax = prop.rows.length;
                    if (xformula.validate(f)) {
                        cellsMap = {};
                        if (refs = xformula.getRefCells(f, colMax, rowMax)) {
                            ood.each(refs, function (v, i) {
                                coo = xformula.toCoordinate(i);
                                tcell = prop.rows[coo.row].cells[coo.col];
                                cellsMap[i] = tcell.value;
                            });
                        }
                        value = xformula.calculate(f, cellsMap, colMax, rowMax);
                    }
                }
            }
            if (profile.afterGridValueCalculated)
                profile.boxing().afterGridValueCalculated(profile, value);

            profile._$gridvalue = value;
            if (prop.excelCellId && profile._$oldgridvalue !== profile._$gridvalue) {
                profile.boxing().notifyExcel(false);
            }
            return profile._$oldgridvalue = value;
        },
        // notify the grid's modification to fake excel ( in module )
        notifyExcel: ood.UI.Input.prototype.notifyExcel,
        // get grid's fake cexcel cell value
        getExcelCellValue: function () {
            var profile = this.get(0), prop = profile.properties, f, refs, coo, value, v2, cellsMap,
                xformula = ood.ExcelFormula, tcell, colMax, rowMax;
            if (prop.excelCellId) {
                value = ('_$gridvalue' in profile) ? profile._$gridvalue : this.caculateGridValue();
                if (ood.isSet(v2 = (profile.onGetExcelCellValue && profile.boxing().onGetExcelCellValue(profile, prop.excelCellId, value))))
                    value = v2;
                return value;
            }
            return null;
        },
        // calculate the cellTo's formula, and apply to the cell
        // only for first level
        applyCellFormula: function (cellTo, dirtyMark, triggerEvent) {
            return this.each(function (prf) {
                var tg = prf.box, formula, j, i, needUpdate, t2, cellsMap = {}, coo,
                    prop = prf.properties,
                    rows = prop.rows,
                    // only for first level
                    colMax = ood.arr.indexOf(prop.header, cellTo._col),
                    rowMax = ood.arr.indexOf(rows, cellTo._row),
                    xformula = ood.ExcelFormula;
                if (formula = tg._getCellFormula(prf, cellTo, xformula.toColumnChr(colMax + 1), rowMax + 1)) {
                    var refs = xformula.getRefCells(formula, colMax, rowMax);
                    if (!refs) return;
                    ood.each(refs, function (v, i) {
                        coo = xformula.toCoordinate(i);
                        tcell = rows[coo.row].cells[coo.col];
                        cellsMap[i] = tcell.value;
                    });
                    t2 = xformula.calculate(formula, cellsMap, colMax, rowMax);
                    if (t2 !== cellTo.value) {
                        needUpdate = [cellTo._serialId, t2, cellTo, formula];
                        if (prf.beforeApplyFormula && false === prf.boxing().beforeApplyFormula(prf, cellTo, t2, formula)) {
                        } else {
                            tg._updCell(prf, needUpdate[0], {value: needUpdate[1]}, dirtyMark, triggerEvent, true);
                        }
                        if (prf.afterApplyFormulas)
                            prf.boxing().afterApplyFormulas(prf, [needUpdate]);
                    }
                }
            });
        },
        // calculate all cells' (or cellFrom's)  formula, and apply to them(it)
        // only for first level
        triggerFormulas: function (cellFrom, dirtyMark, triggerEvent) {
            return this.each(function (prf) {
                var tg = prf.box, cellId,
                    prop = prf.properties,
                    rows = prop.rows,
                    // only for first level
                    rowMax = rows.length,
                    colMax = prop.header.length,
                    xformula = ood.ExcelFormula,
                    formulaCells = {}, formula, tcell;
                //1. collection all formula cells
                ood.arr.each(prop.rows, function (row, i) {
                    ood.arr.each(row.cells, function (c, j) {
                        if (c === cellFrom) cellId = xformula.toCellId(j, i);
                        if (formula = tg._getCellFormula(prf, c, xformula.toColumnChr(j + 1), i + 1)) {
                            formulaCells[xformula.toCellId(j, i)] = [c, formula];
                        }
                    });
                });
                // if input cell, must remove itself;
                if (cellId) delete formulaCells[cellId];
                if (ood.isEmpty(formulaCells)) return;

                //2. collect refs for formulaCells
                var refs = {};
                ood.each(formulaCells, function (a, id) {
                    if (a = xformula.getRefCells(a[1], colMax, rowMax))
                        refs[id] = a;
                });

                //3. loop to calculate non-ref cells
                var count, noFormulaRef, cellsMap = {}, coo, needUpdate = [], t1, t2,
                    changed = {}, needRec;
                if (cellId) {
                    changed[cellId] = 1;
                }
                do {
                    count = 0;
                    ood.filter(refs, function (v, k) {
                        needRec = 0;
                        if (!cellId) needRec = 1;
                        else {
                            for (var i in v) {
                                if (i in changed) {
                                    needRec = 1;
                                    break;
                                }
                            }
                        }
                        // no need to re-calculate
                        if (!needRec) {
                            return false;
                        }

                        noFormulaRef = true;
                        for (var i in v) {
                            if (!cellId && (i in formulaCells)) {
                                noFormulaRef = false;
                            } else {
                                if (!(i in cellsMap)) {
                                    coo = xformula.toCoordinate(i);
                                    tcell = rows[coo.row].cells[coo.col];
                                    cellsMap[i] = tcell.value;
                                }
                            }
                        }
                        if (noFormulaRef) {
                            t1 = formulaCells[k];
                            t2 = xformula.calculate(t1[1], cellsMap, colMax, rowMax);
                            if (t2 !== t1[0].value) {
                                // keep update value
                                needUpdate.push([t1[0], t2, t1[1], t1[0]._serialId]);
                                if (cellId) changed[k] = 1;
                            }
                            // remove from formulaCells
                            delete formulaCells[k];
                            count++;
                            return false;
                        }
                    });
                }
                    // Avoid circular references
                while (!ood.isEmpty(formulaCells) && count > 0);

                // update cell by order
                for (var i = 0, l = needUpdate.length; i < l; i++) {
                    if (prf.beforeApplyFormula && false === prf.boxing().beforeApplyFormula(prf, needUpdate[i][0], needUpdate[i][1], needUpdate[i][2])) {
                    } else {
                        tg._updCell(prf, needUpdate[i][3], {value: needUpdate[i][1]}, dirtyMark, triggerEvent, false);
                    }
                }
                // [[cell servialid, cell value, cell, fomula]]
                if (prf.afterApplyFormulas)
                    prf.boxing().afterApplyFormulas(prf, needUpdate);

                if (prop.gridValueFormula) {
                    prf.boxing().calculateGridValue(false);
                }
            });
        },
        /*insert rows to dom
        arr is formatted properties
        pid,base are item id
        before: insert before?
        */
        _insertRowsToDom: function (profile, arr, pid, base, before, temp) {
            //if parent not open, return
            if (pid) {
                var parent = profile.rowMap[pid];
                if (parent && !parent._inited) return;
            }
            if (!arr)
                arr = [];

            var obj21, obj22, hw,
                box = profile.box,
                prop = profile.properties,
                hw = profile.getSubNode('FHCELL').width();
            if (hw) hw = profile.$forceu(hw);

            //give width at here, and do filter
            ood.arr.each(arr, function (o) {
                o._row0DfW = hw ? ('width:' + hw) : '';
                ood.arr.each(o.cells, function (v, i) {
                    v.width = v._col._colWidth;
                })
            });
            // check freezed row exists?
            if (profile.properties.freezedRow) {
                var t = profile.getSubNode('ROWS12');
                if (!t.isEmpty() && t.query('div', 'id', /-ROWS12\:/).isEmpty())
                    delete profile._passFreezedRow;
            }

            //build dom
            var nodes21 = profile._buildItems('rows21', arr),
                nodes22 = profile._buildItems('rows22', arr);

            //get base dom
            if (!base) {
                //no base add to parent
                if (pid) {
                    obj21 = profile.getSubNode('SUB1', pid);
                    obj22 = profile.getSubNode('SUB2', pid);
                } else {
                    obj21 = profile.getSubNode('ROWS21');
                    obj22 = profile.getSubNode('ROWS22');
                }
                if (before) {
                    obj21.prepend(nodes21);
                    obj22.prepend(nodes22);
                } else {
                    obj21.append(nodes21);
                    obj22.append(nodes22);
                }
            } else {
                //
                obj21 = profile.getSubNode('ROW1', base);
                obj22 = profile.getSubNode('ROW2', base);
                if (before) {
                    obj21.addPrev(nodes21);
                    obj22.addPrev(nodes22);
                } else {
                    obj21.addNext(nodes21);
                    obj22.addNext(nodes22);
                }
            }

            //add sub
            ood.arr.each(arr, function (o) {
                if (o.sub) {
                    o.open = false;
                    if (false === box.getCellOption(profile, o, "initFold"))
                        profile.boxing()._toggleRows([o], true, false, true);
                }
            });

            if (temp && temp.length) {
                var needshowinput = [], arrt = [];
                ood.arr.each(temp, function (o) {
                    if (box.getCellOption(profile, o, "editable") &&
                        (box.getCellOption(profile, o, "editMode") == "inline" || box.getCellOption(profile, o, "type") == 'dropbutton'))
                        needshowinput.push(o);
                });
                temp.length = 0;
                // for performance 25
                if (needshowinput.length) {
                    for (var i = 0, l = needshowinput.length, t; i < l; i++) {
                        t = parseInt(i / 25, 10);
                        if (!arrt[t]) arrt[t] = [];
                        arrt[t].push(needshowinput[i]);
                    }
                    needshowinput.length = 0;
                    var fun = function () {
                        if (arrt.length) {
                            var a = arrt.shift();
                            if (a && a.length) {
                                for (var i = 0, l = a.length; i < l; i++) {
                                    if (profile && profile.box && !profile.destroyed && a[i] && a[i]._row)
                                        profile.box._editCell(profile, a[i], null, true);
                                }
                                ood.asyRun(fun);
                            }
                        } else {
                            arrt = null;
                        }
                    };
                    // for event attached
                    ood.asyRun(fun);
                }
            }

            //clear rows cache
            delete profile.$allrowscache1;
            delete profile.$allrowscache2;

            profile.box._adjustBody(profile, 'addrow');
        },
        _refreshHeader: function (header) {
            var profile = this.get(0),
                prop = profile.properties,
                box = profile.box,
                grpcols = ood.clone(prop.grpCols, false, 2),
                arr, arr2,
                rows = this.getRows("data");

            ood.breakO(profile.colMap, 2);

            header = box._adjustHeader(header || []);
            arr = box._prepareHeader(profile, header);
            prop.header = header;

            this.removeAllRows();

            profile.getSubNodes(['HCELL', 'HSCELL'], true).remove();

            var nodes1, nodes2;
            if (arr.length) {
                nodes1 = profile._buildItems('header1', arr);
                profile.getSubNode('HCELLS1').append(nodes1);
                nodes2 = profile._buildItems('header2', arr);
                profile.getSubNode('LHCELL').addPrev(nodes2);
            }
            if (grpcols && ood.isArr(grpcols) && grpcols.length > 0) {
                grpcols = box._adjustGrpColsData(profile, grpcols);
                prop.grpCols = grpcols;
                arr2 = box._prepareGrpCols(profile, grpcols, arr);
                if (arr2 && arr2.length) {
                    nodes1 = profile._buildItems('grpCols1', arr2);
                    profile.getSubNode('GRPCELLBOX1').append(nodes1);
                    nodes2 = profile._buildItems('grpCols2', arr2);
                    profile.getSubNode('GRPCELLBOX2').append(nodes2);
                }
                box._adjustColsWidth(profile);
                box._adjustColsHeight(profile);

                profile.adjustSize();
            }
            if (rows && rows.length)
                this.setRows(rows);

            box._adjustBody(profile, 'refreshheader');

            //render
            var co = profile.properties.colOptions;
            ood.arr.each(arr, function (o) {
                if (ood.isFun(o.colRenderer || co.colRenderer))
                    (o.colRenderer || co.colRenderer).call(null, profile, o);
            });
            // move it manually
            if (prop.treeMode == 'infirstcell') {
                profile.getSubNode('HCELLA', arr[0]._serialId).prepend(
                    profile.getSubNode('LTAGCMDS')
                ).prepend(
                    profile.getSubNode('HFMARK')
                );
            }

            // clear collist cache
            if (profile.$col_pop) {
                profile.$col_pop.destroy(true);
                delete profile.$col_pop;
            }
            //clear editor cache
            ood.each(profile.$cache_editor, function (o) {
                if (!o.destroyed) o.destroy(true);
            });
            profile.$cache_editor = {};
        },
        _toggleRows: function (rows, expand) {
            var self = this;
            if (rows && rows.length)
                ood.arr.each(rows, function (o) {
                    if (o.id) self.toggleRow(o.id, expand);
                });
        },
        autoRowHeight: function (rowId) {
            return this.each(function (prf) {
                if (prf.renderId) {
                    var ev = ood.Event;
                    if (ev.__realtouch) ev.__simulatedMousedown = 1;
                    if (rowId && prf.rowMap2[rowId])
                        prf.getSubNode('FHANDLER', prf.rowMap2[rowId]).onDblclick(true);
                    else
                        ood.each(prf.rowMap, function (o, i) {
                            prf.getSubNode('FHANDLER', i).onDblclick(true);
                        });
                    if (ev.__realtouch) ev.__simulatedMousedown = 0;
                }
            });
        },
        autoColWidth: function (colId) {
            return this.each(function (prf) {
                if (prf.renderId) {
                    var ev = ood.Event;
                    if (ev.__realtouch) ev.__simulatedMousedown = 1;

                    if (colId && prf.colMap2[colId])
                        prf.getSubNode('HHANDLER', prf.colMap2[colId]).onDblclick(true);
                    else
                        ood.each(prf.colMap, function (o, i) {
                            prf.getSubNode('HHANDLER', i).onDblclick(true);
                        });
                    if (ev.__realtouch) ev.__simulatedMousedown = 0;
                }
            });
        },
        autoColHeight: function () {
            return this.each(function (prf) {
                if (prf.renderId) {
                    var ev = ood.Event;
                    if (ev.__realtouch) ev.__simulatedMousedown = 1;
                    prf.getSubNode('FHANDLER').onDblclick(true);
                    if (ev.__realtouch) ev.__simulatedMousedown = 0;
                }
            });
        },
        addHotRow: function (focusColId) {
            var prf = this.get(0);
            if (prf.renderId)
                prf.box._addTempRow(prf, focusColId || null);
            return this;
        },
        getHotRow: function (type) {
            return this.getRowbyRowId(this.Class._temprowid, type);
        },
        updateHotRow: function (cells, dirtyMark, triggerEvent) {
            return this.updateRow(this.Class._temprowid, {cells: cells}, dirtyMark, triggerEvent);
        },
        removeHotRow: function () {
            var profile = this.get(0);
            profile.box._sethotrowoutterblur(profile, true);
            delete profile.__hastmpRow;
            this.removeRows([profile.box._temprowid], false);
            return this;
        },
        isDirtied: function () {
            var dirty = false, prf = this.get(0);
            // check grid (for delete)
            if (prf._dirty) return true;
            // check row (for new row)
            ood.each(prf.rowMap, function (v) {
                if (v._dirty || v._oValue !== v.value || (('unit' in v) && v._oUnit !== v.unit)) {
                    dirty = true;
                    return false;
                }
            });
            // check cell
            ood.each(prf.cellMap, function (v) {
                if (v._dirty || v._oValue !== v.value || (('unit' in v) && v._oUnit !== v.unit)) {
                    dirty = true;
                    return false;
                }
            });
            return dirty;
        },
        isCellDirtied: function (cell) {
            return cell._dirty || cell._oValue !== cell.value || (('unit' in cell) && cell._oUnit !== cell.unit);
        },
        isRowDirtied: function (row) {
            var ns = this, dirty = row._dirty || row._oValue !== row.value;
            if (prf._dirty) return true;
            for (var i = 0, l = row.cells.length; i < l; i++) {
                if (ns.isCellDirtied(cell))
                    return true;
            }
            return false;
        },
        _getObjByDom: function (src, type) {
            var prf = this.get(0),
                subId = prf.getSubId(typeof src == 'string'
                    ? src.charAt(0) == '!'
                        ? ((src = ood.use(src).get(0)) && src.id)
                        : src
                    : src.id);
            return prf[type == "row" ? "rowMap" : type == "col" ? "colMap" : "cellMap"][subId];
        },
        getRowByDom: function (src, type, splitMixColumn) {
            return this.get(0).box._getRow(this.get(0), this._getObjByDom(src, "row"), type, splitMixColumn);
        },
        getHeaderByDom: function (src) {
            return this._getObjByDom(src, "col");
        },
        getCellByDom: function (src) {
            return this._getObjByDom(src, "cell");
        },
        /*rows related*/
        //type: 'original', 'data', 'map', 'min'
        getRows: function (type, splitMixColumn) {
            var v = this.get(0).properties.rows, a, b, profile = this.get(0);
            if (!ood.isArr(v)) return [];
            if (type == 'data' || type == 'min' || type == 'map' || type == 'value') {
                a = ood.clone(v, true);

                if (a && a.length && a[a.length - 1] && a[a.length - 1].id == this.constructor._temprowid)
                    a.pop();
                if (type == 'value') {

                    var rowValues = [];
                    ood.arr.each(v, function (o, i) {
                        var row = profile.box._getRow(profile, o, type, splitMixColumn);
                        rowValues.push(row)
                    });
                    a = rowValues;

                }
                if (type == 'min') {
                    ood.arr.each(a, function (o, i) {
                        if (a[i].cells) {
                            ood.each(b = a[i] = a[i].cells, function (v, j) {
                                b[j] = v.value;
                            });
                        }
                    });
                } else if (type == 'map') {
                    a = this.getRawData(null, splitMixColumn);
                }
                return a;
            } else
                return v;
        },
        getRowbyRowId: function (rowId, type, splitMixColumn) {
            var profile = this.get(0), v = profile.rowMap2, rows = profile.properties.rows, t;
            if (ood.isNumb(rowId)) rowId = ood.get(rows, [rowId == -1 ? (rows.length - 1) : rowId, "id"]);
            if (v && v[rowId])
                return profile.box._getRow(profile, profile.rowMap[v[rowId]], type, splitMixColumn);
            if ((v = profile.queryItems(rows, function (v, k) {
                return v.id == rowId;
            }, 1, 1)) && v.length)
                return profile.box._getRow(profile, v[0], type, splitMixColumn);
        },
        getRowbyCell: function (cell, type, splitMixColumn) {
            return this.constructor._getRow(this.get(0), cell._row, type, splitMixColumn);
        },
        toggleRow: function (rowId, expand, recursive, stopanim, callback) {
            var ns = this, profile = this.get(0), self = arguments.callee,
                v = profile.rowMap2, rows = profile.properties.rows;
            if (ood.isNumb(rowId)) rowId = ood.get(rows, [rowId == -1 ? (rows.length - 1) : rowId, "id"]);
            if (v && v[rowId]) {
                var row = profile.rowMap[v[rowId]];
                if (row && row.sub && (!ood.isSet(expand) || !!expand !== !!row._checked)) {
                    profile.box._setSub(profile, row, ood.isSet(expand) ? !!expand : !row._checked, recursive, stopanim || recursive, callback);
                }
            } else {
                ood.arr.each(rows, function (row) {
                    if (row.sub)
                        self.call(ns, row.id, expand, recursive, true, callback);
                })
            }
            return this;
        },
        showRows: function (rowId, /*default is the current*/ show) {
            var ns = this,
                profile = ns.get(0),
                showNodes = ood(),
                hideNodes = ood(),
                prop = profile.properties;
            rowId = ood.isHash(rowId) ? rowId.id : ood.isArr(rowId) ? rowId : rowId === 0 ? [0] : rowId ? (rowId + '').split(prop.valueSeparator) : null;
            if (!rowId) {
                rowId = ood.get(ns.getActiveRow(), "id") || ((prop.$UIvalue || prop.value) + "");
                rowId = rowId.split(prop.valueSeparator);
            }
            if (rowId && rowId.length) {
                ood.arr.each(rowId, function (r, row) {
                    if (row = ns.getRowbyRowId(r)) {
                        if (show === false) {
                            if (!row.hidden) hideNodes.merge(ns.getSubNodes(['ROW1', 'ROW2'], row._serialId));
                        } else {
                            if (row.hidden) showNodes.merge(ns.getSubNodes(['ROW1', 'ROW2'], row._serialId));
                        }
                        row.hidden = show === false;
                    }
                });
            }

            // reflect to dom
            if (!showNodes.isEmpty()) showNodes.css('display', '');
            if (!hideNodes.isEmpty()) hideNodes.css('display', 'none');
            return this;
        },
        updateRow: function (rowId/*default is the current*/, options, dirtyMark, triggerEvent) {
            var ns = this,
                profile = ns.get(0),
                box = profile.box,
                prop = profile.properties,
                prforow;

            if (!rowId && rowId !== 0) rowId = ood.get(ns.getActiveRow(), "id") || ((prop.$UIvalue || prop.value) + "").split(prop.valueSeparator)[0];
            orow = ns.getRowbyRowId(rowId);
            if (!orow) return ns;

            var pdm = prop.dirtyMark,
                psdm = pdm && prop.showDirtyMark,
                ishotrow = orow.id == box._temprowid,
                sc = ood.absObj.$specialChars,
                ext;


            if (!ood.isHash(options)) {
                if (ood.isArr(options)) options = {cells: options};
                else options = {value: options};
            }

            options = ood.filter(options, function (o, i, r) {
                r = !sc[i.charAt(0)];
                if (!r) {
                    ext = ext || {};
                    ext[i] = o
                }
                return r;
            });

            if (triggerEvent) {
                if (profile.beforeRowUpdated && false === profile.boxing().beforeRowUpdated(profile, orow, options, ishotrow, ext))
                    return;
            }
            if (!ood.isEmpty(options)) {
                if (orow) {
                    var rid = orow._serialId, t, tt, nid;

                    // [[modify id
                    if (ood.isSet(options.id)) options.id += "";
                    if (options.id && options.id !== rowId) {
                        nid = options.id;
                        var m2 = profile.rowMap2, v;
                        if (!m2[nid]) {
                            if (v = m2[rowId]) {
                                m2[nid] = v;
                                delete m2[rowId];
                                profile.rowMap[v].id = nid;
                                // modify cells link
                                ood.each(profile.colMap, function (o) {
                                    if (o = o._cells) {
                                        o[nid] = o[rowId];
                                        delete o[rowId];
                                    }
                                });
                            }
                        }
                    } else {
                        options.id = rowId;
                    }
                    // modify id only
                    if (ood.isEmpty(options))
                        return ns;
                    //]]

                    // need to refresh
                    if (('group' in options && options.group != orow.group) ||
                        'cells' in options ||
                        ('sub' in options &&
                            // only try to show/hide toggle icon
                            !((options.sub === true && !orow.sub) || (!options.sub && orow.sub === true)))
                    ) {
                        var id = "__special", pid = orow._pid ? profile.rowMap[orow._pid].id : null;
                        // change id in rowMap
                        orow.id = id;
                        // change link in rowMap2
                        profile.rowMap2[id] = profile.rowMap2[nid || rowId];
                        delete profile.rowMap2[nid || rowId];
                        // remove cells link
                        ood.each(profile.colMap, function (o) {
                            if (o = o._cells)
                                delete o[nid || rowId];
                        });
                        // make sure data
                        orow = ood.clone(orow, true);
                        ood.merge(orow, options, 'all');
                        if ('sub' in options && !options.sub) delete orow.sub;

                        ns.insertRows([orow], pid, id, true);
                        ns.removeRows([id]);

                        if (profile.properties.activeMode == 'row') {
                            var uiv = profile.properties.$UIvalue || "",
                                arr = ('' + uiv).split(profile.properties.valueSeparator);
                            if (arr.length && ood.arr.indexOf(arr, rowId) != -1) {
                                if (nid)
                                    ood.arr.removeValue(arr, rowId);
                                ns.setUIValue(arr.join(profile.properties.valueSeparator), true, null, 'sub');
                            }
                        }
                    } else {
                        if ('sub' in options) {
                            t = box._getToggleNode(profile, rid);
                            if (options.sub) {
                                t.addClass('ood-uicmd-toggle');
                                if (orow._layer)
                                    t.removeClass('ood-uicmd-empty');
                            } else {
                                t.removeClass('ood-uicmd-toggle');
                                if (orow._layer)
                                    t.addClass('ood-uicmd-empty');
                            }
                        }
                        //
                        tt = ns.getSubNodes(['CELLS1', 'CELLS2'], rid);
                        if (t = profile.$px(options.height)) profile.box._adjusteditorH(profile, tt.height(orow._rowHeight = profile.$forceu(t)), t);
                        if (t = options.rowStyle) tt.attr('style', tt.attr('style') + ";" + t);
                        if (t = options.rowClass) tt.addClass(t);
                        if (options.hasOwnProperty('disabled')) {
                            var cls = 'ood-uicell-disabled';
                            if (options.disabled)
                                tt.addClass(cls);
                            else
                                tt.removeClass(cls);
                        }
                        if (options.hasOwnProperty('readonly')) {
                            var cls = 'ood-ui-readonly';
                            if (options.readonly)
                                tt.addClass(cls);
                            else
                                tt.removeClass(cls);
                        }
                        //
                        if (t = options.firstCellStyle) (tt = ns.getSubNode('FCELL', rid)).first().attr('style', tt.attr('style') + ";" + t);
                        if (t = options.firstCellClass) ns.getSubNode('FCELL', rid).first().addClass(t);

                        if (options.hasOwnProperty('value') && !ood.isSet(options.caption)) {
                            options.caption = options.value + "";
                        }
                        if (options.hasOwnProperty('caption'))
                            ns.getSubNode('FCELLCAPTION', rid).get(0).innerHTML = options.caption || "";

                        if (options.hasOwnProperty('rowResizer')) {
                            t = !!options.rowResizer;
                            ns.getSubNode('FHANDLER', rid).css('display', (options.rowResizer = t) ? "block" : 'none');
                        }

                        if (options.hasOwnProperty('hidden')) {
                            var b = !!options.hidden;
                            if (b) {
                                if (orow.hidden !== true) {
                                    ns.getSubNodes(['ROW1', 'ROW2'], rid).css('display', 'none');
                                }
                            } else {
                                if (orow.hidden === true) {
                                    ns.getSubNodes(['ROW1', 'ROW2'], rid).css('display', '');
                                }
                            }
                        }

                        ood.merge(orow, options, 'all');

                        //if update value
                        if (options.hasOwnProperty('value')) {
                            var node = profile.getSubNode('CELLA', rid);
                            if (!pdm || dirtyMark === false)
                                orow._oValue = orow.value;
                            else {
                                if (orow.value === orow._oValue) {
                                    if (psdm)
                                        node.removeClass('ood-ui-dirty');
                                } else {
                                    if (psdm)
                                        node.addClass('ood-ui-dirty');
                                }
                            }
                            if (orow._editor) orow._editor.setValue(options.value, true, 'editorini');
                        }
                    }
                } else {
                    var rst = ns.get(0).queryItems(ns.getRows(), function (o) {
                        return typeof o == 'object' ? o.id === rowId : o == rowId
                    }, true, true, true);
                    if (rst.length)
                        ood.merge(orow = rst[0][0], options, 'all');
                }
                orow._dirty = true;
            }
            if (triggerEvent) {
                if (profile.afterRowUpdated)
                    profile.boxing().afterRowUpdated(profile, orow, options, ishotrow, ext);
            }
            return ns;
        },
        //pid,base are id
        insertRows: function (arr, pid/*true: the current item*/, base/*true: the current item*/, before, ignoreMixColumn) {
            var affectUI = arguments[4],
                ns = this,
                c = ns.constructor,
                profile = ns.get(0);
            if (ood.isHash(arr)) arr = [arr];
            if (arr && ood.isArr(arr) && arr.length > 0) {
                var prop = profile.properties,
                    row_m = profile.rowMap2,
                    ro = prop.rowOptions,
                    b = profile.rowMap, temp,
                    tar, t, k;
                // current
                if (pid === true) {
                    v = prop.$UIvalue || prop.value;
                    if (v) v = (v + '').split(prop.valueSeparator);
                    pid = v[0];
                }

                pid = row_m && row_m[pid];
                if (base === true) {
                    v = prop.$UIvalue || prop.value;
                    if (v) v = (v + '').split(prop.valueSeparator);
                    base = v[0];
                }
                base = row_m && row_m[base];
                if (base) {
                    t = profile.rowMap[base];
                    if (t) pid = t._pid;
                }
                arr = c._adjustRows(profile, arr, ignoreMixColumn);
                if (!pid)
                    tar = ood.isArr(prop.rows) ? prop.rows : (prop.rows = []);
                else {
                    k = b && b[pid];
                    tar = ood.isArr(k.sub) ? k.sub : (k.sub = []);
                }

                //1
                var rows;
                if (profile.renderId) {
                    // if insert to root, or the parent node is inited
                    if (!pid || k._inited) {
                        //prepareData(add links)
                        temp = [];
                        rows = c._prepareItems(profile, arr, pid, temp);
                        ns._insertRowsToDom(profile, rows, pid, base, before, temp);

                        //render
                        ood.arr.each(arr, function (o) {
                            if (ood.isFun(o.rowRenderer || ro.rowRenderer))
                                (o.rowRenderer || ro.rowRenderer).call(null, profile, o);
                        });
                    }
                    // normal row to tree row
                    else if (pid && !k.inited) {
                        profile.box._getToggleNode(profile, pid)
                            .removeClass('ood-icon-placeholder ood-uicmd-none')
                            .addClass('ood-uicmd-toggle');
                    }
                }
                //2
                //must be here
                if (!base)
                    ood.arr.insertAny(tar, arr, before ? 0 : -1);
                else {
                    var index = ood.arr.subIndexOf(tar, '_serialId', base);
                    ood.arr.insertAny(tar, arr, before ? index : (index + 1));
                }
                //3
                if (profile.renderId) {
                    profile.box._asy(profile);
                }

                if (rows && rows.length) {
                    ood.breakO(rows, 2);
                    rows.length = 0;
                }
            }
            if (affectUI !== false && profile.renderId && profile.__hastmpRow) {
                profile.box.__ensurehotrow(profile, null);
            }

            // try to hide ui-no-children row
            // logic must same to doFilter
            if (profile.$itemFilter) {
                var hideRows = [];
                ood.arr.each(arr, function (row) {
                    if (row.sub && !row.hidden) {
                        //  if(!row._checked && row.id)
                        //      ns.toggleRow(row.id, true, false, true);
                        if (true !== profile.$itemFilter(row, 'checkSub', profile)) {
                            var flag;
                            for (var i = 0, l = row.sub.length; i < l; i++) {
                                if (!row.sub[i].hidden) {
                                    flag = 1;
                                    break;
                                }
                            }
                            if (!flag) hideRows.push(row.id);
                        } else {
                            hideRows.push(row.id);
                        }
                    }
                });
                if (hideRows.length) ns.showRows(hideRows, false);
            }
            return ns;
        },
        doFilter: ood.absList.prototype.doFilter,
        //delete row according to id
        //ood.UI.TreeGrid.getAll().removeRows(['2','5'])
        removeRows: function (ids/*default is the current*/) {
            var affectUI = arguments[1],
                self = this,
                profile = self.get(0);
            if (!profile.rowMap2) return;

            var p = profile.properties,
                cell = profile.cellMap,
                nodes = [], v, count = 0;

            //get array
            ids = ood.isHash(ids) ? [ids.id] : ood.isArr(ids) ? ids : ids === 0 ? [0] : ids ? (ids + "").split(p.valueSeparator) : null;
            if (!ids) {
                ids = ood.get(self.getActiveRow(), "id") || ((p.$UIvalue || p.value) + "");
                ids = ids.split(p.valueSeparator);
            }
            if (!ids || !ids.length) return self;

            ood.arr.each(ids, function (o, i) {
                if (ood.isNumb(o))
                    o = p.rows[o] && p.rows[o].id;
                ids[i] = '' + o;
            });
            ood.arr.each(ids, function (id) {
                //get item id
                if (id = profile.rowMap2[id]) {
                    count++;
                    //get row
                    var row;
                    if (row = profile.rowMap[id]) {
                        var tdids = row._cells,
                            rowid = row.id,
                            temp;
                        //for sub delete
                        if (row.sub && ood.isArr(row.sub)) {
                            var arr = [];
                            ood.arr.each(row.sub, function (o) {
                                arr.push(o.id)
                            });
                            self.removeRows(arr);
                        }

                        ////delete and clear links
                        ood.each(tdids, function (o, i) {
                            //clear colMap/properties.header
                            delete cell[o]._col._cells[rowid];
                            ood.breakO(cell[o]);
                            //clear cellMap
                            delete cell[o];
                            profile.reclaimSubId(o.slice(3), 'cell');
                        });

                        //clear properties.row array
                        if (temp = row._pid ? (temp = profile.rowMap[row._pid]) ? temp.sub : null : profile.properties.rows)
                            if (ood.isArr(temp))
                                ood.filter(temp, function (o) {
                                    return o._serialId != id;
                                });

                        //clear profile.rowMap2
                        delete profile.rowMap2[rowid];

                        //clear rowMap
                        ood.breakO(profile.rowMap[id]);
                        delete profile.rowMap[id];

                        nodes.push(profile.getSubNode('ROW1', id).get(0));
                        nodes.push(profile.getSubNode('ROW2', id).get(0));
                    }
                    profile.reclaimSubId(id.slice(3), 'row');
                } else {
                    var f = function (rows) {
                        var index = ood.arr.subIndexOf(rows, "id", id);
                        if (index !== -1) {
                            count++;
                            ood.arr.removeFrom(rows, index);
                        }
                        ood.arr.each(rows, function (row) {
                            if (row.sub) f(row.sub);
                        });
                    };
                    f(p.rows);
                }
            });
            if (count > 0) {
                // clear UI value
                if (v = p.$UIvalue) {
                    if ((v = ('' + v).split(p.valueSeparator)).length > 1) {
                        ood.filter(v, function (o) {
                            return ood.arr.indexOf(ids, o) == -1;
                        });
                        p.$UIvalue = v.join(p.valueSeparator);
                    } else {
                        if (ood.arr.indexOf(ids, p.$UIvalue) != -1)
                            p.$UIvalue = null;
                    }
                }
                ood(nodes).remove();

                // remove activerow/cell
                if (profile.$activeCell && !ood.Dom.byId(profile.$activeCell))
                    delete profile.$activeCell;
                if (profile.$activeRow && !ood.Dom.byId(profile.$activeRow))
                    delete profile.$activeRow;

                //clear rows cache
                delete profile.$allrowscache1;
                delete profile.$allrowscache2;

                profile.box._asy(profile);
                profile.box._adjustBody(profile, 'delrow');
            }
            if (affectUI !== false && profile.renderId && profile.__hastmpRow) {
                profile.box.__ensurehotrow(profile, null);
            }
            profile._dirty = 1;
            return self;
        },
        insertCol: function (col, cells, pos) {
            var profile = this.get(0),
                prop = profile.properties,
                box = profile.box,
                rows = prop.rows,
                cell, base, colResult, cellResult;

            //// handle header
            // position
            pos = ood.isNumb(pos) ? pos : -1;
            if (pos === -1 || prop.header.length < pos) pos = prop.header.length;
            if (pos < 0) pos = 0;
            if (prop.treeMode == 'infirstcell' && pos === 0) return false;

            var leftRegion = pos <= prop.freezedColumn - 1;

            var arr = prop.grpCols;
            if (arr && ood.isArr(arr) && arr.length) {
                for (var j = 0, m = arr.length, grp; j < m; j++) {
                    grp = arr[j];
                    if (grp.from > pos) {
                        grp.from++;
                        grp['to']++;
                    } else if (pos >= grp.from && pos <= grp['to']) {
                        grp['to']++;
                    }
                }
            }

            if (profile.renderId) {
                colResult = box._parepareCol(profile, col, prop.header);
                col = colResult[0];

                // insert header
                ood.arr.insertAny(prop.header, col, pos);
                // insert dom node
                base = profile.getSubNode(leftRegion ? 'HCELLS1' : 'HCELLS2').children().get(pos - 1/*must be before LCELL*/);
                if (base)
                    ood(base).addNext(profile._buildItems(leftRegion ? 'header1' : 'header2', [colResult[1]]));

                // render
                var co = profile.properties.colOptions;
                if (ood.isFun(col.colRenderer || co.colRenderer))
                    (col.colRenderer || co.colRenderer).call(null, profile, col);

                // for adjust UI
                prop.grpCols = box._adjustGrpColsData(profile, arr);
                box._adjustColsWidth(profile);
                box._adjustColsHeight(profile);
                box._adjustBody(profile, 'addcol');
            } else {
                // insert header dir
                ood.arr.insertAny(prop.header, col, pos);
            }

            //// handle cells
            cells = ood.isArr(cells) ? cells : [];
            var k = 0, applaycell = function (rows) {
                var temp = [];
                ood.arr.each(rows, function (row, i) {
                    if (row.group) {
                        applaycell(row.sub);
                    } else {
                        cell = cells[k];
                        // this row was rendered
                        base = profile.getSubNode(leftRegion ? 'CELLS1' : 'CELLS2', row._serialId).children().get(pos - 1/*must be before LCELL*/);
                        if (base) {
                            cellResult = box._prepareCell(profile, cell, row, col, temp);

                            // original cell only
                            ood.arr.insertAny(row.cells, cellResult[0], pos);
                            // insert dom node
                            ood(base).addNext(profile._buildItems(leftRegion ? 'rows1.cells' : 'rows2.cells', [cellResult[1]]));
                        } else {
                            // insert cell dir
                            ood.arr.insertAny(row.cells, cell || {}, pos);
                        }
                    }
                    k++;
                });
                if (temp.length) {
                    ood.arr.each(temp, function (o) {
                        if (box.getCellOption(profile, o, "editable") &&
                            (box.getCellOption(profile, o, "editMode") == "inline" || box.getCellOption(profile, o, "type") == "dropbutton"))
                            box._editCell(profile, o);
                    });
                    temp.length = 0;
                }
            };
            if (rows && ood.isArr(rows)) {
                applaycell(rows);
            }
            profile._dirty = 1;
        },
        removeCols: function (ids) {
            var affectUI = arguments[1],
                self = this,
                profile = self.get(0),
                box = profile.box,
                p = profile.properties,
                cell = profile.cellMap,
                SubID = ood.UI.$tag_subId,
                nodes = [], count = 0;

            //get array
            ids = ood.isArr(ids) ? ids : (ids + "").split(p.valueSeparator);
            ood.arr.each(ids, function (o, i) {
                ids[i] = '' + o
            });
            if (ids && ids.length > 1) {
                ids.sort(function (x, y) {
                    var xx = ood.arr.indexOf(p.header, x);
                    if (xx == -1) xx = ood.arr.subIndexOf(p.header, "id", x);
                    var yy = ood.arr.indexOf(p.header, y);
                    if (yy == -1) yy = ood.arr.subIndexOf(p.header, "id", y);
                    return xx > yy ? 1 : xx === yy ? 0 : -1;
                });
            }

            var arr = p.grpCols;
            if (arr && ood.isArr(arr) && arr.length) {
                ood.arr.each(ids, function (id) {
                    var pos = ood.arr.indexOf(p.header, id);
                    if (pos == -1) pos = ood.arr.subIndexOf(p.header, "id", id);
                    if (pos == -1) return;
                    for (var j = 0, m = arr.length, grp; j < m; j++) {
                        grp = arr[j];
                        if (grp.from > pos) {
                            grp.from--;
                            grp['to']--;
                        } else if (pos >= grp.from && pos <= grp['to']) {
                            grp['to']--;
                        }
                    }
                }, null, true);

                ood.filter(arr, function (o) {
                    var r = o['to'] >= o.from;
                    if (!r && profile.renderId) {
                        profile.getSubNode(["HCELL", "HSCELL"], o[SubID]).remove();
                        delete profile.colMap[o[SubID]];
                        delete profile.colMap2[o.id];
                    }
                    return r;
                });
            }

            ood.arr.each(ids, function (id) {
                var index = ood.arr.indexOf(p.header, id);
                if (index == -1) index = ood.arr.subIndexOf(p.header, "id", id);
                if (index == -1) return;

                // clear UI and links
                if (profile.colMap2 && (id = profile.colMap2[id])) {
                    count++;
                    //get row
                    var col;
                    if (col = profile.colMap[id]) {
                        var tdids = col._cells,
                            colid = col.id;

                        ////delete and clear links
                        ood.each(tdids, function (o, i) {
                            nodes.push(profile.getSubNode('CELL', o).get(0));
                            //clear colMap/properties.header
                            delete cell[o]._row._cells[colid];
                            ood.breakO(cell[o]);
                            //clear cellMap
                            delete cell[o];
                            profile.reclaimSubId(o.slice(3), 'cell');
                        });

                        //clear profile.rowMap2
                        delete profile.colMap2[colid];

                        //clear rowMap
                        ood.breakO(profile.colMap[id]);
                        delete profile.colMap[id];
                        var t;
                        t = profile.getSubNode('HCELL', id).get(0);
                        if (t) nodes.push(t);
                        t = profile.getSubNode('HSCELL', id).get(0);
                        if (t) nodes.push(t);
                    }
                    profile.reclaimSubId(id.slice(3), 'header');
                }

                var applaycell = function (rows) {
                    ood.arr.each(rows, function (row) {
                        if (row.cells) ood.arr.removeFrom(row.cells, index);
                        if (row.sub) {
                            applaycell(row.sub);
                        }
                    });
                };
                applaycell(p.rows);

                ood.arr.removeFrom(p.header, index);
            }, null, true);
            if (count > 0) {
                ood(nodes).remove();

                // remove activerow/cell
                if (profile.$activeCell && !ood.Dom.byId(profile.$activeCell))
                    delete profile.$activeCell;

                p.grpCols = box._adjustGrpColsData(profile, arr);
                box._adjustColsWidth(profile);
                box._adjustColsHeight(profile);
                box._adjustBody(profile, 'delcol');
            }
            profile._dirty = 1;
            return self;
        },
        removeAllRows: function () {
            var affectUI = arguments[0],
                profile = this.get(0),
                box = profile.box,
                prop = profile.properties;
            if (!prop.rows || prop.rows.length < 0)
                return this;

            for (var i in profile.cellMap)
                profile.reclaimSubId(i.slice(3), 'cell');
            for (var i in profile.rowMap)
                profile.reclaimSubId(i.slice(3), 'row');

            //remove links
            ood.each(profile.colMap, function (o) {
                o._cells = {};
            });
            ood.breakO([profile.rowMap, profile.cellMap], 3);

            profile.rowMap = {};
            profile.cellMap = {};
            profile.rowMap2 = {};

            // remove activerow/cell
            delete profile.$activeCell;
            delete profile.$activeRow;

            profile.properties.rows.length = 0;
            if (profile.renderId) {
                // ensure the column header scroll to zero
                // code must same to the SCROLL->onScroll event
                if (profile.$sl != 0)
                    profile.getSubNode('HEADER2').get(0).scrollLeft = profile.$sl = 0;
                profile.getSubNodes(['SCROLL21', 'SCROLL22']).scrollTop(0).scrollLeft(0);
                profile.getSubNodes(['ROWS21', 'ROWS22']).empty();
            }
            //clear rows cache
            delete profile.$allrowscache1;
            delete profile.$allrowscache2;
            profile.properties.$UIvalue = null;

            if (affectUI !== false && profile.renderId && profile.__hastmpRow) {
                box.__ensurehotrow(profile, null);
            }

            box._adjustBody(profile, 'delrow');

            return this;
        },

        // reset all cells' value, and clear all dirty mark
        updateGridValue: function () {
            return this.each(function (profile) {
                var prop = profile.properties;
                delete profile._dirty;
                ood.each(profile.rowMap, function (v) {
                    v._oValue = v.value;
                    if ('unit' in v) v._oUnit = v.unit;
                    delete v._dirty;
                });
                ood.each(profile.cellMap, function (v) {
                    v._oValue = v.value;
                    if ('unit' in v) v._oUnit = v.unit;
                    delete v._dirty;
                });
                if (prop.dirtyMark && prop.showDirtyMark)
                    profile.getSubNode('CELLA', true).removeClass('ood-ui-dirty');
            })
        },
        updateRowValue: function (rowId) {
            var profile = this.get(0), row = this.getRowbyRowId(rowId), arr = [], prop = profile.properties;
            // for cells
            ood.arr.each(row.cells, function (o) {
                if (o._oValue !== o.value || (('unit' in o) && o._oUnit !== o.unit)) {
                    o._oValue = o.value;
                    if ('unit' in o) o._oUnit = o.unit;
                    delete o._dirty;
                    if (prop.dirtyMark)
                        arr.push(profile.getSubNode('CELLA', o._serialId).get(0));
                }
            });
            // for row
            row._oValue = row.value;
            delete row._dirty;
            if (prop.dirtyMark)
                arr.push(profile.getSubNode('CELLA', row._serialId).get(0));

            if (prop.dirtyMark && prop.showDirtyMark)
                ood(arr).removeClass('ood-ui-dirty');
        },
        updateColValue: function (colId) {
            var profile = this.get(0), col = this.getHeaderByColId(colId), arr = [], prop = profile.properties;
            ood.arr.each(col.cells, function (o) {
                if (o._oValue !== o.value || (('unit' in o) && o._oUnit !== o.unit)) {
                    o._oValue = o.value;
                    if ('unit' in o) o._oUnit = o.unit;
                    delete o._dirty;
                    if (prop.dirtyMark)
                        arr.push(profile.getSubNode('CELLA', o._serialId).get(0));
                }
            });
            if (prop.dirtyMark && prop.showDirtyMark)
                ood(arr).removeClass('ood-ui-dirty');
        },
        updateCellValue: function (cell) {
            var ns = this, profile = ns.get(0), prop = profile.properties;
            if (typeof cell == 'string') cell = ns.getCell(cell);
            if (cell._oValue !== cell.value || (('unit' in cell) && cell._oUnit !== cell.unit)) {
                cell._oValue = cell.value;
                if ('unit' in cell) cell._oUnit = cell.unit;
                delete cell._dirty;
                if (prop.dirtyMark)
                    profile.getSubNode('CELLA', cell._serialId).removeClass('ood-ui-dirty');
            }
            return ns;
        },
        //resetGridValue
        //resetRow
        //resetCol
        resetCellValue: function (cell) {
            var ns = this, profile = ns.get(0), prop = profile.properties;
            if (typeof cell == 'string') cell = ns.getCell(cell);
            if (cell._oValue !== cell.value || (('unit' in cell) && cell._oUnit !== cell.unit)) {
                cell.value = cell._oValue;
                if ('unit' in cell) cell.unit = cell._oUnit;
                delete cell._dirty;
                profile.box._renderCell(profile, cell, {}, profile.getSubNode('CELLA', cell._serialId));
            }
            return ns;
        },
        getActiveRow: function (type, splitMixColumn) {
            var ar, profile = this.get(0);
            if (profile.properties.activeMode != 'row') return;
            if (!(ar = profile.$activeRow)) return;
            ar = profile.rowMap[profile.getSubId(ar)];
            //   if(ar && ar.id && ar.id==profile.box._temprowid){
            //       ar=null;
            //  }
            return profile.box._getRow(profile, ar, type, splitMixColumn);
        },
        setActiveRow: function (rowId) {
            var dr, row, profile = this.get(0);
            if (profile.properties.activeMode != 'row') return;
            // deative first
            profile.box._activeRow(profile, false);

            if (!(row = this.getRowbyRowId(rowId))) return;
            if (!(dr = profile.getSubNodes(['CELLS1', 'CELLS2'], row._serialId)).isEmpty()) {
                profile.box._activeRow(profile, dr.get(0).id);
                dr.scrollIntoView();
            }
            return this;
        },
        getRowMap: function (rowId) {
            var prf = this.get(0), ins = prf.boxing(), p = prf.properties, t, hash;
            if (ood.isHash(rowId)) rowId = rowId.id;
            if (!ood.isSet(rowId) && prf.renderId && !prf.destroyed) {
                if (p.activeMode = "row") {
                    if (t = ins.getActiveRow()) rowId = t.id;
                } else if (p.activeMode = "cell") {
                    if (t = ins.getActiveCell()) rowId = t._row.id;
                }
            }
            return ins.getRowbyRowId(rowId, "map");
        },
        setRowMap: function (rowId, hash, dirtyMark, triggerEvent) {
            if (ood.isHash(rowId)) rowId = rowId.id;
            return this.each(function (prf) {
                var ins = prf.boxing(), p = prf.properties, t;
                if (!rowId && prf.renderId && !prf.destroyed) {
                    if (p.activeMode = "row") {
                        if (t = ins.getActiveRow()) rowId = t.id;
                    } else if (p.activeMode = "cell") {
                        if (t = ins.getActiveCell()) rowId = t._row.id;
                    }
                }
                if (rowId) {
                    var row = ins.getRowbyRowId(rowId),
                        header = ins.getHeader('min');
                    rowId = row.id;
                    // must adjust it first
                    var rows = prf.box._adjustRows(prf, [hash]),
                        cells = rows[0].cells;
                    ood.arr.each(row.cells, function (t, j) {
                        ood.isDefined(cells[j] && cells[j].value) && ins.updateCellByRowCol(rowId, header[j], cells[j], dirtyMark, triggerEvent);
                    });
                }
                p.rowMap = hash;
            });
        },
        /*column and header related*/
        //type: 'original', 'data', 'min'
        getHeader: function (type) {
            var v = this.get(0).properties.header;
            if (!ood.isArr(v)) return [];
            if (type == 'data')
                return ood.clone(v, true);
            else if (type == 'min') {
                var a = ood.clone(v, true), b;
                ood.arr.each(a, function (o, i) {
                    a[i] = o.id;
                });
                return a;
            } else
                return v;
        },
        getHeaderByColId: function (colId, type) {
            var v = this.get(0).properties.header, i;
            if (ood.isNumb(colId)) colId = ood.get(profile.properties.header, [colId, "id"]);
            i = ood.arr.subIndexOf(v, "id", colId);
            return i == -1 ? null :
                type == 'data' ? ood.clone(v[i], true) :
                    type == 'min' ? v[i].id :
                        v[i];
        },
        getHeaderByCell: function (cell, type) {
            var v = cell._col;
            return !v ? null :
                type == 'data' ? ood.clone(v, true) :
                    type == 'min' ? v.id :
                        v;
        },

        updateHeader: function (colId, options) {
            var ns = this,
                profile = ns.get(0),
                prop = profile.properties,
                colh = ns.getHeaderByColId(colId), isGroup;
            if (!colh) {
                var grpCols = prop.grpCols,
                    index = ood.arr.subIndexOf(grpCols, "id", colId);
                colh = grpCols[index];
                isGroup = true;
            }
            if (colh) {
                if (typeof options != 'object') options = {caption: options + ''};
                else ood.filter(options, true);
                delete options.id;

                if (profile.renderId) {
                    var hid = colh._serialId, t, tt, nd;
                    if (!isGroup) {
                        if (t = options.width) {
                            t = profile.$px(t);
                            var n = [];
                            nd = ns.getSubNode('HCELL', hid).get(0);
                            if (nd) n.push(nd);
                            nd = ns.getSubNode('HSCELL', hid).get(0);
                            if (nd) n.push(nd);
                            ood.each(colh._cells, function (o) {
                                n.push(ns.getSubNode('CELL', o).get(0));
                            });
                            profile.box._adjusteditorW(profile, ood(n).width(colh._colWidth = profile.$forceu(t)), t);

                            ns.getSubNode('SCROLL22').onScroll();
                            ns.constructor._adjustColsWidth(ns.get(0));
                            ns.constructor._adjustBody(ns.get(0), 'setcol');
                        }

                        //  Forward-compatible with 'visibility'
                        if (options.hasOwnProperty('visibility') && !options.hasOwnProperty('hidden'))
                            options.hidden = !options.visibility;

                        if (options.hasOwnProperty('hidden')) {
                            var b = !!options.hidden;
                            if (b) {
                                if (colh.hidden !== true) {
                                    ns.showColumn(colId, false);
                                }
                            } else {
                                if (colh.hidden === true) {
                                    ns.showColumn(colId, true);
                                }
                            }
                        }
                        if ('type' in options) {
                            delete colh.editorCacheKey;
                        }
                    }

                    if (t = options.headerStyle || options.colStyle)
                        (tt = ns.getSubNodes(['HCELLA', 'HSCELLA'], hid)).attr('style', tt.attr('style') + ";" + t);
                    if (t = options.headerClass)
                        ns.getSubNodes(['HCELLA', 'HSCELLA'], hid).addClass(t);
                    if (options.hasOwnProperty('caption'))
                        ns.getSubNodes(['HCELLCAPTION', 'HSCELLCAPTION'], hid).get(0).innerHTML = options.caption;
                    if ('colResizer' in options) {
                        t = !!options.colResizer;
                        ns.getSubNode('HHANDLER', hid).css('display', (options.colResizer = t) ? "block" : 'none');
                    }
                }

                ood.merge(colh, options, 'all');

                if ('flexSize' in options)
                    profile.adjustSize();
            }
        },
        showColumn: function (colId, flag) {
            var profile = this.get(0),
                map = profile.colMap2,
                cols = profile.colMap,
                col,
                sid,
                cells,
                nd,
                n = [];
            if (col = cols[sid = map[colId]]) {
                if (profile.beforeColShowHide && false === profile.boxing().beforeColShowHide(profile, colId, flag))
                    return false;
                nd = profile.getSubNode('HCELL', sid).get(0);
                if (nd) n.push(nd);
                nd = profile.getSubNode('HSCELL', sid).get(0);
                if (nd) n.push(nd);
                ood.each(col._cells, function (id) {
                    n.push(profile.getSubNode('CELL', id).get(0));
                });
                ood(n).css('display', (col.hidden = (flag === false ? true : false)) ? 'none' : '');

                if (profile.afterColShowHide)
                    profile.boxing().afterColShowHide(profile, colId, flag);
            }

            profile.box._adjustColsWidth(profile);
            profile.box._adjustBody(profile, 'setcol');
            return true;
        },
        sortColumn: function (colId, desc, sortby) {
            var prf = this.get(0), sId = prf.colMap2[colId], col = prf.colMap[sId];
            if (sId && col) {
                if (ood.isBool(desc))
                    col._order = !desc;
                if (ood.isFun(sortby))
                    col.sortby = sortby;
                prf.getSubNode("HCELLA", sId).onClick();
            }
            return this;
        },
        /*cell realted*/
        getCell: function (cellId, type) {
            var self = this, profile = this.get(0), v, m;
            ood.each(profile.cellMap, function (o) {
                if (o.id && o.id === cellId) {
                    cellId = o._serialId;
                    return false;
                }
            });
            v = profile.cellMap[cellId];
            return !v ? null :
                type == 'data' ? ood.merge({rowId: v._row.id, colId: v._col.id}, ood.clone(v, true)) :
                    type == 'min' ? v.value :
                        type == 'map' ? ((m = {}) && ((m[v._col.id] = v.value) || 1) && m) :
                            v;
        },
        getCellbyRowCol: function (rowId, colId, type) {
            var self = this, profile = self.get(0), v, m;
            if (ood.isNumb(rowId)) rowId = ood.get(profile.properties.rows, [rowId, "id"]);
            if (ood.isNumb(colId)) colId = ood.get(profile.properties.header, [colId, "id"]);
            v = ood.get(profile.rowMap, [profile.rowMap2[rowId], '_cells', colId]);
            v = v && profile.cellMap[v];
            if (!v) {
                var row = self.getRowbyRowId(rowId), header = self.getHeader('min'), col;
                if (row && row.cells) {
                    col = ood.arr.indexOf(header, colId);
                    if (col != -1) v = row.cells[col];
                }
            }
            return !v ? null :
                type == 'data' ? ood.merge({rowId: rowId, colId: colId}, ood.clone(v, true)) :
                    type == 'min' ? v.value :
                        type == 'map' ? ((m = {}) && ((m[colId] = v.value) || 1) && m) :
                            v;
        },
        getCells: function (rowId, colId, type) {
            var map = {};
            ood.each(this.get(0).cellMap, function (v) {
                if ((rowId ? (rowId == v._row.id) : 1) && (colId ? (colId == v._col.id) : 1)) {
                    map[v.id] = type == 'data' ? ood.merge({rowId: v._row.id, colId: v._col.id}, ood.clone(v, true)) :
                        type == 'min' ? v.value :
                            v;
                }
            });
            //dont return inner value
            return map;
        },

        updateCellByRowCol: function (rowId, colId, options, dirtyMark, triggerEvent, triggerFormula) {
            var t, self = this, con = self.constructor;
            if (t = con._getCellId(self.get(0), rowId, colId))
                con._updCell(self.get(0), t, options, dirtyMark, triggerEvent, triggerFormula);
            else {
                var row = self.getRowbyRowId(rowId), header = self.getHeader('min'), col;
                if (row && row.cells) {
                    col = ood.arr.indexOf(header, colId);
                    if (col != -1) {
                        if (!ood.isHash(row.cells[col])) row.cells[col] = {value: row.cells[col]};
                        ood.merge(row.cells[col], options);
                    }
                }
            }
            return self;
        },
        getCellPos: function (cell, excelType) {
            if (!cell || !cell._row || !cell._col) return null;
            var prf = this.get(0),
                col = ood.arr.indexOf(cell._row.cells, cell),
                row = ood.arr.indexOf(prf.properties.rows, cell._row);
            return col == -1 || row == -1 ? null : excelType ? ood.ExcelFormula.toCellId(col, row) : {
                row: row,
                col: col
            };
        },
        // 0:2 => row:0, col:2
        // A3 => row:0, col:2
        updateCellByRowCol2: function (mixedId, options, dirtyMark, triggerEvent) {
            var arr = mixedId.indexOf(":") != -1 ? mixedId.split(":") : ood.ExcelFormula.toCoordinate("A3", true),
                row = parseInt(arr[0], 10),
                col = parseInt(arr[1], 10);
            return this.updateCellByRowCol(row, col, options, dirtyMark, triggerEvent);
        },
        updateCell: function (cellId, options, dirtyMark, triggerEvent, triggerFormula) {
            var self = this, profile = this.get(0);
            ood.each(profile.cellMap, function (o) {
                if (o.id && o.id === cellId) {
                    cellId = o._serialId;
                    return false;
                }
            });
            self.constructor._updCell(profile, cellId, options, dirtyMark, triggerEvent, triggerFormula);
            return self;
        },
        editCellbyRowCol: function (rowId, colId) {
            var profile = this.get(0), con = profile.box;
            con._editCell(profile, con._getCellId(profile, rowId, colId));
            return this;
        },
        editCell: function (cell/*default is the active cell*/) {
            if (cell = cell ? cell : this.get(0).getSubId(this.get(0).$activeCell + ''))
                this.constructor._editCell(this.get(0), cell);
            return this;
        },
        // only support single line text input
        editFirstCell: function (rowId) {
            var profile = this.get(0),
                getPro = function (key) {
                    return profile.box.getCellOption(profile, row, key)
                },
                row = typeof rowId == 'string' ? (profile.rowMap[profile.rowMap2[rowId]]) : rowId,
                editor;

            if (!profile.properties.firstCellEditable || !row) return;
            if (getPro(profile, row, 'disabled') || getPro(profile, row, 'readonly')) return;
            if (!(profile && profile.renderId) || profile.destroyed) return;

            var cellNode = profile.getSubNode('FCELLCAPTION', row._serialId);
            if (!cellNode.isEmpty()) {
                if (profile.beforeIniEditor) {
                    editor = profile.boxing().beforeIniEditor(profile, row, cellNode, pp, 'row');
                    if (editor === false)
                        return;
                }

                var pp = cellNode.parent(),
                    size2 = pp.cssSize(),
                    baseNode = profile.getSubNode('BORDER'),
                    borderW = baseNode.contentBox() ? 2 : 0,
                    absPos = cellNode.offset(null, pp),
                    absPos2 = pp.offset(null, baseNode);
                // too small
                if (absPos2.left > size2.width - 8) return;

                // try to get from cache
                editor = profile.$cache_editor['firstCellEditor'];
                if (!editor || !editor['ood.UI'] || editor.isDestroyed()) {
                    editor = new ood.UI.ComboInput({type: "input", zIndex: 100});
                    profile.$cache_editor['firstCellEditor'] = editor;
                }
                editor.setWidth(size2.width - absPos.left + borderW)
                    .setHeight(size2.height + borderW)
                    .setValue(row.value || row.value || "");

                if (profile.onBeginEdit) profile.boxing().onBeginEdit(profile, row, editor, 'row');

                editor.undo = function () {
                    var editor = this, row = editor.get(0) && editor.get(0).$row;
                    // execute once
                    editor.undo = null;
                    // row dirty alert
                    if (profile.box) {
                        if (row && row._oValue !== row.value && row.id != profile.box._temprowid && profile.onRowDirtied)
                            profile.boxing().onRowDirtied(profile, row);
                    }
                    if (editor.get(0) && editor.get(0).box) {
                        // for ie's setBlurTrigger doesn't trigger onchange event
                        editor.getSubNode('INPUT').onBlur(true);
                        editor.getRoot().setBlurTrigger("tg_editor_blur:" + profile.$xid);

                        if (profile.properties) {
                            editor.beforeUnitUpdated(null).afterUIValueSet(null).beforeNextFocus(null).onCancel(null).onFileDlgOpen(null);
                            editor.setValue('', true, 'editorreset');
                        }
                        delete editor.get(0).$row;
                        delete editor.get(0)._smartnav;
                        delete editor.get(0).$editMode;
                        //don't use disply:none, firfox has many bugs about Caret or renderer
                        editor.hide();
                    }
                    if (row) delete row._editor;
                    profile.$curEditor = null;
                    if (profile.onEndEdit)
                        profile.boxing().onEndEdit(profile, row, editor, 'row');

                    // don't cache it
                    if (editor.get(0)) {
                        editor.destroy(true);
                    }

                    editor = null;
                };
                editor.afterUIValueSet(function (prf, ov, nv, force, tag) {
                    var options = {value: nv}, t;
                    if (prf.properties.hasOwnProperty("tagVar") && !ood.isEmpty(t = prf.properties.tagVar))
                        options.tagVar = t;
                    if (false !== (profile.beforeEditApply && profile.boxing().beforeEditApply(profile, row, options, editor, tag, 'row'))) {
                        profile.boxing().updateRow(row.id, {value: nv, caption: nv + ""});
                        ood.tryF(editor.undo, [], editor);
                    }
                })
                    .beforeNextFocus(function (prop, e) {
                        ood.tryF(editor.undo, [true], editor);
                        var hash = ood.Event.getEventPara(e);
                        if (hash.key == 'enter') hash.$key = 'right';
                        profile.getSubNode('CELLA', row._serialId).onKeydown(true, hash);
                        //prevent
                        return false;
                    })
                    .onCancel(function () {
                        ood.tryF(editor.undo, [], editor);
                    });

                baseNode.append(editor);

                //show editor
                editor.reBoxing().show((absPos.left + absPos2.left - 1) + 'px', (absPos2.top - 1) + 'px');

                var root = editor.getRoot();
                // For scroll to undo
                root.setBlurTrigger("tg_editor_blur:" + profile.$xid, function () {
                    ood.tryF(editor.undo, [], editor);
                    return false;
                });

                //give reference
                editor.get(0).$row = row;
                editor.get(0)._smartnav = true;
                row._editor = editor;
                profile.$curEditor = editor;

                editor.activate();
            }

            return this;
        },
        focusCellbyRowCol: function (rowId, colId) {
            var profile = this.get(0), con = profile.box,
                cellId = con._getCellId(profile, rowId, colId),
                node = profile.getSubNode('CELLA', cellId);
            if (node && node.get(0)) node.focus(true);
            return this;
        },
        focusCell: function (cell) {
            var cellId = cell._serialId;
            this.get(0).getSubNode('CELLA', cellId).focus(true);
            return this;
        },
        getActiveCell: function (type) {
            var ar, profile = this.get(0), m, v;
            if (profile.properties.activeMode != 'cell') return;
            if (!(ar = profile.$activeCell)) return;
            v = profile.cellMap[profile.getSubId(ar)];
            return !v ? null :
                type == 'data' ? ood.merge({rowId: v._row.id, colId: v._col.id}, ood.clone(v, true)) :
                    type == 'min' ? v.value :
                        type == 'map' ? ((m = {}) && ((m[v._col.id] = v.value) || 1) && m) :
                            v;
        },
        setActiveCell: function (rowId, colId) {
            var dr, cell, profile = this.get(0);
            if (profile.properties.activeMode != 'cell') return;
            // deative first
            profile.box._activeCell(profile, false);

            if (typeof rowId == 'object')
                cell = rowId;
            else
                cell = this.getCellbyRowCol(rowId, colId);

            if (!cell)
                return;

            if (!(dr = profile.getSubNode('CELL', cell._serialId)).isEmpty())
                profile.box._activeCell(profile, dr.get(0).id);
            return this;
        },

        /*others*/
        getDirtied: function (rowId, colId) {
            var map = {};
            ood.each(this.get(0).cellMap, function (v) {
                if ((v._oValue !== v.value || (('unit' in v) && v._oUnit !== v.unit)) && (rowId ? (rowId == v._row.id) : 1) && (colId ? (colId == v._col.id) : 1)) {
                    map[v.id] = {rowId: v._row.id, colId: v._col.id, value: v.value, _oValue: v._oValue};
                    if ('unit' in v) map[v.id]._oUnit = v._oUnit;
                }
            });
            //dont return inner value
            return map;
        },
        getSubNodeInGrid: function (key, rowId, colId) {
            var ns = this,
                t = (ood.isSet(rowId) && ood.isSet(colId)) ? ns.getCellbyRowCol(rowId, colId) :
                    colId ? ns.getHeaderByColId(colId) :
                        rowId ? ns.getRowbyRowId(rowId) : null;
            return ns.getSubNode(key, (t && t._serialId) || true);
        },
        getInlineEditors: function (rowId, colId) {
            var map = {};
            ood.each(this.getCells(rowId, colId), function (cell, id) {
                map[id] = cell._editor;
            });
            return map;
        },
        getEditor: function () {
            return ood.get(this.get(0), ["$curEditor"]);
        },
        updateEditor: function (value, caption, prop) {
            var editor = this.getEditor();
            if (editor) {
                if (ood.isHash(prop)) editor.setProperties(prop, true);
                if (ood.isDefined(caption)) editor.setCaption(caption, true);
                // last one
                if (ood.isDefined(value)) editor.setUIValue(value, true);
            }
            return this;
        },
        getEditCell: function () {
            return ood.get(this.get(0), ["$cellInEditor"]);
        },
        offEditor: function (refresh, ignoreInline) {
            var profile = this.get(0), editor;
            if (!profile) return;
            if (editor = profile.$curEditor) {
                ood.tryF(editor.undo, [], editor);
            }
            if (!ignoreInline)
                ood.each(profile.cellMap, function (cell) {
                    if (editor = cell._editor) {
                        editor.destroy();
                        delete cell._editor;
                    }
                });

            if (refresh) {
                var getPro = profile.box.getCellOption;
                ood.each(profile.cellMap, function (o) {
                    if (getPro(profile, o, "editable") &&
                        (getPro(profile, o, "editMode") == "inline" || getPro(profile, o, "type") == 'dropbutton'))
                        profile.box._editCell(profile, o, null, true);
                });
            }
        },
        adjustEditor: function (adjustFun) {
            var ns = this, prf = this.get(0), borderW = this.getRoot().contentBox();
            if (prf && prf.$curEditor) {
                var editor = prf.$curEditor,
                    cell = prf.$cellInEditor;
                if (typeof adjustFun == 'function') {
                    adjustFun.apply(ns, [editor, cell]);
                } else if (editor.KEY == "ood.UI.ComboInput") {
                    var cellNode = prf.getSubNode('CELL', cell.id),
                        absPos = cellNode.offset(null, prf.getSubNode('SCROLL22')),
                        size = cellNode.cssSize();
                    editor.setLeft(absPos.left - 1).setTop(absPos.top - 1)
                        .setWidth(size.width + borderW + 1).setHeight(size.height + borderW)
                        .reLayout(true);
                }
            }
            return ns;
        }
    },
    Before: function (key, parent_key, o) {
        if (key == 'ood.UI.TreeGrid') {
            this.Behaviors.CELLS1 = this.Behaviors.CELLS2;
            this.Behaviors.GCELLA = this.Behaviors.CELLA;
        }
        return arguments.callee.upper.apply(this, arguments);
    },
    Initialize: function () {
        this.addTemplateKeys(['ALT', 'PROGRESS']);
        this.getCellPro = this.getCellOption;

        var p = this.prototype;

        p.getColumn = p.getHeader;
        p.updateColumn = p.updateHeader;

        p.getColByDom = p.getHeaderByDom;
        p.getColByColId = p.getHeaderByColId;
        p.getColByCell = p.getHeaderByCell;
    },
    Static: {
        HasHtmlTableNode: 1,
        DIRYMARKICON: "DIRTYMARK",
        Templates: {
            tagName: 'div',
            style: '{_style}',
            className: '{_className}',
            BORDER: {
                tagName: 'div',
                BOX: {
                    tagName: 'table',
                    cellspacing: '0',
                    cellpadding: '0',
                    className: 'ood-uibase',
                    TBODY: {
                        tagName: 'tbody',
                        TRHEADER: {
                            tagName: 'tr',
                            TDHEADER1: {
                                tagName: 'td',
                                HEADER1: {
                                    tagName: 'div',
                                    style: "{showHeader}",
                                    HI1: {
                                        tagName: 'div',
                                        HCELLS1: {
                                            tagName: 'div',
                                            style: '{headerHeight}',
                                            /*the first col (row handler) in table header*/
                                            FHCELL: {
                                                $order: 0,
                                                style: '{rowHandlerDisplay};{_row0DfW};height:{_hcellheight};',
                                                className: 'ood-uiborder-noradius ood-uibar ood-uiborder-outset {cellCls}',
                                                tabindex: '{_tabindex}',
                                                HCELLA: {
                                                    //for IE78
                                                    style: '{firstCellStyle};',
                                                    className: 'ood-v-wrapper ood-showfocus {firstCellClass}',
                                                    HHANDLER: {
                                                        tagName: 'div',
                                                        style: '{colDDDisplay}'
                                                    },
                                                    FHANDLER: {
                                                        tagName: 'div',
                                                        style: '{rowDDDisplay}'
                                                    },
                                                    HFMARK: {
                                                        $order: 1,
                                                        className: "oodfont",
                                                        $fonticon: "ood-uicmd-check",
                                                        style: '{_rowMarkDisplay}'
                                                    },
                                                    LTAGCMDS: {
                                                        $order: 2,
                                                        tagName: 'span',
                                                        className: 'ood-ltag-cmds',
                                                        text: "{ltagCmds}"
                                                    },
                                                    GRIDCAPTION: {
                                                        $order: 5,
                                                        text: '{gridHandlerCaption}'
                                                    },
                                                    SORT: {
                                                        className: 'oodfont',
                                                        $fonticon: 'ood-icon-sort',
                                                        style: '{sortDisplay}'
                                                    }
                                                }
                                            },
                                            OTHERHCELLS: {
                                                $order: 1,
                                                tagName: 'text',
                                                text: '{header1}'
                                            }
                                        },
                                        GRPCELLBOX1: {
                                            tagName: 'div',
                                            style: '{headerHeight};',
                                            GRPCELLS: {
                                                $order: 3,
                                                tagName: 'text',
                                                text: '{grpCols1}'
                                            }
                                        }
                                    }
                                }
                            },
                            TDHEADER2: {
                                tagName: 'td',
                                HEADER2: {
                                    $order: 0,
                                    tagName: 'div',
                                    className: 'ood-uibar',
                                    style: "{showHeader}",
                                    //for scroll performance
                                    HI2: {
                                        tagName: 'div',
                                        HCELLS2: {
                                            tagName: 'div',
                                            style: '{headerHeight};',
                                            OTHERHCELLS: {
                                                $order: 1,
                                                tagName: 'text',
                                                text: '{header2}'
                                            },
                                            LHCELL: {
                                                $order: 2,
                                                className: 'ood-v-wrapper ood-uibar',
                                                style: 'width:{tagCmdWidth}em;height:100%;text-align: center',
                                                LHCELLINNER: {
                                                    $order: 1,
                                                    text: '{headerTail}'
                                                },
                                                RTAGCMDS: {
                                                    $order: 1,
                                                    tagName: 'span',
                                                    className: 'ood-rtag-cmds',
                                                    text: "{rtagCmds}"
                                                }
                                            }
                                        },
                                        GRPCELLBOX2: {
                                            tagName: 'div',
                                            style: '{headerHeight};',
                                            GRPCELLS: {
                                                $order: 3,
                                                tagName: 'text',
                                                text: '{grpCols2}'
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        TRLOCKED1: {
                            tagName: 'tr',
                            TDBODY11: {
                                tagName: 'td',
                                SCROLL11: {
                                    $order: 1,
                                    tagName: 'div',
                                    className: '',
                                    BODY11: {
                                        tagName: 'div',
                                        ROWS11: {
                                            $order: 1,
                                            tagName: 'div',
                                            text: '{rows11}'
                                        }
                                    }
                                }
                            },
                            TDBODY12: {
                                tagName: 'td',
                                SCROLL12: {
                                    $order: 1,
                                    tagName: 'div',
                                    className: '{_rowfreezed}',
                                    BODY12: {
                                        tagName: 'div',
                                        ROWS12: {
                                            $order: 1,
                                            tagName: 'div',
                                            text: '{rows12}'
                                        }
                                    }
                                }
                            }
                        },
                        TRBODY: {
                            tagName: 'tr',
                            TDBODY21: {
                                tagName: 'td',
                                SCROLL21: {
                                    $order: 1,
                                    tagName: 'div',
                                    className: '{_columnfreezed}',
                                    BODY21: {
                                        tagName: 'div',
                                        ROWS21: {
                                            $order: 1,
                                            tagName: 'div',
                                            text: '{rows21}'
                                        }
                                    }
                                }
                            },
                            TDBODY22: {
                                tagName: 'td',
                                SCROLL22: {
                                    $order: 1,
                                    tagName: 'div',
                                    BODY22: {
                                        tagName: 'div',
                                        ROWS22: {
                                            $order: 1,
                                            tagName: 'div',
                                            text: '{rows22}'
                                        }
                                    }
                                }
                            }
                        },
                        TRTAIL: {
                            tagName: 'tr',
                            TDTAIL1: {
                                tagName: 'td'
                            },
                            TDTAIL2: {
                                tagName: 'td'
                            }
                        }
                    }
                },
                COLLIST: {
                    tagName: 'div',
                    COLLISTDROP: {
                        className: 'oodfont ood-special-icon',
                        $fonticon: 'ood-icon-triangle-down'
                    }
                },
                ARROW: {
                    className: 'oodfont ood-special-icon',
                    $fonticon: 'ood-icon-bigup',
                    text: '&nbsp;'
                }
            },
            DIRTYMARK: {},
            $submap: {
                /*the other header in table header*/
                header1: function (profile, template, v, tag, result, index) {
                    if (index > profile.properties.freezedColumn) return;
                    profile.colMap[v._serialId]._region = 1;
                    tag = "header";
                    ood.UI.$doTemplate(profile, template, v, tag, result);
                    return tag;
                },
                header2: function (profile, template, v, tag, result, index) {
                    if (index > profile.properties.freezedColumn) {
                        profile.colMap[v._serialId]._region = 2;
                        tag = "header";
                        ood.UI.$doTemplate(profile, template, v, tag, result);
                        return tag;
                    }
                },


                header: {
                    HCELL: {
                        style: "width:{_cellWidth};height:{_hcellheight};{colDisplay};",
                        className: 'ood-uiborder-noradius ood-uibar ood-uiborder-outset {cellCls}',
                        HCELLA: {
                            className: 'ood-v-wrapper ood-showfocus {headerClass}',
                            style: "{headerStyle};{colStyle}",
                            tabindex: '{_tabindex}',
                            HCELLCAPTION: {
                                $order: 5,
                                className: 'ood-v-node',
                                text: "{caption}"
                            },
                            SORT: {
                                className: 'oodfont',
                                $fonticon: 'ood-icon-sort',
                                style: '{sortDisplay}'
                            },
                            HHANDLER: {
                                $order: 2,
                                tagName: 'div',
                                style: '{colDDDisplay}'
                            }
                        }
                    }
                },
                grpCols1: function (profile, template, v, tag, result, index) {
                    var index = profile.properties.freezedColumn - 1,
                        map = profile.colMap;
                    if (v.from > index) return;
                    if (v['to'] > index) {
                        map[v._serialId]._region = 2;
                        map[v._serialId]._shadow = 1;
                        tag = "grpColsShadow";
                        ood.UI.$doTemplate(profile, template, v, tag, result);
                    } else {
                        map[v._serialId]._region = 1;
                        tag = "grpCols";
                        ood.UI.$doTemplate(profile, template, v, tag, result);
                    }
                    return tag;
                },
                grpCols2: function (profile, template, v, tag, result, index) {
                    var index = profile.properties.freezedColumn - 1;
                    if (v['to'] > index) {
                        profile.colMap[v._serialId]._region = 2;
                        tag = "grpCols";
                        ood.UI.$doTemplate(profile, template, v, tag, result);
                        return tag;
                    }
                },
                grpCols: {
                    HCELL: {
                        style: "position:absolute;width:{_cellWidth};height:{_hcellheight};top:{_hcelltop};left:{_hcellleft};",
                        className: 'ood-uiborder-noradius ood-uibar ood-uiborder-outset {cellCls}',
                        HCELLA: {
                            className: 'ood-v-wrapper ood-showfocus {headerClass}',
                            style: "{headerStyle};{colStyle}",
                            tabindex: '{_tabindex}',
                            HCELLCAPTION: {
                                $order: 5,
                                className: "ood-v-node",
                                text: "{caption}"
                            },
                            HHANDLER: {
                                $order: 2,
                                tagName: 'div',
                                style: '{colDDDisplay}'
                            }
                        }
                    }
                },
                grpColsShadow: {
                    HSCELL: {
                        style: "position:absolute;width:{_cellWidth};height:{_hcellheight};top:{_hcelltop};left:{_hcellleft};",
                        className: 'ood-uiborder-noradius ood-uibar ood-uiborder-outset {cellCls}',
                        HSCELLA: {
                            className: 'ood-v-wrapper ood-showfocus {headerClass}',
                            style: "{headerStyle};{colStyle}",
                            tabindex: '{_tabindex}',
                            HSCELLCAPTION: {
                                className: "ood-v-node",
                                text: "{caption}"
                            }
                        }
                    }
                },
                grpCols: {
                    HCELL: {
                        style: "position:absolute;width:{_cellWidth};height:{_hcellheight};top:{_hcelltop};left:{_hcellleft};",
                        className: 'ood-uiborder-noradius ood-uibar ood-uiborder-outset {cellCls}',
                        HCELLA: {
                            className: 'ood-v-wrapper ood-showfocus {headerClass}',
                            style: "{headerStyle};{colStyle}",
                            tabindex: '{_tabindex}',
                            HCELLCAPTION: {
                                $order: 5,
                                className: "ood-v-node",
                                text: "{caption}"
                            },
                            HHANDLER: {
                                $order: 2,
                                tagName: 'div',
                                style: '{colDDDisplay}'
                            }
                        }
                    }
                },
                rows11: function (profile, template, v, tag, result, index) {
                    if (profile._passFreezedRow) return false;
                    if (index > profile.properties.freezedRow) return false;
                    profile.rowMap[v._serialId]._region = 1;
                    // keep realtag for real data
                    ood.UI.$doTemplate(profile, template, v, "row1", result, index, 'rows1');
                },
                rows12: function (profile, template, v, tag, result, index) {
                    if (profile._passFreezedRow) return false;
                    if (index > profile.properties.freezedRow) return false;
                    profile.rowMap[v._serialId]._region = 1;
                    // keep realtag for real data
                    ood.UI.$doTemplate(profile, template, v, "row2", result, index, 'rows2');
                },
                rows21: function (profile, template, v, tag, result, index) {
                    if (!profile._passFreezedRow && index <= profile.properties.freezedRow) return;
                    profile.rowMap[v._serialId]._region = 2;
                    // keep realtag for real data
                    ood.UI.$doTemplate(profile, template, v, "row1", result, index, 'rows1');
                },
                rows22: function (profile, template, v, tag, result, index) {
                    if (!profile._passFreezedRow && index <= profile.properties.freezedRow) return;
                    // *** dont calculate freeeze rows again
                    profile._passFreezedRow = 1;
                    profile.rowMap[v._serialId]._region = 2;
                    // keep realtag for real data
                    ood.UI.$doTemplate(profile, template, v, "row2", result, index, 'rows2');
                },
                row1: {
                    ROW1: {
                        tagName: 'div',
                        style: '{rowDisplay}',
                        CELLS1: {
                            $order: 2,
                            tagName: 'div',
                            className: 'ood-uirowbg ood-uiborder-b ood-uiborder-light {rowCls} {rowClass}',
                            style: '{_rowHeight};{rowStyle}',
                            CELLHANDLER: {
                                tagName: 'text',
                                text: '{_handler_cell}'
                            },
                            GRPCELL2: {
                                tagName: 'text',
                                text: '{_firstcell_grp}'
                            },
                            OTHERCELLS: {
                                tagName: 'text',
                                $order: 2,
                                text: '{cells}'
                            }
                        },
                        SUB1: {
                            $order: 3,
                            tagName: 'div'
                        }
                    }
                },
                row2: {
                    ROW2: {
                        tagName: 'div',
                        style: '{rowDisplay}',
                        CELLS2: {
                            $order: 2,
                            tagName: 'div',
                            className: 'ood-uirowbg ood-uiborder-b ood-uiborder-light {rowCls} {rowClass}',
                            style: '{_rowHeight};{rowStyle}',
                            GRPCELL2: {
                                tagName: 'text',
                                text: '{_firstcell_grp}'
                            },
                            OTHERCELLS: {
                                tagName: 'text',
                                $order: 2,
                                text: '{cells}'
                            },
                            LCELL: {
                                $order: 3,
                                className: 'ood-v-wrapper',
                                LCELLINNER: {
                                    $order: 1,
                                    text: '{rowTail}'
                                },
                                RTAGCMDS: {
                                    $order: 2,
                                    tagName: 'span',
                                    className: 'ood-rtag-cmds',
                                    text: "{rtagCmds}"
                                }
                            }
                        },
                        SUB2: {
                            $order: 3,
                            tagName: 'div'
                        }
                    }
                },
                'rows1._handler_cell': function (profile, template, v, tag, result, index) {
                    ood.UI.$doTemplate(profile, template, v, profile.properties.treeMode == "infirstcell" ? "rows1._handler_cell2" : "rows1._handler_cell1", result);
                },
                'rows1._handler_cell1': {
                    FCELL: {
                        $order: 0,
                        style: '{rowHandlerDisplay};{_row0DfW};',
                        className: 'ood-uiborder-r ood-uiborder-light {cellCls}',
                        CELLA: {
                            tabindex: '{_tabindex}',
                            style: '{cellStyle}{firstCellStyle}',
                            className: 'ood-v-wrapper ood-showfocus {cellClass}{firstCellClass}',
                            MARK: {
                                $order: 1,
                                className: 'oodfont',
                                $fonticon: 'ood-uicmd-check',
                                style: '{_rowMarkDisplay}'
                            },
                            ROWLRULER: {
                                $order: 2,
                                style: '{_treeMode};{_rulerW}'
                            },
                            ROWNUM: {
                                $order: 3,
                                className: 'ood-ui-readonly',
                                style: '{_rowNumbDisplay}'
                            },
                            ROWTOGGLE: {
                                $order: 4,
                                style: '{_treeMode};',
                                className: 'oodfont',
                                $fonticon: '{_fi_togglemark}'
                            },
                            LTAGCMDS: {
                                $order: 1,
                                tagName: 'span',
                                className: 'ood-ltag-cmds',
                                style: '{_ltagDisplay}',
                                text: "{ltagCmds}"
                            },
                            FCELLCAPTION: {
                                $order: 5,
                                className: "ood-v-node",
                                text: ""
                                //  text: "{caption}"
                            },
                            FHANDLER: {
                                $order: 0,
                                tagName: 'div',
                                style: '{rowDDDisplay}'
                            }
                        }
                    }
                },
                'rows1._handler_cell2': {
                    FCELL: {
                        $order: 0,
                        style: '{rowHandlerDisplay};{_row0DfW};',
                        className: 'ood-uiborder-r ood-uiborder-light {cellCls}',
                        CELLA: {
                            tabindex: '{_tabindex}',
                            style: '{cellStyle}{firstCellStyle}',
                            className: 'ood-v-wrapper ood-showfocus {cellClass}{firstCellClass}',
                            FHANDLER: {
                                $order: 6,
                                tagName: 'div',
                                style: '{rowDDDisplay}'
                            }
                        }
                    }
                },
                'rows1._firstcell_grp': function (profile, template, v, tag, result, index) {
                    if (profile.properties.treeMode != "infirstcell") return;
                    if (!profile.properties.freezedColumn) return;
                    ood.UI.$doTemplate(profile, template, v, "rows._firstcell_grp", result);
                },
                'rows2._firstcell_grp': function (profile, template, v, tag, result, index) {
                    if (profile.properties.treeMode != "infirstcell") return;
                    if (profile.properties.freezedColumn) return;
                    ood.UI.$doTemplate(profile, template, v, "rows._firstcell_grp", result);
                },
                'rows._firstcell_grp': {
                    GCELL: {
                        $order: 0,
                        className: '{cellCls}',
                        GCELLA: {
                            tabindex: '{_tabindex}',
                            style: '{cellStyle}{firstCellStyle}',
                            className: 'ood-v-wrapper ood-showfocus {cellClass}{firstCellClass}',
                            MARK: {
                                $order: 1,
                                $customId: 1,
                                className: 'oodfont',
                                $fonticon: 'ood-uicmd-check',
                                style: '{_rowMarkDisplay}'
                            },
                            ROWLRULER: {
                                $order: 2,
                                $customId: 1,
                                style: '{_treeMode};{_rulerW}'
                            },
                            ROWNUM: {
                                $order: 3,
                                $customId: 1,
                                className: 'ood-ui-readonly',
                                style: '{_rowNumbDisplay}'
                            },
                            ROWTOGGLE: {
                                $order: 4,
                                $customId: 1,
                                style: '{_treeMode};',
                                className: 'oodfont',
                                $fonticon: '{_fi_togglemark}'
                            },
                            LTAGCMDS: {
                                $order: 1,
                                $customId: 1,
                                tagName: 'span',
                                style: '{_ltagDisplay}',
                                text: "{ltagCmds}"
                            },
                            FCELLCAPTION: {
                                $order: 5,
                                $customId: 1,
                                className: "ood-v-node",
                                text: "{caption}"
                            }
                        }
                    }
                },
                'rows1.cells': function (profile, template, v, tag, result, index) {
                    if (index > profile.properties.freezedColumn) return;
                    tag = 'rows.cells';

                    var t = profile.box._tplMap2[v.type] || '.input';
                    if (profile.properties.treeMode == 'infirstcell' && index == 1 && t == '.input') {
                        t = '._first_cell';
                    }
                    ood.UI.$doTemplate(profile, template, v, tag + t, result);

                    return tag;
                },
                'rows2.cells': function (profile, template, v, tag, result, index) {
                    if (index <= profile.properties.freezedColumn) return;
                    tag = 'rows.cells';

                    var t = profile.box._tplMap2[v.type] || '.input';
                    if (profile.properties.treeMode == 'infirstcell' && index == 1 && t == '.input') {
                        t = '._first_cell';
                    }
                    ood.UI.$doTemplate(profile, template, v, tag + t, result);

                    return tag;
                },
                'rows.cells._first_cell': {
                    CELL: {
                        style: 'width:{_cellWidth};{cellDisplay};',
                        className: 'ood-uiborder-r ood-uiborder-light ood-treegrid-fcell {cellCls}',
                        CELLA: {
                            className: 'ood-v-wrapper ood-showfocus {cellClass}',
                            style: '{bgcolor};{cellStyle}',
                            tabindex: '{_tabindex}',
                            MARK: {
                                $order: 1,
                                $customId: 1,
                                className: 'oodfont',
                                $fonticon: 'ood-uicmd-check',
                                style: '{_rowMarkDisplay}'
                            },
                            ROWLRULER: {
                                $order: 2,
                                $customId: 1,
                                style: '{_treeMode};{_rulerW}'
                            },
                            ROWNUM: {
                                $order: 3,
                                $customId: 1,
                                className: 'ood-ui-readonly',
                                style: '{_rowNumbDisplay}'
                            },
                            ROWTOGGLE: {
                                $order: 4,
                                $customId: 1,
                                style: '{_treeMode};',
                                className: 'oodfont',
                                $fonticon: '{_fi_togglemark}'
                            },
                            LTAGCMDS: {
                                $order: 1,
                                $customId: 1,
                                tagName: 'span',
                                style: '{_ltagDisplay}',
                                text: "{ltagCmds}"
                            },
                            CELLCAPTION: {
                                $order: 5,
                                style: '{color}',
                                className: 'ood-v-node ood-treegrid-fcellcaption',
                                text: "{_caption}"
                            }
                        }
                    }
                },
                'rows.cells.input': {
                    CELL: {
                        style: 'width:{_cellWidth};{cellDisplay};',
                        className: 'ood-uiborder-r ood-uiborder-light {cellCls}',
                        CELLA: {
                            className: 'ood-v-wrapper ood-showfocus {cellClass}',
                            style: '{bgcolor};{cellStyle}',
                            tabindex: '{_tabindex}',
                            CELLCAPTION: {
                                className: 'ood-v-node',
                                style: '{color}',
                                text: "{_caption}"
                            }
                        }
                    }
                },
                'rows.cells.textarea': {
                    CELL: {
                        style: 'width:{_cellWidth};{cellDisplay};',
                        className: 'ood-uiborder-r ood-uiborder-light {cellCls}',
                        CELLA: {
                            className: 'ood-v-wrapper ood-showfocus ood-cls-wordwrap {cellClass}',
                            style: '{bgcolor};{cellStyle}',
                            tabindex: '{_tabindex}',
                            CELLCAPTION: {
                                className: 'ood-v-node',
                                style: '{color}',
                                text: "{_caption}"
                            }
                        }
                    }
                },
                'rows.cells.button': {
                    CELL: {
                        style: 'width:{_cellWidth};{cellDisplay};',
                        className: 'ood-uiborder-r ood-uiborder-light {cellCls}',
                        CELLA: {
                            tagName: 'button',
                            className: 'ood-node ood-showfocus ood-wrapper ood-ui-btn ood-uibar ood-uigradient ood-uiborder-radius ood-treegrid-tgbtn {cellClass}',
                            style: '{cellStyle}',
                            tabindex: '{_tabindex}',
                            CELLCAPTION: {
                                className: 'ood-v-node',
                                text: "{_caption}"
                            }
                        }
                    }
                },
                'rows.cells.checkbox': {
                    CELL: {
                        style: 'width:{_cellWidth};{cellDisplay}',
                        className: 'ood-uiborder-r ood-uiborder-light {cellCls}',
                        CELLA: {
                            className: 'ood-v-wrapper ood-showfocus {cellClass}',
                            style: '{cellStyle}',
                            tabindex: '{_tabindex}',
                            CHECKBOX: {
                                className: 'oodfont ood-uicmd-check',
                                $fonticon: '{_fi_checkboxCls}'
                            }
                        }
                    }
                },
                'rows.cells.progress': {
                    CELL: {
                        style: 'width:{_cellWidth};{cellDisplay}',
                        className: 'ood-uiborder-r ood-uiborder-light {cellCls}',
                        CELLA: {
                            className: 'ood-showfocus {cellClass}',
                            style: '{cellStyle}',
                            tabindex: '{_tabindex}',
                            PROGRESS: {
                                $order: 2,
                                tagName: 'div',
                                className: 'ood-v-wrapper ood-uibar',
                                style: 'width:{progress};',
                                CELLCAPTION: {
                                    className: 'ood-v-node',
                                    text: "{_caption}"
                                }
                            }
                        }
                    }
                },
                'rows1._handler_cell1.ltagCmds': function (profile, template, v, tag, result) {
                    if (v.id == profile.box._temprowid) return;
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, 'rows.tagCmds' + (profile.box._tplMap[buttonType] || '.button'), result)
                },
                'rows._firstcell_grp.ltagCmds': function (profile, template, v, tag, result) {
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, 'rows.tagCmds' + (profile.box._tplMap[buttonType] || '.button'), result)
                },
                'rows.cells._first_cell.ltagCmds': function (profile, template, v, tag, result) {
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, 'rows.tagCmds' + (profile.box._tplMap[buttonType] || '.button'), result)
                },
                'rows2.rtagCmds': function (profile, template, v, tag, result) {
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, 'rows.tagCmds' + (profile.box._tplMap[buttonType] || '.button'), result)
                },
                'ltagCmds': function (profile, template, v, tag, result) {
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, "rows.tagCmds" + (profile.box._tplMap[buttonType] || '.button'), result)
                },
                'rtagCmds': function (profile, template, v, tag, result) {
                    var buttonType = v.buttonType || v.type;
                    ood.UI.$doTemplate(profile, template, v, "rows.tagCmds" + (profile.box._tplMap[buttonType] || '.button'), result)
                },
                'rows.tagCmds.text': ood.UI.$getTagCmdsTpl('text'),
                'rows.tagCmds.button': ood.UI.$getTagCmdsTpl('button'),
                'rows.tagCmds.image': ood.UI.$getTagCmdsTpl('image')
            }
        },
        Appearances: {
            KEY: {
                //in firefox, a can focused with display:block
                display: 'block',
                position: 'absolute',
                overflow: 'hidden'
            },
            'BORDER': {
                "border-top": "solid 1px",
                "margin": "1px 0px 0px 0px"
            },
            'LTAGCMDS, RTAGCMDS': {
                padding: 0,
                margin: 0,
                'vertical-align': 'middle'
            },
            'HFMARK, MARK': {
                'margin-left': '.5em'
            },
            DIRTYMARK: {
                position: 'absolute',
                width: "1em",
                height: "1em",
                left: "1px",
                top: "1px",
                "z-index": 10
            },
            BOX: {
                'border-collapse': 'collapse',
                height: '100%',
                width: '100%'
            },
            'HEADER1, HEADER2': {
                // 'background-color': '#EDEDED',
                position: 'relative',
                overflow: 'hidden',
                'text-align': 'left'
            },
            'HI1, HI2': {
                position: 'relative'
            },
            'GRPCELLBOX1, GRPCELLBOX2': {
                position: 'absolute',
                overflow: 'visible',
                left: 0,
                top: 0,
                width: 0,
                height: 0
            },
            'SCROLL11, SCROLL12, SCROLL21': {
                position: 'relative',
                'text-align': 'left'
            },
            'SCROLL11, SCROLL12, SCROLL21': {
                overflow: 'hidden'
            },
            SCROLL22: {
                'text-align': 'left',
                overflow: 'auto'
            },
            ARROW: {
                position: 'absolute',
                'z-index': '20',
                left: 0,
                top: 0,
                display: 'none',
                width: 'auto',
                height: 'auto',
                'font-weight': 'bold',
                'text-align': 'center',
                'font-size': '2em'
            },
            'ARROW:before': {
                'margin-left': '-50%'
            },
            COLLIST: {
                position: 'absolute',
                'z-index': '10',
                left: 0,
                top: 0,
                cursor: 'pointer',
                visibility: 'hidden'
            },
            COLLISTDROP: {
                position: 'absolute',
                left: 0,
                bottom: 0,
                cursor: 'pointer'
            },
            'BODY11, BODY12, BODY21, BODY22': {
                overflow: 'visible',
                position: 'absolute',
                left: 0,
                top: 0
            },
            SORT: {
                position: 'absolute',
                right: '.25em',
                bottom: '.25em'
            },
            HHANDLER: {
                position: 'absolute',
                //if set z-index, disappearing in opera
                //'z-index':'10',
                background: ood.browser.ie ? 'url(' + ood.ini.img_bg + ')' : null,
                width: '.5em',
                top: '0',
                right: '0',
                height: '100%',
                cursor: 'e-resize'
            },
            'HCELLS1, HCELLS2, CELLS1, CELLS2': {
                //for ie height change trigger
                'overflow-y': ood.browser.ie ? 'hidden' : '',
                position: 'relative',
                background: 'transparent',
                'white-space': 'nowrap'
            },
            'HCELLS1, HCELLS2, GRPCELLBOX1, GRPCELLBOX2': {
                overflow: 'visible'
            },
            'CELLS1, CELLS2': {
                overflow: 'visible'
            },
            'CELLS1-group FCELL, CELLS2-group FCELL': {
                'border-right': 0,
                'padding-right': '1px',
                overflow: 'visible'
            },
            'CELLS1-group FCELLCAPTION, CELLS1-group CELLA,  CELLS1-group GCELLA, CELLS1-group ROWNUM, CELLS2-group FCELLCAPTION, CELLS2-group CELLA, CELLS2-group GCELLA': {
                'font-weight': 'bold',
                overflow: 'visible'
            },
            'CELLS1-active, CELLS2-active, CELL-active, CELL-active CELLA': {
                $order: 5,
                'background-color': 'var(--ood-bg-light)'
            },
            "CELLS1-hot, CELLS2-hot": {
                $order: 6,
                'background-color': 'var(--ood-warning-light)'
            },
            // hot always use CELLS2
            "CELLS2-hot LTAGCMDS, CELLS2-hot RTAGCMDS": {
                $order: 6,
                'display': 'none'
            },
            'CELLS1-checked, CELLS2-checked, CELLS1-checked .ood-node, CELLS2-checked .ood-node, CELL-checked, CELL-checked .ood-node': {
                $order: 6,
                'background-color': 'var(--ood-bg-medium)',
                color: 'var(--ood-text-inverse)'
            },
            "FCELL CELLA, GCELL GCELLA": {
                'text-align': 'left'
            },
            "FHCELL HCELLA, HSCELLA": {
                'text-align': 'center'
            },
            'CELLCAPTION,HCELLCAPTION,HSCELLCAPTION,SORT,HHANDLER': {
                'vertical-align': 'middle'
            },
            'CELLCAPTION,HCELLCAPTION,HSCELLCAPTION,FCELLCAPTION,GRIDCAPTION': {
                "max-width": "100%",
                "text-overflow": "ellipsis",
                "white-space": "nowrap",
                "overflow": "hidden",
                'font-size': '1em'
            },
            // for "text-overflow": "ellipsis",
            'FCELL FCELLCAPTION, FHCELL GRIDCAPTION': {
                display: "inline"
            },
            'CELL-textarea CELLCAPTION': {
                $order: 10,
                "white-space": "normal"
            },
            FHANDLER: {
                position: 'absolute',
                'height': '.5em',
                left: '0',
                width: '100%',
                bottom: '0',
                cursor: 'n-resize',
                'z-index': 10
            },
            'FCELLCAPTION, ROWNUM': {
                'vertical-align': 'middle',
                overflow: 'hidden'
            },
            'FHCELL, HCELL, HSCELL': {
                padding: 0,
                'vertical-align': 'bottom'
            },
            'ROW1, ROW2': {
                position: 'relative',
                zoom: ood.browser.ie ? 1 : null,
                width: ood.browser.ie ? '100%' : null
            },
            ROWNUM: {
                'padding-right': '.5em'
            },
            'FCELL, CELL': {
                height: '100%',
                //firefox:height:100% without overflow:hidden
                'padding-left': '1px',
                position: 'relative',
                overflow: ood.browser.ie6 ? 'hidden' : '',
                'vertical-align': 'top',
                display: ood.$inlineBlock
            },
            'GCELL': {
                height: '100%',
                width: '100%',
                //firefox:height:100% without overflow:hidden
                'padding-left': '1px',
                position: 'relative',
                overflow: ood.browser.ie6 ? 'hidden' : '',
                'vertical-align': 'top',
                display: ood.$inlineBlock
            },
            "LHCELL, LCELL": {
                height: '100%',
                position: 'relative',
                'vertical-align': 'top'
            },
            'CELLS1-alt, CELLS2-alt': {
                $order: 1,
                'background-color': 'var(--ood-info-light)'
            },
            //
            'CELL-input': {},
            'CELL-number, CELL-spin, CELL-currency': {
                'text-align': 'right'
            },
            'CELL-counter': {
                'text-align': 'center'
            },
            'CELL-checkbox': {
                'text-align': 'center'
            },
            'KEY-tgbtn': {
                $order: 100,
                width: '100%',
                padding: 0,
                'vertical-align': 'text-bottom',
                'line-height': '100%',
                height: '100%'
            },
            'CELLS1-hover, CELLS2-hover': {
                $order: 4,
                'background-color': 'var(--ood-bg-lighter)'
            },
            'CELL-hover, CELL-hover .ood-node[class*="ood-treegrid-"]': {
                $order: 5,
                'background-color': 'var(--ood-bg-medium) !important'
            },
            'FCELL CELLA, GCELL GCELLA, HCELLA, HSCELLA': {
                position: 'relative',
                "text-overflow": "ellipsis"
            },
            'HCELLA, HSCELLA': {
                $order: 3,
                'text-align': 'center',
                'vertical-align': 'middle',
                'line-height': 'inherit'
            },
            'HCELLA, HSCELLA, CELLA, GCELLA': {
                display: 'block',
                overflow: 'hidden',
                '-moz-box-flex': '1',
                'outline-offset': '-1px',
                '-moz-outline-offset': (ood.browser.gek && ood.browser.ver < 3) ? '-1px !important' : null,
                height: '100%',
                //ie need this
                width: ood.browser.ie ? '100%' : '',
                // depends on parent
                'line-height': 'inherit'
            },
            'CELLA-inline': {
                $order: 5,
                display: ood.$inlineBlock,
                width: 'auto',
                '-moz-box-flex': 0
            },
            PROGRESS: {
                border: 'none',
                height: '100%',
                'line-height': '1.83333em',
                overflow: 'visible',
                opacity: 0.7,
                '*filter': 'alpha(opacity=70)'
            },
            'PROGRESS CELLCAPTION': {
                overflow: 'visible'
            },
            'CHECKBOX, MARK': {
                cursor: 'pointer',
                'vertical-align': 'middle'
            },
            'SUB1, SUM22': {
                //for ie bug: relative , height='auto' will disppear
                zoom: ood.browser.ie ? 1 : null,
                height: 0,
                position: 'relative',
                overflow: 'visible'
            },
            ROWTOGGLE: {
                padding: '0 .334em 0 0'
            }
        },
        _objectProp: {rowOptions: 1, colOptions: 1},
        Behaviors: {
            BORDER: {},


            //don't add cell in HoverEffected, for 'hover' editMode
            HoverEffected: {
                ROWTOGGLE: 'ROWTOGGLE',
                GCELL: 'GCELL',
                CELL: 'CELL',
                HCELL: ['HCELL', 'HSCELL'],
                HSCELL: ['HCELL', 'HSCELL'],
                FHCELL: 'FHCELL',
                FCELL: 'FHCELL',
                CMD: 'CMD',
                SCROLL22: "SCROLL22",
                BODY11: "BODY11",
                BODY12: "BODY12",
                BODY21: "BODY22",
                BODY11: "BODY22",
                HEADER1: "HEADER1",
                HEADER2: "HEADER2"
            },
            ClickEffected: {
                ROWTOGGLE: 'ROWTOGGLE',
                GCELL: 'GCELL',
                CELL: 'CELL',
                HCELL: ['HCELL', 'HSCELL'],
                HSCELL: ['HCELL', 'HSCELL'],
                CMD: 'CMD'
            },
            DraggableKeys: ['FCELL'],
            DroppableKeys: ['SCROLL21', 'SCROLL22', 'CELLS1', 'CELLS2', 'FCELL'],
            HFMARK: {
                onClick: function (profile, e, src) {
                    if (profile.properties.selMode != 'multi' && profile.properties.selMode != 'multibycheckbox') return;

                    var rows = [];
                    ood.each(profile.rowMap, function (o) {
                        rows.push(o.id);
                    });

                    if (profile._$checkAll) {
                        delete profile._$checkAll;
                        profile.boxing().setUIValue("", null, null, 'checkbox');
                        ood.use(src).tagClass('-checked', false);
                        profile.boxing().onRowSelected(profile, "allrows", e, src, -1);
                    } else {
                        profile._$checkAll = true;
                        ood.use(src).tagClass('-checked');
                        profile.boxing().setUIValue(rows.join(profile.properties.valueSeparator), null, null, 'click');
                        profile.boxing().onRowSelected(profile, "allrows", e, src, 1);
                    }
                    return false;
                }
            },
            TRLOCKED1: {
                onMouseover: function (profile, e, src) {
                    profile.box.$cancelHoverEditor(profile);
                }
            },
            TRTAIL: {
                onMouseover: function (profile, e, src) {
                    profile.box.$cancelHoverEditor(profile);
                }
            },
            TDBODY21: {
                onMouseover: function (profile, e, src) {
                    profile.box.$cancelHoverEditor(profile);
                }
            },
            TRHEADER: {
                onMouseover: function (profile, e, src) {
                    profile.box.$cancelHoverEditor(profile);
                }
            },
            SCROLL22: {

                swipedown: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swipedown) {
                        box.swipedown(profile, item, e, src);
                        return false;
                    }
                },
                swipeleft: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();
                    if (profile.swipeleft) {
                        box.swipeleft(profile, item, e, src);
                        return false;
                    }
                },
                swipeup: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.swipeup) {
                        box.swipeup(profile, item, e, src);
                        return false;
                    }
                },

                onScroll: function (profile, e, src) {
                    var node = ood.use(src).get(0),
                        l = node.scrollLeft || 0,
                        t = node.scrollTop || 0;
                    if (profile.$sl != l) {
                        profile.getSubNodes(['HEADER2', 'SCROLL12']).scrollLeft(profile.$sl = l);
                    }
                    if (profile.$st != t) {
                        profile.getSubNode('SCROLL21').get(0).scrollTop = profile.$st = t;
                        //for IE11's scrollbar bug
                        if ((t = profile.getSubNode('SCROLL21').get(0).scrollTop) && t != profile.$st) {
                            node.scrollTop = profile.$st = t;
                        }
                    }
                }
            },


            SCROLL21: {
                onScroll: function (profile, e, src) {
                    var node = ood.use(src).get(0),
                        t = node.scrollTop || 0;
                    if (profile.$st != t)
                        profile.getSubNode('SCROLL22').get(0).scrollTop = profile.$st = t;
                }
            },
            HEADER2: {
                onScroll: function (profile, e, src) {
                    var node = ood.use(src).get(0),
                        l = node.scrollLeft || 0;
                    if (profile.$sl != l)
                        profile.getSubNodes(['SCROLL12', 'SCROLL22']).scrollLeft(profile.$sl = l);
                }
            },
            SCROLL12: {
                onScroll: function (profile, e, src) {
                    var node = ood.use(src).get(0),
                        l = node.scrollLeft || 0;
                    if (profile.$sl != l)
                        profile.getSubNodes(['HEADER2', 'SCROLL22']).scrollLeft(profile.$sl = l);
                }
            },
            //colomn resizer
            HHANDLER: {
                beforeMousedown: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != 'left') return;
                    var p = profile.properties,
                        id = profile.getSubId(src),
                        col = profile.colMap[id], o;
                    if (col && col._isgroup) {
                        o = profile.getSubNode("HHANDLER", profile.properties.header[col["to"]]._serialId);
                    } else {
                        o = ood(src);
                    }
                    var minW = o.parent(2).width() - profile.$px(p._minColW),
                        scroll = profile.getSubNode('SCROLL22'),
                        maxW = scroll.offset().left + scroll.width() - ood.Event.getPos(e).left - 4;

                    if (p.disabled) return false;
                    if (col && col.disabled) return false;

                    o.startDrag(e, {
                        horizontalOnly: true,
                        dragType: 'blank',
                        dragDefer: 2,
                        maxLeftOffset: minW,
                        maxRightOffset: maxW,
                        targetReposition: false
                    });
                    ood.use(src).parent(2).onMouseout(true, {$force: true}).onMouseup(true);
                },
                onDragbegin: function (profile, e, src) {
                    ood.DragDrop.getProfile().proxyNode
                        .css({
                            height: profile.getRoot().height() + 'px',
                            width: '4px',
                            backgroundColor: '#DDDDDD',
                            cursor: 'e-resize'
                        });
                },
                onDrag: function (profile, e, src) {
                    var d = ood.DragDrop, p = d.getProfile(), b = 0;
                    if (p.x <= p.restrictedLeft || p.x >= p.restrictedRight) b = true;
                    if (b) {
                        if (!profile._limited) {
                            p.proxyNode.css('backgroundColor', 'var(--ood-warning)');
                            profile._limited = true;
                        }
                    } else {
                        if (profile._limited) {
                            p.proxyNode.css('backgroundColor', 'var(--ood-bg-light)');
                            profile._limited = 0;
                        }
                    }
                },
                onDragstop: function (profile, e, src) {
                    var p = profile.properties,
                        o = ood(src).parent(2),
                        ks = profile.keys,
                        col = profile.colMap[profile.getSubId(src)],
                        oldw = o.width(),
                        w = oldw + ood.DragDrop.getProfile().offset.x,
                        emw;
                    if (col) {
                        if (col && col._isgroup) {
                            col = profile.properties.header[col['to']];
                            o = profile.getSubNode("HCELL", col._serialId);
                        }
                        if (col.hasOwnProperty('maxWidth')) w = Math.min(profile.$px(col.maxWidth), w);
                        if (col.hasOwnProperty('minWidth')) w = Math.max(profile.$px(col.minWidth), w);
                    }

                    if (profile.beforeColResized && false === profile.boxing().beforeColResized(profile, col ? col.id : null, w)) {
                        profile._limited = 0;
                        return;
                    }
                    emw = profile.$forceu(w);
                    o.width(emw);
                    if (col) {
                        if (col.flexSize) {
                            var emw = parseFloat(col.width),
                                percent = w / profile._relAvailable,
                                oldPercent = oldw / profile._relAvailable;
                            col.width = (emw / oldPercent - emw) * percent / (1 - percent) + profile.$picku(col.width);
                        } else {
                            col.width = emw;
                        }
                        col._colWidth = emw;
                    }

                    //collect cell id
                    var ids = [], ws = [];
                    if (profile.getKey(ood.use(src).parent(2).id()) == ks.FHCELL) {
                        profile.box._setRowHanderW(profile, w);
                    } else {
                        var cells = col._cells, t;
                        ood.each(cells, function (o) {
                            if (!(t = profile.getSubNode(ks.CELL, o)).isEmpty()) ids.push(t.id());
                        });
                        profile.box._adjusteditorW(profile, ood(ids).width(emw), w);
                    }

                    if (profile.afterColResized)
                        profile.boxing().afterColResized(profile, col ? col.id : null, w);

                    profile.getSubNode('SCROLL22').onScroll();
                    profile.box._adjustColsWidth(profile);
                    profile.box._adjustBody(profile, 'setcol');
                    profile._limited = 0;
                },
                onClick: function () {
                    return false
                },
                onDblclick: function (profile, e, src) {
                    var p = profile.properties,
                        o = ood.use(src).parent(2),
                        id = profile.getSubId(src);
                    col = profile.colMap[id];

                    if (col && col._isgroup) {
                        col = profile.properties.header[col['to']];
                        o = profile.getSubNode("HCELL", col._serialId);
                    }

                    if (col && col.flexSize) return;
                    if (profile.getRootNode().clientHeight <= 0) return;

                    //for row0
                    if (profile.getKey(ood.use(src).parent(2).id()) == profile.keys.FHCELL) {
                        profile.box._setRowHanderW(profile, true);
                        return;
                    }

                    //for other rows
                    var cells = col._cells,
                        cls = profile.getClass('CELLA', '-inline'),
                        n, nodes = [], ws = [], w, emw;
                    ood.each(cells, function (o) {
                        n = profile.getSubNode('CELLA', o);
                        if (n._nodes.length) {
                            nodes.push(n.get(0));
                            ws.push(n.addClass(cls).width());
                        }
                    });
                    // for group in the first column
                    if (p.treeMode == 'infirstcell' && p.header[0] == col) {
                        profile.getSubNode("GCELLA", true).each(function (o) {
                            ws.push(ood(o).addClass(cls).width());
                            ood(o).removeClass(cls);
                        });
                    }

                    ws.push(profile.$px(p._minColW));
                    w = parseFloat(Math.max.apply(null, ws));
                    if (w > profile.$px(p._maxColW)) w = profile.$px(p._maxColW);

                    if (profile.beforeColResized && false === profile.boxing().beforeColResized(profile, col ? col.id : null, w))
                        return;

                    if (col) {
                        if (col.hasOwnProperty('maxWidth')) w = Math.min(profile.$px(col.maxWidth), w);
                        if (col.hasOwnProperty('minWidth')) w = Math.max(profile.$px(col.minWidth), w);
                    }
                    w += 2;
                    emw = profile.$forceu(w);

                    profile.box._adjusteditorW(profile, ood(nodes).parent().width(emw), w);
                    o.width(col.width = col._colWidth = emw);

                    ood(nodes).removeClass(cls);
                    if (profile.afterColResized)
                        profile.boxing().afterColResized(profile, col.id, w);

                    profile.box._adjustColsWidth(profile);
                    profile.box._adjustBody(profile, 'setcol');
                    return false;
                }
            },
            //row resizer
            FHANDLER: {
                beforeMousedown: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != 'left') return;
                    var p = profile.properties,
                        row = profile.rowMap[profile.getSubId(src)],
                        o = ood(src),
                        minH = o.parent(3).height() - profile.$px(p._minRowH),
                        scroll = profile.getSubNode('SCROLL21'),
                        maxH = scroll.offset().top + scroll.height() - ood.Event.getPos(e).top - 4;

                    if (p.disabled || (row && row.disabled)) return false;
                    o.startDrag(e, {
                        verticalOnly: true,
                        dragType: 'blank',
                        dragDefer: 2,
                        maxTopOffset: minH,
                        maxBottomOffset: maxH,
                        targetReposition: false
                    });
                    ood.use(src).parent(2).onMouseout(true, {$force: true}).onMouseup(true);
                    if (!row)
                        profile.getSubNode('COLLIST').css('visibility', 'hidden');
                },
                onDragbegin: function (profile, e, src) {
                    ood.DragDrop.getProfile().proxyNode
                        .css({
                            width: profile.getRoot().width() + 'px',
                            height: '4px',
                            backgroundColor: '#DDDDDD',
                            cursor: 'n-resize'
                        });
                },
                onDrag: function (profile, e, src) {
                    var d = ood.DragDrop, p = d.getProfile(), b = 0;
                    if (p.y <= p.restrictedTop || p.y >= p.restrictedBottom) b = true;
                    if (b) {
                        if (!profile._limited) {
                            p.proxyNode.css('backgroundColor', '#ff6600');
                            profile._limited = true;
                        }
                    } else {
                        if (profile._limited) {
                            p.proxyNode.css('backgroundColor', '#DDDDDD');
                            profile._limited = 0;
                        }
                    }
                },
                onDragstop: function (profile, e, src) {
                    var subId = profile.getSubId(src),
                        o = ood(src).parent(3),
                        h = o.height() + ood.DragDrop.getProfile().offset.y,
                        row = profile.rowMap[profile.getSubId(src)],
                        prop = profile.properties,
                        header = prop.header,
                        headerHeight = prop.headerHeight;

                    //for ie's weird bug
                    if (ood.browser.ie && ood.browser.ver <= 8 && h % 2 == 1) h += 1;

                    if (profile.beforeRowResized && false === profile.boxing().beforeRowResized(profile, row ? row.id : null, h)) {
                        profile._limited = 0;
                        return;
                    }
                    // use em
                    if (profile.getKey(ood.use(src).parent(2).id()) == profile.keys.FHCELL) {
                        prop.headerHeight = profile.$forceu(h);
                        profile.box._adjustColsHeight(profile);
                        profile.adjustSize();
                    } else {
                        row.height = profile.$forceu(h);
                        profile.getSubNode("CELLS2", subId).height(row.height);
                        o.height(row._rowHeight = row.height);
                        profile.box._adjusteditorH(profile, o, row._rowHeight);
                    }

                    if (profile.afterRowResized)
                        profile.boxing().afterRowResized(profile, row ? row.id : null, h);

                    profile.box._adjustBody(profile, 'setrow');

                    profile._limited = 0;
                },
                onDblclick: function (profile, e, src) {
                    var prop = profile.properties,
                        sid = profile.getSubId(src),
                        row, cells;
                    if (profile.getRootNode().clientHeight <= 0) return;

                    if (sid) {
                        row = profile.rowMap[sid];
                        cells = profile.getSubNodes(['CELLS2', 'CELLS1'], sid);
                        var h = cells.height('auto').height();

                        if (profile.beforeRowResized && false === profile.boxing().beforeRowResized(profile, row.id, h))
                            return;
                        cells.height(row.height = row._rowHeight = profile.$forceu(h));
                        profile.box._adjusteditorH(profile, cells, h);
                    } else {
                        // fake
                        var h = (profile._headerLayers || 0 + 1) * profile.$px(profile.box.$DataStruct.headerHeight);
                        if (profile.beforeRowResized && false === profile.boxing().beforeRowResized(profile, null, h))
                            return;
                        profile.box._adjustColsHeight(profile, true);

                        prop.headerHeight = profile.$forceu(h, profile.$picku(prop.headerHeight));
                        profile.adjustSize();
                    }

                    if (profile.afterRowResized)
                        profile.boxing().afterRowResized(profile, row ? row.id : null, h);

                    profile.box._adjustBody(profile, 'setrow');

                    return false;
                },
                onClick: function () {
                    return false
                }
            },
            //mark click for tree build
            ROWTOGGLE: {
                onClick: function (profile, e, src) {
                    var p = profile.properties, cell,
                        row = profile.rowMap[profile.getSubId(src)];
                    if (!row) {
                        cell = profile.cellMap[profile.getSubId(src)];
                        if (cell) row = cell._row;
                    }
                    if (!row) return;
                    if (p.disabled || row.disabled) return false;
                    //for selection click
                    if (!row.sub) return;

                    profile.box._setSub(profile, row, !row._checked);

                    return false;
                },
                beforeMousedown: function () {
                    return false;
                }
            },
            //HCELLA handler dragdrop
            HSCELLA: {
                onClick: function (profile, e, src) {
                    profile.getSubNode("HCELLA", profile.getSubId(src)).onClick(true);
                }
            },
            HCELLA: {
                onClick: function (profile, e, src) {
                    var p = profile.properties,
                        id = profile.getSubId(src),
                        col = profile.colMap[id];

                    if (!col) {
                        if (profile.onClickGridHandler)
                            profile.boxing().onClickGridHandler(profile, e, src);

                        if (p.disabled) return false;
                        if (!p.colSortable) return;
                    } else {
                        if (profile.onClickHeader)
                            profile.boxing().onClickHeader(profile, col, e, src);

                        if (p.disabled || col.disabled) return false;
                        if (!(col.hasOwnProperty('colSortable') ? col.colSortable : p.colSortable)) return;
                    }

                    if (col && col._isgroup) {
                        col = profile.properties.header[col.from];
                    }
                    if (profile.beforeColSorted && false === profile.boxing().beforeColSorted(profile, col))
                        return false;

                    var order = (col ? col._order : profile._order) || false,
                        type = (col ? col.type : null) || 'input',
                        sortby = col ? col.sortby : null,
                        index = col ? ood.arr.indexOf(p.header, col) : -1,
                        me = arguments.callee,
                        fun = me.fun || (me.fun = function (profile, subNode, index, type, sortby, order, lastrownode1, lastrownode2) {
                            var rows, parent1, parent2, self = arguments.callee;
                            if (subNode) {
                                rows = subNode.sub;
                                parent1 = profile.getSubNode('SUB1', subNode._serialId).get(0);
                                parent2 = profile.getSubNode('SUB2', subNode._serialId).get(0);
                            } else {
                                subNode = {_inited: true};
                                rows = profile.properties.rows;
                                parent1 = profile.getSubNode('ROWS21').get(0);
                                parent2 = profile.getSubNode('ROWS22').get(0);
                            }
                            //sor sub first
                            var a1 = [], a2 = [], a4 = [], t, ff;
                            var a11 = [], a12 = [], a31 = [], a32 = [];
                            ood.arr.each(rows, function (row) {
                                if (row._region == 1) return;

                                if (row.sub && row.sub.length > 1)
                                    self(profile, row, index, type, sortby, order, null);
                                //for short input
                                a1[a1.length] = index == -1
                                    ? row.caption
                                    : (t = row.cells) ? (t = t[index]) ? t.value : '' : row[index];
                                a4[a4.length] = index == -1
                                    ? row
                                    : (t = row.cells) ? t[index] : row[index];
                                a2[a2.length] = a2.length;
                            });
                            var sortf;
                            if (typeof sortby != 'function') {
                                switch (type) {
                                    case 'number':
                                    case 'spin':
                                    case 'counter':
                                    case 'currency':
                                        ff = function (n) {
                                            return parseFloat(n) || 0
                                        };
                                        break;
                                    case 'datetime':
                                    case 'date':
                                        ff = function (n) {
                                            return ood.isDate(n) ? n.getTime() : ood.isFinite(n) ? parseInt(n, 10) : 0
                                        };
                                        break;
                                    default:
                                        ff = function (n) {
                                            return n || ''
                                        };
                                }
                                sortf = function (x, y) {
                                    var xx = ff(a1[x]), yy = ff(a1[y]);
                                    return (xx > yy ? (order ? 1 : -1) : xx === yy ? (x > y ? -1 : 1) : (order ? -1 : 1));
                                };
                            } else {
                                sortf = function (x, y) {
                                    return sortby.apply(profile, [x, y, a1, order, index, a4]);
                                };
                            }
                            a2.sort(sortf);

                            //sort memory array
                            //sort dom node
                            var b = subNode._inited, bak = ood.copy(rows), c;
                            if (b) {
                                a11 = parent1.childNodes;
                                a12 = parent2.childNodes;
                            }
                            ood.arr.each(a2, function (o, i) {
                                rows[i] = bak[o];
                                if (b) {
                                    a31[i] = a11[o];
                                    a32[i] = a12[o];
                                }
                            });
                            if (b) {
                                var fragment1 = document.createDocumentFragment(),
                                    fragment2 = document.createDocumentFragment();
                                for (var i = 0; t = a31[i]; i++) fragment1.appendChild(t);
                                for (var i = 0; t = a32[i]; i++) fragment2.appendChild(t);

                                if (lastrownode1) {
                                    parent1.insertBefore(fragment1, lastrownode1);
                                    parent2.insertBefore(fragment2, lastrownode2);
                                } else {
                                    parent1.appendChild(fragment1);
                                    parent2.appendChild(fragment2);
                                }
                            }
                        });

                    var lastrow, lastrownode1, lastrownode2;
                    if (profile.__hastmpRow) {
                        lastrow = profile.properties.rows.pop();
                        lastrownode1 = profile.getSubNode('ROWS21').get(0).lastChild;
                        lastrownode2 = profile.getSubNode('ROWS22').get(0).lastChild;
                    }

                    fun(profile, null, index, type, sortby, order, lastrownode1, lastrownode2);

                    if (profile.__hastmpRow)
                        profile.properties.rows.push(lastrow);

                    //show sort mark
                    profile.getSubNode('SORT', true).css('display', 'none');
                    var node = (col ? profile.getSubNode('SORT', col._serialId) : profile.getSubNode('SORT')).css('display', '');
                    node.tagClass('-checked', col ? (!(col._order = !col._order)) : (!(profile._order = !profile._order)));

                    profile.box._asy(profile);

                    //clear rows cache
                    delete profile.$allrowscache1;
                    delete profile.$allrowscache2;

                    if (profile.afterColSorted)
                        profile.boxing().afterColSorted(profile, col);
                },
                beforeMousedown: function (profile, e, src) {
                    if (ood.Event.getBtn(e) != 'left') return;

                    var p = profile.properties;
                    if (p.disabled) return;

                    var col = profile.colMap[profile.getSubId(src)];
                    if (!col || col._isgroup) return;
                    if (p.disabled || col.disabled) return false;
                    if (p.treeMode == 'infirstcell' && p.header[0] == col) return false;
                    if (!(col.hasOwnProperty('colMovable') ? col.colMovable : p.colMovable)) return;

                    //fire before event
                    if (false === profile.boxing().beforeColDrag(profile, col.id)) return;

                    var pos = ood.Event.getPos(e),
                        o = ood(src),
                        itemId = profile.getSubId(src);

                    o.startDrag(e, {
                        dragType: 'icon',
                        shadowFrom: o.parent(),
                        dragCursor: 'pointer',
                        targetLeft: pos.left + 12,
                        targetTop: pos.top + 12,
                        targetReposition: false,
                        dragDefer: 2,
                        dragKey: profile.$xid + ":col",
                        dragData: o.parent().id(),
                        tagVar: col._region
                    });
                },
                onDragbegin: function (profile, e, src) {
                    ood(src).parent().onMouseout(true, {$force: true});
                    ood(src).onMouseup(true);
                },
                beforeMouseover: function (profile, e, src) {
                    var p = profile.properties,
                        id = profile.getSubId(src),
                        col = profile.colMap[id];
                    if (!col || col._isgroup) return;
                    if (p.disabled || col.disabled) return false;

                    var dp = ood.DragDrop.getProfile();
                    if (!dp.dragData || dp.dragKey != profile.$xid + ":col") return;
                    if (dp.tagVar != col._region) return;

                    var psrc = ood.use(src).parent().xid();
                    if (false === profile.box._colDragCheck(profile, psrc)) return;
                    ood.DragDrop.setDropElement(src).setDropFace(src, 'move');
                    var nn = ood.use(psrc).get(0), left = nn.offsetLeft + (col._region == 2 ? profile._leftregionw : 0),
                        top = nn.offsetTop + nn.offsetHeight;
                    profile.getSubNode("ARROW")
                        .left(left)
                        .top(top)
                        .css("display", "block");
                },
                beforeMouseout: function (profile, e, src) {
                    var p = profile.properties,
                        id = profile.getSubId(src),
                        col = profile.colMap[id];
                    if (!col) return;
                    if (p.disabled || col.disabled) return false;

                    var dp = ood.DragDrop.getProfile();
                    if (!dp.dragData || dp.dragKey != profile.$xid + ":col") return;

                    var psrc = ood.use(src).parent().xid();
                    ood.DragDrop.setDropElement(null).setDropFace(null, 'none');
                    if (false === profile.box._colDragCheck(profile, psrc)) return;
                    profile.getSubNode("ARROW").css("display", "none");
                },
                onDrop: function (profile, e, src) {
                    var p = profile.properties,
                        box = profile.box,
                        id = profile.getSubId(src),
                        SubID = ood.UI.$tag_subId,
                        col = profile.colMap[id];
                    if (!col) return;
                    if (p.disabled || col.disabled) return false;

                    var psrc = ood.use(src).parent().xid();
                    profile.getSubNode("ARROW").css("display", "none");
                    if (false === box._colDragCheck(profile, psrc)) return;

                    //check dragData
                    var data = ood.DragDrop.getProfile().dragData,
                        fromId = data && profile.getSubId(data),
                        toId = profile.getSubId(psrc),
                        //get properties
                        map = profile.colMap,
                        fromTh = map[fromId],
                        toTh = map[toId];

                    //fire before event
                    if (false === profile.boxing().beforeColMoved(profile, fromTh.id, toTh.id)) return;

                    //remove dragover appearance
                    ood.DragDrop.setDropFace(psrc, 'none');

                    //get index in HCELL array
                    var fromIndex = ood.arr.subIndexOf(p.header, '_serialId', fromId),
                        toIndex = ood.arr.subIndexOf(p.header, '_serialId', toId);

                    //if same or same position, return
                    if (fromIndex === toIndex || fromIndex === toIndex - 1) return;

                    //reposition header dom node
                    profile.getSubNode('HCELL', toId).addPrev(ood(ood.DragDrop.getProfile().dragData));
                    //reposition cell dom nodes
                    ood.each(toTh._cells, function (o, i) {
                        profile.getSubNode('CELL', o).addPrev(profile.getSubNode('CELL', fromTh._cells[i]));
                    });

                    //update memory
                    //HCELL position
                    //keep refrence, and remove
                    var temp = p.header[fromIndex];
                    // 1. insert to right pos
                    ood.arr.insertAny(p.header, temp, toIndex);
                    // 2. then, remove
                    ood.arr.removeFrom(p.header, fromIndex + (fromIndex > toIndex ? 1 : 0));
                    //cell position rowMap
                    var allitems = profile.queryItems(p.rows, true, true);
                    ood.arr.each(allitems, function (o) {
                        //for those non-prepared data
                        o = o.cells ? o.cells : o;
                        if (!o || !ood.isArr(o)) return;
                        temp = o[fromIndex];
                        ood.arr.removeFrom(o, fromIndex);
                        ood.arr.insertAny(o, temp, toIndex);
                    });

                    // group columns
                    var arr = p.grpCols;
                    if (arr && ood.isArr(arr) && arr.length) {
                        for (var j = 0, m = arr.length, grp; j < m; j++) {
                            grp = arr[j];
                            if (grp.from > toIndex) {
                                grp.from++;
                                grp['to']++;
                            } else if (toIndex >= grp.from && toIndex <= grp['to']) {
                                grp['to']++;
                            }
                        }
                        for (var j = 0, m = arr.length, grp; j < m; j++) {
                            grp = arr[j];
                            if (grp.from > fromIndex) {
                                grp.from--;
                                grp['to']--;
                            } else if (fromIndex >= grp.from && fromIndex <= grp['to']) {
                                grp['to']--;
                            }
                        }
                        ood.filter(arr, function (o) {
                            var r = o['to'] >= o.from;
                            if (!r && profile.renderId) {
                                profile.getSubNodes(["HCELL", "HSCELL"], o[SubID]).remove();
                                delete profile.colMap[o[SubID]];
                                delete profile.colMap2[o.id];
                            }
                            return r;
                        });
                        p.grpCols = box._adjustGrpColsData(profile, arr);
                        box._adjustColsWidth(profile);
                        box._adjustColsHeight(profile);
                    }

                    //fire after event
                    profile.boxing().afterColMoved(profile, fromTh.id, toTh.id);

                    //clear rows cache
                    delete profile.$allrowscache1;
                    delete profile.$allrowscache2;
                },
                onMouseover: function (profile, e, src) {
                    var p = profile.properties,
                        id = profile.getSubId(src),
                        col = profile.colMap[id];

                    if (col) {
                        if (p.disabled || col.disabled) return false;
                        if (!(col.hasOwnProperty('colHidable') ? col.colHidable : p.colHidable)) return;
                        if (!(col.hasOwnProperty('colDroppable') ? col.colDroppable : p.colDroppable)) return;
                    } else {
                        if (p.disabled) return false;
                        if (!p.colHidable) return;
                    }

                    ood.resetRun(profile.$xid + ':collist', null);
                    var region = {},
                        pos = ood.use(src).parent().offset(null, profile.getSubNode('BOX')),
                        size = ood.use(src).parent().cssSize();
                    if (size.width < 16) return;

                    region.height = profile.$forceu(size.height);
                    region.left = profile.$forceu(pos.left);
                    region.top = profile.$forceu(pos.top);

                    profile.getSubNode('COLLIST').cssRegion(region).css('visibility', 'visible');
                },
                onMouseout: function (profile, e, src) {
                    var p = profile.properties,
                        id = profile.getSubId(src),
                        col = profile.colMap[id];

                    if (col) {
                        if (p.disabled || col.disabled) return false;
                        if (!(col.hasOwnProperty('colHidable') ? col.colHidable : p.colHidable)) return;
                    } else {
                        if (p.disabled) return false;
                        if (!p.colHidable) return;
                    }

                    ood.resetRun(profile.$xid + ':collist', function () {
                        // destroyed
                        if (!profile.box) return;
                        profile.getSubNode('COLLIST').css({
                            visibility: 'hidden',
                            left: 0 + profile.$picku(),
                            top: 0 + profile.$picku()
                        });
                    });
                },
                onContextmenu: function (profile, e, src) {
                    if (profile.onContextmenu) {
                        var sid = profile.getSubId(src);
                        return profile.boxing().onContextmenu(profile, e, src, sid ? profile.colMap[sid] : null, ood.Event.getPos(e)) !== false;
                    }
                }
            },
            COLLIST: {
                onMouseover: function (profile, e, src) {
                    ood.resetRun(profile.$xid + ':collist', null);
                },
                onMouseout: function (profile, e, src) {
                    ood.resetRun(profile.$xid + ':collist', function () {
                        // destroyed
                        if (!profile.box) return;
                        ood.use(src).css('visibility', 'hidden');
                    });
                },
                onClick: function (profile, e, src) {
                    var p = profile.properties;
                    if (!profile.$col_pop) {
                        var items = [], pop;
                        ood.arr.each(profile.properties.header, function (o) {
                            if (o.hasOwnProperty('colHidable') ? o.colHidable : p.colHidable)
                                items.push({id: o.id, caption: o.caption, type: 'checkbox', value: o.hidden !== true});
                        });
                        if (items.length) {
                            pop = profile.$col_pop = new ood.UI.PopMenu({
                                hideAfterClick: false,
                                items: items
                            }).render(true);
                            pop.onMenuSelected(function (p, i, s) {
                                var b = 1;
                                ood.arr.each(p.properties.items, function (o) {
                                    if (o.value !== false)
                                        return b = false;
                                });
                                if (!b) {
                                    profile.boxing().showColumn(i.id, i.value);
                                } else {
                                    p.getSubNodeByItemId('CHECKBOX', i.id).tagClass('-checked');
                                    i.value = true;
                                }
                            })
                        }
                    }
                    if (profile.$col_pop)
                        profile.$col_pop.pop(src);
                }
            },
            CELLS2: {
                afterMouseover: function (profile, e, src) {
                    var p = profile.properties;
                    if (p.disabled) return;
                    if (p.disableHoverEffect === true) return;
                    if (p.disableHoverEffect && /\bCELLS2\b/.test(p.disableHoverEffect || "")) return;
                    //if(p.activeMode=='row'){
                    var subid = profile.getSubId(src);
                    profile.getSubNodes(['CELLS1', 'CELLS2'], subid).tagClass('-hover');
                    if (profile.onRowHover) {
                        var row = profile.rowMap[subid];
                        profile.boxing().onRowHover(profile, row, true, e, src);
                    }
                    //}
                },
                afterMouseout: function (profile, e, src) {
                    var p = profile.properties;
                    if (p.disabled) return;
                    if (p.disableHoverEffect === true) return;
                    if (p.disableHoverEffect && /\bCELLS2\b/.test(p.disableHoverEffect || "")) return;
                    //if(p.activeMode=='row'){
                    var subid = profile.getSubId(src);
                    profile.getSubNodes(['CELLS1', 'CELLS2'], subid).tagClass('-hover', false);
                    if (profile.onRowHover) {
                        var row = profile.rowMap[subid];
                        profile.boxing().onRowHover(profile, row, false, e, src);
                    }
                    //}
                },
                onDblclick: function (profile, e, src) {
                    var p = profile.properties,
                        row = profile.rowMap[profile.getSubId(src)],
                        nn = ood.Event.getSrc(e),
                        eid = nn && (nn.id || ""),
                        ks = profile.keys,
                        ck = profile.getKey(eid);
                    while (!ck) {
                        nn = nn.offsetParent;
                        ck = profile.getKey(eid = nn.id);
                    }
                    if (!row || p.disabled || row.disabled) return false;
                    if (eid && ood.UIProfile.getFromDom(eid) != profile) return false;
                    if (ck == ks.ROWTOGGLE || ck == ks.MARK) return false;
                    if (profile.onDblclickRow) {
                        if (row) {
                            profile.boxing().setActiveRow(row.id);
                        }
                        profile.boxing().onDblclickRow(profile, row, e, src);
                    }
                    return false;
                },
                onClick: function (profile, e, src) {
                    var p = profile.properties,
                        subid = profile.getSubId(src),
                        ks = profile.keys,
                        row = profile.rowMap[subid],
                        eid = ood.Event.getSrc(e).id || "";
                    if (p.disabled || row.disabled) return false;
                    if (eid && ood.UIProfile.getFromDom(eid) != profile) return false;
                    if (profile.onClickRow) {
                        if (row) {
                            profile.boxing().setActiveRow(row.id);
                        }
                        profile.boxing().onClickRow(profile, row, e, src);
                        profile.boxing().swiperight(profile, row, e, src);
                    }

                }
            },
            CELL: {
                onMouseover: function (profile, e, src) {
                    if (false == profile.box.$cancelHoverEditor(profile)) return;

                    var box = profile.box, p = profile.properties, i = ood.use(src).id(), editor;
                    if (p.disableHoverEffect === true) return;
                    if (p.disableHoverEffect && /\bCELL\b/.test(p.disableHoverEffect || "")) return;
                    i = i.split(":")[2];
                    if (!i) return;
                    i = profile.cellMap[i];
                    if (!i) return;

                    if (box.getCellOption(profile, i, "disabled")) return;

                    var editMode = box.getCellOption(profile, i, "editMode");
                    if (box.getCellOption(profile, i, "editable") && ood.str.startWith(editMode, "hover")) {
                        if (editMode == 'hoversharp' && box.getCellOption(profile, i, "type") == 'file') {
                            //    profile.box.$cancelHoverEditor(profile);
                        } else {
                            //    profile.box.$cancelHoverEditor(profile);
                            ood.resetRun(profile.key + ":" + profile.$xid + ":hovereditor", function () {
                                if (profile.destroyed) return;
                                profile.box._editCell(profile, profile.getSubId(src), true);
                            });
                            return false;
                        }
                    }//else{
                     //   profile.box.$cancelHoverEditor(profile);
                    //}
                }
            },
            GCELL: {
                onMouseover: function (profile, e, src) {
                    profile.box.$cancelHoverEditor(profile);
                }
            },
            CELLA: {
                onDblclick: function (profile, e, src) {
                    var cell = profile.cellMap[profile.getSubId(src)];
                    if (!cell) return;
                    if (profile.properties.disabled) return;
                    var box = profile.box,
                        getPro = box.getCellOption,
                        type = getPro(profile, cell, 'type'),
                        disabled = getPro(profile, cell, 'disabled'),
                        editable = getPro(profile, cell, 'editable');

                    if (!disabled && (!editable || (type == 'button' || type == 'label'))) {
                        profile.boxing().onDblclickCell(profile, cell, e, src);
                        // stop to trigger row's onDblclick event
                        if (type == 'button')
                            return false;
                    }
                },
                afterMousedown: function (profile, e, src) {
                    ood.setNodeData(src, '_tmp_forcefocus');
                },
                onClick: function (profile, e, src) {
                    var p = profile.properties,
                        box = profile.box,
                        getPro = box.getCellOption,
                        cell = profile.cellMap[profile.getSubId(src)],
                        id;
                    if (cell) {
                        if (profile.properties.disabled) return false;
                        var type = getPro(profile, cell, 'type'),
                            disabled = getPro(profile, cell, 'disabled'),
                            readonly = getPro(profile, cell, 'readonly'),
                            event = getPro(profile, cell, 'event'),
                            mode = p.activeMode,
                            editable = getPro(profile, cell, 'editable');

                        if (!disabled && (!editable || (type == 'button' || type == 'label'))) {
                            if (typeof event == 'function' && false === event.call(profile._host || profile, profile, cell, null, null, e, src)) {
                            }
                            else if (profile.onClickCell)
                                profile.boxing().onClickCell(profile, cell, e, src);
                            if (type == 'button')
                                return false;
                        }
                        // checkbox is special for editor
                        if (!disabled && !readonly && type == 'checkbox')
                            if (editable) {
                                box._updCell(profile, cell, !cell.value, p.dirtyMark, true, true);

                                profile.box._trycheckrowdirty(profile, cell);

                                var ishotrow = cell._row.id == profile.box._temprowid;
                                if (ishotrow) {
                                    profile.__needchecktmprow = true;
                                    profile.box._sethotrowoutterblur(profile);
                                }
                            }

                        if (!p.editable) {
                            if (mode == 'cell') {
                                if (getPro(profile, cell, 'disabled'))
                                    return false;
                                id = ood(src).parent().id();
                                box._sel(profile, 'cell', src, id, e);
                            } else if (mode == 'row') {
                                if (p.disabled || cell._row.disabled)
                                    return false;
                                id = ood(src).parent(3).id();
                                box._sel(profile, 'row', src, id, e);
                            }
                        } else {
                            if (p.activeMode == 'row') {
                                id = ood(src).parent(3).id();
                                box._sel(profile, 'row', src, id, e);
                            }
                        }
                        // handler CELL
                    } else {
                        var row = profile.rowMap[profile.getSubId(src)];
                        if (p.disabled || row.disabled)
                            return false;
                        if (profile.keys.MARK) {
                            var ck = profile.getKey(ood.Event.getSrc(e).id || ""),
                                clickMark = ck == profile.keys.MARK;
                        }
                        if (!clickMark) {
                            if (typeof event == 'function' && false === event.call(profile._host || profile, profile, row, null, null, e, src)) {
                            }
                            else if (profile.onClickRowHandler) {
                                if (row) {
                                    profile.boxing().setActiveRow(row.id);
                                }
                                profile.boxing().onClickRowHandler(profile, row, e, src);
                            }

                            // toggle
                            if (row.group) profile.box._getToggleNode(profile, row._serialId).onClick();
                        }

                        if (p.activeMode == 'row') {
                            id = ood(src).parent(3).id();
                            box._sel(profile, 'row', src, id, e);
                        }
                    }
                    if (profile.box) {
                        if (ood.use(src).get(0)) {
                            //in some browsers: if CELLA has a child 'span', you click 'span' will not tigger to focus CELLA
                            if (!ood.getNodeData(src, '_tmp_forcefocus'))
                                profile.box._focusEvent(profile, e, src);
                        }
                    }
                },
                onFocus: function (profile, e, src) {
                    ood.setNodeData(src, '_tmp_forcefocus', 1);
                    profile.box._focusEvent(profile, e, src);
                },
                onKeydown: function (profile, e, src) {
                    var akeys = {"tab": 1, "left": 1, "right": 1, "up": 1, "down": 1},
                        keys = ood.Event.getKey(e),
                        key = keys.key;

                    if (key == 'enter') {
                        ood(src).onClick();
                        return;
                    }

                    if (!akeys[key]) return;

                    var cell = profile.cellMap[profile.getSubId(src)];
                    if (profile.beforeCellKeydown && false === profile.boxing().beforeCellKeydown(profile, cell, keys)) {
                        return false;
                    }

                    // for navigation
                    var p = profile.properties,
                        shift = keys.shiftKey,
                        ctrl = keys.ctrlKey,
                        cur = ood(src),
                        body11 = profile.getSubNode('SCROLL11'),
                        body12 = profile.getSubNode('SCROLL12'),
                        body21 = profile.getSubNode('SCROLL21'),
                        body22 = profile.getSubNode('SCROLL22'),
                        keyid = new RegExp("^" + profile.box.$Keys.CELLA + ":" + profile.serialId + ":"),
                        hasBody12 = !!body12.offsetWidth(),
                        hasBody21 = !!body21.offsetWidth(),
                        hasBody22 = !!body22.offsetHeight(),
                        first11 = body11.nextFocus(true, true, false, keyid),
                        first12 = body12.nextFocus(true, true, false, keyid),
                        first21 = body21.nextFocus(true, true, false, keyid),
                        first22 = body22.nextFocus(true, true, false, keyid),
                        last11 = body11.nextFocus(false, true, false, keyid),
                        last12 = body12.nextFocus(false, true, false, keyid),
                        last21 = body21.nextFocus(false, true, false, keyid),
                        last22 = body22.nextFocus(false, true, false, keyid),
                        first = hasBody12 ? hasBody21 ? first11 : first12 : hasBody21 ? first21 : first22,
                        last = body22 ? last22 : body12 ? last12 : body21 ? last21 : last11,

                        cellNode = cur.parent(),
                        cellsid = cellNode.parent().id(),
                        subId = profile.getSubId(cellsid),
                        row = cell ? cell._row : profile.rowMap[profile.getSubId(src)],
                        ishotrow = row && row.id == profile.box._temprowid,
                        region = cell ? (cell._row._region + "" + cell._col._region) : (row._region + "1"),
                        t;

                    var toLeft = function (inner) {
                            if (src != first.xid()) {
                                var ok;
                                if (!cellNode.get(0).previousSibling || !cellNode.get(0).previousSibling.clientWidth) {
                                    switch (region) {
                                        case '11':
                                        case '21':
                                            // has right region
                                            if (hasBody22) {
                                                if (src == first21.xid()) {
                                                    last12.focus(true);
                                                    ok = 1;
                                                } else {
                                                    var prev = profile.getSubNode("ROW2", subId).prev();
                                                    if (prev) {
                                                        prev.nextFocus(false, true, true, keyid);
                                                        ok = 1;
                                                    }
                                                }
                                            }
                                            break;
                                        case '12':
                                        case '22':
                                            // has left region
                                            if (hasBody21) {
                                                profile.getSubNode("CELLS1", subId).last(2).focus(true);
                                                ok = 1;
                                            }
                                            break;
                                    }
                                }
                                if (!ok) {
                                    cur.nextFocus(false, false, true, keyid);
                                }
                                return false;
                            } else if (inner) {
                                last.focus(true);
                            }
                        },
                        toRight = function (inner) {
                            if (src != last.xid()) {
                                var ok;
                                if (region == "11" || region == "21" ? !cellNode.get(0).nextSibling : (!(t = cellNode.get(0).nextSibling) || !t.clientWidth)) {
                                    switch (region) {
                                        case '11':
                                        case '21':
                                            // has right region
                                            if (hasBody22) {
                                                profile.getSubNode("CELLS2", subId).first(2).focus(true);
                                                ok = 1;
                                            }
                                            break;
                                        case '12':
                                        case '22':
                                            // has left region
                                            if (hasBody21) {
                                                if (src == last12.xid()) {
                                                    first21.focus(true);
                                                    ok = 1;
                                                } else {
                                                    var next = profile.getSubNode("ROW1", subId).next();
                                                    if (next) {
                                                        next.nextFocus(true, true, true, keyid);
                                                        ok = 1;
                                                    }
                                                }
                                            }
                                            break;
                                    }
                                }
                                if (!ok) {
                                    cur.nextFocus(true, false, true, keyid);
                                }
                                return false;
                            } else if (inner) {
                                toDown();
                            }
                        },
                        verticalNav = function (up) {
                            //get no.
                            var count = 1,
                                temp = cur.parent().get(0),
                                max = temp.parentNode.childNodes.length;
                            while (temp = temp.previousSibling) count++;

                            //get row
                            temp = cur.parent(2).get(0);

                            //get all rows
                            if (!profile.$allrowscache2)
                                profile.box._cacheRows(profile);

                            //get index
                            var index = ood.arr.indexOf(region == "12" || region == "22" ? profile.$allrowscache2 : profile.$allrowscache1, temp),
                                rowLen = profile.$allrowscache2.length,
                                newLine = 0;

                            //adjust index
                            if (key == 'up') {
                                index--;
                                if (index == -1) {
                                    index = rowLen - 1;
                                    count--;
                                    if (count == 0) count = max;
                                }
                            } else {
                                index++;
                                if (index == rowLen) {
                                    newLine = 1;
                                    index = 0;
                                    count++;
                                    if (count == max + 1) count = 1;
                                }
                            }
                            //get node
                            var node = ood((region == "12" || region == "22" ? profile.$allrowscache2 : profile.$allrowscache1)[index]).first(),
                                node2 = node;
                            // it's normal cell
                            if (count > 1)
                                node2 = node2.next(count - 1);
                            // no normal cell(group)
                            if (node2.isEmpty())
                                node2 = node;
                            // get CELLA
                            if (node2 && !node2.isEmpty())
                                node2 = node2.first();
                            // focus
                            if (!node2.isEmpty())
                                return [node2, newLine];
                            return null;
                        },
                        toUp = function () {
                            var tnode;
                            if (src != first.xid()) {
                                if (cur.get(0) == first12.get(0) || cur.get(0) == first22.get(0)) {
                                    if (hasBody21) {
                                        tnode = last21;
                                    } else {
                                        tnode = last11;
                                    }
                                }
                                if (!tnode) {
                                    tnode = verticalNav(true)[0];
                                }
                            } else {
                                tnode = last;
                            }
                            if (tnode) tnode.focus(true);
                        },
                        toDown = function () {
                            var newLine, tnode;
                            if (src != last.xid()) {
                                if (cur.get(0) == last11.get(0) || cur.get(0) == last21.get(0)) {
                                    if (hasBody12) {
                                        tnode = first12;
                                    } else {
                                        tnode = first22;
                                    }
                                }
                                if (!tnode) {
                                    tnode = verticalNav();
                                    newLine = tnode[1];
                                    tnode = tnode[0];
                                }
                            } else {
                                tnode = first;
                                newLine = 1;
                            }

                            if (newLine && p.hotRowMode != 'none') {
                                var colId;
                                if (!cell) {
                                    var row = profile.rowMap[profile.getSubId(src)];
                                    if (!row) return false;
                                }
                                colId = (p.hotRowRequired || '').split(p.valueSeparator)[0] || (cell && cell._col && cell._col.id);

                                var addhotrow = true;
                                // if it's just the active row
                                if (profile.__hastmpRow) {
                                    // if it's invalid, dont add new row
                                    addhotrow = profile.box._checkNewLine(profile, 'keydown');

                                    if (!profile.$allrowscache2)
                                        profile.box._cacheRows(profile);
                                }

                                if (addhotrow) {
                                    profile.box._addTempRow(profile, colId);
                                    // dont focus to next cell
                                    return false;
                                }
                            } else {
                                if (tnode) tnode.focus(true);
                            }
                        };
                    switch (key) {
                        //tab to next/pre
                        case 'tab':
                            if (shift) {
                                if (false === toLeft(ishotrow)) {
                                    return false;
                                }
                            } else {
                                if (false === toRight(ishotrow)) {
                                    return false;
                                }
                            }
                            break;
                        case 'left':
                            if (false === toLeft(true)) {
                                return false;
                            }
                            break;
                        case 'right':
                            if (false === toRight(true)) {
                                return false;
                            }
                            break;
                        case 'up':
                            if (ctrl) {
                                if (row && !(p.disabled || row.disabled) && (row.group || row.sub)) {
                                    profile.box._getToggleNode(profile, row._serialId).onClick();
                                    return false;
                                }
                            }
                            toUp();
                            return false;
                            break;
                        case 'down':
                            if (ctrl) {
                                if (row && !(p.disabled || row.disabled) && (row.group || row.sub)) {
                                    profile.box._getToggleNode(profile, row._serialId).onClick();
                                    return false;
                                }
                            }
                            toDown();
                            return false;
                            break;
                    }
                },
                onContextmenu: function (profile, e, src) {
                    if (profile.onContextmenu) {
                        var sid = profile.getSubId(src);
                        // cell or row
                        return profile.boxing().onContextmenu(profile, e, src, sid ? (profile.cellMap[sid] || profile.rowMap[sid]) : null, ood.Event.getPos(e)) !== false;
                    }
                }
            },
            CMD: {
                onClick: function (profile, e, src) {
                    var p = profile.properties,
                        id = ood.use(src).id().split('_'),
                        cmdkey = id[id.length - 1];
                    id.pop();
                    var row = profile.rowMap[profile.getSubId(id.join("_"))];
                    if (p.disabled || (row && row.disabled)) return false;

                    if (profile.onCmd) {
                        if (row) {
                            profile.boxing().setActiveRow(row.id);
                        }
                        profile.boxing().onCmd(profile, row, cmdkey, e, src);
                    }

                    return false;
                }
            }
        },
        DataModel: {
            expression: {
                ini: '',
                action: function () {
                }
            },
            directInput: true,
            listKey: null,
            currencyTpl: "$ *",
            numberTpl: "",
            valueSeparator: ";",
            activeRow: {
                hidden: true,
                ini: null
            },
            activeCell: {
                hidden: true,
                ini: null
            },
            rowMap: {
                hidden: true,
                ini: null
            },
            selMode: {
                ini: 'none',
                listbox: ['single', 'none', 'multi', 'multibycheckbox'],
                action: function (value) {
                    this.getSubNodes(['HFMARK', 'MARK'], true).css('display', (value == 'multi' || value == 'multibycheckbox') ? '' : 'none');
                }
            },
            editMode: {
                ini: 'focus',
                listbox: ["focus", "sharp", "hover", "hoversharp", "inline"]
            },
            dock: 'fill',
            togglePlaceholder: false,
            isFormField: {
                hidden: true,
                ini: false
            },
            altRowsBg: {
                ini: false,
                action: function (value) {
                    var ns = this;
                    var altCls = ns.getClass('CELLS1', '-alt'),
                        nodes21 = ns.getSubNode('CELLS1', true),
                        nodes22 = ns.getSubNode('CELLS2', true),
                        j, o1, o2;
                    nodes21.removeClass(altCls);
                    nodes22.removeClass(altCls);
                    if (value) {
                        alt = [];
                        j = 0;
                        nodes22.each(function (o2, i) {
                            if (o2.clientHeight) {
                                o2 = ood([o2]);
                                o1 = ood([nodes21.get(i)]);
                                if ((j++) % 2 == 1) {
                                    if (!o1.hasClass(altCls)) o1.addClass(altCls);
                                    if (!o2.hasClass(altCls)) o2.addClass(altCls);
                                } else {
                                    if (o1.hasClass(altCls)) o1.removeClass(altCls);
                                    if (o2.hasClass(altCls)) o2.removeClass(altCls);
                                }
                            }
                        });
                    }
                }
            },
            rowNumbered: {
                ini: false,
                action: function (value) {
                    var ns = this,
                        f = ns.CF.getNumberedStr || function (a) {
                            return a
                        },
                        nodes = ns.getSubNode('ROWNUM', true),
                        i = 0,
                        map = ns.rowMap,
                        row, ol = 0, l = 0, a1 = [], a2 = [], tag = '', temp, t;

                    nodes.css('display', value ? '' : 'none');
                    if (value)
                        nodes.each(function (o) {
// for perfomance: remove this
//                            if(o.parentNode.clientHeight){
                            if (row = map[ns.getSubId(o.id)]) {
                                l = row._layer;
                                if (l > ol) {
                                    a1.push(i);
                                    a2.push(tag);
                                    tag = tag + i + '.';
                                    i = 0;
                                } else if (l < ol) {
                                    while (l < ol--) {
                                        i = a1.pop();
                                        tag = a2.pop();
                                    }
                                }
                                i++;
                                ol = l;
                                //o.innerHTML=''+tag+i;
                                row._autoNumber = f(tag + i);
                                temp = row.rowNumber || row._autoNumber;
                                if (t = o.firstChild) {
                                    if (t.nodeValue != temp)
                                        t.nodeValue = temp;
                                } else
                                    o.appendChild(document.createTextNode(temp));
                            }
//                            }
                        });
                    else
                        nodes.text('');
                }
            },
            editable: false,
            firstCellEditable: false,

            $subMargin: '1.375em',

            initFold: true,

            animCollapse: false,

            position: 'absolute',
            width: '25em',
            height: '18em',

            _minColW: '.5em',
            _maxColW: '25em',
            _minRowH: '1.83333em',

            gridHandlerCaption: {
                ini: "",
                action: function (v) {
                    v = (ood.isSet(v) ? v : "") + "";
                    this.getSubNode('GRIDCAPTION').html(ood.adjustRes(v, true));
                }
            },

            headerTail: {
                ini: "",
                action: function (v) {
                    v = (ood.isSet(v) ? v : "") + "";
                    this.getSubNode('LHCELLINNER').html(ood.adjustRes(v, true));
                }
            },

            rowHandlerWidth: {
                $spaceunit: 1,
                ini: '5em',
                set: function (value) {
                    var o = this;
                    if (o.renderId)
                        o.box._setRowHanderW(o, value);
                    else
                        o.properties.rowHandlerWidth = value;
                }
            },

            showHeader: {
                ini: true,
                action: function (value) {
                    this.getSubNodes(['HEADER1', 'HEADER2']).css('display', value ? '' : 'none');
                }
            },
            headerHeight: {
                $spaceunit: 1,
                ini: '2em',
                action: function (v) {
                    var profile = this,
                        prop = profile.properties;
                    profile.box._adjustColsHeight(profile);
                    profile.adjustSize();
                }
            },
            rowHeight: {
                $spaceunit: 1,
                ini: '2em',
                action: function (v) {
                    this.box._adjusteditorH(this, this.getSubNodes(['CELLS1', 'CELLS2'], true).height(v), v);
                }
            },
            _colDfWidth: '8em',


            rowHandler: {
                ini: true,
                action: function (value) {
                    this.getSubNode('FHCELL').css('display', value ? '' : 'none');
                    this.getSubNode('FCELL', true).css('display', value ? '' : 'none');

                    this.box._adjustColsWidth(this);
                    this.box._adjustBody(this, 'rowhandler');
                }
            },
            rowResizer: {
                ini: false,
                action: function (value) {
                    this.getSubNode('FHANDLER', true).css('display', value ? '' : 'none');
                }
            },

            colHidable: false,
            colResizer: {
                ini: true,
                action: function (value) {
                    this.getSubNode('HHANDLER', true).css('display', value ? '' : 'none');
                }
            },
            colSortable: {
                ini: true,
                action: function (value) {
                    if (!value)
                        this.getSubNode('SORT', true).css('display', 'none');
                }
            },
            colMovable: false,

            header: {
                ini: {},
                set: function (value) {
                    var o = this;
                    if (o.renderId) {
                        o.boxing()._refreshHeader(value);
                    } else
                        o.properties.header = ood.copy(value);
                }
            },
            uidColumn: '',
            grpCols: {
                //for default merge
                ini: {},
                set: function (value) {
                    var o = this;
                    o.properties.grpCols = ood.copy(value);
                    if (o.renderId) {
                        o.boxing()._refreshHeader(ood.clone(o.properties.header, false, 2));
                    }
                }
            },
            rows: {
                //for default merge
                ini: {},
                set: function (value) {
                    var o = this;
                    if (o.renderId)
                        o.boxing().removeAllRows(false).insertRows(value);
                    //use copy to avoid outer memory link
                    else
                        o.properties.rows = ood.copy(value);
                }
            },
            // can be se dynamic only
            rawData: {
                ini: [],
                set: function (value) {
                    if (!value || !ood.isArr(value) || !value.length) return;
                    var o = this, cols = {}, header = [], rows = [], i, j, l = value.length, hash;
                    // collect data
                    for (i = 0; i < l; i++) {
                        if (!ood.isHash(hash = value[i])) {
                            return;
                        }
                        for (var k in hash) {
                            if (!(k in cols)) cols[k] = [];
                            cols[k][i] = hash[k];
                        }
                    }
                    //convert to header / rows
                    j = 0;
                    for (var k in cols) {
                        header.push(k);
                        for (i = 0; i < l; i++) {
                            if (!rows[i]) rows[i] = [];
                            rows[i][j] = cols[k][i];
                        }
                        j++;
                    }

                    var ins = o.boxing();
                    if (ins.getHeader('min').join(';') != header.join(';')) {
                        ins.setHeader(header)
                    }
                    ins.setRows(rows);
                },
                get: function (row, splitMixColumn) {
                    var o = this, prop = o.properties, header = prop.header,
                        tid = this.box._temprowid,
                        one = row && row.cells && ood.isArr(row.cells),
                        rows = one ? [row] : ood.isArr(row) && row[0] && row[0].cells && ood.isArr(row[0].cells) ? row : prop.rows,
                        l = header.length, h = rows.length,
                        columns = [], cell, key, keys,
                        data = [];

                    if (h) {
                        for (var i = 0; i < l; i++) {
                            columns.push(header[i].id);
                        }
                        for (var j = 0; j < h; j++) {
                            //ignore temp row for all rows
                            if (!one && rows[j].id == tid) continue;
                            if (rows[j].group || !rows[j].cells) continue;

                            var hash = {};
                            for (var i = 0; i < l; i++) {
                                key = columns[i];
                                cell = rows[j].cells[i];
                                if (splitMixColumn && key.indexOf(":") != -1) {
                                    keys = key.split(':');
                                    hash[keys[0]] = ('value' in cell) ? cell.value : cell;
                                    hash[keys[1]] = ('caption' in cell) ? cell.caption : null;
                                } else {
                                    hash[key.split(':')[0]] = ('value' in cell) ? cell.value : cell;
                                }
                            }
                            data.push(hash);
                        }
                    }
                    return one ? data[0] : data;
                }
            },
            dataset: {
                ini: {},
                get: function () {
                    var prf = this, ins = prf.boxing(), prop = prf.properties;
                    return {
                        name: prop.gridHandlerCaption,
                        dimensions: ins.getHeader('min'),
                        source: ins.getRows('min')
                    };
                },
                set: function (v) {
                    var prf = this, ins = prf.boxing(), prop = prf.properties;
                    var dataset = ood.isFun(v.getDataset) ? v.getDataset() : v;
                    if ((v = prop.tagVar.datasetAdapter) && ood.isFun(v)) dataset = v.call(ins, dataset, prf);
                    if ((v = ins.datasetAdapter) && ood.isFun(v)) dataset = v.call(ins, dataset, prf);
                    if (ins.beforeApplyDataset && false === ins.beforeApplyDataset(prf, dataset)) {
                    } else {
                        if ('name' in dataset) ins.setGridHandlerCaption(dataset.name);
                        if ('dimensions' in dataset) ins.setHeader(dataset.dimensions);
                        if ('source' in dataset) ins.setRows(dataset.source);
                    }
                }
            },
            tagCmds: {
                ini: [],
                action: function () {
                    this.boxing().refresh();
                }
            },
            activeMode: {
                ini: 'row',
                listbox: ['row', 'cell', 'none'],
                action: function (value) {
                    var profile = this;
                    if (value != 'cell' && profile.$activeCell) {
                        ood(profile.$activeCell).tagClass('-active', false);
                        delete profile.$activeCell;
                    }
                    if (value != 'row' && profile.$activeRow) {
                        ood(profile.$activeRow).tagClass('-active', false);
                        delete profile.$activeRow;
                    }
                }
            },

            rowOptions: {
                ini: {},
                action: function (value) {
                    var ins = this.boxing(),
                        rows = ins.getRows('data');
                    ins.removeAllRows();
                    ins.insertRows(rows);
                }
            },
            colOptions: {
                ini: {},
                action: function (value) {
                    var ins = this.boxing(),
                        rows = ins.getRows('data');
                    ins.removeAllRows();
                    ins.insertRows(rows);
                }
            },
            treeMode: {
                ini: 'inhandler',
                // compitable: false->'none'; true->inhanlder
                listbox: ['none', 'inhandler', 'infirstcell'],
                action: function (value, ovalue) {
                    if ((ovalue == 'inhandler' && value == 'infirstcell') || (ovalue == 'infirstcell' && value == 'inhandler')) {
                        this.boxing().refresh();
                    } else {
                        this.getSubNodes(['ROWLRULER', 'ROWTOGGLE'], true).css('display', value ? '' : 'none');
                    }
                }
            },
            freezedColumn: {
                ini: 0,
                action: function () {
                    this.boxing().refresh();
                    this.box._adjustColsWidth(this);
                }
            },
            freezedRow: {
                ini: 0,
                action: function () {
                    this.boxing().refresh();
                }
            },
            hotRowMode: {
                ini: 'none',
                listbox: ['none', 'show', 'hide', 'auto'],
                action: function (value) {
                    if (this.renderId) {
                        if (value == 'none')
                            this.boxing().removeHotRow();
                        else
                            this.box.__ensurehotrow(this, null);
                    }
                }
            },
            excelCellId: {
                ini: "",
                action: function () {
                    this.boxing().notifyExcel(false);
                }
            },
            gridValueFormula: "",
            hotRowNumber: '[*]',
            hotRowCellCap: '(*)',
            hotRowRequired: '',
            noCtrlKey: true
        },
        EventHandlers: {
            onBodyLayout: function (profile, trigger) {
            },
            beforeApplyDataset: function (profile, dataset) {
            },
            onScroll: function (profile, colId) {

            },

            beforeCellKeydown: function (profile, cell, keys) {
            },
            afterCellFocused: function (profile, cell, row) {
            },

            beforeInitHotRow: function (profile) {
            },
            onInitHotRow: function (profile, row) {
            },

            beforeHotRowAdded: function (profile, cellMap, row, leaveGrid) {
            },
            afterHotRowAdded: function (profile, row) {
            },

            onGetContent: function (profile, row, callback) {
            },
            onRowSelected: function (profile, row, e, src, type) {
            },
            onCmd: function (profile, row, cmdkey, e, src) {
            },

            beforeFold: function (profile, item) {
            },
            beforeExpand: function (profile, item) {
            },
            afterFold: function (profile, item) {
            },
            afterExpand: function (profile, item) {
            },

            beforeColDrag: function (profile, colId) {
            },
            beforeColMoved: function (profile, colId, toId) {
            },
            afterColMoved: function (profile, colId, toId) {
            },
            beforeColSorted: function (profile, col) {
            },
            afterColSorted: function (profile, col) {
            },

            beforeColShowHide: function (profile, colId, flag) {
            },
            afterColShowHide: function (profile, colId, flag) {
            },
            beforeColResized: function (profile, colId, width) {
            },
            afterColResized: function (profile, colId, width) {
            },
            beforeRowResized: function (profile, rowId, height) {
            },
            afterRowResized: function (profile, rowId, height) {
            },


            swiperight: function (profile, row, e, src) {
            },
            swipeup: function (profile, item, e, src) {
            },
            swipedown: function (profile, item, e, src) {
            },

            beforePrepareRow: function (profile, row, pid) {
            },
            beforePrepareCol: function (profile, col) {
            },

            beforeRowActive: function (profile, row) {
            },
            afterRowActive: function (profile, row) {
            },
            beforeCellActive: function (profile, cell) {
            },
            afterCellActive: function (profile, cell) {
            },

            beforeCellUpdated: function (profile, cell, options, isHotRow) {
            },
            afterCellUpdated: function (profile, cell, options, isHotRow) {
            },
            beforeRowUpdated: function (profile, obj, options, isHotRow) {
            },
            afterRowUpdated: function (profile, obj, options, isHotRow) {
            },

            onRowDirtied: function (profile, row) {
            },

            onRowHover: function (profile, row, hover, e, src) {
            },
            onClickHeader: function (profile, col, e, src) {
            },
            onClickRow: function (profile, row, e, src) {
            },
            onClickRowHandler: function (profile, row, e, src) {
            },
            onDblclickRow: function (profile, row, e, src) {
            },
            onClickCell: function (profile, cell, e, src) {
            },
            onDblclickCell: function (profile, cell, e, src) {
            },
            onClickGridHandler: function (profile, e, src) {
            },

            beforeIniEditor: function (profile, cell, cellNode, pNode, type) {
            },
            onBeginEdit: function (profile, cell, editor, type) {
            },
            beforeEditApply: function (profile, cell, options, editor, tag, type) {
            },
            onEndEdit: function (profile, cell, editor, type) {
            },

            // Editors' default events
            onFileDlgOpen: function (profile, cell, proEditor, src) {
            },
            beforeComboPop: function (profile, cell, proEditor, pos, e, src) {
            },
            beforePopShow: function (profile, cell, proEditor, popCtl, items) {
            },
            afterPopShow: function (profile, cell, proEditor, popCtl) {
            },
            onCommand: function (profile, cell, proEditor, src, type) {
            },
            onEditorClick: function (profile, cell, proEditor, type, src) {
            },
            beforeUnitUpdated: function (profile, cell, proEditor, type) {
            },

            // beforeApplyGridExcelFormula
            // afterApplyGridExcelFormula
            beforeApplyFormula: function (profile, cell, value, formula) {
            },
            afterApplyFormulas: function (profile, dataArrs) {
            },
            beforeGridValueCalculated: function (profile) {
            },
            afterGridValueCalculated: function (profile, value) {
            },

            onGetExcelCellValue: function (profile, excelCellId, dftValue) {
            }
        },
        RenderTrigger: function () {
            var ns = this,
                box = ns.box,
                prop = ns.properties,
                ins = ns.boxing(),
                getPro = box.getCellOption;

            ns.destroyTrigger = function () {
                var ns = this, prop = ns.properties;
                ood.each(ns.cellMap, function (cell) {
                    if (cell._editor) cell._editor.destroy();
                });
                ood.breakO([ns.colMap, ns.rowMap, ns.cellMap], 3);
                prop.header.length = 0;
                prop.rows.length = 0;
                prop.grpCols.length = 0;
            };
            ns.$cache_editor = {};
            if (!prop.initFold)
                ins._toggleRows(prop.rows, true);
            // trigger render
            ood.arr.each(prop.header, function (o) {
                if (ood.isFun(o.colRenderer || prop.colOptions.colRenderer))
                    (o.colRenderer || prop.colOptions.colRenderer).call(null, ns, o);
            });
            // move it manually
            if (prop.treeMode == 'infirstcell') {
                ns.getSubNode('HCELLA', prop.header[0]._serialId).prepend(
                    ns.getSubNode('LTAGCMDS')
                ).prepend(
                    ns.getSubNode('HFMARK')
                );
            }
            ood.arr.each(prop.rows, function (o) {
                if (ood.isFun(o.rowRenderer || prop.rowOptions.rowRenderer))
                    (o.rowRenderer || prop.rowOptions.rowRenderer).call(null, ns, o);
                if (false === getPro(ns, o, "initFold"))
                    ins._toggleRows([o], true);
            });

            ns.box.__ensurehotrow(ns, null);

            ood.each(ns.cellMap, function (o) {
                if (getPro(ns, o, "editable") &&
                    (getPro(ns, o, "editMode") == "inline" || getPro(ns, o, "type") == 'dropbutton'))
                    box._editCell(ns, o);
            });

            if (prop.excelCellId)
                ns.boxing().calculateGridValue();
        },
        LayoutTrigger: function () {
            var ns = this, box = ns.box, prop = ns.properties, ins = ns.boxing();
            if (ood.isArr(prop.grpCols)) {
                ood.arr.each(prop.grpCols, function (o) {
                    if (ood.isFun(o.colRenderer || prop.colOptions.colRenderer))
                        (o.colRenderer || prop.colOptions.colRenderer).call(null, ns, o);
                });
                box._adjustColsHeight(ns);
            }
            ns.box._asy(ns);
            ns.box._adjustBody(ns, 'render');
        },
        _tplMap: {'text': '.text', 'button': '.button', 'image': '.image'},
        _tplMap2: {'textarea': '.textarea', 'checkbox': '.checkbox', 'button': '.button', 'progress': '.progress'},
        _focusEvent: function (profile, e, src) {
            var ins = profile.boxing(),
                prop = profile.properties,
                cell = profile.cellMap[profile.getSubId(src)],
                row;

            profile.box._focuscell(profile, e, src);

            if (profile.afterCellFocused) {
                if (cell)
                    row = cell._row;
                else
                    row = profile.rowMap[profile.getSubId(src)];
                ins.afterCellFocused(profile, cell, row);
            }
            // to check hot row
            if (prop.hotRowMode != 'none') {
                var cell = profile.cellMap[profile.getSubId(src)], row;
                if (cell)
                    row = cell._row;
                else
                    row = profile.rowMap[profile.getSubId(src)];
                if (profile.__hastmpRow && profile.__needchecktmprow && row.id !== profile.box._temprowid)
                    profile.box._checkNewLine(profile, 'focuscell');
            }
        },

        _tagCmdWidth: function (profile) {
            var prop = profile.properties;
            var tagCmdWidth = 0;
            if (prop.tagCmds) {
                ood.arr.each(prop.tagCmds, function (cmd) {
                    if (cmd.tagCmdsAlign && cmd.tagCmdsAlign != 'left') {
                        switch (cmd.buttonType) {
                            case 'button':
                                tagCmdWidth = tagCmdWidth + 2;
                                break;
                            case 'image':
                                tagCmdWidth = tagCmdWidth + 2;
                                break
                            case 'text':
                                tagCmdWidth = tagCmdWidth + cmd.text ? cmd.text.length : 1;
                                break
                        }
                    }
                });
            }
            return tagCmdWidth
        },

        _haderTail: function (profile) {
            var prop = profile.properties;
            var headerTail = "";
            if (!prop.tagCmds) {
                var rtag = false;
                ood.arr.each(prop.tagCmds, function (cmd) {
                    if (cmd.tagCmdsAlign && cmd.tagCmdsAlign != 'left') {
                        var rtag = true;
                    }
                });
                if (rtag) {
                    headerTail = prop.headerTail ? prop.headerTail : "";
                } else {
                    headerTail = "";
                }
            } else {
                headerTail = "";
            }
            return headerTail;
        },
        __ensurehotrow: function (profile, focusColId) {
            var prop = profile.properties,
                box = profile.box,
                need = false;
            if (!box || !profile.renderId || prop.hotRowMode == "none") return;

            if (profile.__hastmpRow) {
                var rows = profile.properties.rows;
                if (rows.length === 0 || rows[rows.length - 1].id != profile.box._temprowid)
                    need = true;
            } else {
                need = true;
            }

            if (need) {
                // add a temp row
                switch (prop.hotRowMode) {
                    case 'auto':
                        if (!prop.rows || prop.rows.length === 0)
                            box._addTempRow(profile, focusColId);
                        break;
                    case 'show':
                        box._addTempRow(profile, focusColId);
                        break;
                }
            }
        },
        _temprowid: '_ r _temp_',
        isHotRow: function (row) {
            return row && (row.id || row) === this._temprowid;
        },
        _addTempRow: function (profile, focusColId) {
            var prop = profile.properties;
            if (prop.readonly || prop.disabled || !prop.header || prop.header.length <= 0)
                return false;

            // clear first, ensure only one
            profile.box._sethotrowoutterblur(profile, true);
            delete profile.__hastmpRow;
            profile.boxing().removeRows([this._temprowid], false);

            if (profile.beforeInitHotRow && false === profile.boxing().beforeInitHotRow(profile))
                return false;

            profile.__needchecktmprow = true;

            var cells = {},
                row = {cells: cells},
                required = (prop.hotRowRequired || "").split(prop.valueSeparator),
                newcell = {caption: prop.hotRowCellCap},
                ins = profile.boxing();
            if (required.length) {
                ood.arr.each(prop.header, function (col, i) {
                    if (ood.arr.indexOf(required, col.id) != -1) {
                        // must hash for mix column
                        cells[col.id] = newcell;
                    } else if (ood.isSet(col.defaultValue)) {
                        cells[col.id] = col.defaultValue;
                    }
                });
            }

            if (profile.onInitHotRow)
                row = ins.onInitHotRow(profile, row) || row;

            if (ood.isArr(row))
                row = {cells: row};
            else if (!ood.isHash(row))
                row = {cells: [row]};

            // gives a special id
            row.id = this._temprowid;
            row.rowNumber = prop.hotRowNumber;
            row.rowClass = profile.getClass('CELLS2', '-hot');

            ins.insertRows([row], null, null, false, false);

            profile.__hastmpRow = true;

            // focus to next cell
            if (focusColId !== null) {
                ins.focusCellbyRowCol(row.id, focusColId || prop.header[0].id);
                profile.box._sethotrowoutterblur(profile);
            }
        },
        _checkNewLine: function (profile, trigger) {
            var prop = profile.properties;
            profile.box._sethotrowoutterblur(profile, true);

            // checked already
            if (!profile.__hastmpRow)
                return;

            delete profile.__needchecktmprow;

            var ins = profile.boxing(),
                rowId = this._temprowid,
                required = prop.hotRowRequired && prop.hotRowRequired.split(prop.valueSeparator),
                // must be map row
                tempRow = ins.getRowbyRowId(rowId, 'map', true),
                result = !!trigger;
            if (!tempRow)
                return;
            if (required && required.length) {
                for (var i = 0, j, cell, l = required.length; i < l; i++) {
                    j = ood.arr.subIndexOf(prop.header, 'id', required[i]);
                    if (j != -1 && !(ood.isHash(cell = tempRow[required[i].split(':')[0]]) ? cell.value : cell)) {
                        result = null;
                        break;
                    }
                }
            }
            var tempRowData = ins.getRowbyRowId(rowId, 'data', true);
            // clear temp data
            delete tempRowData.id;
            delete tempRowData.rowClass;
            delete tempRowData.rowNumber;
            ood.arr.each(tempRowData.cells, function (cell) {
                if (cell.id.indexOf('-c_') == 0) delete cell.id;
                if (cell.caption === prop.hotRowCellCap) delete cell.caption;
            });

            if (profile.beforeHotRowAdded) {
                var result2 = ins.beforeHotRowAdded(profile, tempRow, tempRowData, !trigger);
                if (ood.isDefined(result2))
                    result = result2 === true ? result2 : result2 === false ? result2 : null;
            }

            // do nothing
            if (result === null) {
                if (prop.hotRowMode == 'hide' || prop.hotRowMode == 'auto') {
                    profile.box._sethotrowoutterblur(profile);
                }
                return false;
            }
            // remove the hot row
            else if (result === false) {
                if (prop.hotRowMode == 'hide' || prop.hotRowMode == 'auto') {
                    delete profile.__hastmpRow;
                    ins.removeRows([rowId], false);
                    if (prop.rows.length === 0 && prop.hotRowMode == 'auto')
                        this._addTempRow(profile, null);
                }
                // dont add new hot row
                return false;
            }
            // add a new row
            else if (result === true) {
                delete profile.__hastmpRow;
                ins.removeRows([rowId], false);
                ins.insertRows(tempRowData, null, null, false, true);

                tempRow = prop.rows[prop.rows.length - 1];
                tempRow._dirty = 1;
                if (profile.afterHotRowAdded)
                    ins.afterHotRowAdded(profile, tempRow);
                if (prop.hotRowMode == 'show') {
                    if (!profile.__hastmpRow)
                        this._addTempRow(profile, null);
                }
                return true;
            }
            // focus the invalid cell, and keep this hot row
            else {
                profile.__needchecktmprow = true;
                // if returns cell
                if (ood.isHash(result))
                    ins.focusCell(result);
                // if return cell id
                else
                    ins.focusCell(ins.getCell(result));

                profile.box._sethotrowoutterblur(profile);
                // dont add new hot row
                return false;
            }
        },
        _sethotrowoutterblur: function (profile, clear) {
            var f = function (k) {
                return profile.getSubNode(k).get(0)
            };
            profile.getSubNode('ROWS22').setBlurTrigger(profile.$domId + ':ROWS22', clear ? null : function (pos, e) {
                var node = ood.Event.getSrc(e),
                    trigger = node == f('SCROLL11') || node == f('SCROLL12') || node == f('SCROLL21') || node == f('SCROLL22') ? 'focusin' : 'focusout';
                profile.__tmpRowBlurTrigger = ood.asyRun(function () {
                    // destroyed
                    if (!profile.box) return;
                    profile.box._checkNewLine(profile, trigger);
                });
            }, ood([f('ROWS11'), f('ROWS12'), f('ROWS21'), f('ROWS22')]), null, true);
            if (clear) {
                if (profile.__tmpRowBlurTrigger) {
                    ood.clearTimeout(profile.__tmpRowBlurTrigger);
                    delete profile.__tmpRowBlurTrigger;
                }
            }
        },
        _cacheRows: function (profile) {
            var all1 = profile.getSubNodes('CELLS1', true).get(),
                all2 = profile.getSubNodes('CELLS2', true).get();
            //filter dispaly==none
            ood.filter(all1, function (o) {
                return !!o.clientHeight;
            });
            ood.filter(all2, function (o) {
                return !!o.clientHeight;
            });
            profile.$allrowscache1 = all1;
            profile.$allrowscache2 = all2;
        },
        _asy: function (profile) {
            var prop = profile.properties, b = profile.boxing(), id = profile.$xid;
            if (prop.altRowsBg) ood.resetRun(id + "1", function () {
                if (profile.rowMap) b.setAltRowsBg(true, true)
            });
            if (prop.rowNumbered) ood.resetRun(id + "2", function () {
                if (profile.rowMap) b.setRowNumbered(true, true)
            });
        },
        _setRowHanderW: function (profile, flag) {
            var prop = profile.properties,
                ww = profile._$subMargin || (profile._$subMargin = profile.$px(prop.$subMargin)),
                map = profile.rowMap,
                hcell = profile.getSubNode('FHCELL'),
                n, w;
            if (ood.isFinite(flag) || profile.$isEm(flag) || profile.$isPx(flag))
                w = profile.$forceu(flag);
            else if (flag === true) {
                var ws = [], t;
                profile.getSubNode('FCELLCAPTION', true).each(function (o) {
                    if ((t = o.parentNode).parentNode.offsetHeight > 0 && ood.Dom.getStyle(t, 'overflow') != 'visible')
                        if (n = map[profile.getSubId(o.id)])
                            ws.push(ood([o]).width() + n._layer * ww);
                });
                ws.push(profile.$px(prop._minColW));
                w = profile.$forceu(Math.max.apply(null, ws) + ww * 2);
            } else
                w = profile.$forceu(hcell.width());

            //set width
            if (w) {
                if (profile.$px(w) < profile.$px(prop._minColW)) w = profile.$em(prop._minColW) + 'em';
                if (profile.$px(w) <= 0) return;
                if (prop.rowHandlerWidth != w) {
                    hcell.width(prop.rowHandlerWidth = w);
                    profile.getSubNode('FCELL', true).width(w);
                    profile.getSubNode('GCELL', true).width(w);

                    /*
                    profile.getSubNode('ROWLRULER',true).each(function(o){
                        n=map[profile.getSubId(o.id)];
                        o.style.width=(4 + n._layer*ww)+'px';
                    });
                    */
                    profile.box._adjustColsWidth(profile);
                    profile.box._adjustBody(profile, 'rowhandler');
                }
            }
        },
        _onStartDrag: function (profile, e, src) {
            var row = profile.rowMap[profile.getSubId(src)];
            if (row && row.id == profile.box._temprowid) return false;

            var pos = ood.Event.getPos(e);
            profile.$_ond = src;
            ood.use(src).startDrag(e, {
                dragSource: profile.$xid,
                dragType: 'icon',
                shadowFrom: ood.use(src).parent()._get(0),
                targetLeft: pos.left + 12,
                targetTop: pos.top + 12,
                dragCursor: 'pointer',
                dragDefer: 2,
                dragKey: profile.box.getDragKey(profile, src),
                dragData: profile.box.getDragData(profile, e, src)
            });
            return false;
        },
        _onDropTest: function (profile, e, src, key, data, item) {
            var fid = data && data.domId, tid = src, fp = data && data.profile, t;
            if (tid) {
                var k = profile.getKey(tid),
                    ks = profile.keys,
                    row = profile.rowMap[profile.getSubId(tid)];
                if (k == ks.FCELL && !row.sub)
                    return false;
                if (profile.properties.rowHandler) {
                    if (k == ks.CELLS2 || k == ks.SCROLL22) return false;
                } else {
                    if (k == ks.CELLS1 || k == ks.SCROLL21) return false;
                }
            }
            if (fp && fp.$xid == profile.$xid) {
                if (fid && profile.getSubId(fid) == profile.getSubId(tid))
                    return false;
                t = profile.$_ond;

                src = ood(src).get(0);
                if (ood.get(src, ['parentNode', 'previousSibling']) == t) return false;
                do {
                    if (src == t) {
                        src = t = null;
                        return false;
                    }
                } while (src && (src = src.parentNode) && src !== document && src !== window);
                src = t = null;
            }
        },
        _onDragstop: function (profile, e, src, key, data, item) {
            delete profile.$_ond;
        },
        _onDrop: function (profile, e, src, key, data, item) {
            if (!data.profile || !data.profile[profile.KEY]) return;
            var k = profile.getKey(src),
                po = data.profile,
                ps = data.domId,
                oitem,
                ks = profile.keys,
                t = ood.absObj.$specialChars,
                b = profile.boxing(),
                arr = ood.copy(b.getUIValue(true)),
                orow = po.rowMap[po.getSubId(ps)],
                row = profile.rowMap[profile.getSubId(src)];

            //remove
            orow = ood.clone(orow, function (o, i) {
                return !t[(i + '').charAt(0)]
            });
            po.boxing().removeRows([orow.id]);

            //add
            if (k == ks.SCROLL21 || k == ks.SCROLL22)
                b.insertRows([orow], null, null, false);
            else if ((k == ks.FCELL) && row.sub)
                b.insertRows([orow], row.id, null, false);
            else if (k == ks.CELLS1 || k == ks.CELLS2)
                b.insertRows([orow], row._pid, row.id, true);

            if (arr && arr.length) {
                if (ood.arr.indexOf(arr, orow.id) != -1) {
                    b.setUIValue(arr, true, null, 'drop');
                }
            }
            data._new = orow;
            return false;
        },

        _beforeSerialized: function (profile) {
            var o = arguments.callee.upper.call(this, profile),
                pp = profile.properties,
                map = ood.absObj.$specialChars,
                op = o.properties,
                us = ood.$us(profile),
                unit = us == 2 ? 'em' : us == -2 ? 'px' : null,
                t;
            op.header = ood.clone(pp.header, function (o, i, d, h) {
                if (d === 2 && i === 'width' && o && o != 'auto') {
                    h[i] = profile.$forceu(o, unit);
                    return false;
                } else
                    return !map[((d === 1 ? o.id : i) + '').charAt(0)] && o != undefined
            });
            op.grpCols = ood.clone(pp.grpCols, function (o, i, d) {
                if (d === 2 && i === 'width' && o && o != 'auto') {
                    h[i] = profile.$forceu(o, unit);
                    return false;
                } else
                    return !map[((d === 1 ? o.id : i) + '').charAt(0)] && o != undefined
            });
            op.rows = ood.clone(pp.rows, function (o, i, d) {
                if (d === 2 && i === 'height' && o && o != 'auto') {
                    h[i] = profile.$forceu(o, unit);
                    return false;
                } else
                    return !map[((d === 1 ? o.id : i) + '').charAt(0)] && o != undefined && ((i == "id" && typeof(o) == "string") ? o.charAt(0) != "-" : true);
            });
            if (ood.isEmpty(op.header)) delete op.header;
            if (ood.isEmpty(op.grpCols)) delete op.grpCols;
            if (ood.isEmpty(op.rows)) delete op.rows;

            delete op.activeRow;
            delete op.activeCell;
            delete op.rawData;
            delete op.dataset;
            return o;
        },
        _clsCache: {},

        _colDragCheck: function (profile, src) {
            var p = profile.properties,
                dd = ood.DragDrop.getProfile(), key = dd.dragKey, data = dd.dragData,
                col = profile.colMap[profile.getSubId(src)];
            if (!col || col._isgroup) return false;
            if (p.treeMode == 'infirstcell' && p.header[0] == col) return false;
            if (!(col.hasOwnProperty('colMovable') ? col.colMovable : profile.properties.colMovable)) return false;
            if (!key || !data || key != (profile.$xid + ":col")) return false;
            if (data == ood.use(src).id() || data == ood.use(src).prev().id()) return false;
        },
        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile),
                NONE = 'display:none',
                prop = profile.properties;

            // init row/cell cache
            profile.rowMap2 = {};
            profile.rowMap = {};
            profile.cellMap = {};

            data.showHeader = prop.showHeader ? '' : NONE;
            data.colDDDisplay = prop.colResizer ? '' : NONE;
            data.rowDDDisplay = prop.rowResizer ? '' : NONE;
            data.rowHandlerDisplay = prop.rowHandler ? '' : NONE;
            data.sortDisplay = NONE;
            data._rowMarkDisplay = (prop.selMode == "multi" || prop.selMode == "multibycheckbox") ? "" : "display:none;";

            if (!prop.header || !ood.isArr(prop.header))
                prop.header = [];
            if (!prop.grpCols || !ood.isArr(prop.grpCols))
                prop.grpCols = [];
            if (!prop.rows || !ood.isArr(prop.rows))
                prop.rows = [];
            data.tagCmdWidth = this._tagCmdWidth(profile);
            data.haderTail = this._haderTail(profile);
            prop.header = this._adjustHeader(prop.header);
            data.header = this._prepareHeader(profile, prop.header);
            // for triggerring render
            data.header1 = data.header2 = data.header;
            prop.grpCols = this._adjustGrpColsData(profile, prop.grpCols);
            data.grpCols = this._prepareGrpCols(profile, prop.grpCols, data.header);
            // for triggerring render
            data.grpCols1 = data.grpCols2 = data.grpCols;
            data._row0DfW = data.rowHandlerWidth ? ('width:' + profile.$forceu(data.rowHandlerWidth)) : '';

            // make sure its' size
            if (profile.$isEm(prop.headerHeight)) data.headerHeight = profile.$forceu(profile.$px(prop.headerHeight, 0, true), 'em');
            if (profile.$isEm(prop.rowHeight)) data.rowHeight = profile.$forceu(profile.$px(prop.rowHeight, 0, true), 'em');
            if (profile.$isEm(prop.rowHandlerWidth)) data.headerHeight = profile.$forceu(profile.$px(prop.rowHandlerWidth, 0, true), 'em');

            arguments.callee.upper.call(this, profile);

            prop.rows = this._adjustRows(profile, prop.rows);
            data.rows11 = data.rows12 = data.rows21 = data.rows22 = this._prepareItems(profile, prop.rows);

            data.tagCmds = ood.clone(prop.colOptions.tagCmds || data.tagCmds);
            if (data.tagCmds) {
                this._prepareCmds(profile, data, function (item) {
                    var pos = item.pos || item.tag;
                    return !pos || pos != "row";
                });
            }
            data._columnfreezed = prop.freezedColumn ? 'ood-ui-shadow-r ood-uiborder-r ood-uiborder-dark' : '';
            data._rowfreezed = prop.freezedRow ? 'ood-ui-shadow-b ood-uiborder-b ood-uiborder-dark' : '';

            return data;
        },
        _parepareCol: function (profile, col, cols, index) {
            // build header
            var SubID = ood.UI.$tag_subId,
                prop = profile.properties,
                headerHeight = profile.$px(prop.headerHeight),
                borderH = profile.getRoot().contentBox() ? 2 : 0,
                NONE = 'display:none', iid,
                ii = 1, tt,
                oid, uicol;


            if (!ood.isHash(col)) {
                oid = col + "";
                col = {id: oid};
            } else {
                oid = col.id + "";
            }

            // links
            col._cells = {};
            iid = profile.pickSubId('header');
            col[SubID] = '-h_' + iid;

            col.id = col.id || iid;
            while ((tt = ood.arr.subIndexOf(cols, "id", col.id)) != -1 && tt !== index) {
                col.id = iid + (ii++);
            }

            profile.colMap[col[SubID]] = col;

            var _ww = profile.$px(col.width) || profile.$px(prop._colDfWidth);
            if ('relWidth' in col) {
                col.flexSize = col.relWidth;
                delete col.relWidth;
            }
            // width
            if (!col.flexSize) {
                if (col.hasOwnProperty('minWidth')) _ww = Math.max(_ww, profile.$px(col.minWidth));
                if (col.hasOwnProperty('maxWidth')) _ww = Math.min(_ww, profile.$px(col.minWidth));
            }

            col.width = col._cellWidth = col._colWidth = profile.$forceu(_ww);
            col._hcellheight = profile.$forceu(headerHeight - borderH);

            uicol = {
                sortDisplay: NONE,
                rowHandlerDisplay: prop.rowHandler ? '' : NONE
            };
            uicol[SubID] = col[SubID];
            uicol._tabindex = prop.tabindex;
            uicol.colDDDisplay = (('colResizer' in col) ? col.colResizer : prop.colResizer) ? '' : NONE;

            //if(col.flexSize)uicol.colDDDisplay = NONE;

            //  Forward-compatible with 'visibility'
            if (col.hasOwnProperty('visibility') && !col.hasOwnProperty('hidden'))
                col.hidden = !col.visibility;

            uicol.colDisplay = col.hidden === true ? NONE : '';

            uicol.firstCellStyle = prop.colOptions.firstCellStyle || '';
            uicol.firstCellClass = prop.colOptions.firstCellClass || '';

            if (!col.type) col.type = prop.colOptions.type || 'input';
            if (!(('caption' in col) && ood.isDefined(col.caption))) col.caption = oid;
            ood.UI.adjustData(profile, col, uicol, 'sub');

            // id to dom item id
            profile.colMap2[col.id] = col[SubID];

            return [col, uicol];
        },
        _prepareCell: function (profile, cell, row, col, temp, _row, index) {
            // build header
            var ns = this,
                SubID = ood.UI.$tag_subId,
                prop = profile.properties,
                NONE = 'display:none',
                uicell = {};
            cell = ood.isSet(cell) ? ood.isHash(cell) ? cell : {value: cell} : {};
            //cell/cell link to row
            cell._row = row;
            //cell/cell link to header
            cell._col = col;
            //_serialId
            cell[SubID] = '-c_' + profile.pickSubId('cell');
            // give id
            cell.id = cell.id || cell[SubID];
            // adjust
            ns._adjustCell(profile, cell, uicell);
            // cell only link its' dom item id to properties item
            profile.cellMap[uicell[SubID]] = cell;
            if (temp) temp.push(cell);
            // row link to cell/cell
            row._cells[col.id] = uicell[SubID];
            // header link to cell/cell
            col._cells[row.id] = uicell[SubID];

            // for _first_cell
            if (prop.treeMode == 'infirstcell' && index === 0 && _row) {
                uicell._treeMode = _row._treeMode;
                uicell._rulerW = _row._rulerW;
                uicell._fi_togglemark = _row._fi_togglemark;
                uicell._rowMarkDisplay = _row._rowMarkDisplay;
                uicell._rowNumbDisplay = _row._rowNumbDisplay;
                uicell._ltagDisplay = _row._ltagDisplay;
                uicell.ltagCmds = _row.ltagCmds;
                uicell[ood.UI.$tag_subId_c] = _row[ood.UI.$tag_subId];
            }

            return [cell, uicell];
        },
        _prepareGrpCols: function (profile, arr, _header) {
            var prop = profile.properties;
            if (prop.showHeader && arr && ood.isArr(arr) && arr.length) {
                var header = prop.header,
                    headerHeight = profile.$px(prop.headerHeight),
                    borderH = profile.getRoot().contentBox() ? 2 : 0,
                    SubID = ood.UI.$tag_subId,
                    NONE = 'display:none',
                    _ngrp = [],
                    _grp, w, h, _left, _ww,

                    layer = profile._headerLayers,
                    h = headerHeight / (layer + 1),
                    flag = false;

                for (var j = 0, m = arr.length, grp; j < m; j++) {
                    _grp = {};
                    w = 0;
                    flag = false;
                    _left = 0;//prop.rowHandler?(profile.$px(prop.rowHandlerWidth)+borderH):0;

                    grp = arr[j];
                    ood.UI.adjustData(profile, grp, _grp, 'sub');
                    for (var k = 0, o; k <= grp['to']; k++) {
                        o = header[k];
                        p = _header[k];
                        _ww = profile.$px(p._colWidth);
                        if (k === grp.from) {
                            flag = true;
                            _grp._hcellleft = profile.$forceu(_left);
                        }
                        _left += _ww + borderH;
                        if (flag && !o.hidden) {
                            w += _ww + borderH;
                        }
                    }
                    _grp._colWidth = _grp._cellWidth = profile.$forceu(w - borderH);

                    _grp._hcellheight = profile.$forceu(h - borderH);
                    _grp._hcelltop = profile.$forceu(h * (grp._layer - 1));

                    _grp._tabindex = prop.tabindex;
                    _grp.colDDDisplay = (('colResizer' in grp) ? grp.colResizer : prop.colResizer) ? '' : NONE;

                    _ngrp.push(_grp)
                }

                // adjust base columns' height
                for (var k = 0, n = header.length, o, p; k < n; k++) {
                    o = header[k];
                    p = _header[k];
                    if (o._grp && o._grp.length) {
                        p._hcellheight = profile.$forceu(headerHeight - o._grp.length * h - borderH);
                    }
                }
                return _ngrp;
            }
        },
        _prepareHeader: function (profile, arr) {
            var header = [], colResult, prop = profile.properties;

            // init cols cache
            profile.colMap2 = {};
            profile.colMap = {};


            ood.arr.each(arr, function (o, i) {
                if (profile.beforePrepareCol && false === profile.boxing().beforePrepareCol(profile, o)) {
                    return;
                }
                colResult = profile.box._parepareCol(profile, o, arr, i);
                arr[i] = colResult[0];
                header.push(colResult[1]);
            });

            return header;
        },
        // to set uicell, or set dom node directly
        // uicell and node are not occur at the same time
        _renderCell: function (profile, cell, uicell, node, options) {
            var cellType, defalutTypes = [
                'input', 'password', 'combobox', 'checkbox', 'listbox', 'file', 'getter', 'helpinput', 'button',
                'dropbutton', 'cmdbox', 'cmd', 'popbox', 'textarea', 'label', 'date', 'profile', 'image',
                'text', 'time', 'datetime', 'color', 'spin', 'counter', 'currency', 'number', 'split'
            ];
            if (cell._col && cell._col.type) {
                cellType = cell._col.type;
            }
            var getPro = profile.box.getCellOption,
                type = getPro(profile, cell, 'type');
            if (ood.arr.indexOf(defalutTypes, type) == -1) {
                type = cellType;
            }


            var t1 = '',
                t2 = '',
                caption,
                cellanode = node,
                capOut = uicell && ood.isStr(uicell._caption) ? uicell._caption : uicell && ood.isStr(cell.caption) ? uicell.caption : ood.isStr(cell.caption) ? cell.caption : null,
                reg1 = /</g,
                dcls = 'ood-uicell-disabled',
                rcls = 'ood-ui-readonly',
                ren = function (profile, cell, uicell, fun, o) {
                    return (
                        // 1 renderer in cell
                        (o = cell.renderer || cell._renderer) ? ood.UI._applyRenderer(profile, o, cell, uicell) :
                            // typeof (cell.renderer||cell._renderer)=='function'? (cell.renderer||cell._renderer).call(profile,cell) :
                            // 2 template in cell
                            (uicell && typeof uicell.caption == 'string') ? uicell.caption :
                                // 3 default caption function
                                typeof fun == 'function' ? fun(cell.value, profile, cell) :
                                    // 4 value in cell
                                    (ood.isSet(cell.value) ? ("" + cell.value) :
                                        // 5 empty
                                        "")
                        // default value
                    ) || ""
                },
                f0 = function (v, profile, cell) {
                    return v ? ood.Date.getText(v, getPro(profile, cell, 'dateEditorTpl') || 'ymdhn') : "";
                },
                f1 = function (v, profile, cell) {
                    return v ? ood.Date.getText(v, getPro(profile, cell, 'dateEditorTpl') || 'ymd') : "";
                },
                f2 = function (v) {
                    return v ? (v + '').replace(reg1, '&lt;').replace(/\t/g, '    ')/*.replace(/ /g,' ')*/.replace(/(\r\n|\n|\r)/g, "<br />") : ""
                },
                f3 = function (v) {
                    return (v || v === 0) ? ((v * 100).toFixed(2) + '%') : ""
                },
                f4 = function (v, profile, cell) {
                    if (v || v === 0) {
                        return ood.formatNumeric(
                            parseFloat(v),
                            getPro(profile, cell, 'precision'),
                            getPro(profile, cell, 'groupingSeparator'),
                            getPro(profile, cell, 'decimalSeparator'),
                            getPro(profile, cell, 'forceFillZero'),
                            getPro(profile, cell, 'trimTailZero')
                        );
                    } else
                        return "";
                },
                f5 = function (v, profile, cell) {
                    if (v || v === 0) {
                        var precision = getPro(profile, cell, 'precision');
                        return ood.formatNumeric(
                            parseFloat(v),
                            // currency default precision is 2
                            ood.isSet(precision) ? precision : 2,
                            getPro(profile, cell, 'groupingSeparator'),
                            getPro(profile, cell, 'decimalSeparator'),
                            getPro(profile, cell, 'forceFillZero'),
                            getPro(profile, cell, 'trimTailZero')
                        );
                    } else
                        return "";
                },
                f6 = function (v, profile, cell) {
                    var t = getPro(profile, cell, 'editorListItems');
                    if (!t)
                        if (t = getPro(profile, cell, 'editorListKey'))
                            t = ood.UI.getCachedData(typeof(t) == "function" ? t() : t);
                    if ((typeof(t) == "function" ? (t = t()) : t) && t.length)
                        for (var i = 0, l = t.length; i < l; i++)
                            if (t[i].id === v)
                                return t[i].caption || v;
                    return f7(v, profile, cell);
                },
                f7 = function (v, profile, cell) {
                    if (v) {
                        v = v + "";
                        var t = v.indexOf('=');
                        if (t != -1) {
                            cell.value = v.substr(0, t);
                            return v.substr(t + 1);
                        }
                    }
                    return v;
                },
                unit = function (caption, cell) {
                    return caption + (cell.unit ? " " + cell.unit : "")
                };
            // get caption node
            if (node && node.get(0)) node = node.last();
            switch (type) {
                //  case 'number':
                //   case 'spin':
                case 'counter':
                    var v = parseFloat(cell.value);
                    cell.value = (v || v === 0) ? v : null;
                    caption = unit(capOut || ren(profile, cell, uicell, f4), cell);
                    var tpl = getPro(profile, cell, 'numberTpl');
                    if (tpl && caption)
                        caption = tpl.replace("*", caption);
                    if (node)
                        node.html(caption, false);
                    break;
                case 'currency':
                    var v = parseFloat((cell.value + "").replace(/[^\d.-]/g, ''));
                    cell.value = (v || v === 0) ? v : null;
                    //  Note that cell value has true numeric value, while caption has currency format with commas.
                    caption = unit(capOut || ren(profile, cell, uicell, f5), cell);
                    var tpl = getPro(profile, cell, 'currencyTpl');
                    if (tpl && caption !== "")
                        caption = tpl.replace("*", caption);
                    if (node)
                        node.html(caption, false);
                    break;
                case 'date':
                    cell.value = ood.isDate(cell.value) ? cell.value : ood.isFinite(cell.value) ? new Date(parseInt(cell.value, 10)) : ood.Date.parse(cell.value);
                    caption = unit(capOut || ren(profile, cell, uicell, f1), cell);
                    if (node)
                        node.html(caption, false);
                    break;
                case 'datetime':
                    cell.value = ood.isDate(cell.value) ? cell.value : ood.isFinite(cell.value) ? new Date(parseInt(cell.value, 10)) : ood.Date.parse(cell.value);
                    caption = unit(capOut || ren(profile, cell, uicell, f0), cell);
                    if (node)
                        node.html(caption, false);
                    break;
                case 'input':
                    cell.value = cell.value || "";
                    caption = unit(capOut || ren(profile, cell, uicell), cell);
                    if (node) node.html(caption, false);
                    break;
                case 'textarea':
                    cell.value = cell.value || "";
                    caption = unit(capOut || ren(profile, cell, uicell, f2), cell);
                    if (node) node.html(caption, false);
                    break;
                case 'color':
                    var c = ood.UI.ColorPicker._ensureValue(0, cell.value);
                    cell.value = cell.value ? ((c !== "transparent" ? '#' : '') + c) : "";
                    caption = unit(capOut || ren(profile, cell, uicell), cell);
                    if (cell.value) {
                        t1 = ood.UI.ColorPicker.getTextColor(cell.value);
                        if (node) {
                            node.html(caption, false);
                            node.css('color', t1);
                            node.parent().css('backgroundColor', cell.value);
                        } else {
                            uicell.color = 'color:' + t1 + ';';
                            uicell.bgcolor = 'background-color:' + cell.value + ';';
                        }
                    } else {
                        if (node) {
                            node.html(caption, false);
                            node.css('color', '');
                            node.parent().css('backgroundColor', '');
                        } else {
                            //uicell.color='color:#000;';
                            //uicell.bgcolor='background-color:#fff;';
                        }
                    }
                    break;
                case 'checkbox':
                    cell.value = cell.value === "0" ? false : !!cell.value;
                    caption = unit(cell.value + '', cell);
                    if (node)
                        node.tagClass('-checked', cell.value);
                    else {
                        uicell._fi_checkboxCls = cell.value ? 'oodfont-checked ood-uicmd-check-checked' : '';
                    }
                    break;
                case 'progress':
                    cell.value = parseFloat(cell.value) || 0;
                    cell.value = Math.min(Math.max(cell.value, 0), 1);
                    caption = unit(capOut || ren(profile, cell, uicell, f3), cell);
                    if (node) {
                        node.first().html(caption, false);
                        node.width(caption);
                    } else
                        uicell.progress = caption;
                    break;
                case 'listbox':
                    cell.value = cell.hasOwnProperty("value") ? cell.value : "";
                    caption = ood.adjustRes(unit(capOut || ren(profile, cell, uicell, f6), cell));
                    if (node) node.html((caption === null || caption === undefined) ? cell.value : caption, false);
                    break;
                case 'dropbox':
                case 'cmdbox':
                    cell.value = cell.hasOwnProperty("value") ? cell.value : "";
                    caption = ood.adjustRes(unit(capOut || ren(profile, cell, uicell, f7), cell));
                    if (node) node.html((caption === null || caption === undefined) ? cell.value : caption, false);
                    break;
                default:
                    cell.value = cell.hasOwnProperty("value") ? cell.value : "";
                    caption = ood.adjustRes(unit(capOut || ren(profile, cell, uicell), cell));
                    if (node) node.html((caption === null || caption === undefined) ? cell.value : caption, false);
            }

            if ('_renderer' in cell) delete cell._renderer;
            cell._caption = cell._$tips = cell._$tmpcap = caption;

            var t2 = getPro(profile, cell, 'disabled'),
                t3 = getPro(profile, cell, 'readonly');
            if (uicell) {
                /*
                    colRenderer
                    rowRenderer

                    cellStyle
                    cellClass
                    cellRenderer

                    renderer
                    type
                    disabled
                    readonly
                    increment
                    min
                    max
                    maxlength
                    precision
                    dateEditorTpl
                    editable
                    value
                    caption
                    sortby [for column only]

                    customEditor -> an object for custom editor. or the below prop

                    editorListKey
                    editorListItems
                    editorFormat
                    editorMask
                    editorReadonly
                    editorDropListWidth
                    editorDropListHeight
                    editorProperties
                    editorCC
                    editorCS
                    editorEvents
                */
                uicell.cellCls = profile.getClass('CELL', '-' + type) + (t2 ? (' ' + dcls) : '') + (t3 ? (' ' + rcls) : '');
                uicell.type = type;
                uicell.value = cell.value;
                uicell._caption = caption;
                uicell.cellStyle = getPro(profile, cell, 'cellStyle');
                uicell.cellClass = getPro(profile, cell, 'cellClass');
            } else {
                if (t2) cellanode.parent().addClass(dcls);
                else cellanode.parent().removeClass(dcls);
                if (t3) cellanode.parent().addClass(rcls);
                else cellanode.parent().removeClass(rcls);

                if (t2 = options.cellStyle)
                    cellanode.attr('style', cellanode.attr('style') + ";" + t2);
                if (t2 = options.cellUnclass)
                    cellanode.removeClass(t2);
                if (t2 = options.cellClass)
                    cellanode.addClass(t2);
            }
            return cell;
        },
        _applyRendererEx: function (profile, prop, events, cell, adjustRenderer, t) {
            // for cell only
            if (cell) {
                if (t = cell._col) {
                    adjustRenderer(t, prop, events);
                    adjustRenderer(t.tagVar, prop, events);
                }
                if (t = cell._row) {
                    adjustRenderer(t, prop, events);
                    adjustRenderer(t.tagVar, prop, events);
                }
            }
        },
        _prepareItems: function (profile, arr, pid, temparr) {
            var self = this,
                prop = profile.properties,
                _treemode = prop.treeMode,
                mm = profile._$subMargin || (profile._$subMargin = profile.$px(prop.$subMargin)),
                a = profile.rowMap2,
                b = profile.rowMap,
                _layer = pid ? b[pid] ? (b[pid]._layer + 1) : 0 : 0,
                SubID = ood.UI.$tag_subId,
                ider = profile._id || (profile._id = new ood.id()),
                rows = [],
                temp, cells, t, row, v, cellResult,
                ro = prop.rowOptions,
                itemFilter = profile.$itemFilter,
                NONE = 'display:none';

            _treemode = !(!_treemode || _treemode == "none");


            if (itemFilter) itemFilter('begin', 'prepareItem', profile);
            for (var i = 0, l = arr.length; i < l; i++) {
                row = arr[i];
                // give id (avoid conflicts)
                if (!row.id || a[row.id]) {
                    while (a[t = ider.next()]) ;
                    row.id = "-" + t;
                } else {
                    row.id += "";
                }
                if (profile.beforePrepareRow && false === profile.boxing().beforePrepareRow(profile, row, pid, temparr)) {
                    continue;
                }

                // give _serialId
                temp = '-r_' + profile.pickSubId('row');
                row[SubID] = temp;
                b[temp] = row;

                //#
                row._pid = pid;
                row._cells = {};
                row._layer = _layer;

                row._tabindex = prop.tabindex;
                row._rowMarkDisplay = (prop.selMode == "multi" || prop.selMode == "multibycheckbox") ? "" : NONE;

                row._treeMode = _treemode ? '' : NONE;

                row._rowNumbDisplay = prop.rowNumbered ? '' : NONE;
                t = {id: row.id};

                t.rowCls = "";
                if (row.disabled)
                    t.rowCls += ' ood-uicell-disabled';
                if (row.readonly)
                    t.rowCls += ' ood-ui-readonly';
                if (row.group) {
                    t.group = 1;
                    t.rowCls += ' ' + profile.getClass('CELLS1', '-group') + " ood-uiborder-r ood-uiborder-light";
                }
                // filter: hidden
                if (itemFilter) row.hidden = !!itemFilter(row, 'prepareItem', profile);

                if (row.hidden)
                    t.rowDisplay = NONE;

                t._row0DfW = prop.rowHandlerWidth ? ('width:' + profile.$forceu(prop.rowHandlerWidth)) : '';
                t._rulerW = 'width:' + (row.rulerWidth || profile.$forceu(4 + _layer * mm));

                // use em for row Height
                t._rowHeight = profile.$forceu(row._rowHeight || row.height || prop.rowHeight, 'em');
                row._rowHeight = t._rowHeight;
                t._rowHeight = "height:" + t._rowHeight;

                t.rowHandlerDisplay = prop.rowHandler ? '' : NONE;
                t.rowDDDisplay = (('rowResizer' in row) ? row.rowResizer : prop.rowResizer) ? '' : NONE;

                t.firstCellStyle = row.firstCellStyle || ro.firstCellStyle || '';
                t.firstCellClass = row.firstCellClass || ro.firstCellClass || '';

                cells = t.cells = [];

                t[SubID] = temp;
                //   t._fi_togglemark = row.sub?'ood-uicmd-toggle':(row._layer?'ood-uicmd-empty':'');
                // t._fi_togglemark = row.sub?'ood-uicmd-toggle':'';
                t._fi_togglemark = row.sub ? ('ood-uicmd-toggle' + (row._checked ? " oodfont-checked ood-uicmd-toggle-checked" : "")) : (prop.togglePlaceholder ? 'ood-icon-placeholder' : 'ood-uicmd-none');

                // id to dom item id
                a[row.id] = temp;

                if (!row.hasOwnProperty('caption') && row.hasOwnProperty('value'))
                    row.caption = '' + row.value;

                row._oValue = row.value;

                if (row.caption && !row.tips)
                    row._$tips = row.caption;

                ood.UI.adjustData(profile, row, t, 'sub');

                t.tagCmds = ood.clone(t.tagCmds || ro.tagCmds || prop.tagCmds);


                if (t.tagCmds) {

                    this._prepareCmds(profile, t, function (item) {
                        var pos = item.pos || item.tag;
                        return !pos || !(pos == 'header' || pos == 'header row' || pos == 'all');
                    });
                }


                // for cells
                if (row.group)
                    row.cells = null;
                if ((v = row.cells)) {
                    ood.arr.each(prop.header, function (col, j) {
                        cellResult = profile.box._prepareCell(profile, v[j], row, col, temparr, t, j);
                        v[j] = cellResult[0];
                        cells.push(cellResult[1]);
                    });
                }

                var hash = {};
                ood.merge(hash, t, function (o, i) {
                    return ood.isNumb(o) || ood.isStr(o) || i == 'ltagCmds';
                });
                hash[ood.UI.$tag_subId_c] = t[ood.UI.$tag_subId];
                t._handler_cell = ood.clone(hash);

                if (prop.treeMode == 'infirstcell') {
                    if (row.group)
                        t._firstcell_grp = ood.clone(hash);

                    t._rulerW = t._fi_togglemark = '';
                    t._treeMode = t.tMarkDisplay = t.tNumbDisplay = t._ltagDisplay = NONE;
                    t.ltagCmds = null;
                }
                rows.push(t);
            }
            if (itemFilter) itemFilter('end', 'prepareItem', profile);
            return rows;
        },
        _adjustCell: function (profile, cell, uicell) {
            var self = this,
                prop = profile.properties,
                col = cell._col,
                renderer = self.getCellOption(profile, cell, 'cellRenderer') || prop.renderer,
                cellCapTpl = self.getCellOption(profile, cell, 'cellCapTpl');

            // allow to set caption dynamically
            if (cellCapTpl)
                cell._caption = cellCapTpl;
            ood.UI.adjustData(profile, cell, uicell, 'sub');

            if (renderer)
                cell._renderer = renderer;
            if (!uicell._cellWidth)
                uicell._cellWidth = col._colWidth;

            uicell._tabindex = prop.tabindex;
            uicell.cellDisplay = col.hidden === true ? 'display:none;' : '';

            self._renderCell(profile, cell, uicell);

            //next
            cell._oValue = cell.value;
            if ('unit' in cell) cell._oUnit = cell.unit;
        },
        _setSub: function (profile, item, flag, recursive, stopanim, cb) {
            var id = profile.domId,
                ins = profile.boxing(),
                prop = profile.properties,
                itemId = profile.rowMap2[item.id],
                markNode = profile.box._getToggleNode(profile, itemId),
                subNs = profile.getSubNodes(['SUB1', 'SUB2'], itemId),

                subNs1 = ood(subNs.get(0)),
                subNs2 = ood(subNs.get(1));

            if (ood.Thread.isAlive(profile.key + profile.id)) return;
            //close
            if (!flag) {
                if (item._checked) {
                    if (ins.beforeFold && false === ins.beforeFold(profile, item)) {
                        return;
                    }
                    var onend = function () {
                        subNs.css({display: 'none', height: 0, overflow: ''});
                        markNode.tagClass('-checked', false);
                        item._checked = false;

                        if (prop.dynDestory || item.dynDestory) {
                            var s = item.sub, arr = [];
                            for (var i = 0, l = s.length; i < l; i++)
                                arr.push(s[i].id);
                            profile.boxing().removeRows(arr);
                            item.sub = true;
                            delete item._inited;
                        }
                        if (ins.afterFold)
                            ins.afterFold(profile, item);

                        ood.resetRun(id, function (cb) {
                            profile.box._asy(profile);
                            //clear rows cache
                            delete profile.$allrowscache1;
                            delete profile.$allrowscache2;
                            profile.box._adjustBody(profile, 'foldrow');
                            if (cb) ood.tryF(cb, [profile, item], ins);
                        }, 0, [cb]);
                    };
                    if (!stopanim) {
                        if (prop.animCollapse) {
                            subNs.css('overflow', 'hidden');
                            subNs.animate({'height': [subNs2.height(), 0]}, null, onend, 200, null, 'expoOut', profile.key + profile.id).start();
                        } else onend();
                    } else onend();
                }
                if (recursive && item.sub && !prop.dynDestory && !item.dynDestory) {
                    ood.arr.each(item.sub, function (o) {
                        if (o.sub && o.sub.length)
                            profile.box._setSub(profile, o, flag, recursive, true, cb);
                    });
                }
            } else {
                //open
                if (!item._checked) {
                    if (ins.beforeExpand && false === ins.beforeExpand(profile, item)) {
                        return;
                    }
                    var onend = function (empty, t) {
                            //markNode.css('background','');
                            // compitable with IE<8
                            if (ood.browser.ie && ood.browser.ver <= 8) {
                                markNode.css({
                                    backgroundImage: '',
                                    backgroundRepeat: '',
                                    backgroundPositionX: '',
                                    backgroundPositionY: '',
                                    backgroundColor: '',
                                    backgroundAttachment: ''
                                });
                            } else {
                                markNode.removeClass('ood-icon-loading');
                            }
                            if (!empty) {
                                item._checked = true;
                                if (ins.afterExpand)
                                    ins.afterExpand(profile, item);
                            }
                            subNs.css({display: '', height: 'auto', overflow: ''});
                            if ((prop.freezedRow || prop.rowHandler) && !subNs1.height() && (t = subNs2.height()))
                                subNs1.height(t);

                            ood.resetRun(id, function (cb) {
                                profile.box._asy(profile);
                                //clear rows cache
                                delete profile.$allrowscache1;
                                delete profile.$allrowscache2;
                                profile.box._adjustBody(profile, 'expandrow');
                                if (cb) ood.tryF(cb, [profile, item], ins);
                            }, 0, [cb]);
                        },
                        openSub = function (profile, item, id, markNode, subNs1, subNs2, subNs, sub) {
                            var b = profile.boxing(),
                                p = profile.properties,
                                empty = sub === false;
                            //created
                            if (!empty && !item._inited) {
                                delete item.sub;
                                //before insertRows
                                item._inited = true;
                                if (sub) {
                                    if (typeof sub == 'string') {
                                        subNs2.html(item.sub = sub, false);
                                        // right-bottom border
                                        subNs.addClass('ood-uiborder-r ood-uiborder-b ood-uiborder-light');
                                    } else if (sub['ood.Template'] || sub['ood.UI']) {
                                        subNs2.append(item.sub = sub.render(true));
                                        // right-bottom border
                                        subNs.addClass('ood-uiborder-r ood-uiborder-b ood-uiborder-light');
                                    } else if (ood.isArr(sub)) {
                                        b.insertRows(sub, item.id);
                                        // for []
                                        if (!item.sub) item.sub = sub;
                                    }
                                    var s = 0, arr = b.getUIValue(true);
                                    if (arr && arr.length) {
                                        ood.arr.each(sub, function (o) {
                                            if (ood.arr.indexOf(arr, o.id || o) != -1) {
                                                s = 1;
                                                return false;
                                            }
                                        });
                                        if (s) {
                                            //set checked items
                                            b._setCtrlValue(b.getUIValue());
                                        }
                                    }
                                }
                            }

                            if (!empty) {
                                markNode.tagClass('-checked');
                            }

                            if (!stopanim) {
                                subNs.css("height", "0px").css("display", '');

                                if (p.animCollapse) {
                                    var h = 0;
                                    subNs2.children().each(function (o) {
                                        h += o.offsetHeight;
                                    });
                                    subNs.css('overflow', 'hidden');
                                    subNs.animate({'height': [0, h]}, null, function () {
                                        onend(empty);
                                    }, 200, null, 'expoIn', profile.key + profile.id).start();
                                } else onend(empty);
                            } else onend(empty);
                        },
                        sub = item.sub,
                        callback = function (sub) {
                            openSub(profile, item, id, markNode, subNs1, subNs2, subNs, sub);
                        }, t;

                    if ((t = typeof sub) == 'string' || t == 'object')
                        callback(sub);
                    else if (profile.onGetContent) {
                        if (ood.browser.ie && ood.browser.ver <= 8) {
                            markNode.css('background', 'url(' + ood.ini.img_busy + ') no-repeat');
                        } else {
                            markNode.addClass('ood-icon-loading');
                        }
                        var r = profile.boxing().onGetContent(profile, item, callback);
                        if (r || r === false) {
                            //return true: toggle icon will be checked
                            if (r === true)
                                item._inited = true;
                            callback(r);
                        }
                    }
                }
                if (recursive && item.sub) {
                    ood.arr.each(item.sub, function (o) {
                        if (o.sub && o.sub.length && !o._checked)
                            profile.box._setSub(profile, o, flag, recursive, true, cb);
                    });
                }
            }
        },
        _getCellId: function (profile, rowId, colId) {
            if (ood.isNumb(rowId)) rowId = ood.get(profile.properties.rows, [rowId, "id"]);
            if (ood.isNumb(colId)) colId = ood.get(profile.properties.header, [colId, "id"]);
            return ood.get(profile.rowMap, [profile.rowMap2[rowId], '_cells', colId]);
        },
        _updCell: function (profile, cellId, options, dirtyMark, triggerEvent, triggerFormula) {
            var box = profile.box,
                prop = profile.properties,
                pdm = prop.dirtyMark,
                psdm = pdm && prop.showDirtyMark,
                sc = ood.absObj.$specialChars,
                cell, node, ishotrow, ext;

            if (typeof cellId == 'string')
                cell = profile.cellMap[cellId];
            else {
                cell = cellId;
                cellId = cell._serialId;
            }
            if (!cell || !cell._row) return;
            ishotrow = cell._row.id == box._temprowid;
            if (ishotrow && cell.caption == prop.hotRowCellCap)
                delete cell.caption;

            if (!ood.isHash(options)) options = {value: options};
            options = ood.filter(options, function (o, i, r) {
                r = !sc[i.charAt(0)];
                if (!r) {
                    ext = ext || {};
                    ext[i] = o
                }
                return r;
            });
            if (triggerEvent) {
                if (profile.beforeCellUpdated && false === profile.boxing().beforeCellUpdated(profile, cell, options, ishotrow, ext))
                    return;
            }
            if (!ood.isEmpty(options)) {
                // * remove cell's special setting first
                delete cell._$tips;
                delete cell._$tmpcap;

                ood.merge(cell, options, 'all');

                node = profile.getSubNode('CELLA', cellId);
                if ('type' in options) {
                    var uicell = {};
                    box._adjustCell(profile, cell, uicell);
                    node.parent().replace(profile._buildItems('rows2.cells', [uicell]));
                    node = profile.getSubNode('CELLA', cellId);
                } else {
                    // allow to set caption dynamically
                    var cellCapTpl = box.getCellOption(profile, cell, 'cellCapTpl');
                    // * : only for cellCapTpl => caption
                    if (cellCapTpl)
                        cell.caption = ood.adjustRes(cellCapTpl, true, false, null, null, cell);
                    cell = box._renderCell(profile, cell, null, node, options);
                }

                var editor = cell._editor;

                //if update value
                if ('value' in options) {
                    if (!pdm || dirtyMark === false)
                        cell._oValue = cell.value;
                    if ('unit' in cell) cell._oUnit = cell.unit;
                    else {
                        if (cell.value === cell._oValue && (!('unit' in cell) || cell._oUnit === cell.unit)) {
                            if (psdm)
                                node.removeClass('ood-ui-dirty');
                        } else {
                            if (psdm)
                                node.addClass('ood-ui-dirty');
                        }
                    }
                    if (editor) editor.setValue(cell.value, true, 'editorini');
                    // formula
                    if (triggerFormula !== false)
                        ood.resetRun(profile.key + ":" + profile.$xid + ":" + cell.id, function () {
                            if (profile && profile.box) profile.boxing().triggerFormulas(cell, 'updatecell');
                        });
                }
                if (('caption' in options) && editor && editor.setCaption) {
                    editor.setCaption(options.caption || null, true);
                }

                cell._dirty = 1;
            }
            if (triggerEvent) {
                if (profile.afterCellUpdated)
                    profile.boxing().afterCellUpdated(profile, cell, options, ishotrow, ext);
            }
        },
        _ensureValue: function (profile, value) {
            if (profile.properties.selMode == 'multi' || profile.properties.selMode == 'multibycheckbox') {
                var arr = ood.isArr(value) ? value : (value ? ('' + value) : '').split(profile.properties.valueSeparator);
                // ignore hot row
                ood.arr.removeValue(arr, this._temprowid);
                arr.sort();
                return arr.join(profile.properties.valueSeparator);
            } else {
                // ignore hot row
                return value == this._temprowid ? null : value;
            }
        },
        _sel: function (profile, type, src, id, e) {
            var properties = profile.properties;
            if (properties.activeMode != type) return;

            var targetId = profile.getSubId(id),
                map = type == 'cell' ? profile.cellMap : profile.rowMap,
                box = profile.boxing(),
                targetItem = map[targetId],
                ks = ood.Event.getKey(e),
                sid = type == 'cell' ? (targetItem._row.id + '|' + targetItem._col.id) : targetItem.id,
                mode = properties.selMode;
            switch (mode) {
                case 'none':
                    box.onRowSelected(profile, targetItem, e, src, 0);
                    break;
                case 'multibycheckbox':
                    if (profile.keys.MARK) {
                        var ck = profile.getKey(ood.Event.getSrc(e).id || ""),
                            clickMark = ck == profile.keys.MARK;
                        if (!clickMark) {
                            box.onRowSelected(profile, targetItem, e, src, 0);
                            break;
                        }
                    }
                case 'multi':
                    var value = box.getUIValue(),
                        arr = value ? ('' + value).split(properties.valueSeparator) : [],
                        checktype = 1;
                    if (arr.length && (ks.ctrlKey || ks.shiftKey || properties.noCtrlKey)) {
                        //todo: give cell multi selection function
                        if (ks.shiftKey && type == 'row') {
                            if (profile.$firstV._pid != targetItem._pid) return false;
                            var items = properties.rows;
                            if (targetItem._pid) {
                                var pitem = map[targetItem._pid];
                                if (pitem) items = pitem.sub;
                            }
                            var i1 = ood.arr.subIndexOf(items, 'id', profile.$firstV.id),
                                i2 = ood.arr.subIndexOf(items, 'id', targetItem.id),
                                i;
                            arr.length = 0;
                            for (i = Math.min(i1, i2); i <= Math.max(i1, i2); i++)
                                arr.push(items[i].id);
                        } else {
                            if (ood.arr.indexOf(arr, sid) != -1) {
                                ood.arr.removeValue(arr, sid);
                                checktype = -1;
                            } else
                                arr.push(sid);
                        }

                        arr.sort();
                        value = arr.join(properties.valueSeparator);

                        //update string value only for setCtrlValue
                        if (box.getUIValue() != value) {
                            box.setUIValue(value, null, null, 'click');
                            if (box.get(0) && box.getUIValue() == value)
                                box.onRowSelected(profile, targetItem, e, src, checktype);
                        }
                        break;
                    }
                case 'single':
                    if (box.getUIValue() != sid) {
                        profile.$firstV = targetItem;
                        box.setUIValue(sid, null, null, 'click');
                        if (box.get(0) && box.getUIValue() == sid)
                            box.onRowSelected(profile, targetItem, e, src, 1);
                    }
                    break;
            }
        },
        _activeCell: function (profile, id) {
            if (profile.properties.activeMode != 'cell') return;
            if (profile.$activeCell == id) return;
            var targetCell = null;
            if (profile.$activeCell) {
                ood(profile.$activeCell).tagClass('-active', false);
                delete profile.$activeCell;
            }
            if (id !== false) {
                var targetId = profile.getSubId(id),
                    map = profile.cellMap;
                targetCell = map[targetId];
                if (profile.beforeCellActive && (false === profile.boxing().beforeCellActive(profile, targetCell))) return;
                ood(profile.$activeCell = id).tagClass('-active');
            }
            if (profile.afterCellActive) profile.boxing().afterCellActive(profile, targetCell);
        },
        _activeRow: function (profile, id) {
            if (profile.properties.activeMode != 'row') return;
            if (profile.$activeRow == id) return;
            var targetRow = null, subId;
            if (profile.$activeRow) {
                subId = profile.getSubId(profile.$activeRow);
                profile.getSubNodes(['CELLS1', 'CELLS2'], subId).tagClass('-active', false);
                delete profile.$activeRow;
            }
            if (id !== false) {
                var targetId = profile.getSubId(id),
                    map = profile.rowMap;
                targetRow = map[targetId];
                //before event
                if (profile.beforeRowActive && (false === profile.boxing().beforeRowActive(profile, targetRow))) return;
                subId = profile.getSubId(profile.$activeRow = id);
                profile.getSubNodes(['CELLS1', 'CELLS2'], subId).tagClass('-active');
            }
            //after event
            if (profile.afterRowActive) profile.boxing().afterRowActive(profile, targetRow);
        },
        _getCellFormula: function (profile, cell, col, row) {
            var t, p = profile.properties, f1 = function (t, col) {
                t = ood.isStr(t) ? t : ('=' + t);
                return t.replace(/(\B)(\?)([0-9]+\b)/g, '$1' + col + '$3').replace(/(\b)(_)([0-9]+\b)/g, '$1' + col + '$3');
            }, f2 = function (t, row) {
                t = ood.isStr(t) ? t : ('=' + t);
                return t.replace(/(\b[A-Z]+)(\?)(\B)/g, '$1' + row + '$3').replace(/(\b[A-Z]+)(_)(\b)/g, '$1' + row + '$3');
            };
            return (cell && (t = cell.formula)) ? t
                : (cell && (t = cell._row) && (t = t.formula)) ? f1(t, col)
                    : ((t = p.rowOptions) && (t = t.formula)) ? f1(t, col)
                        : (cell && (t = cell._col) && (t = t.formula)) ? f2(t, row)
                            : ((t = p.colOptions) && (t = t.formula)) ? f2(t, row)
                                : null;
        },
        getCellOption: function (profile, cell, key) {
            var t = cell, p = profile.properties;


            return (t && t.hasOwnProperty(key) && ood.isSet(t = t[key])) ? t
                //  : (cell && (t = cell._row) && t.hasOwnProperty(key) && ood.isSet(t = t[key])) ? t
                : ((t = p.rowOptions) && t.hasOwnProperty(key) && ood.isSet(t = t[key])) ? t
                    : (cell && (t = cell._col) && t.hasOwnProperty(key) && ood.isSet(t = t[key])) ? t
                        : ((t = p.colOptions) && t.hasOwnProperty(key) && ood.isSet(t = t[key])) ? t
                            : ((t = p) && t.hasOwnProperty(key) && ood.isSet(t = t[key])) ? t : null;
        },
        _trycheckrowdirty: function (profile, cell) {
            if (!cell || !cell._row) return;

            ood.resetRun(profile.key + ":" + profile.$xid + ":" + cell._row.id, function () {
                // destroyed
                if (!profile.box) return;
                var lc = profile.$cellInEditor;
                if (cell._row && (!lc || (lc._row && lc._row != cell._row))) {
                    var dirty = false;
                    ood.arr.each(cell._row.cells, function (v) {
                        if (v._oValue !== v.value || (('unit' in v) && v._oUnit !== v.unit)) {
                            dirty = true;
                            return false;
                        }
                    });
                    if (dirty && cell._row.id != profile.box._temprowid && profile.onRowDirtied)
                        profile.boxing().onRowDirtied(profile, cell._row);
                }
            }, 100);
        },
        _adjusteditorW: function (profile, nodes, width) {
            if (nodes) {
                nodes.each(function (n, i) {
                    if (!(i = n.id)) return;
                    i = i.split(":")[2];
                    if (i = profile.cellMap[i])
                        if (i._editor)
                            i._editor.setWidth(width);
                });
            }
        },
        _adjusteditorH: function (profile, nodes, height) {
            nodes.each(function (n, i) {
                if (!(i = n.id)) return;
                i = i.split(":")[2];
                if (i = profile.rowMap[i]) {
                    i = i.cells;
                    for (var j in i) {
                        j = i[j];
                        if (j._editor)
                            j._editor.setHeight(profile.$addpx(height, 1, j._editor.getRootNode()));
                    }
                }
            });
        },
        _editCell: function (profile, cellId, byhover, inactive) {
            var cell = typeof cellId == 'string' ? (profile.cellMap[cellId] || profile.cellMap[profile.cellMap2[cellId]]) : cellId;
            if (!cell) return;
            // real cellId
            cellId = cell._serialId;

            var box = profile.box,
                getPro = function (key, _cell) {
                    return box.getCellOption(profile, _cell || cell, key)
                };

            if (getPro('disabled') || getPro('readonly') || !getPro('editable')) return;

            var editor,
                grid = this,
                prop = profile.properties,
                cb = profile.getRoot().contentBox(),
                type = getPro('type') || 'input',
                //region = prop.freezedColumn prop.freezedRow
                col = cell._col,
                colId = col.id,
                row = cell._row,
                rowId = row.id,
                ishotrow = rowId == profile.box._temprowid,
                editMode = getPro('editMode'),
                inline = editMode == "inline" || (getPro('type') == 'dropbutton'),
                baseNode = profile.getSubNode('SCROLL' + row._region + col._region),
                //baseNode = profile.getSubNode('BORDER'),
                cellNode = profile.getSubNode('CELL', cellId),
                toggleNode = prop.treeMode == 'infirstcell' && profile.getSubNode('ROWTOGGLE', cellId);

            // only for first cell and, shown toggle
            if (toggleNode && (toggleNode.isEmpty() || !toggleNode.get(0).clientWidth)) {
                toggleNode = null;
            }

            if (!inline) {
                //clear the prev editor
                editor = profile.$curEditor;
                if (editor) ood.tryF(editor.undo, [], editor);
                editor = null;
            }

            // -1. for special type
            if (inline && cell._editor) {
                if (!inactive) cell._editor.activate();
                return;
            } else if (type == 'checkbox' || type == 'button') {
                if (!inactive) profile.getSubNode('CELLA', cellId).focus(true);
                return;
            }

            // 1. customEditor in cell/row or header
            if ((editor = getPro('customEditor')) && typeof editor.iniEditor == 'function') {
                editor.iniEditor(profile, cell, cellNode);
                if (!inactive) ood.tryF(editor.activate, [], editor);
                if (profile.onBeginEdit)
                    profile.boxing().onBeginEdit(profile, cell, editor, 'cell');
            } else {
                // 2. beforeIniEditor
                //      returns an editor(ood.UI object)
                //      or, sets $editorValue
                if (profile.beforeIniEditor) {
                    editor = profile.boxing().beforeIniEditor(profile, cell, cellNode, baseNode, 'cell');
                    // if return false, dont set $curEditor
                    if (editor === false)
                        return;
                }

                // 3. for lable type only, give it an chance to customEditor/beforeIniEditor
                if (type == 'label') {
                    if (!inactive) profile.getSubNode('CELLA', cellId).focus(true);
                    return;
                }

                // if beforeIniEditor doesnt return an editor
                if (!editor || !editor['ood.UI']) {
                    var editorAutoPop = getPro('editorAutoPop'),
                        editorCacheKey = getPro('editorCacheKey'),
                        editorProperties = getPro('editorProperties'),
                        editorCC = getPro('editorCC'),
                        editorCS = getPro('editorCS'),
                        editorEvents = getPro('editorEvents'),
                        editorFormat = getPro('editorFormat'),
                        editorMask = getPro('editorMask'),
                        editorReadonly = getPro('editorReadonly'),
                        editorHAlign = getPro('editorHAlign'),
                        editorDropListWidth = getPro('editorDropListWidth'),
                        editorDropListHeight = getPro('editorDropListHeight'),
                        editorCommandBtn = getPro('editorCommandBtn'),
                        t, oldProp;


                    if (!inline) {
                        // 4. try to get editor from cache
                        if (editorCacheKey && profile.$cache_editor[editorCacheKey])
                            editor = profile.$cache_editor[editorCacheKey];
                        if (editor && (!editor.get(0) || editor.isDestroyed()))
                            editor = nulll;
                    }
                    // 5. else, create a ComboInput Editor, and cache it
                    if (!editor) {
                        var iniprop = {
                            dirtyMark: false,
                            cachePopWnd: false,
                            left: -1000,
                            top: -1000,
                            position: 'absolute',
                            visibility: 'hidden',
                            zIndex: 100
                        };
                        if (inline) {
                            ood.merge(iniprop, {
                                left: 0,
                                top: 0,
                                cachePopWnd: true,
                                width: profile.$px(cell._col._colWidth) + (cb ? 2 : 1),
                                height: profile.$px(cell._row._rowHeight) + (cb ? 1 : 0),
                                visibility: 'visible',
                                zIndex: 100
                            }, 'all');
                        }
                        editor = new ood.UI.ComboInput(iniprop);
                    }
                    switch (type) {
                        // input
                        // button
                        // checkbox
                        //case 'number':
                        case 'spin':
                        case 'counter':
                        case 'currency':
                            editor.setType(type);
                            ood.each(ood.toArr('precision,increment,min,max,maxlength,currencyTpl,numberTpl,groupingSeparator,decimalSeparator,forceFillZero,trimTailZero,unit,units'), function (key, u) {
                                v = getPro(key);
                                if (type == 'currency') {
                                    if (key == 'precision' && !v) v = 2;
                                } else {
                                    if (key == 'precision' && !v) v = 0;
                                    if (key == 'increment' && !v) v = 1;
                                }

                                if (ood.isSet(v)) editor['set' + ood.str.initial(key)](v);
                            });
                            break;
                        case 'progress':
                            editor.setType('spin').setMax(1).setMin(0).setPrecision(4).setIncrement(0.01);
                            break;
                        case 'input':
                            editor.setType('none');
                            break;
                        case 'checkbox':
                            editor.setType('checkbox');
                            break;
                        case 'textarea':
                            editor.setType('none').setMultiLines(true).setCommandBtn('save').onCommand(function (p) {
                                p.boxing().hide();
                            });
                            if (!inline)
                                ood.tryF(editor.setResizer, [true], editor);
                            break;
                        case 'date':
                        case 'datetime':
                            var dateEditorTpl = getPro('dateEditorTpl');
                            if (dateEditorTpl)
                                editor.setDateEditorTpl(dateEditorTpl);
                        case 'listbox':
                        case 'combobox':
                        case 'helpinput':
                        case 'time':
                        case 'color':
                        case 'getter':
                        case 'popbox':
                        case 'dropbutton':
                        case 'cmdbox':
                            editor.setType(type);
                            if (profile.box.getCellOption(profile, cell, 'disabled')) {
                            } else {
                                editor.beforeComboPop(function (editorprf, pos, e, src) {
                                    var cell = editorprf.$cell,
                                        event = profile.box.getCellOption(profile, cell, 'event');
                                    if (typeof event == 'function')
                                        return event.call(profile._host || profile, profile, cell, editorprf, pos, e, src);
                                    else
                                        return profile.boxing().beforeComboPop(profile, cell, editorprf, pos, e, src);
                                });
                                if (profile.beforePopShow)
                                    editor.beforePopShow(function (editorprf, popCtl, items) {
                                        return profile.boxing().beforePopShow(profile, editorprf.$cell, editorprf, popCtl, items);
                                    });
                                if (profile.afterPopShow)
                                    editor.afterPopShow(function (editorprf, popCtl) {
                                        return profile.boxing().afterPopShow(profile, editorprf.$cell, editorprf, popCtl);
                                    });
                                if (type == 'popbox' || type == 'cmdbox' || type == 'getter' || type == 'dropbutton') {
                                    if (profile.onEditorClick)
                                        editor.onClick(function (prf, e, src, btn) {
                                            return profile.boxing().onEditorClick(profile, prf.$cell, prf, btn, src);
                                        });
                                }
                            }
                            break;
                        case 'file':
                            editor.setType(type);
                            break;
                    }
                    if (profile.onCommand)
                        editor.onCommand(function (editorprf, node, type) {
                            return profile.boxing().onCommand(profile, editorprf.$cell, editorprf, node, type);
                        });

                    cell._editor = editor;
                    if (inline) {
                        cellNode.append(editor);
                    } else {
                        baseNode.append(editor);
                    }
                    //cache the stantdard editor
                    if (!inline && editorCacheKey)
                        profile.$cache_editor[editorCacheKey] = editor;

                    if (editor.setInputReadonly)
                        editor.setInputReadonly(!!editorReadonly);
                    if (editor.setDropListWidth && editorDropListWidth)
                        editor.setDropListWidth(editorDropListWidth);
                    if (editor.setDropListHeight && editorDropListHeight)
                        editor.setDropListHeight(editorDropListHeight);
                    if (editor.setHAlign && editorHAlign)
                        editor.setHAlign(editorHAlign);
                    if (editor.setCommandBtn && editorCommandBtn)
                        editor.setCommandBtn(editorCommandBtn);
                    if (editorFormat) {
                        if (typeof editorFormat == 'function' && editor.beforeFormatCheck)
                            editor.beforeFormatCheck(editorFormat);
                        else if (typeof editorFormat == 'string' && editor.setValueFormat)
                            editor.setValueFormat(editorFormat);
                    }
                    if (editorMask && editor.setMask)
                        editor.setMask(editorMask);
                    if (editorProperties) {
                        oldProp = {};
                        var h = profile.getProperties();
                        ood.each(editorProperties, function (o, i) {
                            oldProp = h[i];
                        });
                        editor.setProperties(editorProperties);
                    }
                    if (editorCC)
                        editor.setCustomClass(ood.clone(editorCC, 2));
                    if (editorCS)
                        editor.setCustomStyle(ood.clone(editorCS, 2));
                    if (editorEvents)
                        editor.setEvents(editorEvents);
                    if (!inline) {
                        // clear for valueFormat, setValue maybe cant set value because of valueFormat
                        editor.resetValue();
                    }
                    //set properities
                    switch (type) {
                        case 'listbox':
                        case 'combobox':
                        case 'helpinput':
                            // set properties
                            if (t = getPro('editorListItems')) {
                                editor.setListKey(null);
                                editor.setItems(typeof(t) == "function" ? t() : t);
                            } else if (t = getPro('editorListKey')) {
                                editor.setItems(null);
                                editor.setListKey(typeof(t) == "function" ? t() : t);
                            }
                            break;
                    }

                    // must set value here, after setItems/setListKey
                    //$editorValue must be set in beforeIniEditor
                    editor.setValue(ood.isSet(cell.$editorValue) ? cell.$editorValue : cell.value, true, 'editorini');
                    delete cell.$editorValue;

                    if (editor.setCaption) {
                        if (editorProperties && ('caption' in editorProperties) && ood.isDefined(editorProperties.caption)) {
                            editor.setCaption(editorProperties.caption, true);
                        } else if (type == "cmdbox" || type == "popbox" || type == "button" || type == "dropbutton") {
                            editor.setCaption(cell._caption || cell._$tmpcap || cell.caption || "", true);
                        }
                    }
                    //$tag for compatible
                    if (cell.$tag) {
                        if (editor.setCaption) editor.setCaption(cell.$tag);
                        else if (editor.setValue) editor.setValue(cell.$tag, null, 'editortag');
                    }
                    //give a reference
                    editor.get(0).$cell = cell;
                    editor.get(0)._smartnav = true;

                    //undo function is a must
                    editor.undo = inline ? null : function (refocus, inactive) {
                        var editor = this;
                        // execute once
                        editor.undo = null;
                        // row dirty alert
                        if (profile.box)
                            profile.box._trycheckrowdirty(profile, profile.$cellInEditor);
                        if (!inactive) {
                            if (editor.get(0) && editor.get(0).box) {
                                // for ie's setBlurTrigger doesn't trigger onchange event
                                editor.getSubNode('INPUT').onBlur(true);

                                if (refocus && ood.str.endWith(editMode, "sharp")) {
                                    cell._ignorefocus = 1;
                                    profile.boxing().focusCell(profile.$cellInEditor);
                                    ood.asyRun(function () {
                                        delete cell._ignorefocus;
                                    });
                                }
                            }
                            editor.getRoot().setBlurTrigger(profile.$xid + ":editor");
                            if (profile.properties && !profile.properties.directInput) {
                                editor.beforeUnitUpdated(null).afterUIValueSet(null).beforeNextFocus(null).onCancel(null).afterPopHide(null);
                                editor.setValue('', true, 'editorreset');
                            }
                            // clear those setting
                            if (editorFormat) {
                                if (editor.beforeFormatCheck) editor.beforeFormatCheck(null);
                                if (editor.setValueFormat) editor.setValueFormat('');
                            }
                            if (editorMask)
                                if (editor.setMask) editor.setMask('');
                            if (editor.setInputReadonly) editor.setInputReadonly(!editorReadonly);
                            if (editorDropListWidth)
                                if (editor.setDropListWidth) editor.setDropListWidth(0);
                            if (editorDropListHeight)
                                if (editor.setDropListHeight) editor.setDropListHeight(0);
                            if (oldProp) {
                                editor.setProperties(oldProp);
                                oldProp = null;
                            }
                            delete editor.get(0).$cell;
                            delete editor.get(0)._smartnav;
                            //don't use disply:none, firfox has many bugs about Caret or renderer
                            editor.hide();

                            if (ood.isFun(editor.collapse)) editor.collapse();
                        }
                        if (editorEvents) {
                            var h = {};
                            ood.each(editorEvents, function (o, i) {
                                h[i] = null;
                            });
                            editor.setEvents(h);
                        }
                        profile.$curEditor = null;
                        profile.$cellInEditor = null;
                        if (profile.onEndEdit)
                            profile.boxing().onEndEdit(profile, cell, editor, 'cell');

                        // don't cache it
                        if (!editorCacheKey && editor.get(0)) {
                            editor.destroy(true);
                        }
                        cell._editor = editor = null;
                    };
                    var g1 = profile.boxing(), pos = g1.getCellPos(cell), cc, nc,
                        _getcell = function (editorPrf) {
                            if (pos) return g1.getCellbyRowCol(pos.row, pos.col);
                            else return editorPrf.$cell;
                        };

                    //editor change value, update cell value
                    editor
                        .beforeUnitUpdated(function (editorPrf, v) {
                            cc = _getcell(editorPrf);
                            if (profile.beforeUnitUpdated && false === g1.beforeUnitUpdated(profile, cc, editorPrf, v))
                                return false;
                            grid._updCell(profile, cc, {
                                value: cc.value,
                                unit: v
                            }, profile.properties.dirtyMark, true, true);
                            if ((nc = _getcell(editorPrf)) && nc !== cc) {
                                editorPrf.$cell = nc;
                                nc._editor = editor;
                                if (!inline) {
                                    profile.$cellInEditor = nc;
                                }
                            }
                        })
                        .afterUIValueSet(function (editorPrf, oV, nV, force, tag) {
                            cc = _getcell(editorPrf);
                            if (!cc) return;

                            var type = getPro('type', cc), caption;
                            switch (type) {
                                case 'number':
                                case 'spin':
                                case 'counter':
                                case 'progress':
                                    nV = parseFloat(nV);
                                    nV = (nV || nV === 0) ? nV : null;
                                    break;
                                case 'currency':
                                    nV = parseFloat(('' + nV).replace(/[^\d.-]/g, ''));
                                    nV = (nV || nV === 0) ? nV : null;
                                    break;
                                case 'cmdbox':
                                case 'button':
                                case 'dropbutton':
                                case 'popbox':
                                case 'combobox':
                                case 'listbox':
                                case 'helpinput':
                                    caption = editorPrf.boxing().getShowValue();
                                    break;
                            }
                            var options = {
                                value: nV
                            };

                            if (ood.isDefined(caption))
                                options.caption = caption;

                            if (editorPrf.properties.hasOwnProperty("tagVar") && !ood.isEmpty(editorPrf.properties.tagVar))
                                options.tagVar = editorPrf.properties.tagVar;

                            if (false !== (profile.beforeEditApply && profile.boxing().beforeEditApply(profile, cc, options, editor, tag, 'cell'))) {
                                grid._updCell(profile, cc, options, profile.properties.dirtyMark, true, true);
                                if ((nc = _getcell(editorPrf)) && nc !== cc) {
                                    editorPrf.$cell = nc;
                                    nc._editor = editor;
                                    if (!inline) {
                                        profile.$cellInEditor = nc;
                                    }
                                }

                                if (ood.str.endWith(editMode, "sharp") && type != 'spin' && type != 'counter') {
                                    ood.tryF(editor.undo, [true], editor);
                                }
                            }
                        })
                        .beforeNextFocus(function (editorPrf, e) {
                            if (editor.undo)
                                ood.tryF(editor.undo, [true], editor);
                            var hash = ood.Event.getEventPara(e);
                            // fake 'right' key
                            if (hash.key == 'enter') hash.$key = 'right';
                            profile.getSubNode('CELLA', cell._serialId).onKeydown(true, hash);
                            //prevent
                            return false;
                        })
                        .onFileDlgOpen(function (editorPrf, src) {
                            if (profile.onFileDlgOpen) profile.boxing().onFileDlgOpen(profile, cell, editorPrf, src);
                        });

                    if (!inline) {
                        editor
                            .onCancel(function () {
                                if (editor)
                                    ood.tryF(editor.undo, [], editor);
                            })
                            .afterPopHide(function (p, r, type) {
                                if (ood.str.endWith(editMode, "sharp"))
                                    ood.tryF(editor.undo, [type != "blur" && type != "call"], editor);
                            })
                            .getRoot().setBlurTrigger(profile.$xid + ":editor", function () {
                            if (editor)
                                ood.tryF(editor.undo, [], editor);
                            return false;
                        });

                        var absPos = cellNode.offset(null, baseNode),
                            size = cellNode.cssSize(),
                            absPos2 = toggleNode ? toggleNode.offset(null, cellNode) : null,
                            w2 = toggleNode ? toggleNode.width() : null;
                        if (absPos2) absPos2.left += w2;
                        // too small
                        if (toggleNode && (absPos2.left > size.width - 8)) return;

                        //show editor
                        if (type == 'textarea') {
                            editor.setWidth(Math.max(200, size.width - (toggleNode ? absPos2.left : 0) + (cb ? 3 : 0))).setHeight(Math.max(100, size.height + (cb ? 2 : 0)))
                                .reLayout(true, true)
                                .reBoxing()
                                .popToTop(cellNode, 4, baseNode);
                        } else {
                            //**toggleNode
                            editor.setWidth(size.width - (toggleNode ? absPos2.left : 0) + (cb ? 3 : 0)).setHeight(size.height + (cb ? 2 : 0)).reLayout(true);
                            editor.reBoxing().show((absPos.left + (toggleNode ? absPos2.left : 0) - (cb ? 1 : 0)) + 'px', (absPos.top - (cb ? 1 : 0)) + 'px');
                        }

                        var expand,
                            noInputType = type == 'cmdbox' || type == 'cmdbox' || type == 'listbox' || type == 'file',
                            insPopType = noInputType || type == 'date' || type == 'time' || type == 'datetime' || type == 'color',
                            inputReadonly = editor.getInputReadonly && editor.getInputReadonly(),
                            issharp = ood.str.endWith(editMode, "sharp") && (editorAutoPop || inputReadonly || insPopType);
                        if (!inactive) {
                            if (ood.isFun(editor.expand)
                                && editorAutoPop !== false
                                && (issharp || ((ood.str.endWith(editMode, "sharp") || editMode == "focus") && (editorAutoPop || noInputType)))
                            ) {
                                expand = 1;
                                editor.expand(cellNode, false, null);
                            }
                        }
                        editor.get(0).$editMode = editMode;

                        if (!inline)
                            editor.setVisibility(issharp ? "hidden" : "visible");
                        //activate editor
                        if (!ood.str.startWith(editMode, "hover") || !byhover) {
                            if (!inactive) {
                                ood.asyRun(function () {
                                    // destroyed
                                    if (!profile.box) return;
                                    var target = editor;
                                    if (target.get(0) && target.get(0).box) {
                                        if (expand && editor.getPopWnd)
                                            target = editor.getPopWnd();
                                        if (target) {
                                            ood.tryF(target && target.activate, [], target);
                                            target.get(0)._stopmouseupcaret = 1;
                                        }
                                    }
                                });
                            }
                        } else {
                            var bfun = function () {
                                if (editor) editor.getRoot().onMouseout(null, "tg-hover-edit");
                            }, cfun = function () {
                                if (editor) editor.getRoot().onMouseout(function () {
                                    if (editor) ood.tryF(editor.undo, [], editor);
                                }, "tg-hover-edit");
                            }, dfun = function () {
                                // if(editor) ood.tryF(editor.undo,[],editor);
                            };
                            editor.onFocus(bfun).beforePopShow(function (editorPrf, popCtl, items) {
                                bfun();
                                editor.onBlur(null);
                                // for compitable
                                if (profile.beforePopShow)
                                    return profile.boxing().beforePopShow(profile, editorPrf.$cell, editorPrf, popCtl, items);
                            }).afterPopHide(function () {
                                cfun();
                                editor.onBlur(dfun);
                            }).onBlur(dfun);

                            if (!inactive && !expand)
                                ood.tryF(editor && editor.activate, [], editor);
                        }
                    }
                    if (profile.onBeginEdit)
                        profile.boxing().onBeginEdit(profile, cell, editor, 'cell');
                }
            }
            if (!inline) {
                //give a reference
                profile.$curEditor = editor;
                profile.$cellInEditor = cell;
            }
            if (ishotrow) {
                profile.__needchecktmprow = true;
                profile.box._sethotrowoutterblur(profile);
            }
        },
        _adjustBody: function (profile, trigger, callback) {
            if (!profile.renderId || profile.destroyed) return;

            ood.resetRun(profile.$xid + '4', function () {
                // destroyed
                if (!profile.renderId || profile.destroyed) return;

                var prop = profile.properties,
                    us = ood.$us(profile),
                    adjustunit = function (v, emRate) {
                        return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                    },
                    size = profile.getSubNode("BORDER").cssSize(),
                    _border = profile.getRoot().contentBox() ? 2 : 0,
                    width = profile.$px(size.width),
                    height = profile.$px(size.height),

                    //left region
                    w1 = prop.rowHandler ? (profile.$px(prop.rowHandlerWidth) + _border) : 0,
                    w2,
                    h1 = profile.getSubNode('HEADER1'),
                    h2 = profile.getSubNode('HEADER2'),
                    b12 = profile.getSubNode('BODY12'),
                    b21 = profile.getSubNode('BODY21'),
                    s11 = profile.getSubNode('SCROLL11'),
                    s12 = profile.getSubNode('SCROLL12'),
                    s21 = profile.getSubNode('SCROLL21'),
                    s22 = profile.getSubNode('SCROLL22'),
                    rh = h2.height(),
                    rr = b12.height();

                // adjust width
                // left region
                if (prop.freezedColumn) {
                    ood.arr.each(prop.header, function (col, i) {
                        if (i == prop.freezedColumn) return false;
                        if (!col.hidden) w1 += profile.$px(col.width) + _border;
                    });
                }
                // for border-bottom
                if (rr && prop.freezedRow) rr -= 1;
                // for border-right
                if (w1 && prop.freezedColumn) w1 -= 1;

                w2 = width - w1;
                profile._leftregionw = w1;

                //h1.width(adjustunit(w1));
                //s21.width(adjustunit(w1));
                h2.width(adjustunit(w2));
                s22.width(adjustunit(w2));

                // for scroll sync
                ood.asyRun(function () {
                    // separated read/write
                    var b21e = b21.isEmpty(),
                        s21e = s21.isEmpty(),
                        b12e = b12.isEmpty(),
                        s12e = s12.isEmpty(),
                        fr = prop.freezedRow,
                        pb = !s21e ? ((s22.isScrollBarShowed('x') ? ood.Dom.getScrollBarSize() : 0) + 'px') : '',
                        st = !s21e ? s22.scrollTop() : 0,
                        sl = (fr && !s12e) ? s22.scrollLeft() : 0,
                        pr = (fr && !b12e) ? ((s22.isScrollBarShowed('y') ? ood.Dom.getScrollBarSize() : 0) + 'px') : '';

                    if (!b21e) b21.css('padding-bottom', pb);
                    if (fr && !b12e) b12.css('padding-right', pr);
                    if (!s21e) s21.scrollTop(st);
                    if (fr && !s12e) s12.scrollLeft(sl);
                }, 100);

                // adjust height
                s11.height(rr ? adjustunit(rr) : 0);
                s12.height(rr ? adjustunit(rr) : 0);
                s21.height(adjustunit(height - rh - rr));
                s22.height(adjustunit(height - rh - rr));

                // avoid onmouseout of CELLS2 trigger CELLS1 scroll to top
                s11.css('display', rr && profile._leftregionw ? '' : 'none');
                s12.css('display', rr ? '' : 'none');
                s21.css('display', profile._leftregionw ? '' : 'none');

                // others
                s22.css('overflow', 'hidden');
                var overflowX = profile.box._adjustRelWith(profile);

                var body = profile.getSubNode('ROWS22'),
                    header = profile.getSubNode('HCELLS2'),
                    cols = profile.properties.header,
                    scroll = profile.getSubNode('SCROLL22'),
                    t, l, last, keys = profile.keys, ww, bw, hiw, bodyw;

                if (body.get(0).clientHeight) {
                    if (header.get(0).clientHeight) {
                        if (t = header.get(0).childNodes) {
                            l = t.length;
                            while (l) {
                                if (t[l - 1].clientHeight) {
                                    last = t[l - 1];
                                    break;
                                }
                                --l;
                            }
                        }
                        ww = last ? (last.offsetWidth + last.offsetLeft + 100) : 0;
                        hiw = adjustunit(ww);
                        bodyw = adjustunit(bw = ww);
                    } else {
                        if (t = body.get(0).childNodes) {
                            l = t.length;
                            while (l) {
                                if (t[l - 1].clientHeight) {
                                    last = t[l - 1];
                                    break;
                                }
                                --l;
                            }
                            if (last) {
                                var sid = profile.getSubId(last.id);
                                t = profile.getSubNode('CELLS2', sid);
                                if (t = t.get(0).childNodes) {
                                    l = t.length;
                                    while (l) {
                                        if (t[l - 1].clientHeight) {
                                            last = t[l - 1];
                                            break;
                                        }
                                        --l;
                                    }
                                }
                            }
                        }
                    }
                }

                if (last) {
                    bodyw = adjustunit(bw = last.offsetLeft);
                } else {
                    var prop = profile.properties, hd = prop.header, rows = prop.rows,
                        //defult
                        w = 0;
                    ood.arr.each(hd, function (o) {
                        if (o.hidden !== true)
                            w += ('_colWidth' in o) ? profile.$px(o._colWidth) : (profile.$px(o.width) + _border);
                    });
                    bodyw = adjustunit(bw = w);
                }
                t = last = null;

                //HI
                if (hiw) header.parent().width(hiw);
                if (bodyw) body.width(bodyw);

                // must use 'auto' for Android
                scroll.css('overflow', 'auto');

                if (bw > scroll.width() + _border) {
                    overflowX = "auto";
                }

                scroll.css('overflowX', overflowX);

                scroll.onScroll();

                if (profile.onBodyLayout)
                    profile.boxing().onBodyLayout(profile, trigger);

                if (callback) callback();
            });
            // formula
            if (trigger != 'render' && trigger != 'rowhandler' && trigger != 'foldrow' && trigger != 'expandrow' && trigger != 'setcol' && trigger != 'resize')
                ood.resetRun(profile.key + ":" + profile.$xid, function () {
                    if (profile && profile.box) profile.boxing().triggerFormulas(null, trigger);
                });
        },
        _adjustHeader: function (arr) {
            var a = ood.copy(arr), m;

            ood.arr.each(a, function (o, i) {
                //id will be adjusted in _prepareHeader
                a[i] = ood.copy(o);
            });
            return a;
        },
        _adjustGrpColsData: function (profile, arr) {
            if (!ood.isArr(arr)) return ood.copy(arr);

            var prop = profile.properties,
                header = prop.header,
                len = header.length,
                slen = (len + '').length,
                SubID = ood.UI.$tag_subId,
                a = ood.copy(arr, function (o) {
                    o.from = parseInt(o.from, 10) || 0;
                    o['to'] = parseInt(o['to'], 10) || 0;
                    return o.from <= len && o['to'] <= len && o['to'] >= o.from;
                });

            ood.arr.each(a, function (o, i) {
                a[i] = ood.isHash ? ood.copy(o) : {};
            });
            ood.arr.stableSort(a, function (x, y) {
                // desc by from, aesc by to
                return x.from > y.from ? 1 : x.from == y.from ? (x['to'] > y['to'] ? -1 : x['to'] == y['to'] ? 0 : 1) : -1;
            });
            for (var j = 0, m = a.length, grp; j < m; j++) {
                grp = a[j];
                grp[SubID] = grp[SubID] || ('-g_' + profile.pickSubId('grpCol'));
                grp.id = grp.id || grp[SubID];
                if (!grp.caption) grp.caption = grp.id;
                grp._isgroup = 1;
                delete grp._grp;

                profile.colMap[grp[SubID]] = grp;
                profile.colMap2[grp.id] = grp[SubID];
            }
            ood.arr.each(a, function (o, i) {
                for (var j = 0; j < i; j++) {
                    // across
                    if (a[i]['to'] > a[j].from && a[i].from < a[j]['to']) {
                        // cut
                        if (a[i]['to'] > a[j]['to']) a[i]['to'] = a[j]['to'];
                        // record it
                        (a[i]._grp || (a[i]._grp = [])).push(a[j].id);
                    }
                }
            });
            ood.arr.each(header, function (o) {
                delete o._grp;
            });

            var layer = 0;
            // calculate layers
            for (var j = 0, m = a.length, grp, o; j < m; j++) {
                grp = a[j];
                for (var i = grp.from; i <= grp['to']; i++) {
                    o = header[i];
                    (o._grp || (o._grp = [])).push(grp.id);
                    if (!grp._layer) {
                        grp._layer = o._grp.length;
                    }
                    layer = Math.max(layer, grp._layer);
                }
            }
            profile._headerLayers = layer;
            return a;
        },
        _adjustRows: function (profile, arr, ignoreMixColumn) {
            var a, m, h = {}, hvalue = {}, hcap = {}, p = profile.properties, uid = p.uidColumn, key, keys, mixcol,
                rheader = [];
            if (uid) uid = ood.arr.subIndexOf(p.header, 'id', uid);
            else uid = -1;

            ood.arr.each(p.header, function (c, i) {
                key = c.id || c;
                keys = null;
                if (!ignoreMixColumn && key.indexOf(":") != -1) {
                    keys = key.split(':');
                }
                if (keys && keys[0] && keys[1]) {
                    hvalue[keys[0]] = hcap[keys[1]] = i;
                    rheader.push(keys[0], keys[1]);
                    mixcol = 1;
                } else {
                    h[key] = i;
                    rheader.push(key);
                }
            });

            if (ood.isArr(arr) && arr.length && typeof arr[0] != 'object') a = [arr];
            else a = ood.copy(arr);

            ood.arr.each(a, function (o, i) {
                //id will be adjusted in _prepareItems
                if (ood.isArr(o)) a[i] = {cells: ood.copy(o)};
                else a[i] = ood.copy(o);

                // there's mix column
                if (mixcol && ood.isArr(a[i].cells)) {
                    var cells1 = a[i].cells, cells2 = [], col;
                    for (var j = 0, l = rheader.length; j < l; j++) {
                        col = rheader[j];
                        if (col in h) cells2.push(cells1[j]);
                        else {
                            if (col in hvalue) {
                                cells2.push({
                                    value: cells1[j],
                                    caption: cells1[++j]
                                });
                            }
                        }
                    }
                    a[i].cells = cells2;
                }

                // check if it's a map row data
                //1 > {col:value} 2 >{cells:{col:value}}
                var tt = (ood.isHash(a[i]) && (!a[i].cells || !ood.isObj(a[i].cells))) ? 1 : (a[i].cells && ood.isHash(a[i].cells)) ? 2 : 0;
                if (!o.group && tt) {
                    var cells = [], hash;
                    ood.each(tt == 1 ? a[i] : a[i].cells, function (v, i) {
                        if (i in h) cells[h[i]] = ood.isHash(v) ? v : {value: v};
                        else {
                            if (i in hvalue) {
                                hash = cells[hvalue[i]] || {};
                                hash.value = v;
                                cells[hvalue[i]] = hash;
                            }
                            if (i in hcap) {
                                hash = cells[hcap[i]] || {};
                                hash.caption = v;
                                cells[hcap[i]] = hash;
                            }
                        }
                    });
                    a[i].cells = cells;
                }

                ood.arr.each(m = a[i].cells, function (o, i) {
                    if (ood.isDefined(o)) {
                        //It's a hash
                        if (!!o && ood.isHash(o))
                            m[i] = ood.copy(o);
                        // not a hash
                        else
                            m[i] = {value: o};
                    }
                });
                // set uidColumn cell's value to row id
                if (!('id' in a[i]) && uid != -1 && m[uid] && m[uid].value) {
                    a[i].id = m[uid].value;
                }
            });
            return a;
        },
        _adjustColsWidth: function (profile) {
            var prop = profile.properties,
                header = prop.header,
                arr = prop.grpCols,
                border = profile.getRoot().contentBox() ? 2 : 0;


            if (prop.showHeader) {
                if (arr && ood.isArr(arr) && arr.length) {
                    var _left, _l, _w, flag = false, _ww,
                        _l2 = 0;
                    for (var j = 0, m = arr.length, grp, n; j < m; j++) {
                        _l = _w = 0;
                        flag = false;
                        grp = arr[j];
                        _left = 0;
                        for (var k = 0, o; k <= grp['to']; k++) {
                            o = header[k];
                            _ww = profile.$px(o._colWidth, null, true);
                            // for the main region
                            if (prop.freezedColumn && prop.freezedColumn == k && !_l2) {
                                _l2 = _left;
                            }
                            if (k === grp.from) {
                                flag = true;
                                _l = _left;
                            }
                            _left += _ww + border;
                            if (flag && !o.hidden) {
                                _w += _ww + border;
                            }
                        }
                        n = profile.getSubNode("HCELL", grp._serialId);
                        if (_w > border) {
                            n.css({
                                display: '', left: profile.$forceu(_l - (prop.freezedColumn
                                        ? (grp['to'] > prop.freezedColumn - 1
                                                ? _l2
                                                : (prop.rowHandler ? -(profile.$px(prop.rowHandlerWidth) + border) : 0)
                                        )
                                        : 0
                                )
                                ), width: profile.$forceu(_w - border)
                            });
                        } else {
                            n.css({display: 'none'});
                        }
                        if (prop.freezedColumn && prop.rowHandler && grp._shadow) {
                            n = profile.getSubNode("HSCELL", grp._serialId);
                            if (_w > border) {
                                n.css({
                                    display: '',
                                    left: profile.$forceu(_l + (profile.$px(prop.rowHandlerWidth) + border)),
                                    width: profile.$forceu(_w - border)
                                });
                            } else {
                                n.css({display: 'none'});
                            }
                        }
                    }
                }
            }
        },
        // use em here
        _adjustColsHeight: function (profile, force) {
            var map = profile.colMap,
                map2 = profile.colMap2,
                _layers = profile._headerLayers,
                headerh = profile.properties.headerHeight,
                h = profile.$px(headerh, 0, true),
                cacuH = profile.$px(profile.box.$DataModel.headerHeight.ini, 0, true) * (_layers + 1),
                border = profile.getRoot().contentBox() ? 1 : 0,
                tt, l, th, col, rt, rh, upper, grpcolsh, h2;
            // ensure height here
            if (force || h < cacuH) {
                h = cacuH;
            }

            profile.getSubNodes(['HCELLS1', 'HCELLS2', 'GRPCELLBOX1', 'GRPCELLBOX2']).height(profile.$px2em(h) + 'em');
            h2 = profile.$px2em(h - border) + "em";
            profile.getSubNode('FHCELL').css({height: h2});
            if (!_layers) {
                profile.getSubNode('HCELL', true).css({height: h2});
                // if(ood.browser.ie6) // ignore ie6 here
                //    profile.getSubNode('HCELLA',true).css({'line-height':h2});
            } else {
                th = h / (_layers + 1);
                profile.getSubNode('HCELL', true).each(function (o) {
                    col = profile.getSubId(o.id);
                    if (col = map[col]) {
                        // group
                        if (col && col._isgroup) {
                            upper = 0;
                            for (var i in map) {
                                tt = map[i];
                                if (tt._isgroup && tt._layer < col._layer && tt.from <= col['to'] && tt['to'] >= col['from']) {
                                    upper += profile.$px(tt.height || th);
                                }
                            }
                            ood(o).top(profile.$px2em(upper) + 'em');
                            rh = profile.$px(col.height || th);
                        } else {
                            if (col._grp && (l = col._grp.length)) {
                                grpcolsh = 0;
                                for (var i = 0; i < l; i++) {
                                    if (tt = map2[col._grp[i]]) {
                                        grpcolsh += profile.$px(map[tt].height || th);
                                    }
                                }
                                rh = h - grpcolsh;
                            } else
                                rh = h;
                        }
                        ood(o).height(profile.$px2em(rh - border) + 'em');

                        if (col && col._isgroup && col._shadow) {
                            o = profile.getSubNode("HSCELL", col._serialId);
                            ood(o).top(profile.$px2em(upper) + 'em');
                            ood(o).height(profile.$px2em(rh - border) + 'em');
                        }
                    }
                });
            }
        },
        _focuscell: function (profile, e, src) {
            if (profile.properties.disabled || profile.properties.readonly) return;
            if (!ood.use(src).get(0)) return;
            // ensure call _focuscell once when click
            if (!profile.$_ensureOnce) {
                profile.$_ensureOnce = 1;
                ood.asyRun(function () {
                    profile.$_ensureOnce = 0;
                });
            } else return;

            var p = profile.properties,
                box = profile.box,
                getPro = box.getCellOption,
                cell = profile.cellMap[profile.getSubId(src)],
                mode = p.activeMode, id;

            if (cell && cell._ignorefocus) return;

            if (cell) {
                var edit = false, type = getPro(profile, cell, "type");
                if (getPro(profile, cell, 'editable')) {
                    if (getPro(profile, cell, 'disabled') || getPro(profile, cell, 'readonly')) {
                        edit = false;
                    } else {
                        edit = true;
                        if ((getPro(profile, cell, 'editMode') == "inline" && type !== 'label') || type == 'dropbutton') {
                            if (cell._editor) cell._editor.activate();
                        } else {
                            box._editCell(profile, cell._serialId);
                            ood(src).parent().tagClass('-active', false);
                            ood.asyRun(function () {
                                // destroyed
                                if (!profile.box) return;
                                ood.use(src).parent().onMouseout(true, {$force: true})
                                    .parent().onMouseout(true, {$force: true});
                            });
                        }
                    }
                }
                // if not in edit mode
                if (!edit) {
                    if (cell && mode == 'cell') {
                        id = ood.use(src).parent().id();
                        box._activeCell(profile, id);
                    }
                } else {
                    if (cell && mode == 'cell') {
                        box._activeCell(profile, false);
                    }
                }
            } else {
                var row = profile.rowMap[profile.getSubId(src)];
                if (getPro(profile, row, 'editable')) {
                    if (getPro(profile, row, 'disabled') || getPro(profile, row, 'readonly')) {
                    } else {
                        profile.boxing().editFirstCell(row);
                    }
                }
            }
            if (mode == 'row') {
                id = ood.use(src).parent(2).id();
                box._activeRow(profile, id);
            }
        },
        _getToggleNode: function (profile, rowId) {
            return profile.getSubNode('ROWTOGGLE', rowId);
        },
        _showTips: function (profile, node, pos) {
            if (profile.properties.disableTips) return;
            if (profile.onShowTips)
                return profile.boxing().onShowTips(profile, node, pos);
            if (!ood.Tips) return;

            var ks = profile.keys, item, sid, id, pid, ppid;
            if (profile.properties.disabled) return;

            id = node.id;
            pid = ood.get(node, ["parentNode", "id"]) || "";
            ppid = ood.get(node, ["parentNode", "parentNode", "id"]) || "";
            sid = profile.getSubId(id);

            if (id.indexOf(ks.FHCELL) == 0 || pid.indexOf(ks.FHCELL) == 0 || ppid.indexOf(ks.FHCELL) == 0)
                item = {tips: profile.properties.tips};
            else if (id.indexOf(ks.FCELL) == 0 || pid.indexOf(ks.FCELL) == 0)
                item = profile.rowMap[sid];
            else if (id.indexOf(ks.HCELL) == 0 || id.indexOf(ks.HSCELL) == 0 || pid.indexOf(ks.HCELLA) == 0)
                item = profile.colMap[sid];
            else if (id.indexOf(ks.CELL) == 0 || pid.indexOf(ks.CELLA) == 0)
                item = profile.cellMap[sid];

            if (item) {
                ood.Tips.show(pos, ('tips' in item) ? item.tips : (item._$tips || item._caption || item.caption));
                return false;
            } else
                return true;
        },
        _adjustRelWith: function (profile) {
            var prop = profile.properties,
                _ww,
                cols = profile.colMap,
                t2 = profile.getSubNode('SCROLL22'),
                t3 = profile.getSubNode('BODY22'),
                bW = t3.contentBox() ? 2 : 0,
                width = t2.width(),
                borderW = 0,
                borderC = 0;

            profile.getSubNodes('HCELL', true).each(function (hc) {
                if (hc.clientHeight) {
                    borderW = hc.offsetWidth - profile.$px(hc.style.width);
                    return false;
                }
            });

            var fixW = 0, relWTotal = 0, relWCol = [], relWCol2 = [], overflowX;
            //if(prop.rowHandler){
            //borderC++;
            //fixW=profile.$px(prop.rowHandlerWidth);
            //}
            ood.each(profile.colMap, function (col) {
                if (col.hidden || col._isgroup) return;
                // ignore left region columns
                if (col._region == 1) return;

                if (!col.flexSize) {
                    fixW += profile.$px(col.width);
                } else {
                    relWTotal += profile.$px(col.width);
                    relWCol.push(col);
                    relWCol2.push(col);
                }
                borderC++;
            });

            var lcellw = profile.getSubNode("LHCELL").get(0).clientWidth || 0;
            profile.getSubNodes('LCELL', true).each(function (hc) {
                if (hc.children.length) {
                    lcellw = Math.max(lcellw, hc.clientWidth);
                }
            });
            profile.__lcellW = lcellw;

            if (!relWCol.length) {
                overflowX = 'auto';
                profile.box._adjustColsWidth(profile);
                return;
            } else {
                overflowX = 'hidden';
                if (t2.scrollable('y'))
                    width -= ood.Dom.getScrollBarSize();
            }

            width -= profile.__lcellW;
            // all flexSize cols' width
            profile._relWTotal = relWTotal;
            // available room for flexSize cols
            profile._relAvailable = width - (fixW + borderC * borderW);

            while (relWCol.length && width != fixW + borderC * borderW) {
                var fW = profile._relAvailable,
                    fW1 = 0, t,
                    l = relWCol.length,
                    retry = 0;
                for (var i = l - 1; i >= 0; i--) {
                    var col = relWCol[i],
                        w = i === 0 ? (fW - fW1) : Math.round(fW * (profile.$px(col.width) / relWTotal));

                    if (w < 0) w = 0;
                    _ww = w;
                    if (col.hasOwnProperty('minWidth')) {
                        if ((t = profile.$px(col.minWidth)) > w) {
                            fixW += t;
                            _ww = t;
                            ood.arr.removeFrom(relWCol, i);
                            retry++;
                        }
                    }
                    if (col.hasOwnProperty('maxWidth')) {
                        if ((t = profile.$px(col.maxWidth)) < w) {
                            fixW += t;
                            _ww = t;
                            ood.arr.removeFrom(relWCol, i);
                            retry++;
                        }
                    }
                    col._colWidth = profile.$forceu(_ww);
                    fW1 += _ww;
                }
                // break while;
                if (retry === 0 || retry === l)
                    break;
            }
            profile.box._adjustColsWidth(profile);
            if (relWCol2.length) {
                ood.arr.each(relWCol2, function (col) {
                    var n, nodes = [];
                    ood.each(col._cells, function (o) {
                        n = profile.getSubNode('CELL', o);
                        if (n._nodes.length) nodes.push(n.get(0));
                    });
                    n = profile.getSubNode('HCELL', col._serialId);
                    if (n._nodes.length) {
                        nodes.push(n.get(0));
                    }
                    profile.box._adjusteditorW(profile, ood(nodes).width(col._colWidth), profile.$px(col._colWidth) + bW);
                });
            }
            return overflowX;
        },

        _getRow: function (profile, row, type, splitMixColumn) {
            if (row) {
                if (type == 'data') {
                    return ood.clone(row, true);
                } else if (type == 'value') {
                    var data = {};
                    ood.each(row.cells || row, function (cell, j) {
                        data[cell._col.id] = ('value' in cell) ? cell.value : cell;
                    });
                    return data;
                } else if (type == 'min') {
                    var a = [];
                    ood.each(row.cells || row, function (cell, j) {
                        a[j] = ('value' in cell) ? cell.value : cell;
                    });
                    return a;
                } else if (type == 'map') {
                    return profile.boxing().getRawData(row, splitMixColumn);
                } else
                    return row;
            }
        },
        $cancelHoverEditor: function (profile) {
            if (profile.destroyed) return;
            var type = ood.get(profile, ['$curEditor', '_nodes', 0, '$editMode']) || "", t;
            if (ood.str.startWith(type, 'hover')) {
                var editor = profile.$curEditor;
                if (type == "hover" && (t = editor.get(0)) && t.$poplink) return false;
                ood.tryF(editor.undo, [], editor);
            }
        },
        _onresize: function (profile, width, height) {
            var prop = profile.properties,
                f = function (k) {
                    return profile.getSubNode(k)
                },
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                root = profile.getRoot(),
                borderW = root.contentBox() ? 2 : 0,
                w1 = prop.rowHandler ? (profile.$px(prop.rowHandlerWidth) + borderW) : 0,
                w2,
                border = f('BORDER'),
                h1 = f('HEADER1'),
                h2 = f('HEADER2'),
                b12 = f('BODY12'),
                b21 = f('BODY21'),
                s11 = f('SCROLL11'),
                s12 = f('SCROLL12'),
                s21 = f('SCROLL21'),
                s22 = f('SCROLL22'),

                rh = h2.height(),
                rr = b12.height();

            // calculate by px
            width = width ? profile.$px(width, null, true) : width;
            height = height ? profile.$px(height, null, true) : height;

            border.cssSize({
                width: width ? adjustunit(width) : null,
                height: height ? adjustunit(height) : null
            });

            // adjust width
            if (width) {
                // left region
                if (prop.freezedColumn) {
                    ood.arr.each(prop.header, function (col, i) {
                        if (i == prop.freezedColumn) return false;
                        if (!col.hidden) w1 += profile.$px(col.width) + borderW;
                    });
                }
                // for border-bottom
                if (rr && prop.freezedRow) rr -= 1;
                // for border-right
                if (w1 && prop.freezedColumn) w1 -= 1;

                w2 = width - w1;
                profile._leftregionw = w1;

                //h1.width(adjustunit(w1));
                h2.width(adjustunit(w2));
                //s21.width(adjustunit(w1));
                //s22.width(adjustunit(w2));
            }

            // adjust height
            if (height) {
                s11.height(rr ? adjustunit(rr) : 0);
                s12.height(rr ? adjustunit(rr) : 0);
                s21.height(adjustunit(height - rh - rr));
                s22.height(adjustunit(height - rh - rr));
                // avoid onmouseout of CELLS2 trigger CELLS1 scroll to top
                s11.css('display', rr ? '' : 'none');
                s12.css('display', rr ? '' : 'none');
            }
            if (width) {
                // avoid onmouseout of CELLS2 trigger CELLS1 scroll to top
                s11.css('display', profile._leftregionw ? '' : 'none');
                s21.css('display', profile._leftregionw ? '' : 'none');
            }
            // for modify em value
            if (profile.$forceRelayout) {
                this._adjustColsWidth(profile);
                this._adjustColsHeight(profile);
            }

            this._adjustBody(profile, 'resize');
        }
    }
});ood.Class("ood.UI.Dialog", "ood.UI.Widget", {
    Instance: {
        iniProp: {caption: ''},
        // 
        setTheme: function (theme) {
            return this.each(function (profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();

                // 
                root.attr('data-theme', theme);

                // 
                localStorage.setItem('dialog-theme', theme);
            });
        },

        // Get current theme
        getTheme: function () {
            var profile = this.get(0);
            // 
            var savedTheme = null;
            try {
                savedTheme = window.localStorage.getItem('dialog-theme');
            } catch(e) {
                console.log('Failed to read theme preference:', e);
            }
            return profile.properties.theme || savedTheme || 'dark';
        },
        
        // 
        toggleTheme: function() {
            const themes = ['light', 'dark', 'high-contrast'];
            const currentTheme = this.getTheme();
            const nextIndex = (themes.indexOf(currentTheme) + 1) % themes.length;
            this.setTheme(themes[nextIndex]);
            return this;
        },
        setChildren: function (childrens, prf) {
            var host = this;
            this.removeChildren(true, true, true);
            ood.addChild({children: childrens}, host, host.getModule(), host.getModule());
        },


        showModal: function (parent, left, top, callback, ignoreEffects) {
            this.show(parent, true, left, top, callback, ignoreEffects);
        },
        show: function (parent, modal, left, top, callback, ignoreEffects) {
            parent = parent || ood('body');
            return this.each(function (profile) {
                if (profile.inShowing) return;
                
                // ARIA attributes
                var root = profile.getRoot();
                root.attr({
                    'role': 'dialog',
                    'aria-modal': 'true',
                    'aria-labelledby': profile.getId('CAPTION')
                });
                
                // Focus management
                profile.getSubNode('CONTENT').attr('tabindex', '0');
                var t,
                    p = profile.properties,
                    us = ood.$us(profile),
                    ins = profile.boxing();
                // default to center dlg
                switch (p.initPos) {
                    case 'auto':
                        // all in px
                        if (ood.isHash(left)) {
                            top = left.top;
                            left = left.left;
                        } else {
                            top = (top || top === 0) ? top : profile.$px(p.top);
                            left = (left || left === 0) ? left : profile.$px(p.left);
                        }
                        break;
                    case 'center':
                        if (ood.isHash(left)) {
                            top = left.top + (left.height - profile.$px(p.height)) / 2;
                            left = left.left + (left.width - profile.$px(p.width)) / 2;
                        } else {
                            var pr = parent.get(0) == ood('body').get(0) ? ood.win : (parent['ood.UI'] ? parent.getRoot() : parent),
                                scale = pr == ood.win && ood.ini.$zoomScale || 1;
                            // here, have to use global em
                            top = (top || top === 0) ? top : Math.max(0, (pr.height() / scale - profile.$px(p.height)) / 2 + pr.scrollTop() / scale);
                            left = (left || left === 0) ? left : Math.max(0, (pr.width() / scale - profile.$px(p.width)) / 2 + pr.scrollLeft() / scale);
                        }
                        break;
                }
                if (left < 0) left = 0;
                if (top < 0) top = 0;

                if (p.status == 'max') {
                    left = top = 0;
                }

                var f1 = function () {
                    parent.append(ins);
                    var box = profile.box,
                        root = profile.getRoot(),
                        adjustunit = function (v, emRate) {
                            return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                        };

                    if (p.iframeAutoLoad || p.ajaxAutoLoad)
                        ood.UI.Div._applyAutoLoad(profile);

                    if ((modal || p.modal) && !profile.$inModal)
                        box._modal(profile);

                    ins.activate();
                    var tt = profile._$rs_args, fun = function () {
                        if (profile.onShow) profile.boxing().onShow(profile);
                        delete profile.inShowing;
                        delete profile.$inThread;
                        ood.tryF(callback);

                        // attention animation
                        if (p && p.activeAnim) {
                            ood.asyRun(function () {
                                if (profile && !profile.destroyed)
                                    ins.setActiveAnim(p.activeAnim, true);
                            });
                        }

                    };
                    if (p.status == 'min')
                        box._min(profile, 'normal', fun, true);
                    else if (p.status == 'max')
                        box._max(profile, 'normal', fun, ignoreEffects);
                    else {
                        // resize immidiately here, maybe max here
                        ood.UI.$doResize(profile, (tt && tt[1]) || p.width, (tt && tt[2]) || p.height);
                        root.show(left || left === 0 ? adjustunit(left) : null, top || top === 0 ? adjustunit(top) : null, fun, null, ignoreEffects);
                        box._refreshRegion(profile);
                    }
                };

                profile.inShowing = 1;
                if (t = p.fromRegion) {
                    root.css({
                        'left': t.left + 'px',
                        'top': t.top + 'px',
                        'width': t.width + 'px',
                        'height': t.height + 'px'
                    }).addClass('dialog-animate-open');
                    setTimeout(f1, 300);
                }
                else
                    f1();
            });
        },
        hide: function (ignoreEffects) {
            this.each(function (profile) {
                var pro = profile.properties,
                    box = profile.box,
                    us = ood.$us(profile),
                    root = profile.getRoot();

                var fun = function () {
                    if (profile.inHiding) return;
                    profile.inHiding = 1;
                    if (profile.$inModal)
                        box._unModal(profile);
                    //max has dock prop
                    if (pro.status == 'max' || pro.status == 'min') {
                        var os = pro.status;
                        box._restore(profile);
                        pro.status = os;
                    }

                    var t = pro.fromRegion, f1 = function () {
                        delete profile.inHiding;
                        delete profile.$inThread;
                    };
                    if (t)
                        profile.$inThread = ood.Dom.animate({
                            border: 'solid 1px var(--border-color)',
                            background: 'var(--bg-secondary)',
                            opacity: .1
                        }, {
                            left: [profile.$px(pro.left), t.left],
                            top: [profile.$px(pro.top), t.top],
                            width: [profile.$px(pro.width), t.width],
                            height: [profile.$px(pro.height), t.height]
                        }, null, f1, 300, 0, 'expoOut').start();
                    else
                        f1();
                };
                root.hide(fun, null, ignoreEffects);
            });
            return this;
        },
        close: function (triggerEvent, ignoreEffects) {
            return this.each(function (profile) {
                if (false !== triggerEvent && profile.beforeClose && false === profile.boxing().beforeClose(profile))
                    return;
                if (profile.inClosing) return;
                profile.inClosing = 1;
                var pro = profile.properties, t = pro.fromRegion, fun = function () {
                    profile.boxing().destroy(ignoreEffects);
                    delete profile.inClosing;
                    delete profile.$inThread;
                };

                if (t)
                    profile.$inThread = ood.Dom.animate({
                        border: 'solid 1px var(--border-color)',
                        background: 'var(--bg-secondary)',
                        opacity: .1
                    }, {
                        left: [pro.left, t.left],
                        top: [pro.top, t.top],
                        width: [pro.width, t.width],
                        height: [pro.height, t.height]
                    }, null, fun, 300, 0, 'expoOut').start();
                else
                    fun();
            });
        },
        activate: function (flag) {
            var self = this, profile = this.get(0), ifocus;
            profile.box._active(profile, flag);
            this.getChildren(null, true).each(function (o) {
                if (ood.get(o, ['properties', 'defaultFocus'])) {
                    try {
                        ood.asyRun(function () {
                            o.boxing().activate()
                        })
                    } catch (e) {
                    }
                    ifocus = 1;
                    return false;
                }
            });
            ood.asyRun(function () {
                if (flag !== false && !ifocus) {
                    try {
                        profile.getSubNode('CAPTION').focus(true);
                    } catch (e) {
                    }
                }
                if (self.onActivated) self.onActivated(profile);
            });
        },
        isPinned: function () {
            return !!ood.get(this.get(0), ['properties', 'pinned']);
        },


        // Method to initialize theme
        initTheme: function () {
            // Prefer theme saved in localStorage
            var savedTheme = null;
            try {
                savedTheme = localStorage.getItem('dialog-theme');
            } catch (e) {
            }

            // If no saved theme, detect system theme
            var theme = savedTheme || this.detectSystemTheme();

            // Apply theme
            return this.setTheme(theme);
        },

        // Add method to auto-detect system theme
        detectSystemTheme: function () {
            // 
            var darkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            var hcMode = window.matchMedia && window.matchMedia('(prefers-contrast: more)').matches;
            
            if (hcMode) return 'high-contrast';
            return darkMode ? 'dark' : 'light';
        },

        // Modern initialization trigger
        DialogTrigger: function () {
            var profile = this.get(0);
            var prop = profile.properties

            // Initialize theme
            if (prop.theme) {
                this.setTheme(prop.theme);
            } else {
                // Restore theme from local storage
                var savedTheme = localStorage.getItem('dialog-theme');
                if (savedTheme) {
                    this.setTheme(savedTheme);
                }
            }

            // Initialize responsive design
            if (prop.responsive !== false) {
                this.adjustLayout();
                // Note: Window resize listeners need to be handled at application level
                // OOD framework has its own event handling mechanism
            }

            // Initialize accessibility
            this.enhanceAccessibility();
        },

        // Responsive layout adjustment
        adjustLayout: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    width = ood(document.body).cssSize().width,
                    screenWidth = ood.win.width(),
                    screenHeight = ood.win.height(),
                    dialogWidth = profile.$px(profile.properties.width),
                    dialogHeight = profile.$px(profile.properties.height),
                    border = profile.getSubNode('BORDER'),
                    tbar = profile.getSubNode('TBAR'),
                    caption = profile.getSubNode('CAPTION'),
                    barcmdl = profile.getSubNode('BARCMDL'),
                    barcmdr = profile.getSubNode('BARCMDR');

                // Adjust dialog size and position for small screens
                if (width < 768) {
                    root.addClass('dialog-mobile');

                    // Full screen or near full screen display on mobile
                    var mobileWidth = Math.min(screenWidth - 20, dialogWidth);
                    var mobileHeight = Math.min(screenHeight - 40, dialogHeight);

                    profile.properties.width = mobileWidth + 'px';
                    profile.properties.height = mobileHeight + 'px';
                    profile.properties.left = 10;
                    profile.properties.top = 20;

                    // Title bar layout adjustment
                    barcmdl.css({
                        'flex-direction': 'column',
                        'align-items': 'flex-start'
                    });

                    // Button group adjustment
                    barcmdr.css({
                        'flex-wrap': 'wrap',
                        'gap': '4px'
                    });

                    // Font size adjustment
                    caption.css('font-size', '0.9em');

                    // Force reposition to screen center
                    ood.asyRun(function () {
                        if (profile.renderId) {
                            root.css({
                                'left': '10px',
                                'top': '20px',
                                'width': mobileWidth + 'px',
                                'height': mobileHeight + 'px'
                            });
                        }
                    });
                } else {
                    root.removeClass('dialog-mobile');

                    // Restore desktop layout
                    barcmdl.css({
                        'flex-direction': '',
                        'align-items': ''
                    });

                    barcmdr.css({
                        'flex-wrap': '',
                        'gap': ''
                    });

                    caption.css('font-size', '');
                }

                // Mobile adaptation
                if (width < 768) {
                    root.addClass('dialog-mobile');

                    // Hide some buttons
                    var buttons = ['INFO', 'OPT', 'REFRESH', 'PIN'];
                    ood.arr.each(buttons, function (btn) {
                        profile.getSubNode(btn).css('display', 'none');
                    });
                } else {
                    root.removeClass('dialog-tiny');

                    // Restore button display
                    var prop = profile.properties;
                    profile.getSubNode('INFO').css('display', prop.infoBtn ? '' : 'none');
                    profile.getSubNode('OPT').css('display', prop.optBtn ? '' : 'none');
                    profile.getSubNode('REFRESH').css('display', prop.refreshBtn ? '' : 'none');
                    profile.getSubNode('PIN').css('display', prop.pinBtn ? '' : 'none');
                }
            });
        },

        // Enhance accessibility support
        enhanceAccessibility: function () {
            return this.each(function (profile) {
                var border = profile.getSubNode('BORDER'),
                    caption = profile.getSubNode('CAPTION'),
                    panel = profile.getSubNode('PANEL'),
                    buttons = ['MIN', 'MAX', 'CLOSE', 'INFO', 'OPT', 'REFRESH', 'PIN', 'LAND'];

                // Add ARIA attributes to dialog
                border.attr({
                    'role': 'dialog',
                    'aria-modal': 'true',
                    'aria-labelledby': caption.id()
                });

                caption.attr({
                    'role': 'heading',
                    'aria-level': '1',
                    'tabindex': '0'
                });

                panel.attr({
                    'role': 'document',
                    'aria-labelledby': caption.id()
                });

                // Add ARIA labels and keyboard support for buttons
                ood.arr.each(buttons, function (btnName) {
                    var btn = profile.getSubNode(btnName);
                    if (btn && !btn.isEmpty()) {
                        var label = btnName.toLowerCase();
                        var ariaLabel = {
                            'min': ood.getRes('UI.dialog.minimize'),
                            'max': ood.getRes('UI.dialog.maximize'),
                            'close': ood.getRes('UI.dialog.close'),
                            'info': ood.getRes('UI.dialog.showInfo'),
                            'opt': ood.getRes('UI.dialog.showOptions'),
                            'refresh': ood.getRes('UI.dialog.refresh'),
                            'pin': ood.getRes('UI.dialog.pin'),
                            'land': ood.getRes('UI.dialog.move')
                        }[label] || label + ' button';

                        btn.attr({
                            'role': 'button',
                            'aria-label': ariaLabel,
                            'tabindex': '0'
                        });

                    }
                });

            });
        }
    },
    Initialize: function () {
        var ns = this, t = ns.getTemplate();
        // 
        if (!t) {
            t = {};
        }
        // FRAMEBORDER
        if (!t.FRAME) t.FRAME = {};
        if (!t.FRAME.BORDER) t.FRAME.BORDER = {};

        ood.merge(t.FRAME.BORDER, {
            tabindex: '{tabindex}',
            className: 'ood-uiborder-outset ood-uiborder-box ood-uiborder-radius-big',
            TABSTOP1: {$order: -1},
            TBAR: {
                tagName: 'div',
                style: '{_displayBar}',
                className: 'ood-uibar-top',
                TBARTDL: {
                    className: 'ood-uibar-tdl ood-uibar ood-uiborder-radius-big-tl',
                    TBARTDLT: {
                        className: 'ood-uibar-tdlt'
                    }
                },
                TBARTDM: {
                    $order: 1,
                    className: 'ood-uibar-tdm ood-uibar',
                    TBARTDMT: {
                        className: 'ood-uibar-tdmt'
                    }
                },
                TBARTDR: {
                    $order: 2,
                    className: 'ood-uibar-tdr ood-uibar ood-uiborder-radius-big-tr',
                    TBARTDRT: {
                        className: 'ood-uibar-tdrt'
                    }
                },
                BARCMDL: {
                    $order: 3,
                    tagName: 'div',
                    className: 'ood-uibar-cmdl',
                    style: '{_align}',
                    RULER: {
                        className: 'ood-ui-ruler'
                    },
                    LTAGCMDS: {
                        tagName: 'span',
                        className: 'ood-ltag-cmds',
                        style: '{_ltagDisplay}',
                        text: "{ltagCmds}"
                    },
                    ICON: {
                        $order: 2,
                        className: 'oodcon {imageClass}  {picClass}',
                        style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{imageDisplay}{iconStyle}',
                        text: '{iconFontCode}'
                    },
                    CAPTION: {
                        tabindex: '{tabindex}',
                        className: "ood-title-node",
                        text: '{caption}',
                        $order: 3
                    }
                },
                BARCMDR: {
                    $order: 4,
                    tagName: 'div',
                    className: 'ood-uibar-cmdr',
                    RTAGCMDS: {
                        $order: 0,
                        tagName: 'span',
                        className: 'ood-rtag-cmds',
                        style: '{_rtagDisplay}',
                        text: "{rtagCmds}"
                    },
                    INFO: {
                        className: 'oodcon dialog-btn dialog-btn-info',
                        $fonticon: 'ood-uicmd-info',
                        $order: 2
                    },
                    OPT: {
                        className: 'oodcon dialog-btn dialog-btn-opt',
                        $fonticon: 'ood-uicmd-opt',
                        $order: 3
                    },
                    PIN: {
                        $order: 4,
                        className: 'oodcon dialog-btn dialog-btn-pin',
                        $fonticon: 'ood-uicmd-pin'
                    },
                    LAND: {
                        $order: 5,
                        className: 'oodcon dialog-btn dialog-btn-land',
                        $fonticon: 'ood-uicmd-land'
                    },
                    REFRESH: {
                        className: 'oodcon dialog-btn dialog-btn-refresh',
                        $fonticon: 'ood-uicmd-refresh',
                        $order: 6
                    },
                    MIN: {
                        $order: 7,
                        className: 'oodcon',
                        $fonticon: 'ood-uicmd-min',
                        style: '{minDisplay}'
                    },
                    RESTORE: {
                        $order: 8,
                        className: 'oodcon',
                        $fonticon: 'ood-uicmd-restore',
                        style: 'display:none;'
                    },
                    MAX: {
                        $order: 9,
                        className: 'oodcon',
                        $fonticon: 'ood-uicmd-max',
                        style: '{maxDisplay}'
                    },
                    CLOSE: {
                        $order: 10,
                        className: 'oodcon',
                        $fonticon: 'ood-uicmd-close',
                        style: '{closeDisplay}'
                    }
                },
                TBARTDB: {
                    $order: 5,
                    tagName: 'div',
                    className: 'ood-uibar-tdb ood-uiborder-inset ood-uiborder-radius'
                }
            },
            MAIN: {
                $order: 2,
                tagName: 'div',
                className: 'ood-uicon-main ood-uibar',
                MAINI: {
                    tagName: 'div',
                    className: 'ood-uicon-maini ood-uibar',
                    PANEL: {
                        tagName: 'div',
                        style: "{_panelstyle};{_overflow};",
                        className: 'ood-uibar ood-uicontainer',
                        text: '{html}' + ood.UI.$childTag
                    }
                }
            },
            BBAR: {
                $order: 3,
                tagName: 'div',
                className: 'ood-uibar-bottom',
                BBARTDL: {
                    $order: 1,
                    className: 'ood-uibar-tdl ood-uibar ood-uiborder-radius-big-bl'
                },
                BBARTDM: {
                    $order: 2,
                    className: 'ood-uibar-tdm ood-uibar'
                },
                BBARTDR: {
                    $order: 3,
                    className: 'ood-uibar-tdr ood-uibar ood-uiborder-radius-big-br'
                }
            },
            TABSTOP2: {$order: 9}
        }, 'all');
        t.$submap = ood.UI.$getTagCmdsTpl();

        ns.setTemplate(t);

        ood.alert = ns.alert;
        ood.confirm = ns.confirm;
        ood.pop = ns.pop;
        ood.prompt = ns.prompt;
    },
    Static: {
        Appearances: {
            KEY: {
                overflow: 'visible',
                transition: 'all 0.3s ease'
            },
            'BORDER': {
                'box-shadow': '0 8px 32px rgba(0,0,0,0.3)',
                'border-radius': '12px',
                'backdrop-filter': 'blur(10px)',
                transition: 'box-shadow 0.3s ease, transform 0.3s ease',
                outline: 0
            },
            'BORDER:hover': {
                'box-shadow': '0 12px 48px rgba(0,0,0,0.4)'
                //  'transform': 'translateY(-2px)'
            },
            'TBAR': {
                //   'background': 'linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)',
                height:'2.5em',
                'border-radius': '12px 12px 0 0',
                'padding': '8px 8px',
                'display': 'flex',
                'align-items': 'center',
                'justify-content': 'space-between',
                'border-bottom': '1px solid rgba(0,0,0,0.1)'
            },
            'PANEL': {
                position: 'relative',
                overflow: 'auto',
                'border-radius': '0 0 12px 12px',
                'background-color': 'var(--light-bg)',
                transition: 'background-color 0.3s ease'
            },
            'CAPTION': {
                display: 'inline',
                'font-weight': '600',
                'font-size': '1.1em',
                'color': 'var(--light-text)',
                'vertical-align': ood.browser.ie6 ? 'baseline' : 'middle'
            },
            'BARCMDL, BARCMDR': {
                'display': 'flex',
                'align-items': 'center',
                'gap': '8px'
            },
            // Button style enhancements
            'MIN, MAX, CLOSE, INFO, OPT, REFRESH, PIN, LAND': {
                'border-radius': '6px',
             //   'padding': '6px 8px',
                'transition': 'all 0.2s ease',
                'cursor': 'pointer',
                'font-size': '1.1em'
            },
            'MIN:hover, MAX:hover,  INFO:hover, OPT:hover, REFRESH:hover, PIN:hover, LAND:hover': {
                'background-color': 'rgba(0,0,0,0.1)',
                'color': 'var(--ood-success)',
                'transform': 'scale(1.1)'
            },
            'CLOSE:hover': {
                'background-color': 'var(--ood-error)',
                'color': 'var(--ood-text-inverse)'
            },
            'LTAGCMDS, RTAGCMDS': {
                padding: 0,
                margin: 0,
                'vertical-align': 'middle'
            },
            "TABSTOP1,TABSTOP2": {
                height: 0,
                width: "16px",
                display: 'inline',
                position: 'absolute'
            },
            'TBART, BBART': {
                'border-spacing': 0,
                'border-collapse': 'separate'
            },
            MAINI: {
                'padding-top': '.16667em'
            },
            // Responsive design styles
            '.dialog-mobile TBAR': {
                'flex-direction': 'column',
                'align-items': 'flex-start',
                'gap': '8px',
                'padding': '8px 12px'
            },
            '.dialog-mobile BARCMDR': {
                'flex-wrap': 'wrap'
            },
            '.dialog-mobile BORDER': {
                'border-radius': '8px',
                'margin': '10px'
            },
            '.dialog-tiny CAPTION': {
                'font-size': '0.9em'
            }
          
        },
        Behaviors: {
            DroppableKeys: ['PANEL'],
            PanelKeys: ['PANEL'],
            DraggableKeys: ['LAND'],
            NoDraggableKeys: ['LAND', 'MIN', 'MAX', 'RESTORE', 'PIN', 'INFO', 'OPT', 'CLOSE', 'REFRESH', 'CMD'],
            HoverEffected: {
                LAND: 'LAND',
                MIN: 'MIN',
                MAX: 'MAX',
                RESTORE: 'RESTORE',
                PIN: 'PIN',
                INFO: 'INFO',
                OPT: 'OPT',
                CLOSE: 'CLOSE',
                REFRESH: 'REFRESH',
                CMD: 'CMD',
                ICON: 'ICON'
            },
            ClickEffected: {
                LAND: 'LAND',
                MIN: 'MIN',
                MAX: 'MAX',
                RESTORE: 'RESTORE',
                PIN: 'PIN',
                INFO: 'INFO',
                OPT: 'OPT',
                CLOSE: 'CLOSE',
                REFRESH: 'REFRESH',
                CMD: 'CMD',
                ICON: 'ICON'
            },
            onMousedown: function (profile, e) {
                if (!profile.$inModal)
                    profile.box._active(profile);
            },
            afterKeydown: function (profile, e) {
                var keys = ood.Event.getKey(e);
                if ((e.$key || e.keyCode || e.charCode) == 9) {
                    // hack for ie tab event
                    if (ood.browser.ie) {
                        var id = "ood::_specialforietab";
                        if (!ood.Dom.byId(id))
                            ood('body').append("<div style='display:none;position:absolute;' id=" + id + "></div>");
                        ood.Dom.byId(id).innerHTML = ood.stamp() + "";
                    }
                    var n1 = profile.getSubNode("TABSTOP1").get(0),
                        n2 = profile.getSubNode("TABSTOP2").get(0),
                        m = ood.Event.getSrc(e), t;
                    if (keys.shiftKey) {
                        if (m !== n1)
                            n1.tabIndex = m.tabIndex;
                        n2.removeAttribute("tabIndex");
                    } else {
                        if (m !== n2)
                            n2.tabIndex = m.tabIndex;
                        n1.removeAttribute("tabIndex");
                    }
                    n1 = n2 = m = null;
                }
            },
            onDragstop: function (profile) {
                var p = profile.properties,
                    us = ood.$us(profile),
                    root = profile.getRoot(),
                    pos = root.cssPos(),
                    l = null, t = null;

                if (profile.$px(p.left) !== pos.left)
                    p.left = l = profile.$forceu(pos.left, null);
                if (profile.$px(p.top) !== pos.top)
                    p.top = t = profile.$forceu(pos.top, null);

                root.cssPos({left: l, top: t});

                if (profile.onMove && (l !== null || t !== null))
                    profile.boxing().onMove(profile, l, t, null, null);
            },
            TABSTOP1: {
                onFocus: function (profile, e, src) {
                    var tabindex = parseInt(ood.use(src).get(0).tabIndex || 1 + "", 10) - 1;
                    var children = profile.getRoot().get(0).getElementsByTagName('*'), t, n;
                    for (var i = 0, l = children.length, o; o = children[i]; i++) {
                        if (o.nodeType == 1) {
                            //cant set tabIndex to zero
                            if (o.tabIndex && o.tabIndex <= tabindex) {
                                if (!t) t = (n = o).tabIndex;
                                if (o.tabIndex > t) t = (n = o).tabIndex;
                                if (t === tabindex) break;
                            }
                        }
                    }
                    if (o) {
                        ood(o).focus(true);
                        ood.use(src).get(0).tabIndex = o.tabIndex;
                    }
                    else {
                        o = profile.getRoot().nextFocus(false, true, false);
                        ood(o).focus(true);
                        ood.use(src).get(0).tabIndex = o.get(0).tabIndex;
                    }
                    children = o = null;
                }
            },
            TABSTOP2: {
                onFocus: function (profile, e, src) {
                    var tabindex = parseInt(ood.use(src).get(0).tabIndex || 1 + "") + 1;
                    var children = profile.getRoot().get(0).getElementsByTagName('*'), t, n;
                    for (var i = 0, l = children.length, o; o = children[i]; i++) {
                        if (o.nodeType == 1) {
                            //cant set tabIndex to zero
                            if (o.tabIndex && o.tabIndex >= tabindex) {
                                if (!t) t = (n = o).tabIndex;
                                if (o.tabIndex < t) t = (n = o).tabIndex;
                                if (t === tabindex) break;
                            }
                        }
                    }
                    if (o) {
                        ood(o).focus(true);
                        ood.use(src).get(0).tabIndex = o.tabIndex;
                    }
                    else {
                        o = profile.getRoot().nextFocus(true, true, false);
                        ood(o).focus(true);
                        ood.use(src).get(0).tabIndex = o.get(0).tabIndex;
                    }
                    children = o = null;
                }
            },
            TBAR: {
                beforeMousedown: function (profile, e, src) {
                    if (profile.$inDesign) return;

                    if (ood.Event.getBtn(e) != "left") return;
                    if (profile.getKey(ood.Event.getSrc(e).parentNode.id) == profile.keys.BARCMDR) return;
                    if (profile.properties.status == "max") return false;

                    if (profile.properties.movable && !profile._locked) {
                        profile.box._active(profile);
                        var root = profile.getRoot(),
                            region = root.cssRegion(),
                            pregion = root.parent().cssRegion(),
                            dist = profile.getEmSize();
                        root.startDrag(e, {
                            dragDefer: 2,
                            maxLeftOffset: region.left,
                            maxRightOffset: pregion.width - region.left - dist,
                            maxTopOffset: region.top,
                            maxBottomOffset: pregion.height - region.top - dist,
                            magneticDistance: dist,
                            xMagneticLines: [0, pregion.width - region.width],
                            yMagneticLines: [0, pregion.height - region.height],
                            targetOffsetParent: root.parent()
                        });
                    }
                },
                onDblclick: function (profile, e, src) {
                    if (profile.getKey(ood.Event.getSrc(e).parentNode.id) == profile.keys.BARCMDR) return;
                    if (!profile.properties.maxBtn) return;
                    if (profile.properties.status == 'max')
                        profile.box._restore(profile);
                    else
                        profile.box._max(profile);
                }
            },
            PIN: {
                onClick: function (profile, e, src) {
                    var key = profile.keys.PIN, t = profile.properties, ins = profile.boxing();
                    if (profile.beforePin && false === profile.boxing().beforePin(profile, t.pinned))
                        return;

                    //set pinned status
                    t.pinned = !t.pinned;
                    //set appea
                    profile.getSubNode('PIN').tagClass('-checked', t.pinned);
                    //set lock flag for not movable
                    profile._locked = t.pinned;

                    // add/remove resize
                    if (t.resizer) {
                        if (!t.pinned) {
                            // if not in min mode
                            if (t.status != 'min')
                                ins._resizer();
                        } else if (profile.$resizer)
                        //profile.boxing().setResizer(false);
                            ins._unResizer();
                    }
                }
            },
            MIN: {
                onClick: function (profile, e, src) {
                    profile.box._min(profile, null, null, true);
                }
            },
            MAX: {
                onClick: function (profile, e, src) {
                    profile.box._max(profile, null, null, true);
                }
            },
            RESTORE: {
                onClick: function (profile, e, src) {
                    profile.box._restore(profile);
                }
            },
            LAND: {
                onClick: function (profile, e, src) {
                    profile.boxing().onLand(profile, e, src);
                }
            },
            PANEL: {
                onClick: function (profile, e, src) {
                    var p = profile.properties;
                    if (p.disabled) return false;
                    if (profile.onClickPanel)
                        return profile.boxing().onClickPanel(profile, e, src);
                }
            },

            INFO: {
                role: 'button',
                'aria-label': 'Information',
                onClick: function (profile, e, src) {
                    profile.boxing().onShowInfo(profile, e, src);
                }
            },
            OPT: {
                role: 'button',
                'aria-label': 'Options',
                onClick: function (profile, e, src) {
                    profile.boxing().onShowOptions(profile, e, src);
                }
            },
            REFRESH: {
                role: 'button',
                'aria-label': 'Refresh',
                onClick: function (profile, e, src) {
                    profile.boxing().onRefresh(profile);
                }
            },
            CLOSE: {
                role: 'button',
                'aria-label': 'Close dialog',
                onClick: function (profile, e, src) {
                    profile.boxing().close();
                }
            },
            CMD: {
                onClick: function (profile, e, src) {
                    var prop = profile.properties;
                    if (prop.disabled) return false;
                    if (profile.onCmd)
                        profile.boxing().onCmd(profile, ood.use(src).id().split('_')[1], e, src);
                    return false;
                }
            }
        },
        DataModel: {
            // Theme properties
            theme: {
                ini: 'light',
                listbox: ['light', 'dark', 'system'],
                action: function (v) {
                    // If system theme selected, detect system preference
                    if (v === 'system') {
                        v = this.boxing().detectSystemTheme();
                    }
                    this.boxing().setTheme(v);
                }
            },
            // Responsive design properties
            responsive: {
                ini: true,
                action: function (v) {
                    if (v) {
                        this.boxing().adjustLayout();
                        // Add resize listener
                        ood.Event.on(window, 'resize.' + this.get(0).serialId, this.boxing().adjustLayout.bind(this.boxing()));
                    } else {
                        // Remove resize listener
                        ood.Event.off(window, 'resize.' + this.get(0).serialId);
                    }
                }
            },
            rotate: null,
            selectable: true,
            tips: null,
            border: null,
            disabled: null,
            dock: 'none',
            showEffects: "Classic",
            hideEffects: "",
            initPos: {
                ini: 'center',
                listbox: ['auto', 'center']
            },
            iframeAutoLoad: {
                ini: "",
                action: function () {
                    ood.UI.Div._applyAutoLoad(this);
                }
            },
            ajaxAutoLoad: {
                ini: "",
                action: function () {
                    ood.UI.Div._applyAutoLoad(this);
                }
            },
            html: {
                html: 1,
                action: function (v, ov, force) {
                    this.getSubNode('PANEL').html(ood.adjustRes(v, 0, 1), null, null, force);
                }
            },

            // setCaption and getCaption
            caption: {
                ini: undefined,
                // ui update function when setCaption
                action: function (v) {
                    v = (ood.isSet(v) ? v : "") + "";
                    this.getSubNode('CAPTION').html(ood.adjustRes(v, true));
                }
            },
            image: {
                format: 'image',
                action: function (v) {
                    ood.UI.$iconAction(this);
                }
            },
            imagePos: {
                action: function (value) {
                    this.getSubNode('ICON').css('backgroundPosition', value || 'center');
                }
            },
            imageBgSize: {
                action: function (value) {
                    this.getSubNode('ICON').css('backgroundSize', value || '');
                }
            },
            imageClass: {
                ini: '',
                action: function (v, ov) {
                    ood.UI.$iconAction(this, 'ICON', ov);
                }
            },
            iconFontCode: {
                action: function (v) {
                    ood.UI.$iconAction(this);
                }
            },
            // setCaption and getCaption
            shadow: true,
            resizer: true,
            movable: true,

            displayBar: {
                ini: true,
                action: function (v) {
                    var o = this.getSubNode('TBAR');
                    if (v)
                        o.css('display', '');
                    else
                        o.css('display', 'none');
                }
            },

            minBtn: {
                ini: true,
                action: function (v) {
                    var o = this.getSubNode('MIN');
                    if (v)
                        o.setInlineBlock();
                    else
                        o.css('display', 'none');
                }
            },
            maxBtn: {
                ini: true,
                action: function (v) {
                    var o = this.getSubNode('MAX');
                    if (v)
                        o.setInlineBlock();
                    else
                        o.css('display', 'none');
                }
            },
            restoreBtn: {
                ini: true,
                action: function (v) {
                    var o = this.getSubNode('RESTORE');
                    if (v)
                        o.setInlineBlock();
                    else
                        o.css('display', 'none');
                }
            },
            infoBtn: {
                ini: false,
                action: function (v) {
                    this.getSubNode('INFO').css('display', v ? '' : 'none');
                }
            },
            optBtn: {
                ini: false,
                action: function (v) {
                    this.getSubNode('OPT').css('display', v ? '' : 'none');
                }
            },
            closeBtn: {
                ini: true,
                action: function (v) {
                    var o = this.getSubNode('CLOSE');
                    if (v)
                        o.setInlineBlock();
                    else
                        o.css('display', 'none');
                }
            },
            refreshBtn: {
                ini: false,
                action: function (v) {
                    this.getSubNode('REFRESH').css('display', v ? '' : 'none');
                }
            },
            pinBtn: {
                ini: false,
                action: function (v) {
                    var o = this.getSubNode('PIN');
                    if (v)
                        o.setInlineBlock();
                    else
                        o.css('display', 'none');
                }
            },
            landBtn: {
                ini: false,
                action: function (v) {
                    var o = this.getSubNode('LAND');
                    if (v)
                        o.setInlineBlock();
                    else
                        o.css('display', 'none');
                }
            },
            width: {
                $spaceunit: 1,
                ini: '25em'
            },
            height: {
                $spaceunit: 1,
                ini: '36em'
            },
            minWidth: 200,
            minHeight: 100,

            position: 'absolute',
            fromRegion: {
                hidden: true,
                ini: null
            },
            modal: {
                ini: false,
                action: function (v) {
                    if (this.box) {
                        if (v) this.box._modal(this);
                        else this.box._unModal(this);
                    }
                }
            },
            status: {
                ini: 'normal',
                listbox: ['normal', 'min', 'max'],
                action: function (v, o) {
                    var self = this, b = self.box;
                    if (v == 'min') b._min(self, o, null, true);
                    else if (v == 'max') b._max(self, o, null, true);
                    else b._restore(self, o);
                }
            },
            hAlign: {
                ini: 'left',
                listbox: ['left', 'center', 'right'],
                action: function (v) {
                    this.getSubNode("BARCMDL").css('textAlign', v);
                }
            },
            tagCmds: {
                ini: [],
                action: function () {
                    this.boxing().refresh();
                }
            },
            //hide props( with px)
            $hborder: 1,
            $vborder: 1
        },
        EventHandlers: {
            onIniPanelView: function (profile) {
            },
            onShow: function (profile) {
            },
            onActivated: function (profile) {
            },
            beforePin: function (profile, value) {
            },
            beforeStatusChanged: function (profile, oldStatus, newStatus) {
            },
            afterStatusChanged: function (profile, oldStatus, newStatus) {
            },
            onClickPanel: function (profile, e, src) {
            },

            onLand: function (profile, e, src) {
            },
            beforeClose: function (profile) {
            },
            onShowInfo: function (profile, e, src) {
            },
            onShowOptions: function (profile, e, src) {
            },
            onRefresh: function (profile) {
            },
            onCmd: function (profile, cmdkey, e, src) {
            }
        },
        RenderTrigger: function () {
            var ns = this;
            ns.destroyTrigger = function () {
                var s = this;
                if (s.$inModal) s.box._unModal(s);
            };
        },


        LayoutTrigger: function () {
            var self = this, t = self.properties;
            // ensure modal
            if (t.modal) {
                var p = self.$modalDiv && self.$modalDiv.parent(), b = self.box;
                if (p && p.get(0) && p.get(0) !== self.getRootNode()) {
                    b._unModal(self);
                }
                b._modal(self);

                // Enhance modal background styles
                if (self.$modalDiv) {
                    self.$modalDiv.addClass('dialog-modal-backdrop');
                }
            }

            // Modern feature initialization
            self.boxing().DialogTrigger();

            // Remove calls to non-existent methods
            self.boxing().initTheme();

            // Set responsive layout
            self.boxing().adjustLayout();

            // Add system theme change listener
            if (window.matchMedia) {
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function (e) {
                    if (self.properties.theme === 'system' || !self.properties.theme) {
                        self.boxing().setTheme(e.matches ? 'dark' : 'light');
                    }
                });
            }
        },
        _prepareData: function (profile) {
            var data = arguments.callee.upper.call(this, profile),
                nodisplay = 'display:none';

            data._displayBar = data.displayBar ? '' : nodisplay;
            data.minDisplay = data.minBtn ? '' : nodisplay;
            data.maxDisplay = data.maxBtn ? '' : nodisplay;
            data.infoDisplay = data.infoBtn ? '' : nodisplay;
            data.optDisplay = data.optBtn ? '' : nodisplay;
            data.closeDisplay = data.closeBtn ? '' : nodisplay;
            data.pinDisplay = data.pinBtn ? '' : nodisplay;
            data.landDisplay = data.landBtn ? '' : nodisplay;
            data.refreshDisplay = data.refreshBtn ? '' : nodisplay;
            data._align = 'text-align:' + data.hAlign + ';';

            var status = profile.properties.status;
            if (status == 'min' || status == 'max')
                profile.$noR = 1;
            if (ood.isStr(data.overflow))
                data._overflow = data.overflow.indexOf(':') != -1 ? (data.overflow) : (data.overflow ? ("overflow:" + data.overflow) : "");

            if (!ood.isEmpty(data.tagCmds))
                this._prepareCmds(profile, data);

            return data;
        },

        //ov from design mode
        _min: function (profile, status, effectcallback, ignoreEffects) {
            var o = profile.getRoot(),
                box = profile.box,
                p = o.parent(),
                ins = profile.boxing(),
                t = profile.properties,
                a = ood.Dom._getEffects(t.showEffects, 1);
            if (profile.$inThread) profile.$inThread.abort();
            if (!status) status = t.status;
            if (profile.beforeStatusChanged && false === profile.boxing().beforeStatusChanged(profile, 'min', status))
                return;

            // unMax
            if (status == 'max')
                box._unMax(profile);
            // keep restore values
            else
                box._refreshRegion(profile);

            // hide those
            profile.getSubNodes(['PANEL', 'BBAR']).css('display', 'none');

            if (t.minBtn) {
                // show restore button
                if (t.restoreBtn)
                    profile.getSubNode('RESTORE').setInlineBlock();
                // hide min button
                profile.getSubNode('MIN').css('display', 'none');
            }

            // lockResize function
            if (t.resizer && profile.$resizer)
                ins._unResizer();

            //set it before resize
            t.status = 'min';

            var h1 = o.height(),
                h2 = profile.getSubNode('BORDER').height(),
                h = profile.getSubNode('TBAR').height();
            // resize
            o.cssSize({width: t.minWidth, height: h + h1 - h2}, true);
            if (profile.afterStatusChanged) profile.boxing().afterStatusChanged(profile, 'min', status);

            if (a && ood.browser.ie678)
                ood.filter(a.params, function (o, i) {
                    return !!ood.Dom._cssfake[i];
                });
            o.show(null, null, effectcallback, null, ignoreEffects);
        },
        _max: function (profile, status, effectcallback, ignoreEffects) {
            var o = profile.getRoot(),
                box = profile.box,
                ins = profile.boxing(),
                p = o.parent(),
                t = profile.properties,
                a = ood.Dom._getEffects(t.showEffects, 1);
            if (!status) status = t.status;
            if (profile.$inThread) profile.$inThread.abort();

            if (profile.beforeStatusChanged && false === profile.boxing().beforeStatusChanged(profile, 'max', status))
                return;

            // if from normal status
            if (status == 'min')
            //unset min
                box._unMin(profile);
            else
                box._refreshRegion(profile);

            // hide pin button
            if (t.pinBtn)
                profile.getSubNode('PIN').css('display', 'none');
            if (t.maxBtn) {
                // hide max button
                profile.getSubNode('MAX').css('display', 'none');
                // show restore button
                if (t.restoreBtn)
                    profile.getSubNode('RESTORE').setInlineBlock();
            }

            if (t.resizer && profile.$resizer)
                ins._unResizer();

            t.status = 'max';

            ins.setDock('cover', true);
            if (profile.afterStatusChanged) profile.boxing().afterStatusChanged(profile, 'max', status);
            if (a && ood.browser.ie678)
                ood.filter(a.params, function (o, i) {
                    return !!ood.Dom._cssfake[i];
                });
            o.show(null, null, effectcallback, null, ignoreEffects);
        },
        _restore: function (profile, status) {
            var o = profile.getRoot(),
                box = profile.box,
                t = profile.properties;
            if (!status) status = t.status;
            t.status = 'normal';

            if (profile.beforeStatusChanged && false === profile.boxing().beforeStatusChanged(profile, 'normal', status))
                return;

            // if from max
            if (status == 'max') box._unMax(profile);
            if (status == 'min') box._unMin(profile);

            profile.getSubNode('BORDER').ieRemedy();

            // hide restore button
            profile.getSubNode('RESTORE').css('display', 'none');
        },
        _unMax: function (profile) {
            var t = profile.properties,
                ins = profile.boxing();
            profile.getSubNode('MAX').setInlineBlock();
            if (t.pinBtn)
                profile.getSubNode('PIN').setInlineBlock();

            if (t.resizer && !t.pinned) {
                ins._resizer();
            }

            ins.setDock('none');

            // resize
            profile.adjustSize(true);
            if (profile.afterStatusChanged) profile.boxing().afterStatusChanged(profile, 'normal', status);
        },
        _unMin: function (profile) {
            var t = profile.properties,
                ins = profile.boxing();
            profile.getSubNodes(['PANEL', 'BBAR']).css('display', 'block');
            profile.getSubNode('MIN').setInlineBlock();

            if (t.resizer && !t.pinned) {
                ins._resizer();
            }

            profile.getRoot().cssSize({width: t.width, height: t.height});
            // resize
            profile.adjustSize(true);
        },
        _active: function (profile, flag) {
            var self = this;
            if (profile.$inDesign) return;

            if (flag !== false && ood.$cache.unique.activeWndId == profile.$xid) return;

            self._deActive();
            if (flag !== false) {
                var o = ood(profile.domId),
                    //in ie, .children can't get the same thread added node(modal div,  here)
                    t1 = o.topZindex(),
                    t2 = parseInt(o.css('zIndex'), 0);
                o.css('zIndex', t1 > t2 ? t1 : t2);

                profile.getSubNode('TBAR').tagClass('-focus');
                ood.$cache.unique.activeWndId = profile.$xid;
            }
        },
        _deActive: function () {
            var profile;
            if (profile = ood.UI._cache['$' + ood.$cache.unique.activeWndId])
                profile.getSubNode('TBAR').tagClass('-focus', false);
            delete ood.$cache.unique.activeWndId;
        },
        _modal: function (profile) {
            var s = profile.getRoot(), temp, p = s.parent(), cover;
            if (!p.isEmpty()) {
                if (!profile.$inModal) {
                    cover = profile.$modalDiv;
                    if (!cover || !cover.get(0) || !cover.get(0).parentNode) {
                        cover = profile.$modalDiv = ood.create("<div class='ood-cover ood-custom ood-cover-modal' style='left:0;top:0;position:absolute;overflow:hidden;display:block;z-index:0;'></div>");
                        cover.setSelectable(false);
                    }
                    p.append(cover);

                    // attach onresize event
                    if (p.get(0) === document.body || p.get(0) === document || p.get(0) === window) p = ood.win;

                    cover.css({
                        display: 'block',
                        width: Math.max(p.width(), p.scrollWidth()) + 'px',
                        height: Math.max(p.height(), p.scrollHeight()) + 'px'
                    })
                        .onMousedown(function () {
                            return profile.$inDesign ? null : false
                        })
                        .topZindex(true);

                    if (profile.$inDesign) cover.onClick(function () {
                        s.onClick(true)
                    });

                    p.onSize(function (node) {
                        node = ood(node);


                        var w = node.width() + "px", h = node.height() + "px";
                        // set widht/height first
                        cover.css({width: w, height: h});
                        ood.asyRun(function () {
                            var w = Math.max(node.width(), node.scrollWidth()) + "px",
                                h = Math.max(node.height(), node.scrollHeight()) + "px";
                            cover.css({width: w, height: h});
                        });
                    }, "dialog:" + profile.serialId);

                    var i = (parseInt(cover.css('zIndex'), 10) || 0) + 1;
                    s.css('zIndex', i);

                    if (i >= ood.Dom.TOP_ZINDEX)
                        ood.Dom.TOP_ZINDEX = i + 1;


                    profile.$inModal = true;
                    // avoid triggering the previously set trigger
                    p.setBlurTrigger(profile.$xid + "_anti", true, ood([cover.get(0), profile.getRootNode()]));
                }
            }
        },
        _unModal: function (profile) {
            if (profile.$inModal) {
                // detach onresize event
                var p = profile.$modalDiv.parent();
                if (p.get(0) === document.body || p.get(0) === document || p.get(0) === window)
                    p = ood.win;

                p.onSize(null, "dialog:" + profile.serialId);

                profile.getRoot().css('zIndex', 0);

                profile.$modalDiv.css('display', 'none');
                var node = profile.getSubNode('BORDER');
                if (!node.isEmpty())
                    node.append(profile.$modalDiv);

                profile.$inModal = false;
                p.setBlurTrigger(profile.$xid + "_anti");
            }
        },
        _refreshRegion: function (profile) {
            if (!profile.renderId) return;
            var prop = profile.properties,
                root = profile.getRoot(),
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                nr = root.cssRegion();

            nr.left = adjustunit(nr.left);
            nr.top = adjustunit(nr.top);
            nr.width = adjustunit(nr.width);
            nr.height = adjustunit(nr.height);

            return ood.merge(prop, nr, function (o, i) {
                return prop[i] != 'auto'
            });
        },

        _adjust: function (dialog, caption, content, dftTilte, left, top) {
            caption = ood.adjustRes(caption || '');
            if (!ood.isSet(content) || content === "") {
                content = caption;
                caption = dftTilte || "";
            }

            var node = dialog.$div.reBoxing(),
                ID = 'ood:temp:dialog',
                me = arguments.callee,
                w, h;

            if (!ood.Dom.byId(ID)) {
                n2 = me._cache = node.clone(false);
                ood('body').append(n2);
                n2.css({
                    overflow: 'visible',
                    position: 'absolute',
                    visibility: 'visible',
                    left: ood.Dom.HIDE_VALUE,
                    top: ood.Dom.HIDE_VALUE
                })
                    .id(ID, true);
            }
            var n2 = me._cache;
            n2.width('auto').height('auto');
            n2.html(content, false);
            var size = n2.cssSize();
            size.width += 10;
            size.height += 10;

            node.html(content);

            if (size.width > 500) {
                size.width = 500;
                n2.width(500);
                size.height = n2.offsetHeight() + 10;
                n2.width('auto');
            }
            n2.html("", false);
            size.height += 10;
            if (size.height > 400) size.height = 400;
            if (size.width < 150) size.width = 150;
            if (size.height < 30) size.height = 30;

            node.cssSize(size).css('overflow', 'auto').show();

            var fs = dialog.getRoot()._getEmSize();
            w = size.width + fs * 2;
            h = size.height + fs * 7.5;
            dialog.setCaption(caption).setWidth(w).setHeight(h);
            return {width: w, height: h};
        },
        alert: function (title, content, onClose, btnCap, left, top, parent, subId, noCache) {
            var me = arguments.callee, dialog;
            if (noCache || !(dialog = me.dialog) || !dialog.get(0) || (!dialog.get(0).renderId)) {
                dialog = new ood.UI.Dialog({
                    overflow: 'hidden',
                    minBtn: false,
                    maxBtn: false,
                    pinBtn: false,
                    resizer: false
                }, {
                    beforeClose: function () {
                        ood.tryF(dialog._$onClose);
                        dialog._$onClose = null;
                        if (!noCache) {
                            dialog.hide();
                            return false;
                        }
                    },
                    onHotKeydown: function (p, k) {
                        if (k.key == 'esc')
                            dialog.close();
                    }
                });

                var cmd = dialog.$cmd = new ood.UI.Div({
                        //  height:'2.5em',
                        dock: 'bottom',
                        zIndex: 10
                    }, null, null, null, {KEY: "text-align:center;padding-top:.5em"}),

                    btn = dialog.$btn = new ood.UI.SButton({
                            position: 'relative',
                            tabindex: 1
                        },
                        {
                            onClick: function () {
                                dialog.close();
                            },
                            onHotKeydown: function (p, k) {
                                if (k.key == 'enter')
                                    dialog.close();
                            }
                        }, null, null, {KEY: 'margin:0 .5em'});
                cmd.append(btn);

                var div = dialog.$div = new ood.UI.Div({
                    left: 10,
                    top: 10
                });
                dialog.append(cmd).append(div).render();

                if (!noCache)
                    me.dialog = dialog;
            }
            dialog._$onClose = onClose;

            dialog.$btn.setCaption("&nbsp;&nbsp;" + (btnCap || ood.wrapRes('$inline.ok')) + "&nbsp;&nbsp;");

            var size = ood.UI.Dialog._adjust(dialog, title, content, "Alert");

            if (parent && parent["ood.UI"]) parent = parent.getContainer(subId);
            if (!ood.isSet(parent)) parent = ood('body');

            dialog.show(parent, true, left, top);
            ood.resetRun("dlg_focus:" + dialog.get(0).$xid, function () {
                dialog.$btn.activate();
            });
            return dialog;
        },
        confirm: function (title, caption, onYes, onNo, btnCapYes, btnCapNo, left, top, parent, subId, noCache) {
            var me = arguments.callee, dialog;

            if (noCache || !(dialog = me.dialog) || !dialog.get(0) || (!dialog.get(0).renderId)) {
                dialog = new ood.UI.Dialog({
                    overflow: 'hidden',
                    minBtn: false,
                    maxBtn: false,
                    pinBtn: false,
                    resizer: false
                }, {
                    beforeClose: function () {
                        if (!dialog._$_clicked)
                            ood.tryF(dialog._$onNo, ['close']);
                        else
                            delete dialog._$_clicked;
                        dialog._$onYes = dialog._$onNo = null;
                        if (!noCache) {
                            dialog.hide();
                            return false;
                        }
                    },
                    onHotKeydown: function (p, k) {
                        if (k.key == 'esc')
                            dialog.close();
                    }
                });

                var cmd = dialog.$cmd = new ood.UI.Div({
                        height: '3.5em',
                        dock: 'bottom',
                        zIndex: 10
                    }, null, null, null, {KEY: "text-align:center;padding-top:.5em"}),
                    btn = dialog.$btn1 = new ood.UI.SButton({
                            tabindex: 1,
                            position: 'relative'
                        },
                        {
                            onClick: function () {
                                ood.tryF(dialog._$onYes, ['yes']);
                                dialog._$_clicked = 1;
                                dialog.close();
                            }
                        }, null, null, {KEY: 'margin:0 .5em'});
                cmd.append(btn);

                btn = dialog.$btn2 = new ood.UI.SButton({
                        tabindex: 1,
                        position: 'relative'
                    },
                    {
                        onClick: function () {
                            ood.tryF(dialog._$onNo, ['no']);
                            dialog._$_clicked = 1;
                            dialog.close();
                        }
                    }, null, null, {KEY: 'margin:0 .5em'});
                cmd.append(btn);

                var div = dialog.$div = new ood.UI.Div({
                    left: 10,
                    top: 10
                });
                dialog.append(cmd).append(div).render();

                if (!noCache)
                    me.dialog = dialog;
            }
            dialog._$onYes = onYes;
            dialog._$onNo = onNo;
            delete dialog._$_clicked;
            dialog.$btn1.setCaption("&nbsp;&nbsp;" + (btnCapYes || ood.wrapRes('$inline.yes')) + "&nbsp;&nbsp;");
            dialog.$btn2.setCaption("&nbsp;&nbsp;" + (btnCapNo || ood.wrapRes('$inline.no')) + "&nbsp;&nbsp;");
            var size = ood.UI.Dialog._adjust(dialog, title, caption, "Confirm");

            if (parent && parent["ood.UI"]) parent = parent.getContainer(subId);
            if (!ood.isSet(parent)) parent = ood('body');

            dialog.show(parent, true, left, top);
            ood.resetRun("dlg_focus:" + dialog.get(0).$xid, function () {
                dialog.$btn2.activate();
            });
            return dialog;
        },
        pop: function (title, content, btnCap, left, top, parent, subId) {
            var dialog = new ood.UI.Dialog({
                    overflow: 'hidden',
                    minBtn: false,
                    maxBtn: false,
                    pinBtn: false,
                    resizer: false
                }, {
                    onHotKeydown: function (p, k) {
                        if (k.key == 'esc')
                            dialog.close();
                    }
                }),

                cmd = dialog.$cmd = new ood.UI.Div({
                    height: '2.5em',
                    dock: 'bottom',
                    zIndex: 10
                }, null, null, null, {KEY: "text-align:center;padding-top:.5em"})
                    .append(dialog.$btn = new ood.UI.SButton({
                            caption: "&nbsp;&nbsp;" + (btnCap || '$inline.ok') + "&nbsp;&nbsp;",
                            tabindex: 1,
                            position: 'relative'
                        },
                        {
                            onClick: function () {
                                dialog.destroy();
                            },
                            onHotKeydown: function (p, k) {
                                if (k.key == 'enter')
                                    dialog.close();
                            }
                        }, null, null, {KEY: 'margin:0 .5em'})),

                div = dialog.$div = new ood.UI.Div({
                    left: 10,
                    top: 10,
                    width: '7em'
                }).setCustomStyle({
                    KEY: 'overflow:visible'
                });

            dialog.append(cmd).append(div).render();

            var size = ood.UI.Dialog._adjust(dialog, title, content, "Message");

            if (parent && parent["ood.UI"]) parent = parent.getContainer(subId);
            if (!ood.isSet(parent)) parent = ood('body');

            dialog.show(parent, false, left, top);

            ood.resetRun("dlg_focus:" + dialog.get(0).$xid, function () {
                dialog.$btn.activate();
            });
            return dialog;
        },
        prompt: function (title, caption, content, onYes, onNo, btnCapYes, btnCapNo, left, top, parent, subId, noCache) {
            var dialog,
                me = arguments.callee;
            if (noCache || !(dialog = me.dialog) || !dialog.get(0) || (!dialog.get(0).renderId)) {
                dialog = new ood.UI.Dialog({
                    overflow: 'hidden',
                    minBtn: false,
                    maxBtn: false,
                    pinBtn: false,
                    left: left || 200,
                    top: top || 200,
                    width: '25em',
                    height: '11em',
                    conDockPadding: {left: '.5em', right: '.5em', top: 0, bottom: 0}
                }, {
                    beforeClose: function () {
                        if (!dialog._$_clickYes)
                            ood.tryF(dialog._$onNo, ["no"]);
                        else
                            delete dialog._$_clickYes;

                        dialog._$input.setValue('', false, 'prompt');
                        dialog._$onYes = dialog._$onNo = null;
                        if (!noCache) {
                            dialog.hide();
                            return false;
                        }
                    }
                });
                var con = dialog._$caption = new ood.UI.Div({
                        height: '1.5em',
                        dock: 'top'
                    }),
                    cmd = new ood.UI.Div({
                        height: '2.5em',
                        dock: 'bottom',
                        zIndex: 10
                    }, null, null, null, {KEY: "text-align:center;padding-top:.5em"})
                        .append(dialog.$btn1 = new ood.UI.SButton({
                                position: 'relative',
                                tabindex: 1
                            },
                            {
                                onClick: function () {
                                    if (false !== ood.tryF(dialog._$onYes, [dialog._$input.getUIValue()])) {
                                        dialog._$_clickYes = 1;
                                        dialog.close();
                                    }
                                }
                            }, null, null, {KEY: 'margin:0 .5em'}));

                cmd.append(dialog.$btn2 = new ood.UI.SButton({
                        tabindex: 1,
                        position: 'relative'
                    },
                    {
                        onClick: function () {
                            dialog.close();
                        }
                    }, null, null, {KEY: 'margin:0 .5em'}));
                var inp = dialog._$input = new ood.UI.Input({
                    dock: 'fill',
                    multiLines: true
                })
                dialog.append(con).append(cmd).append(inp).render();
                if (!noCache)
                    me.dialog = dialog;
            }
            dialog.setCaption(title || 'Prompt');
            dialog._$caption.setHtml(caption || "");
            dialog._$input.setValue(content || "", true, 'prompt');
            dialog._$onYes = onYes;
            dialog._$onNo = onNo;
            delete dialog._$_clickYes;
            dialog.$btn1.setCaption("&nbsp;&nbsp;" + (btnCapYes || ood.wrapRes('$inline.ok')) + "&nbsp;&nbsp;");
            dialog.$btn2.setCaption("&nbsp;&nbsp;" + (btnCapNo || ood.wrapRes('$inline.cancel')) + "&nbsp;&nbsp;");

            if (parent && parent["ood.UI"]) parent = parent.getContainer(subId);
            if (!ood.isSet(parent)) parent = ood('body');

            dialog.show(parent, true, left, top);
            ood.resetRun("dlg_focus:" + dialog.get(0).$xid, function () {
                dialog._$input.activate();
            });
            return dialog;
        },
        //
        _onresize: function (profile, width, height, force) {
            if (width && profile.properties.status == 'min')
                width = profile.properties.minWidth;

            var prop = profile.properties,
                us = ood.$us(profile),
                adjustunit = function (v, emRate) {
                    return profile.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                size = arguments.callee.upper.apply(this, arguments),
                isize = {},
                v0 = profile.getSubNode('BORDER'),
                v1 = profile.getSubNode('TBAR'),
                v2 = profile.getSubNode('PANEL'),
                v4 = profile.getSubNode('BBAR'),
                v5 = profile.getSubNode('MAIN'),
                v6 = profile.getSubNode('MAINI'),
                cb1 = v0.contentBox(),
                cb2 = v2.contentBox(),
                h1, h4, t;
            // caculate with px
            if (width) width = profile.$px(width);
            if (height) height = profile.$px(height);
            if (size.left) size.left = profile.$px(size.left);
            if (size.top) size.top = profile.$px(size.top);
            if (size.width) size.width = profile.$px(size.width);
            if (size.height) size.height = profile.$px(size.height);

            if (height) {
                if (height == 'auto') {
                    isize.height = height;
                } else {
                    //force to get height
                    h1 = v1.offsetHeight(true);
                    h4 = v4.offsetHeight(true);
                    if ((t = size.height - h1 - h4) > 0)
                        isize.height = t;
                }
            }
            if (height)
                isize.height = isize.height - v6._paddingH() - (cb1 ? 0 : v0._borderH()) - (cb2 ? 0 : v2._borderH());

            if (width)
                isize.width = size.width
                    - (parseFloat(v6.css('paddingRight')) || 0) - (parseFloat(v6.css('borderRightWidth')) || 0)
                    - (parseFloat(v5.css('paddingLeft')) || 0) - (parseFloat(v5.css('borderLeftWidth')) || 0);
            -(cb1 ? 0 : v0._borderW()) - (cb2 ? 0 : v2._borderW())

            if (width && us > 0) isize.width = adjustunit(isize.width);
            if (height && us > 0) isize.height = adjustunit(isize.height);

            v2.cssSize(isize, true);
            if (width) {
                ood.UI._adjustConW(profile, v2, isize.width);
            }
        }
    }
});
ood.Class("ood.UI.FormLayout", ["ood.UI", "ood.absList"], {
    Initialize: function () {
        this.addTemplateKeys(['ITEM', 'TABLE', 'CBORDER', 'CBT', 'CBL', 'HOLDER', 'SPREADER']);
    },
    Instance: {
        //  iniProp 
        iniProp: {

            "name": "TestForm",
            "showEffects": "Classic",
            "width": "50em",
            "height": "20em",
            "visibility": "visible",
            "floatHandler": false,
            "defaultRowHeight": 35,
            "defaultColWidth": 150,
            "layoutData": {
                "rows": 3,
                "cols": 2,
                "merged": [
                    {
                        "row": 0,
                        "col": 0,
                        "rowspan": 1,
                        "colspan": 2,
                        "removed": false
                    }
                ],
                "rowSetting": {
                    "1": {
                        "manualHeight": 56
                    },
                    "2": {
                        "manualHeight": 35
                    },
                    "3": {
                        "manualHeight": 142
                    }
                },
                "colSetting": {
                    "A": {
                        "manualWidth": 150
                    },
                    "B": {
                        "manualWidth": 525
                    }
                },
                "cells": {
                    "A1": {
                        "value": "",
                        "style": {
                            "textAlign": "center",
                            "fontSize": "28px"
                        }
                    },
                    "A2": {
                        "value": "",
                        "style": {
                            "textAlign": "center"
                        }
                    },
                    "B2": {
                        "value": "",
                        "style": {
                            "textAlign": "left",
                            "paddingLeft": "10px"
                        }
                    },
                    "A3": {
                        "value": "",
                        "style": {
                            "textAlign": "center"
                        }
                    },
                    "B3": {
                        "value": "",
                        "style": {
                            "textAlign": "left",
                            "paddingLeft": "10px",
                            "fontSize": "14px",
                            "color": "#666"
                        }
                    }
                }

            }
        },

        _isDesignMode: function () {
            return this.getMode() == "design";
        },
        getContainer: function (subId) {
            var prf = this.get(0);
            if (prf.ItemIdMapSubSerialId && prf.ItemIdMapSubSerialId[subId]) {
                return arguments.callee.upper.apply(this, [subId]);
            } else {
                return this.getSubNode("POOL");
            }
        },
    },


    setChildren: function (childrens, prf) {
        var host = this, items = [], ctx = host.getModule().getCtxComponents();
        this.removeChildren(true, true, true);
        ood.each(childrens, function (o) {
            if (o && o.alias) {
                if (o.alias == 'PAGECTX') {
                    ctx.boxing().removeChildren(true, true, true);
                    host.getModule().addCtxComponents(o.children);
                } else {
                    items.push(o);
                }
            }
        });
        ood.addChild({children: items}, host, host.getModule(), host.getModule());
    },

    // 
    setTheme: function (theme) {


        // CSS
        if (!document.getElementById('input-theme-css')) {
            var link = document.createElement('link');
            link.id = 'input-theme-css';
            link.rel = 'stylesheet';
            link.href = '/ood/css/formlayout-themes.css';
            document.head.appendChild(link);
        }


        return this.each(function (profile) {
            // 
            profile.properties.theme = theme;

            // OODAPI
            if (window.ood && ood.setGlobalTheme) {
                ood.setGlobalTheme(theme);
            } else {
                // data-theme
                document.documentElement.setAttribute('data-theme', theme);
                localStorage.setItem('global-theme', theme);
            }
        });
    },

    // 
    FormLayoutTrigger: function () {
        var profile = this.get(0);
        var prop = profile.properties,
            boxing = this;

        // 
        if (prop.theme) {
            boxing.setTheme(prop.theme);
        } else {
            // 
            var savedTheme = localStorage.getItem('formlayout-theme');
            if (savedTheme) {
                boxing.setTheme(savedTheme);
            }
        }

        // 
        if (prop.responsive !== false) {
            boxing.adjustLayout();
            // 
            // OOD
        }

        // 
        boxing.enhanceAccessibility();
    },


    // 
    getTheme: function () {
        var profile = this.get(0);
        return profile.properties.theme || localStorage.getItem('formlayout-theme') || 'light';
    },

    // 
    toggleDarkMode: function () {
        var currentTheme = this.getTheme();
        this.setTheme(currentTheme === 'light' ? 'dark' : 'light');
    },

    // 
    toggleHighContrast: function () {
        var currentTheme = this.getTheme();
        this.setTheme(currentTheme === 'highcontrast' ? 'light' : 'highcontrast');
    },

    // 
    adjustLayout: function () {
        return this.each(function (profile) {
            var root = profile.getRoot(),
                width = ood(document.body).cssSize().width,
                box = profile.getSubNode('BOX'),
                table = profile.getSubNode('TABLE'),
                items = profile.getSubNode('ITEM', true),
                prop = profile.properties;

            // 
            if (width < 768) {
                root.addClass('formlayout-mobile');

                // 
                if (table && !table.isEmpty()) {
                    table.css({
                        'font-size': '0.9em'
                    });
                }
                items.css({
                    'padding': '4px 6px',
                    'font-size': '0.9em'
                });

                // 
                if (profile.boxing()._isDesignMode()) {
                    if (prop.defaultRowHeight > 40) {
                        profile.getSubNode('BOX').css('--row-height', '40px');
                    }
                    if (prop.defaultColWidth > 100) {
                        profile.getSubNode('BOX').css('--col-width', '100px');
                    }
                }
            } else {
                root.removeClass('formlayout-mobile');

                // 
                if (table && !table.isEmpty()) {
                    table.css({
                        'font-size': ''
                    });
                }
                items.css({
                    'padding': '',
                    'font-size': ''
                });

                // 
                if (profile.boxing()._isDesignMode()) {
                    profile.getSubNode('BOX').css({
                        '--row-height': '',
                        '--col-width': ''
                    });
                }
            }

            // 
            if (width < 480) {
                root.addClass('formlayout-tiny');

                // 
                items.css({
                    'padding': '2px 4px',
                    'font-size': '0.8em'
                });
            } else {
                root.removeClass('formlayout-tiny');

                // 
                if (width >= 768) {
                    items.css({
                        'padding': '',
                        'font-size': ''
                    });
                }
            }

            // 
            if (profile.renderId && profile.box._resizeTable) {
                var size = box.cssSize();
                profile.box._resizeTable(profile, size, false, true);
            }
        });
    },

    // 
    enhanceAccessibility: function () {
        return this.each(function (profile) {
            var root = profile.getRoot(),
                box = profile.getSubNode('BOX'),
                table = profile.getSubNode('TABLE'),
                items = profile.getSubNode('ITEM', true),
                holder = profile.getSubNode('HOLDER');

            // ARIA
            root.attr({
                'role': 'grid',
                'aria-label': ''
            });

            // ARIA
            if (table && !table.isEmpty()) {
                table.attr({
                    'role': 'table',
                    'aria-label': ''
                });
            }

            // ARIA
            if (holder && !holder.isEmpty()) {
                holder.attr({
                    'role': 'region',
                    'aria-label': ''
                });
            }

            // ARIA
            items.each(function (item) {
                var itemNode = ood(item);
                var coord = itemNode.attr('data-coord');
                if (coord) {
                    itemNode.attr({
                        'role': 'gridcell',
                        'aria-label': ' ' + coord,
                        'tabindex': '0'
                    });
                }
            });

            // 
            // OODDOMAPI
        });
    },

    Static: {
        HasHtmlTableNode: 1,
        _CONTAINERKEY: "ITEM",
        _ITEMCONTAINER: 1,
        _ACTIVEHANDLER: ["KEY", "HOLDER"],
        _NoProp: {"conLayoutColumns": 1},
        _objectProp: {layoutData: 1},
        Appearances: {
            KEY: {
                overflow: 'hidden',
                transition: 'all 0.3s ease'
            },
            BOX: {
                position: 'absolute',
                left: 0,
                top: 0,
                'z-index': 1,
                'border': '1px solid rgba(0,0,0,0.1)',
                'border-radius': '6px',
                'box-shadow': '0 2px 4px rgba(0,0,0,0.1)',
                transition: 'all 0.3s ease'
            },
            'BOX:hover': {
                'box-shadow': '0 3px 6px rgba(0,0,0,0.15)'
            },
            CBORDER: {
                position: 'absolute',
                left: 0,
                top: 0
            },
            'CBORDER div': {
                position: 'absolute',
                display: 'block'
            },
            POOL: {
                position: 'absolute',
                left: '-100%',
                top: '-100%',
                width: 0,
                height: 0
            },
            HOLDER: {
                overflow: 'auto',
                position: 'relative',
                'border-radius': '4px',
                transition: 'background-color 0.3s ease'
            },
            TABLE: {
                'overflow': 'hidden',
                'border-collapse': 'separate',
                'border-spacing': '0',
                margin: '0',
                'border-width': '0',
                'table-layout': 'fixed',
                width: '0',
                'outline-width': '0',
                cursor: 'default',
                'max-width': 'none',
                'max-height': 'none',
                transition: 'background-color 0.3s ease'
            },
            "ITEM:empty:after": {
                'text-align': 'center',
                color: '#cccccc',
                content: 'attr(data-coord)',
                position: 'absolute',
                top: '0',
                bottom: '0',
                left: '0',
                right: '0',
                margin: 'auto',
                height: '1.5em',
                '-moz-user-select': ood.browser.gek ? '-moz-none' : null,
                '-khtml-user-select': ood.browser.kde ? 'none' : null,
                '-webkit-user-select': ood.browser.kde ? 'none' : null,
                '-o-user-select': ood.browser.opr ? 'none' : null,
                '-ms-user-select': (ood.browser.ie || ood.browser.newie) ? 'none' : null,
                'user-select': 'none',
                'touch-action': 'none',
                transition: 'color 0.3s ease'
            },
            // {{ for read/write mode (layoutcell)
            "ITEM.layoutcell": {
                "border-right": "1px solid rgba(0,0,0,0.1)",
                "border-bottom": "1px solid rgba(0,0,0,0.1)",
                "border-left": "none",
                "border-top": "none",
                transition: 'all 0.2s ease',
                $order: 1
            },
            "ITEM.layoutcell:hover": {
                'background-color': '#f8f9fa',
                'box-shadow': '0 1px 3px rgba(0,0,0,0.1)'
            },
            "ITEM.layoutcell.firstrow": {
                "border-top": "1px solid rgba(0,0,0,0.1)",
                $order: 2
            },
            "ITEM.layoutcell.firstcol": {
                "border-left": "1px solid rgba(0,0,0,0.1)",
                $order: 2
            },
            // "BOX.solidgridline ITEM.layoutcell": {
            //     "border-right": "1px solid #007bff",
            //     "border-bottom": "1px solid #007bff",
            //     "border-left": "none",
            //     "border-top": "none",
            //     $order: 3
            // },
            // "BOX.solidgridline ITEM.layoutcell.firstrow": {
            //     "border-top": "1px solid #007bff",
            //     $order: 4
            // },
            // "BOX.solidgridline ITEM.layoutcell.firstcol": {
            //     "border-left": "1px solid #007bff",
            //     $order: 4
            // },
            // }}

            // {{ for design mode (handsontable)
            // reset 
            "KEY ITEM": {
                "position": "relative",
                background: "transparent",
                height: '22px',
                padding: '0 4px',
                overflow: 'hidden',
                'outline-width': '0',
                'white-space': 'pre-line',
                'empty-cells': 'show',
                'line-height': '1.22',
                'text-align': 'left',
                'vertical-align': 'middle',
                'background-clip': 'padding-box',
                transition: 'background-color 0.2s ease'
            },
            "KEY ITEM:hover": {
                'background-color': 'rgba(0,123,255,0.1)'
            },
            "KEY .handsontableInput": {
                'line-height': '1.22'
            },
            "KEY .handsontable tr": {
                background: "transparent"
            },
            // reset
            "BOX.handsontable tr:first-child td, BOX.handsontable tr:first-child th": {
                "border-top": "none"
            },
            "BOX.handsontable tr:first-child > td, BOX.handsontable tr:first-child > th": {
                "border-top": "1px solid #dee2e6"
            },
            // for handsontable solid grid lines
            ".handsontable.solidgridline td": {
                "border-right": "1px solid #007bff",
                "border-bottom": "1px solid #007bff"
            },
            ".handsontable.solidgridline tr:first-child > td": {
                "border-top": "1px solid #007bff"
            },
            ".handsontable.solidgridline th:nth-child(2), .handsontable.solidgridline td:first-of-type, .handsontable.solidgridline .htNoFrame + th, .handsontable.solidgridline .htNoFrame + td": {
                "border-left": "1px solid #007bff"
            },
            ".handsontable.nogridline td": {
                "border-right": "1px solid transparent",
                "border-bottom": "1px solid transparent"
            },
            ".handsontable.nogridline tr:first-child > td": {
                "border-top": "1px solid transparent"
            },
            ".handsontable.nogridline th:nth-child(2), .handsontable.nogridline td:first-of-type, .handsontable.nogridline .htNoFrame + th, .handsontable.nogridline .htNoFrame + td": {
                "border-left": "1px solid transparent"
            },
            // }}

            // 
            'BOX': {
                className: 'formlayout-box'
            },
            'HOLDER': {
                className: 'formlayout-holder'
            },
            'TABLE': {
                className: 'formlayout-table'
            },
            'ITEM.layoutcell': {
                className: 'formlayout-item'
            },

            // 
            'formlayout-mobile TABLE': {
                'font-size': '0.9em'
            },
            'formlayout-mobile ITEM.layoutcell': {
                'padding': '4px 6px',
                'font-size': '0.9em'
            },

            // 
            'formlayout-tiny ITEM.layoutcell': {
                'padding': '2px 4px',
                'font-size': '0.8em'
            }
        },
        Templates: {
            tagName: 'div',
            className: '{_className}',
            style: '{_style}',
            BOX: {
                tagName: 'div'
            },
            POOL: {
                tagName: 'div'
            }
        },
        Behaviors: {
            DroppableKeys: ['ITEM'],
            PanelKeys: ['ITEM'],
            HotKeyAllowed: false,
            ITEM: {}
        },
        DataModel: {
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark'],
                action: function (value) {
                    this.boxing().setTheme(value);
                },
                caption: ood.getResText("DataModel.theme") || ""
            },
            responsive: {
                ini: true,
                action: function (value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                },
                caption: ood.getResText("DataModel.responsive") || ""
            },

            expression: {
                ini: '',
                action: function () {
                },
                caption: ood.getResText("DataModel.expression") || ""
            },
            tabindex: null,
            defaultFocus: null,
            disableClickEffect: null,
            disableHoverEffect: null,
            disableTips: null,
            disabled: null,
            renderer: null,
            selectable: null,
            tips: null,
            autoTips: null,
            overflow: null,
            items: {
                hidden: true,
                ini: [],
                caption: ood.getResText("DataModel.item") || ""
            },
            listKey: null,
            dragSortable: null,
            mode: {
                ini: 'write',
                listbox: ['design', 'write', 'read'],
                get: function () {
                    return this.$inDesign ? 'design' : (this.properties.mode || 'read');
                },
                action: function () {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.mode") || ""
            },
            lineSpacing: {
                ini: 10,
                action: function (value) {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.rowGap") || ""
            },
            width: {
                $spaceunit: 1,
                ini: '30em',
                caption: ood.getResText("DataModel.width") || ""
            },
            height: {
                $spaceunit: 1,
                ini: '25em',
                caption: ood.getResText("DataModel.height") || ""
            },
            solidGridlines: {
                ini: true,
                action: function (value) {
                    var cls = value ? "solidgridline" : this.boxing()._isDesignMode() ? "" : "nogridline",
                        node = this.getSubNode('BOX');
                    node.removeClass("solidgridline nogridline");
                    if (cls) node.addClass(cls);
                },
                caption: ood.getResText("DataModel.solidGrid") || ""
            },
            stretchHeight: {
                ini: "none",
                listbox: ["none", "last", "all"],
                action: function () {
                    if (this.boxing()._isDesignMode()) {
                        this.box._updateSetting(this, 'stretchHeight');
                        var size = this.getRoot().cssSize();
                        this.box._resizeTable(this, this.getSubNode('BOX').cssSize(), false, true);
                    } else {
                        this.box._resizeTable(this, this.getSubNode('BOX').cssSize(), false, true);
                    }
                },
                caption: ood.getResText("DataModel.stretchHeight") || ""
            },
            stretchH: {
                ini: "all",
                listbox: ["all", "none", "last"],
                action: function () {
                    if (this.boxing()._isDesignMode()) {
                        this.box._updateSetting(this, 'stretchH');
                        this.box._resizeTable(this, this.getSubNode('BOX').cssSize(), false, true);
                    } else {
                        this.box._resizeTable(this, this.getSubNode('BOX').cssSize(), false, true);
                    }
                },
                caption: ood.getResText("DataModel.horizontalStretch") || ""
            },
            rowHeaderWidth: {
                ini: 25,
                action: function () {
                    if (this.boxing()._isDesignMode()) {
                        this.box._updateSetting(this, 'rowHeaderWidth');
                        var size = this.getRoot().cssSize();
                        ood.UI.$tryResize(this, size.width, size.height);
                    }
                },
                caption: ood.getResText("DataModel.rowTitleWidth") || ""
            },
            columnHeaderHeight: {
                ini: 25,
                action: function () {
                    if (this.boxing()._isDesignMode()) {
                        this.box._updateSetting(this, 'columnHeaderHeight');
                        var size = this.getRoot().cssSize();
                        ood.UI.$tryResize(this, size.width, size.height);
                    }
                },
                caption: ood.getResText("DataModel.colHeaderHeight") || ""
            },
            floatHandler: {
                ini: true,
                action: function () {
                    if (this.boxing()._isDesignMode()) {
                        var size = this.getRoot().cssSize();
                        ood.UI.$tryResize(this, size.width, size.height, true);
                    }
                },
                caption: ood.getResText("DataModel.floatHandling") || ""
            },
            defaultRowSize: {
                ini: 5,
                caption: ood.getResText("DataModel.defaultRows") || ""
            },
            defaultColumnSize: {
                ini: 5,
                caption: ood.getResText("DataModel.defaultCols") || ""
            },
            defaultRowHeight: {
                ini: 50,
                caption: ood.getResText("DataModel.defaultRowHeight") || ""
            },
            defaultColWidth: {
                ini: 120,
                caption: ood.getResText("DataModel.defaultColWidth") || ""
            },

            // don't use handsometable's cell className - buggy (when moving row/column)
            // rows:5, cols:5, rowSetting:{'3':{}}, colSetting:{"B":{}}, cells:{A3:{type:"",value:"",,style:"",border:""}}, merged:[]
            layoutData: {
                ini: {},
                action: function () {
                    this.boxing().refresh();
                },
                caption: ood.getResText("DataModel.layoutData") || ""
            },

            // if use handsontable 6.22 (MIT license) as renderer
            rendererCDNJS: {
                ini: "/plugins/formlayout/handsontable.full.min.js",
                caption: ood.getResText("DataModel.rendererJS") || "JS"
            },
            rendererCDNCSS: {
                ini: "/plugins/formlayout/handsontable.full.min.css",
                caption: ood.getResText("DataModel.rendererCSS") || "CSS"
            }
        },
        RenderTrigger: function () {
            var prf = this, prop = prf.properties, cls = prf.box;
            if (prf.boxing()._isDesignMode()) {
                if (window.Handsontable) cls._renderAsHandsontable(prf);
                else {
                    // prf.boxing().busy(false, "Loading table ...");
                    var cssId = "ood.UI.HTable:Handsontable";
                    ood.CSS.includeLink(prop.rendererCDNCSS, cssId);
                    ood.include("Handsontable", prop.rendererCDNJS, function () {
                        if (ood(cssId).get(0)) {
                            //prf.boxing().free();
                            cls._renderAsHandsontable(prf);
                            var size = prf.getRoot().cssSize();
                            ood.UI.$tryResize(prf, size.width, size.height);
                        } else {
                            ood.Thread.repeat(function () {
                                if (ood(cssId).get(0)) {
                                    //prf.boxing().free();
                                    cls._renderAsHandsontable(prf);
                                    var size = prf.getRoot().cssSize();
                                    ood.UI.$tryResize(prf, size.width, size.height);

                                    return false;
                                }
                            }, 200);
                        }
                    }, null, false, {cache: true});
                }
            } else {
                cls._renderAsH5Table(prf);
            }
            // will be called in refresh()
            prf.$handleCustomVars = function (d) {
                if (!d) {
                    ood.arr.each(prf.children, function (c) {
                        delete c[0]._attached2cell;
                        delete c[0]._autoexpand;
                    });
                }
            }
            prf.boxing().setSolidGridlines(prop.solidGridlines, true);

            // 
            var self = prf;
            // ood.asyRun(function(){
            //     self.boxing().FormLayoutTrigger();
            // });
        },


        EventHandlers: {
            onShowTips: null,
            onGetCellData: function (cellCoord, cellObj, cellChild) {
            }
        },
        _getHeaderOffset: function (prf) {
            var prop = prf.properties, offset = {left: 0, top: 0};
            if (prop.floatHandler && prf.boxing()._isDesignMode()) {
                offset.left = prop.rowHeaderWidth;
                offset.top = prop.columnHeaderHeight + 1;
            }
            return offset;
        },
        _layoutChanged: function (prf, force) {
            if (force || prf._$tableInited)
                ood.resetRun(prf.getUid("layoutchanged"), function () {
                    //console.log("onLayoutChanged");
                    if (prf.properties) {
                        var oData = prf.properties.layoutData;
                        prf.properties.layoutData = prf.box._getLayoutData(prf);
                        if (prf.$onLayoutChanged) prf.$onLayoutChanged(prf, oData, prf.properties.layoutData);
                    }

                });
        },
        _getLayoutData: function (prf) {
            var prop = prf.properties,
                cells = {}, borders, rowSetting = {}, colSetting = {}, merged = [],
                layoutData = {},
                data, rows, cols, t, p, s, tmp;

            // handsontable to ood
            if (t = prf.$htable) {
                // rows:5, cols:5, merged:[]
                layoutData.rows = t.countRows();
                layoutData.cols = t.countCols();
                merged = ood.copy(ood.get(t.getPlugin("mergeCells"), ["mergedCellsCollection", "mergedCells"]));
                if (!ood.isEmpty(merged)) layoutData.merged = merged;

                s = t.getSettings();
                // rowSetting:{'3':{}}
                p = t.getPlugin("ManualRowResize");
                for (var i = 0, l = layoutData.rows, h; i < l; i++) {
                    var row = t.toPhysicalRow(i);
                    if (p.manualRowHeights && p.manualRowHeights[row]) ood.set(rowSetting, [i + 1, 'manualHeight'], p.manualRowHeights[row]);
                    if (tmp = ood.isArr(s.rowHeights) ? s.rowHeights[row] : s.rowHeights) ood.set(rowSetting, [i + 1, 'height'], tmp);
                }
                if (!ood.isEmpty(rowSetting)) layoutData.rowSetting = rowSetting;

                // colSetting:{"B":{}}
                p = t.getPlugin("ManualColumnResize");
                for (var i = 0, l = layoutData.cols, w; i < l; i++) {
                    var col = t.toPhysicalColumn(i);
                    if (p.manualColumnWidths && p.manualColumnWidths[col]) ood.set(colSetting, [ood.ExcelFormula.toColumnChr(i + 1), 'manualWidth'], p.manualColumnWidths[col]);
//                    if(tmp = ood.isArr(s.colWidths)?s.colWidths[col]:s.colWidths) ood.set(colSetting, [ood.ExcelFormula.toColumnChr(i+1), 'width'], tmp);
                }
                if (!ood.isEmpty(colSetting)) layoutData.colSetting = colSetting;

                // cells:{A3:{type:"",value:"",style:"",border:""}
                data = t.getData();
                // cells:{A3:{value:"v"}
                for (var i = 0, l = data.length; i < l; i++) {
                    var row = data[i];
                    for (var m = 0, n = row.length; m < n; m++) {
                        // ignore null/undefined/""
                        if (ood.isSet(data[i][m]) && data[i][m] !== "") {
                            ood.set(cells, [ood.ExcelFormula.toCellId(m, i), "value"], data[i][m]);
                        }
                    }
                }
                // cells:{A3:{style:{}}
                for (var i = 0, l = layoutData.rows; i < l; i++) {
                    var row = t.toPhysicalRow(i);
                    var rowMetas = t.getCellMetaAtRow(row);
                    if (rowMetas && rowMetas.length) {
                        for (var m = 0, n = rowMetas.length; m < n; m++) {
                            var col = t.toPhysicalColumn(m);
                            // align settings
                            // don't use className - buggy
//                        if(rowMetas[col].className)
//                            ood.set(cells, [ood.ExcelFormula.toCellId(m,i), "className"], ood.str.trim(rowMetas[col].className));
                            // style: ignore empty {}
                            if (!ood.isEmpty(rowMetas[col].style))
                                ood.set(cells, [ood.ExcelFormula.toCellId(m, i), "style"], ood.copy(rowMetas[col].style));
                        }
                    }

                }
                if (!ood.isEmpty(cells)) layoutData.cells = cells;

                var cbPlugin = t.getPlugin('customBorders');
                if ((borders = cbPlugin.getBorders()).length) {
                    layoutData.customBorders = ood.clone(borders, function (h, i) {
                        return i != 'id' && i != 'border'
                    });
                }
            }
            return layoutData;
        },
        _renderAsH5Table: function (prf) {
            var boxNode = prf.getSubNode("BOX"),
                elem = boxNode.get(0),
                prop = prf.properties,
                layoutData = prop.layoutData,
                rowSize = layoutData.rows || prop.defaultRowSize,
                colSize = layoutData.cols || prop.defaultColumnSize,
                childrenMap = {}, t, merged = {}, merged2 = {},
                getCellData = function (childrenMap, itemId) {
                    var data = prf.onGetCellData && prf.boxing().onGetCellData(prf, itemId, ood.get(layoutData, ["cells", itemId]), childrenMap[itemId]);
                    if (!ood.isSet(data)) {
                        if (!childrenMap[itemId]) {
                            data = ood.get(layoutData, ["cells", itemId, "value"]);
                        } else {
                            var childPrf = childrenMap[itemId], ins = childPrf && childPrf.boxing();
                            if (childPrf.key == 'ood.UI.RichEditor' || childPrf.key == 'ood.UI.Image' || childPrf.key == 'ood.UI.Label') {
                                data = '';
                            } else if (childPrf.key == 'ood.UI.CheckBox' || childPrf.key == 'ood.UI.SCheckBox') {
                                data = '<input type="checkbox" disabled tabindex="-1"  onclick="javascript:return false;"'
                                    + (ins.getUIValue() ? "checked" : "")
                                    + '>';// + ins.getCaption();
                            } else {
                                data = ins.getShowValue ? ins.getShowValue() :
                                    ins.getValue ? ('$UIvalue' in childPrf.properties ? ins.getUIValue() : ins.getValue()) :
                                        ins.getCaption ? ins.getCaption() :
                                            ins.getHtml ? ins.getHtml() :
                                                ins.getLabel ? ins.getLabel() :
                                                    '';
                            }
                        }
                    }
                    return ood.isSet(data) ? data : "";
                },
                cellProp, subSerialId, item, itemId, domId, styles, tpl = [];

            ood.arr.each(prf.children, function (v) {
                childrenMap[v[1]] = v[0];
            });
            ood.arr.each(layoutData.merged, function (v) {
                merged[v.row + ":" + v.col] = (v.rowspan > 1 ? (" rowspan=" + v.rowspan) : "") + (v.colspan ? (" colspan = " + v.colspan) : "") + " ";
                for (var i = 0, l = v.rowspan; i < l; i++) {
                    for (var j = 0, k = v.colspan; j < k; j++) {
                        if (i === 0 && j === 0) continue;
                        merged2[(v.row + i) + ":" + (v.col + j)] = 1;
                    }
                }
            });

            tpl.push("<div id='" + prf.key + "-HOLDER:" + prf.serialId + ":" + "' class='" + prf.getClass("HOLDER")
                + "' style='width:" + prop.width + "; height:" + prop.height
                + "' >");
            tpl.push("<table id='" + prf.key + "-TABLE:" + prf.serialId + ":" + "' class='" + prf.getClass("TABLE") + "'"
                + (prop.stretchH != 'none' ? (" style='width:" + prop.width + ";'") : "")
                + ">");
            // colgroup
            var colWidths = prf.box._getColWidths(prf, prf.$px(prop.width));
            tpl.push("<colgroup><col style='width:0;border:0;margin:0;padding:0;'></col>");
            for (var col = 0, n = colSize; col < n; col++) {
                tpl.push("<col rowid=" + row + " style='width:" + colWidths[col] + ";'></col>");
            }
            tpl.push("</colgroup>");
            // tbody
            tpl.push("<tbody>");

            for (var row = 0, l = rowSize; row < l; row++) {
                tpl.push("<tr rowid=" + row + "><th style='width:0;border:0;margin:0;padding:0;");
                if (t = ood.get(layoutData, ['rowSetting', row + 1, 'height']) || ood.get(layoutData, ['rowSetting', row + 1, 'manualHeight']) || prop.defaultRowHeight) {
                    tpl.push("height:" + (t - (row === 0 ? 1/*2*/ : 1)) + "px;");
                    //tpl.push("height:" + rowHeights[row] + "px;");
                }
                tpl.push("'></th>");
                for (var col = 0, n = colSize; col < n; col++) {
                    subSerialId = prf.pickSubId('items');
                    itemId = ood.ExcelFormula.toCellId(col, row);
                    item = {
                        _serialId: subSerialId,
                        col: col,
                        row: row,
                        id: itemId,
                        value: getCellData(childrenMap, itemId),
                        style: ood.get(layoutData, ["cells", itemId, "style"]) || {}
                    };
                    prf.ItemIdMapSubSerialId[itemId] = subSerialId;
                    prf.SubSerialIdMapItem[subSerialId] = item;

                    domId = prf.key + "-ITEM:" + prf.serialId + ":" + subSerialId;
                    styles = [];
                    ood.each(item.style, function (v, k) {
                        styles.push(k.replace(/[A-Z]/g, function (a) {
                            return '-' + a.toLowerCase()
                        }) + ":" + v);
                    });
                    // layoutData.merged
                    if (!merged2[row + ":" + col]) {
                        tpl.push("<td rowid=" + row + " id='" + domId + "' class='layoutcell " + (row === 0 ? 'firstrow ' : '') + (col === 0 ? 'firstcol ' : '') + prf.getClass("ITEM") + "' style='" + styles.join(";") + "' " + (merged[row + ":" + col] || "") + ">");
                        tpl.push(item.value);
                        tpl.push("</td>");
                    }
                }
                tpl.push("</tr>");
            }
            tpl.push("</tbody></table>");
            tpl.push("<div id='" + prf.key + "-CBORDER:" + prf.serialId + ":" + "' class='" + prf.getClass("CBORDER") + "' ></div>");
            tpl.push("</div>");

            elem.innerHTML = tpl.join("");
            ood.UI.$addEventsHandler(prf, elem, false);

            // layoutData.customBorders
            prf.box._setCustomBorders(prf);

            // lazy append
            var arr = [];
            ood.each(prf.children, function (v) {
                arr.push(v);
            });
            prf.children = [];
            ood.arr.each(arr, function (v) {
                prf.boxing().append(v[0], v[1]);
            });
        },
        _renderAsHandsontable: function (prf) {
            if (!prf || !prf.box) return;
            var onLayoutChanged = function (prf, force) {
                prf.box._layoutChanged(prf, force);
            };
            var boxNode = prf.getSubNode("BOX"),
                elem = boxNode.get(0),
                htable,
                prop = prf.properties,
                layoutData = prop.layoutData,
                designMode = true,
                fixedSet = {
                    // "fix" some functions for handsontable
                    autoWrapRow: true,
                    renderAllRows: true,
                    persistentState: false,

                    // "readonly" handsontable
                    readOnly: !designMode,
                    readOnlyCellClassName: "no",
                    comments: !designMode,
                    disableVisualSelection: !designMode,
                    enterBeginsEditing: designMode,
                    manualRowMove: designMode,
                    manualColumnMove: designMode,
                    contextMenu: designMode,
                    copyable: designMode,
                    copyPaste: designMode,
                    beforeOnCellMouseDown: !designMode ? null : function (e, c) {
                        // fire event
                        if (c.row === -1 && c.col === -1) {
                            e.stopImmediatePropagation();
                        }
                    },
                    afterOnCellMouseUp: !designMode ? null : function (e, c) {
                        // fire event
                        if (c.row === -1 && c.col === -1) {
                            this.deselectCell();
                            prf.getRoot().onClick(true);
                            e.stopImmediatePropagation();
                        }
                    },

                    /* cell render*/
                    // for ood dom id & event handler
                    beforeRenderer: function (TD, row, col, vprop, value, cellprop) {
                        var subSerialId = prf.pickSubId('items'),
                            itemId = ood.ExcelFormula.toCellId(col, row);
                        // memory map
                        cellprop.oid = cellprop.id;
                        cellprop.id = itemId;
                        if (cellprop.oid && cellprop.oid != cellprop.id) {
                            prf.$cellIdChangedMap[cellprop.oid] = cellprop.id;
                        }
                        cellprop._serialId = subSerialId;
                        prf.ItemIdMapSubSerialId[itemId] = subSerialId;
                        prf.SubSerialIdMapItem[subSerialId] = cellprop;
                        // customized styles
                        // first time, set cellprop.style from prop.layoutData
                        if (!cellprop.style) {
                            cellprop.style = ood.get(prop.layoutData, ["cells", ood.ExcelFormula.toCellId(col, row), "style"]) || {};
                        }
                        // dom
                        TD.id = prf.key + "-ITEM:" + prf.serialId + ":" + subSerialId;
                        ood.UI.$addEventsHandler(prf, TD, true);
                        for (var i in cellprop.style) TD.style[i] = cellprop.style[i];
                        // align class
//                        if(!cellprop.className){
//                            cellprop.className = ood.get(prop.layoutData, ["cells", ood.ExcelFormula.toCellId(col,row),"className"]) || "";
//                        }
                        TD.className = (TD.className || "") + prf.getClass("ITEM");
                        if (designMode)
                            TD.setAttribute('data-coord', itemId);
                        if (cellprop._child_autoexpandH) {
                            TD.style.height = cellprop._child_autoexpandH + "px";
                        } else {
                            TD.style.height = "";
                        }
                    },
                    /* cell renderer
                    renderer : function(instance, TD, row, col, vprop, value, cellprop){
                    },
                    */
                    /* table render*/
                    beforeRender: function (flag) {
                        // **: updateSetting will re-render all table elements
                        // we have to reset memory map, and keep children here
                        if (prf._$tableInited) {
                            prf.$cellIdChangedMap = {};
                            //*** save children first
                            var pool = prf.getSubNode("POOL").get(0), arr = [];
                            ood.arr.each(prf.children, function (v) {
                                if (v[0] && v[0].rendered) {
                                    pool.appendChild(v[0].getRootNode());
                                    arr.push(v);
                                }
                            });
                            //keep children, prevent to be destroyed
                            if (arr.length) {
                                prf._pool_children = arr;
                            }

                            // reset memory map
                            prf.children = [];
                            for (var i in prf.SubSerialIdMapItem)
                                prf.reclaimSubId(i, "items");
                            prf.ItemIdMapSubSerialId = {};
                            prf.SubSerialIdMapItem = {};
                        }
                    },
                    afterInit: function () {
                        prf._$tableInited = 1;
                    },
                    afterRender: function (isForced) {
                        //console.log('afterRender');
                        ood.tryF(prf.$onrender, [], prf);

//                        onLayoutChanged(prf);

                        // Set id for important nodes, for getting profile from dom id
                        var node = prf.getSubNode("BOX");
                        node = node.first();
                        node.id(prf.key + "-MASTER:" + prf.serialId + ":");
                        node = node.first();
                        node.id(prf.key + "-HOLDER:" + prf.serialId + ":");
                        node = node.first();
                        node.id(prf.key + "-HIDER:" + prf.serialId + ":");
                        node = node.first();
                        node.id(prf.key + "-SPREADER:" + prf.serialId + ":");

                        if (prf._$tableInited) {
                            var map = prf.$cellIdChangedMap;

                            //*** restore children
                            if (prf._pool_children) {
                                ood.arr.each(prf._pool_children, function (v) {
                                    delete v[0].$dockParent;
                                    if (v[0].$domId) {
                                        prf.boxing().append(v[0], map[v[1]] || v[1]);
                                    }

                                });
                                delete prf._pool_children;
                            }
                        } else {
                            //
                            // lazy append
                            var arr = [];
                            ood.each(prf.children, function (v) {
                                if (v[0].$domId) {
                                    arr.push(v);
                                }
                            });
                            prf.children = [];

                            ood.arr.each(arr, function (v) {
                                if (v[0].$xid) {
                                    prf.boxing().append(v[0], v[1]);
                                }

                            });

                            prf.getRoot().onMouseup(function (p, e) {
                                prf.$lastMousePos = ood.Event.getPos(e);
                            });
                        }
                    },

                    afterSelection: function () {
                        if (prop.floatHandler)
                            prf.getRoot().css('overflow', 'visible');
                    },
                    outsideClickDeselects: function (node) {
                        //for lang span, or inner renderer
                        while ((
                                (!node.id)
                                || node.id == ood.$localeDomId
                                || node.tagName == 'tspan'
                            )
                            && node.parentNode !== document && node.parentNode !== window
                            ) node = node.parentNode;
                        var p = ood.UIProfile.getFromDom(node);
                        if (p && prf.$popmenu) {
                            var r = prf.$popmenu.get(0);
                            if (p == r || p.$parentPopMenu == r || p.$popGrp == r.$popGrp) {
                                return false;
                            }
                        }

                        prf.getRoot().css('overflow', '');
                        return true;
                    },
                    afterContextMenuShow: !designMode ? null : function (context) {
                        if (prf.$onPopMenu) prf.$popmenu = prf.$onPopMenu(prf, prf.$popmenu, context.menu);
                        // don't use dft menu
                        context.menu.container.style.display = 'none';
                    },

                    afterUpdateSettings: function () {
                        // only resize use this
                        onLayoutChanged(prf);
                    },
                    afterRedo: function () {
                        onLayoutChanged(prf);
                    },
                    afterUndo: function () {
                        onLayoutChanged(prf);
                    },
                    afterChange: function (change, source) {
                        if (source != 'loadData' && source != 'populateFromArray')
                            onLayoutChanged(prf);
                    },
                    beforeCellAlignment: function () {
                        onLayoutChanged(prf);
                    },
                    afterMergeCells: function (a, b, auto) {
                        if (!auto)
                            onLayoutChanged(prf);
                    },
                    afterUnmergeCells: function (a, b, auto) {
                        if (!auto)
                            onLayoutChanged(prf);
                    },

                    // reset autoexpand
                    afterRowResize: function (row, size, dblclick) {
                        onLayoutChanged(prf);
                        var cells = this.getCellMetaAtRow(row);
                        for (var i = 0, l = cells.length; i < l; i++) {
                            var target = prf.boxing().getChildren(cells[i].id);
                            if (target['ood.UI.Input']
                                && target.getMultiLines && target.getMultiLines()
                                && target.setAutoexpand
                            ) {
                                target.get(0)._autoexpand = (size - 1) + "px";
                            }
                        }
                    },

                    afterColumnResize: function () {
                        onLayoutChanged(prf);
                    },
                    afterColumnSort: function () {
                        onLayoutChanged(prf);
                    },
                    afterRowMove: function (rows, target) {
                        onLayoutChanged(prf);
                    },
                    afterColumnMove: function () {
                        onLayoutChanged(prf);
                    },
                    // for fix ManualColumnResize and ManualRowResize
                    afterCreateCol: function (index, amount) {
                        onLayoutChanged(prf);

                        // patch for ManualColumnResize
                        var p = this.getPlugin("ManualColumnResize");
                        // new cols
                        var arr = [];
                        for (var i = 0; i < amount; i++) arr.push(prop.defaultColWidth);
                        // ensure length
                        if (!p.manualColumnWidths) p.manualColumnWidths = [];
                        for (var i = 0; i < index; i++) p.manualColumnWidths[i] = p.manualColumnWidths[i] || (void 0);
                        // insert
                        p.manualColumnWidths.splice.apply(p.manualColumnWidths, [index, 0].concat(arr));

                        this.deselectCell();
                        var ns = this;
                        ood.asyRun(function () {
                            ns.selectColumns(index);
                        });
                    },
                    afterCreateRow: function (index, amount) {
                        onLayoutChanged(prf);
                        // patch for ManualRowResize
                        var p = this.getPlugin("ManualRowResize");
                        // new row
                        var arr = [];
                        for (var i = 0; i < amount; i++) arr.push(prop.defaultRowHeight);
                        // ensure length
                        if (!p.manualRowHeights) p.manualRowHeights = [];
                        for (var i = 0; i < index; i++) p.manualRowHeights[i] = p.manualRowHeights[i] || (void 0);
                        // insert
                        p.manualRowHeights.splice.apply(p.manualRowHeights, [index, 0].concat(arr));

                        this.deselectCell();
                        var ns = this;
                        ood.asyRun(function () {
                            ns.selectRows(index);
                        });
                    },
                    afterRemoveCol: function (index, amount) {
                        onLayoutChanged(prf);
                        var p = this.getPlugin("ManualColumnResize");
                        if (p.manualColumnWidths) {
                            p.manualColumnWidths.splice(index, amount);
                        }
                        this.deselectCell();
                    },
                    afterRemoveRow: function (index, amount) {
                        onLayoutChanged(prf);
                        var p = this.getPlugin("ManualRowResize");
                        if (p.manualRowHeights) {
                            p.manualRowHeights.splice(index, amount);
                        }
                        this.deselectCell();
                    }
                },
                settings = {}, t;

            var offset = prf.box._getHeaderOffset(prf);
            // size
            settings.height = prf.$px(prop.height) + offset.top;
            settings.width = prf.$px(prop.width) + offset.left;
            // stretch
            settings.stretchHeight = (t = prop.stretchHeight) == "last" ? "last" : t == "all" ? "all" : "none";
            settings.stretchH = (t = prop.stretchH) == "last" ? "last" : t == "all" ? "all" : "none";
            // dft widht/height
            settings.rowHeaderWidth = prop.rowHeaderWidth;
            settings.columnHeaderHeight = prop.columnHeaderHeight;
            settings.defaultColumnWidth = prop.defaultColWidth;
            // show header?
            settings.rowHeaders = designMode;
            settings.colHeaders = designMode;


            // merged info
            if (layoutData.merged) {
                settings.mergeCells = layoutData.merged;
            } else {
                settings.mergeCells = designMode;
            }

            // data, manualRowResize, minRowHeights, manualColumnResize, colWidths, cellMetas
            // if there's table data
            if (layoutData.cols) {
                // cell data
                var minRowHeights = [], colWidths = [], manualRowResize = [], manualColumnResize = [], data = [], row;
                // manualRowResize (start from "1")
                ood.each(layoutData.rowSetting, function (v, k) {
                    if (ood.isSet(v.manualHeight || v)) manualRowResize[parseInt(k, 10) - 1] = parseInt(v.manualHeight || v, 10);
                    if (ood.isSet(v.height || v)) minRowHeights[parseInt(k, 10) - 1] = parseInt(v.height || v, 10);
                });
                // manualColumnResize (start from "A"=>"1")
                ood.each(layoutData.colSetting, function (v, k) {
                    k = ood.ExcelFormula.toColumnNum(k);
                    if (ood.isSet(v.manualWidth || v)) manualColumnResize[k - 1] = parseInt(v.manualWidth || v, 10);
                    // if(ood.isSet(v.width||v))colWidths[k - 1]=parseInt(v.width||v,10);
                });
                // init data
                for (var i = 0, l = layoutData.rows || prop.defaultRowSize; i < l; i++) {
                    data.push(row = []);
                    for (var m = 0, n = layoutData.cols || prop.defaultColumnSize; m < n; m++) {
                        row.push(null);
                    }
                }
                // fill data
                ood.each(layoutData.cells, function (cell, id) {
                    var coord = ood.ExcelFormula.toCoordinate(id);
                    data[coord.row][coord.col] = ood.isSet(cell.value) ? cell.value : null;
                });

                // set manualRowResize, manualColumnResize and data
                for (var i = 0; i < layoutData.rows; i++) {
                    manualRowResize[i] = manualRowResize[i] || prop.defaultRowHeight;
                }
                settings.manualRowResize = manualRowResize;
                settings.manualColumnResize = !ood.isEmpty(manualColumnResize) ? manualColumnResize : designMode;

                if (!ood.isEmpty(minRowHeights)) settings.rowHeights = minRowHeights;
                // don't use colWidths
                //if(!ood.isEmpty(colWidths))settings.colWidths = colWidths;

                settings.data = data;

                if (layoutData.customBorders)
                    settings.customBorders = layoutData.customBorders;
            } else {
                settings.manualColumnResize = designMode;
                var manualRowResize = [];
                for (var i = 0; i < prop.defaultRowSize; i++) {
                    manualRowResize[i] = prop.defaultRowHeight;
                }
                settings.manualRowResize = manualRowResize;
            }
            prf.$htable = htable = new Handsontable(elem, ood.merge(settings, fixedSet, 'all'));

            if (!layoutData.cols) {
                // reset layoutData
                prf.properties.layoutData = prf.box._getLayoutData(prf);
            }

            // set before destroy function
            (prf.$beforeDestroy = (prf.$beforeDestroy || {}))["destroyhtable"] = function () {
                var t;
                if (t = this.$htable) {
                    // must purge lazy-bound node here
                    var node = this.getSubNode("BOX").get(0);
                    if (node)
                        ood.$purgeChildren(node);

                    if (!t.isDestroyed) {
                        Handsontable.hooks.destroy(t);
                        t.destroy();
                    }
                    delete this.$htable;
                }
                if (t = this.$popmenu) {
                    t.destroy();
                }
            }
        },

        _getRowHeights: function (prf, tableHeight, ispx) {
            var prop = prf.properties, layoutData = prop.layoutData, t,
                rowSize = layoutData.rows || prop.defaultRowSize, rowsize = [],
                reCalculated = [], rowHeights = [], fix = 0, count = 0, per, off, rc = 0, bW = 0,
                stretchHeight = prop.stretchHeight || 'all',
                lastoff = prop.defaultRowHeight;

            for (var row = 0, n = rowSize; row < n; row++) {
                if (t = ood.get(layoutData, ['rowSetting', row + 1, 'manualHeight'])) {
                    if (row < rowSize - 1) {
                        fix += parseInt(t);
                    }
                }
            }
            lastoff = tableHeight - fix;
            if (stretchHeight == "all") {
                for (var row = 0, n = rowSize; row < n; row++) {
                    if (t = ood.get(layoutData, ['rowSetting', row + 1, 'manualHeight'])) {
                        fix += parseInt(t);
                        reCalculated.push(t);
                    } else {
                        count++;
                        reCalculated.push(null);
                    }
                }
                per = (tableHeight - fix) / count;
                off = per - Math.round(per);
            }
            for (var row = 0, n = rowSize; row < n; row++) {
                var aW, px = !ispx ? "px" : "";
                rc++;
                t = ood.get(layoutData, ['rowSetting', row + 1, 'manualHeight']) || (prop.defaultRowHeight);
                switch (stretchHeight) {
                    case 'all':
                        aW = reCalculated[row] === null ? Math.max(prop.defaultRowHeight, (Math.round(per))) : reCalculated[row];
                        bW += aW;
                        rowHeights.push((row == rowSize - 1 ? Math.round(tableHeight - bW + aW) : aW) + px);
                        break;
                    case 'last':
                        rowHeights.push(row == rowSize - 1 ? lastoff + px : (t + px));
                        break;
                    default:
                        rowHeights.push(t + px);
                }
            }
            return rowHeights;
        },
        _getColWidths: function (prf, tableWidth) {
            var prop = prf.properties, layoutData = prop.layoutData, t,
                colSize = layoutData.cols || prop.defaultColumnSize,
                stretchH = prop.stretchH || 'all',
                reCalculated = [], colWidths = [], fix = 0, count = 0, per, off, rc = 0, bW = 0;

            if (colSize.length < 3) {
                return colSize;
            }

            if (stretchH == "all") {
                for (var col = 0, n = colSize; col < n; col++) {
                    var chr = ood.ExcelFormula.toColumnChr(col + 1);
                    if (t = ood.get(layoutData, ['colSetting', chr, 'manualWidth'])) {
                        fix += parseInt(t);
                        reCalculated.push(t);
                    } else {
                        count++;
                        reCalculated.push(null);
                    }
                }
                per = (tableWidth - fix) / count;
                off = per - Math.round(per);
            }
            var allW = 0;
            for (var col = 0, n = colSize; col < n; col++) {
                var chr = ood.ExcelFormula.toColumnChr(col + 1), aW;
                rc++;
                t = ood.get(layoutData, ['colSetting', chr, 'manualWidth']) || (prop.defaultColWidth);
                width = t = parseInt(t);
                switch (stretchH) {
                    case 'all':
                        aW = reCalculated[col] === null ? Math.max(prop.defaultColWidth, (Math.round(per))) : reCalculated[col];
                        if (ood.isNumb(aW)) {
                            bW += aW;
                        } else {
                            bW += parseInt(aW);
                        }
                        width = (col == colSize - 1 ? Math.round(tableWidth - bW + aW) - 25 : aW);
                        break;
                    case 'last':
                        width = col == colSize - 1 ? tableWidth - allW - 5 : t;
                        width = width - 20;
                        break;
                    default:
                        width = t;
                }
                allW = allW + width;
                colWidths.push(width);

            }
            return colWidths;

        },
        _setCustomBorders: function (prf) {
            ood.resetRun(prf.getUid() + ":cborder", function () {
                if (!prf.renderId) return;
                var cborder = prf.getSubNode("CBORDER").get(0);
                ood.arr.each(prf.properties.layoutData.customBorders, function (conf) {
                    var itemId = ood.ExcelFormula.toCellId(conf.col, conf.row),
                        subSerialId = prf.ItemIdMapSubSerialId[itemId],
                        table = prf.getSubNode("TABLE").get(0),
                        td = prf.getSubNode("ITEM", subSerialId),
                        pos = td.offset(null, table),
                        id, div, style;
                    if (conf.top && conf.top.width) {
                        id = prf.key + "-CBT:" + prf.serialId + ":" + subSerialId;
                        div = ood.Dom.byId(id);
                        style = div && div.style;
                        if (!div) {
                            div = document.createElement("div");
                            div.id = id;
                            cborder.appendChild(div);
                        }
                        style = div.style;
                        style.backgroundColor = conf.top.color;
                        style.left = (pos.left - 1) + "px";
                        style.top = (pos.top - 1) + "px";
                        style.width = td.offsetWidth() + "px";
                        style.height = "1px";
                    }
                    if (conf.left && conf.left.width) {
                        id = prf.key + "-CBL:" + prf.serialId + ":" + subSerialId;
                        div = ood.Dom.byId(id);
                        if (!div) {
                            div = document.createElement("div");
                            div.id = id;
                            cborder.appendChild(div);
                        }
                        style = div.style;
                        style.backgroundColor = conf.left.color;
                        style.left = (pos.left - 1) + "px";
                        style.top = (pos.top - 1) + "px";
                        style.width = "1px";
                        style.height = td.offsetHeight() + "px";
                    }
                });
            });
        },
        _resizeTable: function (prf, size, force, reload) {

            if (prf.boxing()._isDesignMode()) {
                var t;
                if (t = prf.$htable) {
                    try {
                        var osize = prf.getSubNode("HOLDER").cssSize();
                        if (!force && (size.width != osize.width || size.height != osize.height) || reload) {
                            prf.getSubNode("HOLDER").cssSize(size);
                            size.manualRowResize = this._getRowHeights(prf, size.height, true);
                            size.manualColumnResize = this._getColWidths(prf, size.width);
                            size.mergeCells = ood.copy(ood.get(t.getPlugin("mergeCells"), ["mergedCellsCollection", "mergedCells"]));
                            t.updateSettings(size);
                        }

                    } catch (e) {

                    }

                }
            } else {
                prf.getSubNode("HOLDER").cssSize(size);
                var tb = prf.getSubNode("TABLE");
                var tr = prf.getSubNode("TR");

                if (tb.get(0)) {
                    if (prf.properties.stretchH && prf.properties.stretchH != 'none') {
                        var rw = size.width - (tb.offsetHeight() > size.height ? ood.Dom.getScrollBarSize() : 0);
                        tb.width(rw);
                    }

                    //if (force || !prf.properties.stretchH || prf.properties.stretchH == "all") {
                    var colWidths = this._getColWidths(prf, rw);
                    tb.first().children().each(function (node, i) {
                        // ignore the first one for th
                        if (i !== 0) {
                            var width = colWidths[i - 1];
                            if (!ood.str.endWith(width + '', 'px')) {
                                width = width + 'px';
                            }
                            node.style.width = width;
                        }
                    });
                    //   }
                    var cells = [], rowHeights = this._getRowHeights(prf, size.height);
                    if (prf.properties.stretchHeight != 'none') {
                        var rh = size.height - (tb.offsetHeight() > size.height ? ood.Dom.getScrollBarSize() : 0);
                        tb.height(rh);
                        prf.getSubNodes("ITEM", true).each(function (cell) {
                            if (cell.parentNode.attributes.rowid) {
                                var rowid = parseInt(cell.attributes.rowid.value);
                                var height = rowHeights[rowid];
                                var th = cell.parentNode.children[0];
                                th.style.height = height;
                                //cell.style.height = height;
                            }
                        });

                    }

                    // to trigger cells onsize

                    prf.getSubNodes("ITEM", true).each(function (cell) {
                        if (ood.Dom.$hasEventHandler(cell, 'onsize')) cells.push(cell);
                    });
                    if (cells.length) ood(cells).onSize(true);

                    // adjust custom borders
                    prf.box._setCustomBorders(prf);
                }
            }
        },
        _updateSetting: function (prf, opt) {
            var t = prf.$htable;
            if (typeof opt == "string") {
                var h = {};
                h[opt] = prf.properties[opt];
                opt = h;
            }
            // for merged cells
            opt.mergeCells = ood.copy(ood.get(t.getPlugin("mergeCells"), ["mergedCellsCollection", "mergedCells"]));
            if ((!opt["stretchHeight"] && !opt["stretchH"]) || (opt["stretchHeight"] == 'none' || opt["stretchH"] == 'none')) {
                t.updateSettings(opt);
            }


        },


        $beforeAppend: function (prf, target, subId) {
            if (!subId) return false;
            // only one allowed
            // if (target && target.size && target.size() == 1) {
            //     ood.arr.each(prf.children, function (v) {
            //         if (v[0] && subId == v[1] && v[0] !== target.get(0)) {
            //             v[0].boxing().destroy();
            //         }
            //     }, true);
            // }
        },
        $afterAppend: function (prf, target, subId) {
            if (!subId) return;
            // force dock for the only widget
            var lineSpacing = prf.properties.lineSpacing | 0;
            if (prf.renderId && target['ood.UI'] && target.size() == 1) {
                var item = prf.getItemByItemId(subId), inputPrf = target.get(0), iProp = inputPrf.properties;
                if (item) {
                    var cell = prf.getSubNode("ITEM", item._serialId),
                        isFormField = inputPrf.box._isFormField ? inputPrf.box._isFormField(inputPrf) : !!ood.get(inputPrf, ['properties', 'isFormField']),
                        mode = prf.boxing().getMode(),
                        show = mode != 'read' || target['ood.UI.RichEditor'] || target['RAD.expression.JavaEditor'];
                    if (isFormField && (!iProp.name || prf.ItemIdMapSubSerialId[iProp.name])) {
                        iProp.name = item.id;
                    }
                    // for form field only
                    // onsize for dom must here
                    if (cell && cell.get(0)) {
                        // if parent is re-rendered
                        if (inputPrf._cellresizeP != cell) {
                            var adjustSize = function () {
                                if (!cell.get(0)) return;
                                if (target['ood.UI.Image'] || target['ood.UI.ProgressBar'] || target['ood.UI.Button']) {
                                    return;
                                }

                                target.setPosition('absolute').setLeft(0).setTop(lineSpacing / 2).setBottom(lineSpacing / 2);
                                var height = cell.offsetHeight(), width = cell.offsetWidth();
                                // first row/col , 2 pix border

                                if (target.setWidth) target.setWidth(width - (item.col ? 1 : 2));
                                if (target.setHeight) target.setHeight(height - (item.row ? 1 : 2) - lineSpacing);
                            };
                            adjustSize();
                            cell.onSize(adjustSize);
                            inputPrf._cellresizeP = cell;
                        }
                    }

                    if (!inputPrf._attached2cell) {
                        //console.log('afterappend',subId);
                        inputPrf._attached2cell = 1;
                        // for form field only
                        // prop and autoexpand
                        if (isFormField) {
                            if (show) {
                                inputPrf.locked = 1;
                                inputPrf.boxing().setDisplay('');
                                //if (target.setLabelPos) target.setLabelPos('none').setLabelCaption('').setLabelSize('0');
                                if (target.setLabelPos) target.setLabelPos('none').setLabelSize('0');
                                if (target.setVAlign) target.setVAlign('middle');

                                if (target['ood.UI.Input']
                                    && target.getMultiLines && target.getMultiLines()
                                    && target.setAutoexpand
                                ) {
                                    // use the hidden one: _autoexpand
                                    // once: set minH from subId
                                    if (!parseFloat(inputPrf._autoexpand)) {
                                        // need set autoexpand in afterRowResize too
                                        inputPrf._autoexpand = (cell.offsetHeight() - 1) + "px";
                                        inputPrf.getSubNode("INPUT").addClass("autoexpand");
                                        inputPrf.$beforeAutoexpand = function (p, h) {
                                            h = target.getAutoexpandHeight();
                                            item._child_autoexpandH = h;
                                            if (prf.boxing()._isDesignMode()) {
                                                // ensure to trigger table render once
                                                ood.resetRun(prf.getUid("autoex"), function () {
                                                    if (prf.$htable) prf.$htable.render();
                                                });
                                            } else {
                                                cell.height(h);
                                            }
                                            // adjust custom borders
                                            if (!prf.boxing()._isDesignMode())
                                                prf.box._setCustomBorders(prf);
                                            return false;
                                        };
                                        // try to trigger aoutoexpand
                                        inputPrf.box._checkAutoexpand(inputPrf);
                                    }
                                }
                                if (mode == 'read') {
                                    if (target.setReadonly) target.setReadonly(true, true);
                                }
                            } else {
                                inputPrf.boxing().setDisplay('none');
                            }
                        }
                        inputPrf.$handleCustomVars = function (d) {
                            if (d) {
                                for (var i in d) if (d[i]) this[i] = d[i];
                            } else {
                                return {
                                    _attached2cell: this._attached2cell,
                                    _autoexpand: this._autoexpand,
                                    $beforeAutoexpand: this.$beforeAutoexpand
                                }
                            }
                        }
                    }
                }
            }
        },
        _IllegalDetect: function (pro, target, throwErr) {
            return null;
            // detect those with html table node
            var count = 0, detect = function (arr) {
                ood.arr.each(arr, function (c) {
                    c = c[0] || c;
                    if (c.box && c.box.HasHtmlTableNode) count++;
                    else detect(c.children);
                });
            };
            detect(target._nodes);
            if (count) {
                if (throwErr) throw new Error('Cant append control with HTML TABLE node into ' + pro.key);
                else return count;
            }
        },
        _onresize: function (prf, width, height) {
            var prop = prf.properties,
                // compare with px
                us = ood.$us(prf),
                adjustunit = function (v, emRate) {
                    return prf.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                root = prf.getRoot(),
                boxNode = prf.getSubNode('BOX'),
                offset = prf.box._getHeaderOffset(prf),
                // caculate by px
                ww = width ? prf.$px(width) : width,
                hh = height ? prf.$px(height) : height,
                t;
            if (width || height) {
                // reset here
                if (width) prop.width = adjustunit(ww);
                if (height) prop.height = adjustunit(hh);

                boxNode.css({
                    marginLeft: -offset.left + "px",
                    marginTop: -offset.top + "px",
                    width: width ? (ww + offset.left + 'px') : null,
                    height: height ? (hh + offset.top + 'px') : null
                });

                ood.resetRun(prf.getUid("resize"), function () {
                    if (prf && prf.box) prf.box._resizeTable(prf, prf.getSubNode('BOX').cssSize(), false);
                });
            }
        }
    }
});ood.Class("ood.UI.MFormLayout", ["ood.UI", "ood.absList"], {
    Initialize: function () {
        this.addTemplateKeys(['ITEM', 'TABLE', 'CBORDER', 'CBT', 'CBL', 'HOLDER', 'SPREADER']);
    },
    Instance: {
        _isDesignMode: function () {
            return this.getMode() == "design";
        },
        getContainer: function (subId) {
            var prf = this.get(0);
            if (prf.ItemIdMapSubSerialId && prf.ItemIdMapSubSerialId[subId]) {
                return arguments.callee.upper.apply(this, [subId]);
            } else {
                return this.getSubNode("POOL");
            }
        },

        //  iniProp 
        iniProp: {
            items: []
        },
        //  iniProp 
        iniProp: {

            "name": "TestForm",
            "showEffects": "Classic",
            "width": "50em",
            "height": "20em",
            "visibility": "visible",
            "floatHandler": false,
            "defaultRowHeight": 35,
            "defaultColWidth": 150,
            "layoutData": {
                "rows": 3,
                "cols": 2,
                "merged": [
                    {
                        "row": 0,
                        "col": 0,
                        "rowspan": 1,
                        "colspan": 2,
                        "removed": false
                    }
                ],
                "rowSetting": {
                    "1": {
                        "manualHeight": 56
                    },
                    "2": {
                        "manualHeight": 35
                    },
                    "3": {
                        "manualHeight": 142
                    }
                },
                "colSetting": {
                    "A": {
                        "manualWidth": 150
                    },
                    "B": {
                        "manualWidth": 525
                    }
                },
                "cells": {
                    "A1": {
                        "value": "",
                        "style": {
                            "textAlign": "center",
                            "fontSize": "28px"
                        }
                    },
                    "A2": {
                        "value": "",
                        "style": {
                            "textAlign": "center"
                        }
                    },
                    "B2": {
                        "value": "",
                        "style": {
                            "textAlign": "left",
                            "paddingLeft": "10px"
                        }
                    },
                    "A3": {
                        "value": "",
                        "style": {
                            "textAlign": "center"
                        }
                    },
                    "B3": {
                        "value": "",
                        "style": {
                            "textAlign": "left",
                            "paddingLeft": "10px",
                            "fontSize": "14px",
                            "color": "#666"
                        }
                    }
                }

            }
        }
    },
    Static: {
        HasHtmlTableNode: 1,
        _CONTAINERKEY: "ITEM",
        _ITEMCONTAINER: 1,
        _ACTIVEHANDLER: ["KEY", "HOLDER"],
        _NoProp: {"conLayoutColumns": 1},
        _objectProp: {layoutData: 1},
        Appearances: {
            KEY: {
                overflow: 'hidden'
            },
            BOX: {
                position: 'absolute',
                left: 0,
                top: 0,
                'z-index': 1
            },
            CBORDER: {
                position: 'absolute',
                left: 0,
                top: 0
            },
            'CBORDER div': {
                position: 'absolute',
                display: 'block'
            },
            POOL: {
                position: 'absolute',
                left: '-100%',
                top: '-100%',
                width: 0,
                height: 0
            },
            HOLDER: {
                overflow: 'auto',
                position: 'relative'
            },
            TABLE: {
                'overflow': 'hidden',
                'border-collapse': 'separate',
                'border-spacing': '0',
                margin: '0',
                'border-width': '0',
                'table-layout': 'fixed',
                width: '0',
                'outline-width': '0',
                cursor: 'default',
                'max-width': 'none',
                'max-height': 'none'
            },
            "ITEM:empty:after": {
                'text-align': 'center',
                color: 'var(--text-muted)',
                content: 'attr(data-coord)',
                position: 'absolute',
                top: '0',
                bottom: '0',
                left: '0',
                right: '0',
                margin: 'auto',
                height: '1.5em',
                '-moz-user-select': ood.browser.gek ? '-moz-none' : null,
                '-khtml-user-select': ood.browser.kde ? 'none' : null,
                '-webkit-user-select': ood.browser.kde ? 'none' : null,
                '-o-user-select': ood.browser.opr ? 'none' : null,
                '-ms-user-select': (ood.browser.ie || ood.browser.newie) ? 'none' : null,
                'user-select': 'none',
                'touch-action': 'none'
            },
            // {{ for read/write mode (layoutcell)
            "ITEM.layoutcell": {
                "border-right": "1px solid transparent",
                "border-bottom": "1px solid transparent",
                "border-left": "none",
                "border-top": "none",
                $order: 1
            },
            "ITEM.layoutcell.firstrow": {
                "border-top": "1px solid transparent",
                $order: 2
            },
            "ITEM.layoutcell.firstcol": {
                "border-left": "1px solid transparent",
                $order: 2
            },
            "BOX.solidgridline ITEM.layoutcell": {
                "border-right": "1px solid var(--border)",
                "border-bottom": "1px solid var(--border)",
                "border-left": "none",
                "border-top": "none",
                $order: 3
            },
            "BOX.solidgridline ITEM.layoutcell.firstrow": {
                "border-top": "1px solid var(--border)",
                $order: 4
            },
            "BOX.solidgridline ITEM.layoutcell.firstcol": {
                "border-left": "1px solid var(--border)",
                $order: 4
            },
            // }}

            // {{ for design mode (handsontable)
            // reset 
            "KEY ITEM": {
                "position": "relative",
                background: "transparent",
                height: '22px',
                padding: '0 4px',
                overflow: 'hidden',
                'outline-width': '0',
                'white-space': 'pre-line',
                'empty-cells': 'show',
                'line-height': '1.22',
                'text-align': 'left',
                'vertical-align': 'middle',
                'background-clip': 'padding-box'
            },
            "KEY .handsontableInput": {
                'line-height': '1.22'
            },
            "KEY .handsontable tr": {
                background: "transparent"
            },
            // reset
            "BOX.handsontable tr:first-child td, BOX.handsontable tr:first-child th": {
                "border-top": "none"
            },
            "BOX.handsontable tr:first-child > td, BOX.handsontable tr:first-child > th": {
                "border-top": "1px solid #ccc"
            },
            // for handsontable solid grid lines
            ".handsontable.solidgridline td": {
                "border-right": "1px solid #444",
                "border-bottom": "1px solid #444"
            },
            ".handsontable.solidgridline tr:first-child > td": {
                "border-top": "1px solid #444"
            },
            ".handsontable.solidgridline th:nth-child(2), .handsontable.solidgridline td:first-of-type, .handsontable.solidgridline .htNoFrame + th, .handsontable.solidgridline .htNoFrame + td": {
                "border-left": "1px solid #444"
            },
            ".handsontable.nogridline td": {
                "border-right": "1px solid transparent",
                "border-bottom": "1px solid transparent"
            },
            ".handsontable.nogridline tr:first-child > td": {
                "border-top": "1px solid transparent"
            },
            ".handsontable.nogridline th:nth-child(2), .handsontable.nogridline td:first-of-type, .handsontable.nogridline .htNoFrame + th, .handsontable.nogridline .htNoFrame + td": {
                "border-left": "1px solid transparent"
            }
            // }}
        },
        Templates: {
            tagName: 'div',
            className: '{_className}',
            style: '{_style}',
            BOX: {
                tagName: 'div'
            },
            POOL: {
                tagName: 'div'
            }
        },
        Behaviors: {
            DroppableKeys: ['ITEM'],
            PanelKeys: ['ITEM'],
            HotKeyAllowed: false,
            ITEM: {}
        },
        DataModel: {
            expression: {
                ini: '',
                action: function () {
                }
            },
            tabindex: null,

            defaultFocus: null,
            disableClickEffect: null,
            disableHoverEffect: null,
            disableTips: null,
            disabled: null,
            renderer: null,
            selectable: null,
            tips: null,
            autoTips: null,
            overflow: null,
            items: {
                hidden: true
            },
            listKey: null,
            dragSortable: null,
            mode: {
                ini: 'write',
                listbox: ['design', 'write', 'read'],
                get: function () {
                    return this.$inDesign ? 'design' : (this.properties.mode || 'read');
                },
                action: function () {
                    this.boxing().refresh();
                }
            },
            lineSpacing: {
                ini: 0,
                action: function (value) {
                    this.boxing().refresh();
                }

            },
            width: {
                $spaceunit: 1,
                ini: '30em'
            },
            height: {
                $spaceunit: 1,
                ini: '25em'
            },
            solidGridlines: {
                ini: true,
                action: function (value) {
                    var cls = value ? "solidgridline" : this.boxing()._isDesignMode() ? "" : "nogridline",
                        node = this.getSubNode('BOX');
                    node.removeClass("solidgridline nogridline");
                    if (cls) node.addClass(cls);
                }
            },
            stretchHeight: {
                ini: "none",
                listbox: ["none", "last", "all"],
                action: function () {
                    if (this.boxing()._isDesignMode()) {
                        this.box._updateSetting(this, 'stretchHeight');
                        var size = this.getRoot().cssSize();
                        this.box._resizeTable(this, this.getSubNode('BOX').cssSize(), false, true);
                    } else {
                        this.box._resizeTable(this, this.getSubNode('BOX').cssSize(), false, true);
                    }
                }
            },
            stretchH: {
                ini: "all",
                listbox: ["all", "none", "last"],
                action: function () {
                    if (this.boxing()._isDesignMode()) {
                        this.box._updateSetting(this, 'stretchH');
                        this.box._resizeTable(this, this.getSubNode('BOX').cssSize(), false, true);
                    } else {
                        this.box._resizeTable(this, this.getSubNode('BOX').cssSize(), false, true);
                    }
                }
            },
            rowHeaderWidth: {
                ini: 25,
                action: function () {
                    if (this.boxing()._isDesignMode()) {
                        this.box._updateSetting(this, 'rowHeaderWidth');
                        var size = this.getRoot().cssSize();
                        ood.UI.$tryResize(this, size.width, size.height);
                    }
                }
            },
            columnHeaderHeight: {
                ini: 25,
                action: function () {
                    if (this.boxing()._isDesignMode()) {
                        this.box._updateSetting(this, 'columnHeaderHeight');
                        var size = this.getRoot().cssSize();
                        ood.UI.$tryResize(this, size.width, size.height);
                    }
                }
            },
            floatHandler: {
                ini: true,
                action: function () {
                    if (this.boxing()._isDesignMode()) {
                        var size = this.getRoot().cssSize();
                        ood.UI.$tryResize(this, size.width, size.height, true);
                    }
                }
            },
            defaultRowSize: 5,
            defaultColumnSize: 5,
            defaultRowHeight: 50,
            defaultColWidth: 120,

            // don't use handsometable's cell className - buggy (when moving row/column)
            // rows:5, cols:5, rowSetting:{'3':{}}, colSetting:{"B":{}}, cells:{A3:{type:"",value:"",,style:"",border:""}}, merged:[]
            layoutData: {
                ini: {},
                action: function () {
                    this.boxing().refresh();
                }
            },

            // if use handsontable 6.22 (MIT license) as renderer
            rendererCDNJS: "/plugins/formlayout/handsontable.full.min.js",
            rendererCDNCSS: "/plugins/formlayout/handsontable.full.min.css"
        },
        RenderTrigger: function () {
            var prf = this, prop = prf.properties, cls = prf.box;
            if (prf.boxing()._isDesignMode()) {
                if (window.Handsontable) cls._renderAsHandsontable(prf);
                else {
                    // prf.boxing().busy(false, "Loading table ...");
                    var cssId = "ood.UI.HTable:Handsontable";
                    ood.CSS.includeLink(prop.rendererCDNCSS, cssId);
                    ood.include("Handsontable", prop.rendererCDNJS, function () {
                        if (ood(cssId).get(0)) {
                            //prf.boxing().free();
                            cls._renderAsHandsontable(prf);
                            var size = prf.getRoot().cssSize();
                            ood.UI.$tryResize(prf, size.width, size.height);
                        } else {
                            ood.Thread.repeat(function () {
                                if (ood(cssId).get(0)) {
                                    //prf.boxing().free();
                                    cls._renderAsHandsontable(prf);
                                    var size = prf.getRoot().cssSize();
                                    ood.UI.$tryResize(prf, size.width, size.height);

                                    return false;
                                }
                            }, 200);
                        }
                    }, null, false, {cache: true});
                }
            } else {
                cls._renderAsH5Table(prf);
            }
            // will be called in refresh()
            prf.$handleCustomVars = function (d) {
                if (!d) {
                    ood.arr.each(prf.children, function (c) {
                        delete c[0]._attached2cell;
                        delete c[0]._autoexpand;
                    });
                }
            }
            prf.boxing().setSolidGridlines(prop.solidGridlines, true);
        },
        EventHandlers: {
            onShowTips: null,
            onGetCellData: function (cellCoord, cellObj, cellChild) {
            }
        },
        _getHeaderOffset: function (prf) {
            var prop = prf.properties, offset = {left: 0, top: 0};
            if (prop.floatHandler && prf.boxing()._isDesignMode()) {
                offset.left = prop.rowHeaderWidth;
                offset.top = prop.columnHeaderHeight + 1;
            }
            return offset;
        },
        _layoutChanged: function (prf, force) {
            if (force || prf._$tableInited)
                ood.resetRun(prf.getUid("layoutchanged"), function () {
                    //console.log("onLayoutChanged");
                    if (prf.properties) {
                        var oData = prf.properties.layoutData;
                        prf.properties.layoutData = prf.box._getLayoutData(prf);
                        if (prf.$onLayoutChanged) prf.$onLayoutChanged(prf, oData, prf.properties.layoutData);
                    }

                });
        },
        _getLayoutData: function (prf) {
            var prop = prf.properties,
                cells = {}, borders, rowSetting = {}, colSetting = {}, merged = [],
                layoutData = {},
                data, rows, cols, t, p, s, tmp;

            // handsontable to ood
            if (t = prf.$htable) {
                // rows:5, cols:5, merged:[]
                layoutData.rows = t.countRows();
                layoutData.cols = t.countCols();
                merged = ood.copy(ood.get(t.getPlugin("mergeCells"), ["mergedCellsCollection", "mergedCells"]));
                if (!ood.isEmpty(merged)) layoutData.merged = merged;

                s = t.getSettings();
                // rowSetting:{'3':{}}
                p = t.getPlugin("ManualRowResize");
                for (var i = 0, l = layoutData.rows, h; i < l; i++) {
                    var row = t.toPhysicalRow(i);
                    if (p.manualRowHeights && p.manualRowHeights[row]) ood.set(rowSetting, [i + 1, 'manualHeight'], p.manualRowHeights[row]);
                    if (tmp = ood.isArr(s.rowHeights) ? s.rowHeights[row] : s.rowHeights) ood.set(rowSetting, [i + 1, 'height'], tmp);
                }
                if (!ood.isEmpty(rowSetting)) layoutData.rowSetting = rowSetting;

                // colSetting:{"B":{}}
                p = t.getPlugin("ManualColumnResize");
                for (var i = 0, l = layoutData.cols, w; i < l; i++) {
                    var col = t.toPhysicalColumn(i);
                    if (p.manualColumnWidths && p.manualColumnWidths[col]) ood.set(colSetting, [ood.ExcelFormula.toColumnChr(i + 1), 'manualWidth'], p.manualColumnWidths[col]);
//                    if(tmp = ood.isArr(s.colWidths)?s.colWidths[col]:s.colWidths) ood.set(colSetting, [ood.ExcelFormula.toColumnChr(i+1), 'width'], tmp);
                }
                if (!ood.isEmpty(colSetting)) layoutData.colSetting = colSetting;

                // cells:{A3:{type:"",value:"",style:"",border:""}
                data = t.getData();
                // cells:{A3:{value:"v"}
                for (var i = 0, l = data.length; i < l; i++) {
                    var row = data[i];
                    for (var m = 0, n = row.length; m < n; m++) {
                        // ignore null/undefined/""
                        if (ood.isSet(data[i][m]) && data[i][m] !== "") {
                            ood.set(cells, [ood.ExcelFormula.toCellId(m, i), "value"], data[i][m]);
                        }
                    }
                }
                // cells:{A3:{style:{}}
                for (var i = 0, l = layoutData.rows; i < l; i++) {
                    var row = t.toPhysicalRow(i);
                    var rowMetas = t.getCellMetaAtRow(row);
                    if (rowMetas && rowMetas.length) {
                        for (var m = 0, n = rowMetas.length; m < n; m++) {
                            var col = t.toPhysicalColumn(m);
                            // align settings
                            // don't use className - buggy
//                        if(rowMetas[col].className)
//                            ood.set(cells, [ood.ExcelFormula.toCellId(m,i), "className"], ood.str.trim(rowMetas[col].className));
                            // style: ignore empty {}
                            if (!ood.isEmpty(rowMetas[col].style))
                                ood.set(cells, [ood.ExcelFormula.toCellId(m, i), "style"], ood.copy(rowMetas[col].style));
                        }
                    }

                }
                if (!ood.isEmpty(cells)) layoutData.cells = cells;

                var cbPlugin = t.getPlugin('customBorders');
                if ((borders = cbPlugin.getBorders()).length) {
                    layoutData.customBorders = ood.clone(borders, function (h, i) {
                        return i != 'id' && i != 'border'
                    });
                }
            }
            return layoutData;
        },
        _renderAsH5Table: function (prf) {
            var boxNode = prf.getSubNode("BOX"),
                elem = boxNode.get(0),
                prop = prf.properties,
                layoutData = prop.layoutData,
                rowSize = layoutData.rows || prop.defaultRowSize,
                colSize = layoutData.cols || prop.defaultColumnSize,
                childrenMap = {}, t, merged = {}, merged2 = {},
                getCellData = function (childrenMap, itemId) {
                    var data = prf.onGetCellData && prf.boxing().onGetCellData(prf, itemId, ood.get(layoutData, ["cells", itemId]), childrenMap[itemId]);
                    if (!ood.isSet(data)) {
                        if (!childrenMap[itemId]) {
                            data = ood.get(layoutData, ["cells", itemId, "value"]);
                        } else {
                            var childPrf = childrenMap[itemId], ins = childPrf && childPrf.boxing();
                            if (childPrf.key == 'ood.UI.RichEditor' || childPrf.key == 'ood.UI.Image') {
                                data = '';
                            } else if (childPrf.key == 'ood.UI.CheckBox' || childPrf.key == 'ood.UI.SCheckBox') {
                                data = '<input type="checkbox" disabled tabindex="-1"  onclick="javascript:return false;"'
                                    + (ins.getUIValue() ? "checked" : "")
                                    + '>' + ins.getCaption();
                            } else {
                                data = ins.getShowValue ? ins.getShowValue() :
                                    ins.getValue ? ('$UIvalue' in childPrf.properties ? ins.getUIValue() : ins.getValue()) :
                                        ins.getCaption ? ins.getCaption() :
                                            ins.getHtml ? ins.getHtml() :
                                                ins.getLabel ? ins.getLabel() :
                                                    '';
                            }
                        }
                    }
                    return ood.isSet(data) ? data : "";
                },
                cellProp, subSerialId, item, itemId, domId, styles, tpl = [];

            ood.arr.each(prf.children, function (v) {
                childrenMap[v[1]] = v[0];
            });
            ood.arr.each(layoutData.merged, function (v) {
                merged[v.row + ":" + v.col] = (v.rowspan > 1 ? (" rowspan=" + v.rowspan) : "") + (v.colspan ? (" colspan = " + v.colspan) : "") + " ";
                for (var i = 0, l = v.rowspan; i < l; i++) {
                    for (var j = 0, k = v.colspan; j < k; j++) {
                        if (i === 0 && j === 0) continue;
                        merged2[(v.row + i) + ":" + (v.col + j)] = 1;
                    }
                }
            });

            tpl.push("<div id='" + prf.key + "-HOLDER:" + prf.serialId + ":" + "' class='" + prf.getClass("HOLDER")
                + "' style='width:" + prop.width + "; height:" + prop.height
                + "' >");
            tpl.push("<table id='" + prf.key + "-TABLE:" + prf.serialId + ":" + "' class='" + prf.getClass("TABLE") + "'"
                + (prop.stretchH != 'none' ? (" style='width:" + prop.width + ";'") : "")
                + ">");
            // colgroup
            var colWidths = prf.box._getColWidths(prf, prf.$px(prop.width));
            tpl.push("<colgroup><col style='width:0;border:0;margin:0;padding:0;'></col>");
            for (var col = 0, n = colSize; col < n; col++) {
                tpl.push("<col rowid=" + row + " style='width:" + colWidths[col] + ";'></col>");
            }
            tpl.push("</colgroup>");
            // tbody
            tpl.push("<tbody>");

            for (var row = 0, l = rowSize; row < l; row++) {
                tpl.push("<tr rowid=" + row + "><th style='width:0;border:0;margin:0;padding:0;");
                if (t = ood.get(layoutData, ['rowSetting', row + 1, 'height']) || ood.get(layoutData, ['rowSetting', row + 1, 'manualHeight']) || prop.defaultRowHeight) {
                    tpl.push("height:" + (t - (row === 0 ? 1/*2*/ : 1)) + "px;");
                    //tpl.push("height:" + rowHeights[row] + "px;");
                }
                tpl.push("'></th>");
                for (var col = 0, n = colSize; col < n; col++) {
                    subSerialId = prf.pickSubId('items');
                    itemId = ood.ExcelFormula.toCellId(col, row);
                    item = {
                        _serialId: subSerialId,
                        col: col,
                        row: row,
                        id: itemId,
                        value: getCellData(childrenMap, itemId),
                        style: ood.get(layoutData, ["cells", itemId, "style"]) || {}
                    };
                    prf.ItemIdMapSubSerialId[itemId] = subSerialId;
                    prf.SubSerialIdMapItem[subSerialId] = item;

                    domId = prf.key + "-ITEM:" + prf.serialId + ":" + subSerialId;
                    styles = [];
                    ood.each(item.style, function (v, k) {
                        styles.push(k.replace(/[A-Z]/g, function (a) {
                            return '-' + a.toLowerCase()
                        }) + ":" + v);
                    });
                    // layoutData.merged
                    if (!merged2[row + ":" + col]) {
                        tpl.push("<td rowid=" + row + " id='" + domId + "' class='layoutcell " + (row === 0 ? 'firstrow ' : '') + (col === 0 ? 'firstcol ' : '') + prf.getClass("ITEM") + "' style='" + styles.join(";") + "' " + (merged[row + ":" + col] || "") + ">");
                        tpl.push(item.value);
                        tpl.push("</td>");
                    }
                }
                tpl.push("</tr>");
            }
            tpl.push("</tbody></table>");
            tpl.push("<div id='" + prf.key + "-CBORDER:" + prf.serialId + ":" + "' class='" + prf.getClass("CBORDER") + "' ></div>");
            tpl.push("</div>");

            elem.innerHTML = tpl.join("");
            ood.UI.$addEventsHandler(prf, elem, false);

            // layoutData.customBorders
            prf.box._setCustomBorders(prf);

            // lazy append
            var arr = [];
            ood.each(prf.children, function (v) {
                arr.push(v);
            });
            prf.children = [];
            ood.arr.each(arr, function (v) {
                prf.boxing().append(v[0], v[1]);
            });
        },
        _renderAsHandsontable: function (prf) {
            if (!prf || !prf.box) return;
            var onLayoutChanged = function (prf, force) {
                prf.box._layoutChanged(prf, force);
            };
            var boxNode = prf.getSubNode("BOX"),
                elem = boxNode.get(0),
                htable,
                prop = prf.properties,
                layoutData = prop.layoutData,
                designMode = true,
                fixedSet = {
                    // "fix" some functions for handsontable
                    autoWrapRow: true,
                    renderAllRows: true,
                    persistentState: false,

                    // "readonly" handsontable
                    readOnly: !designMode,
                    readOnlyCellClassName: "no",
                    comments: !designMode,
                    disableVisualSelection: !designMode,
                    enterBeginsEditing: designMode,
                    manualRowMove: designMode,
                    manualColumnMove: designMode,
                    contextMenu: designMode,
                    copyable: designMode,
                    copyPaste: designMode,
                    beforeOnCellMouseDown: !designMode ? null : function (e, c) {
                        // fire event
                        if (c.row === -1 && c.col === -1) {
                            e.stopImmediatePropagation();
                        }
                    },
                    afterOnCellMouseUp: !designMode ? null : function (e, c) {
                        // fire event
                        if (c.row === -1 && c.col === -1) {
                            this.deselectCell();
                            prf.getRoot().onClick(true);
                            e.stopImmediatePropagation();
                        }
                    },

                    /* cell render*/
                    // for ood dom id & event handler
                    beforeRenderer: function (TD, row, col, vprop, value, cellprop) {
                        var subSerialId = prf.pickSubId('items'),
                            itemId = ood.ExcelFormula.toCellId(col, row);
                        // memory map
                        cellprop.oid = cellprop.id;
                        cellprop.id = itemId;
                        if (cellprop.oid && cellprop.oid != cellprop.id) {
                            prf.$cellIdChangedMap[cellprop.oid] = cellprop.id;
                        }
                        cellprop._serialId = subSerialId;
                        prf.ItemIdMapSubSerialId[itemId] = subSerialId;
                        prf.SubSerialIdMapItem[subSerialId] = cellprop;
                        // customized styles
                        // first time, set cellprop.style from prop.layoutData
                        if (!cellprop.style) {
                            cellprop.style = ood.get(prop.layoutData, ["cells", ood.ExcelFormula.toCellId(col, row), "style"]) || {};
                        }
                        // dom
                        TD.id = prf.key + "-ITEM:" + prf.serialId + ":" + subSerialId;
                        ood.UI.$addEventsHandler(prf, TD, true);
                        for (var i in cellprop.style) TD.style[i] = cellprop.style[i];
                        // align class
//                        if(!cellprop.className){
//                            cellprop.className = ood.get(prop.layoutData, ["cells", ood.ExcelFormula.toCellId(col,row),"className"]) || "";
//                        }
                        TD.className = (TD.className || "") + prf.getClass("ITEM");
                        if (designMode)
                            TD.setAttribute('data-coord', itemId);
                        if (cellprop._child_autoexpandH) {
                            TD.style.height = cellprop._child_autoexpandH + "px";
                        } else {
                            TD.style.height = "";
                        }
                    },
                    /* cell renderer
                    renderer : function(instance, TD, row, col, vprop, value, cellprop){
                    },
                    */
                    /* table render*/
                    beforeRender: function (flag) {
                        // **: updateSetting will re-render all table elements
                        // we have to reset memory map, and keep children here
                        if (prf._$tableInited) {
                            prf.$cellIdChangedMap = {};
                            //*** save children first
                            var pool = prf.getSubNode("POOL").get(0), arr = [];
                            ood.arr.each(prf.children, function (v) {
                                if (v[0] && v[0].rendered) {
                                    pool.appendChild(v[0].getRootNode());
                                    arr.push(v);
                                }
                            });
                            //keep children, prevent to be destroyed
                            if (arr.length) {
                                prf._pool_children = arr;
                            }

                            // reset memory map
                            prf.children = [];
                            for (var i in prf.SubSerialIdMapItem)
                                prf.reclaimSubId(i, "items");
                            prf.ItemIdMapSubSerialId = {};
                            prf.SubSerialIdMapItem = {};
                        }
                    },
                    afterInit: function () {
                        prf._$tableInited = 1;
                    },
                    afterRender: function (isForced) {
                        //console.log('afterRender');
                        ood.tryF(prf.$onrender, [], prf);

//                        onLayoutChanged(prf);

                        // Set id for important nodes, for getting profile from dom id
                        var node = prf.getSubNode("BOX");
                        node = node.first();
                        node.id(prf.key + "-MASTER:" + prf.serialId + ":");
                        node = node.first();
                        node.id(prf.key + "-HOLDER:" + prf.serialId + ":");
                        node = node.first();
                        node.id(prf.key + "-HIDER:" + prf.serialId + ":");
                        node = node.first();
                        node.id(prf.key + "-SPREADER:" + prf.serialId + ":");

                        if (prf._$tableInited) {
                            var map = prf.$cellIdChangedMap;

                            //*** restore children
                            if (prf._pool_children) {
                                ood.arr.each(prf._pool_children, function (v) {
                                    delete v[0].$dockParent;
                                    if (v[0].$domId) {
                                        prf.boxing().append(v[0], map[v[1]] || v[1]);
                                    }

                                });
                                delete prf._pool_children;
                            }
                        } else {
                            //
                            // lazy append
                            var arr = [];
                            ood.each(prf.children, function (v) {
                                if (v[0].$domId) {
                                    arr.push(v);
                                }
                            });
                            prf.children = [];

                            ood.arr.each(arr, function (v) {
                                if (v[0].$xid) {
                                    prf.boxing().append(v[0], v[1]);
                                }

                            });

                            prf.getRoot().onMouseup(function (p, e) {
                                prf.$lastMousePos = ood.Event.getPos(e);
                            });
                        }
                    },

                    afterSelection: function () {
                        if (prop.floatHandler)
                            prf.getRoot().css('overflow', 'visible');
                    },
                    outsideClickDeselects: function (node) {
                        //for lang span, or inner renderer
                        while ((
                                (!node.id)
                                || node.id == ood.$localeDomId
                                || node.tagName == 'tspan'
                            )
                            && node.parentNode !== document && node.parentNode !== window
                            ) node = node.parentNode;
                        var p = ood.UIProfile.getFromDom(node);
                        if (p && prf.$popmenu) {
                            var r = prf.$popmenu.get(0);
                            if (p == r || p.$parentPopMenu == r || p.$popGrp == r.$popGrp) {
                                return false;
                            }
                        }

                        prf.getRoot().css('overflow', '');
                        return true;
                    },
                    afterContextMenuShow: !designMode ? null : function (context) {
                        if (prf.$onPopMenu) prf.$popmenu = prf.$onPopMenu(prf, prf.$popmenu, context.menu);
                        // don't use dft menu
                        context.menu.container.style.display = 'none';
                    },

                    afterUpdateSettings: function () {
                        // only resize use this
                        onLayoutChanged(prf);
                    },
                    afterRedo: function () {
                        onLayoutChanged(prf);
                    },
                    afterUndo: function () {
                        onLayoutChanged(prf);
                    },
                    afterChange: function (change, source) {
                        if (source != 'loadData' && source != 'populateFromArray')
                            onLayoutChanged(prf);
                    },
                    beforeCellAlignment: function () {
                        onLayoutChanged(prf);
                    },
                    afterMergeCells: function (a, b, auto) {
                        if (!auto)
                            onLayoutChanged(prf);
                    },
                    afterUnmergeCells: function (a, b, auto) {
                        if (!auto)
                            onLayoutChanged(prf);
                    },

                    // reset autoexpand
                    afterRowResize: function (row, size, dblclick) {
                        onLayoutChanged(prf);
                        var cells = this.getCellMetaAtRow(row);
                        for (var i = 0, l = cells.length; i < l; i++) {
                            var target = prf.boxing().getChildren(cells[i].id);
                            if (target['ood.UI.Input']
                                && target.getMultiLines && target.getMultiLines()
                                && target.setAutoexpand
                            ) {
                                target.get(0)._autoexpand = (size - 1) + "px";
                            }
                        }
                    },

                    afterColumnResize: function () {
                        onLayoutChanged(prf);
                    },
                    afterColumnSort: function () {
                        onLayoutChanged(prf);
                    },
                    afterRowMove: function (rows, target) {
                        onLayoutChanged(prf);
                    },
                    afterColumnMove: function () {
                        onLayoutChanged(prf);
                    },
                    // for fix ManualColumnResize and ManualRowResize
                    afterCreateCol: function (index, amount) {
                        onLayoutChanged(prf);

                        // patch for ManualColumnResize
                        var p = this.getPlugin("ManualColumnResize");
                        // new cols
                        var arr = [];
                        for (var i = 0; i < amount; i++) arr.push(prop.defaultColWidth);
                        // ensure length
                        if (!p.manualColumnWidths) p.manualColumnWidths = [];
                        for (var i = 0; i < index; i++) p.manualColumnWidths[i] = p.manualColumnWidths[i] || (void 0);
                        // insert
                        p.manualColumnWidths.splice.apply(p.manualColumnWidths, [index, 0].concat(arr));

                        this.deselectCell();
                        var ns = this;
                        ood.asyRun(function () {
                            ns.selectColumns(index);
                        });
                    },
                    afterCreateRow: function (index, amount) {
                        onLayoutChanged(prf);
                        // patch for ManualRowResize
                        var p = this.getPlugin("ManualRowResize");
                        // new row
                        var arr = [];
                        for (var i = 0; i < amount; i++) arr.push(prop.defaultRowHeight);
                        // ensure length
                        if (!p.manualRowHeights) p.manualRowHeights = [];
                        for (var i = 0; i < index; i++) p.manualRowHeights[i] = p.manualRowHeights[i] || (void 0);
                        // insert
                        p.manualRowHeights.splice.apply(p.manualRowHeights, [index, 0].concat(arr));

                        this.deselectCell();
                        var ns = this;
                        ood.asyRun(function () {
                            ns.selectRows(index);
                        });
                    },
                    afterRemoveCol: function (index, amount) {
                        onLayoutChanged(prf);
                        var p = this.getPlugin("ManualColumnResize");
                        if (p.manualColumnWidths) {
                            p.manualColumnWidths.splice(index, amount);
                        }
                        this.deselectCell();
                    },
                    afterRemoveRow: function (index, amount) {
                        onLayoutChanged(prf);
                        var p = this.getPlugin("ManualRowResize");
                        if (p.manualRowHeights) {
                            p.manualRowHeights.splice(index, amount);
                        }
                        this.deselectCell();
                    }
                },
                settings = {}, t;

            var offset = prf.box._getHeaderOffset(prf);
            // size
            settings.height = prf.$px(prop.height) + offset.top;
            settings.width = prf.$px(prop.width) + offset.left;
            // stretch
            settings.stretchHeight = (t = prop.stretchHeight) == "last" ? "last" : t == "all" ? "all" : "none";
            settings.stretchH = (t = prop.stretchH) == "last" ? "last" : t == "all" ? "all" : "none";
            // dft widht/height
            settings.rowHeaderWidth = prop.rowHeaderWidth;
            settings.columnHeaderHeight = prop.columnHeaderHeight;
            settings.defaultColumnWidth = prop.defaultColWidth;
            // show header?
            settings.rowHeaders = designMode;
            settings.colHeaders = designMode;


            // merged info
            if (layoutData.merged) {
                settings.mergeCells = layoutData.merged;
            } else {
                settings.mergeCells = designMode;
            }

            // data, manualRowResize, minRowHeights, manualColumnResize, colWidths, cellMetas
            // if there's table data
            if (layoutData.cols) {
                // cell data
                var minRowHeights = [], colWidths = [], manualRowResize = [], manualColumnResize = [], data = [], row;
                // manualRowResize (start from "1")
                ood.each(layoutData.rowSetting, function (v, k) {
                    if (ood.isSet(v.manualHeight || v)) manualRowResize[parseInt(k, 10) - 1] = parseInt(v.manualHeight || v, 10);
                    if (ood.isSet(v.height || v)) minRowHeights[parseInt(k, 10) - 1] = parseInt(v.height || v, 10);
                });
                // manualColumnResize (start from "A"=>"1")
                ood.each(layoutData.colSetting, function (v, k) {
                    k = ood.ExcelFormula.toColumnNum(k);
                    if (ood.isSet(v.manualWidth || v)) manualColumnResize[k - 1] = parseInt(v.manualWidth || v, 10);
                    // if(ood.isSet(v.width||v))colWidths[k - 1]=parseInt(v.width||v,10);
                });
                // init data
                for (var i = 0, l = layoutData.rows || prop.defaultRowSize; i < l; i++) {
                    data.push(row = []);
                    for (var m = 0, n = layoutData.cols || prop.defaultColumnSize; m < n; m++) {
                        row.push(null);
                    }
                }
                // fill data
                ood.each(layoutData.cells, function (cell, id) {
                    var coord = ood.ExcelFormula.toCoordinate(id);
                    data[coord.row][coord.col] = ood.isSet(cell.value) ? cell.value : null;
                });

                // set manualRowResize, manualColumnResize and data
                for (var i = 0; i < layoutData.rows; i++) {
                    manualRowResize[i] = manualRowResize[i] || prop.defaultRowHeight;
                }
                settings.manualRowResize = manualRowResize;
                settings.manualColumnResize = !ood.isEmpty(manualColumnResize) ? manualColumnResize : designMode;

                if (!ood.isEmpty(minRowHeights)) settings.rowHeights = minRowHeights;
                // don't use colWidths
                //if(!ood.isEmpty(colWidths))settings.colWidths = colWidths;

                settings.data = data;

                if (layoutData.customBorders)
                    settings.customBorders = layoutData.customBorders;
            } else {
                settings.manualColumnResize = designMode;
                var manualRowResize = [];
                for (var i = 0; i < prop.defaultRowSize; i++) {
                    manualRowResize[i] = prop.defaultRowHeight;
                }
                settings.manualRowResize = manualRowResize;
            }
            prf.$htable = htable = new Handsontable(elem, ood.merge(settings, fixedSet, 'all'));

            if (!layoutData.cols) {
                // reset layoutData
                prf.properties.layoutData = prf.box._getLayoutData(prf);
            }

            // set before destroy function
            (prf.$beforeDestroy = (prf.$beforeDestroy || {}))["destroyhtable"] = function () {
                var t;
                if (t = this.$htable) {
                    // must purge lazy-bound node here
                    var node = this.getSubNode("BOX").get(0);
                    if (node)
                        ood.$purgeChildren(node);

                    if (!t.isDestroyed) {
                        Handsontable.hooks.destroy(t);
                        t.destroy();
                    }
                    delete this.$htable;
                }
                if (t = this.$popmenu) {
                    t.destroy();
                }
            }
        },

        _getRowHeights: function (prf, tableHeight, ispx) {
            var prop = prf.properties, layoutData = prop.layoutData, t,
                rowSize = layoutData.rows || prop.defaultRowSize, rowsize = [],
                reCalculated = [], rowHeights = [], fix = 0, count = 0, per, off, rc = 0, bW = 0,
                stretchHeight = prop.stretchHeight || 'all',
                lastoff = prop.defaultRowHeight;

            for (var row = 0, n = rowSize; row < n; row++) {
                if (t = ood.get(layoutData, ['rowSetting', row + 1, 'manualHeight'])) {
                    if (row < rowSize - 1) {
                        fix += parseInt(t);
                    }
                }
            }
            lastoff = tableHeight - fix;
            if (stretchHeight == "all") {
                for (var row = 0, n = rowSize; row < n; row++) {
                    if (t = ood.get(layoutData, ['rowSetting', row + 1, 'manualHeight'])) {
                        fix += parseInt(t);
                        reCalculated.push(t);
                    } else {
                        count++;
                        reCalculated.push(null);
                    }
                }
                per = (tableHeight - fix) / count;
                off = per - Math.round(per);
            }
            for (var row = 0, n = rowSize; row < n; row++) {
                var aW, px = !ispx ? "px" : "";
                rc++;
                t = ood.get(layoutData, ['rowSetting', row + 1, 'manualHeight']) || (prop.defaultRowHeight);
                switch (stretchHeight) {
                    case 'all':
                        aW = reCalculated[row] === null ? Math.max(prop.defaultRowHeight, (Math.round(per))) : reCalculated[row];
                        bW += aW;
                        rowHeights.push((row == rowSize - 1 ? Math.round(tableHeight - bW + aW) : aW) + px);
                        break;
                    case 'last':
                        rowHeights.push(row == rowSize - 1 ? lastoff + px : (t + px));
                        break;
                    default:
                        rowHeights.push(t + px);
                }
            }
            return rowHeights;
        },
        _getColWidths: function (prf, tableWidth) {
            var prop = prf.properties, layoutData = prop.layoutData, t,
                colSize = layoutData.cols || prop.defaultColumnSize,
                stretchH = prop.stretchH || 'all',
                reCalculated = [], colWidths = [], fix = 0, count = 0, per, off, rc = 0, bW = 0;

            if (colSize.length < 3) {
                return colSize;
            }

            if (stretchH == "all") {
                for (var col = 0, n = colSize; col < n; col++) {
                    var chr = ood.ExcelFormula.toColumnChr(col + 1);
                    if (t = ood.get(layoutData, ['colSetting', chr, 'manualWidth'])) {
                        fix += parseInt(t);
                        reCalculated.push(t);
                    } else {
                        count++;
                        reCalculated.push(null);
                    }
                }
                per = (tableWidth - fix) / count;
                off = per - Math.round(per);
            }
            var allW = 0;
            for (var col = 0, n = colSize; col < n; col++) {
                var chr = ood.ExcelFormula.toColumnChr(col + 1), aW;
                rc++;
                t = ood.get(layoutData, ['colSetting', chr, 'manualWidth']) || (prop.defaultColWidth);
                width = t = parseInt(t);

                allW = allW + width;
                switch (stretchH) {
                    case 'all':
                        aW = reCalculated[col] === null ? Math.max(prop.defaultColWidth, (Math.round(per))) : reCalculated[col];
                        if (ood.isNumb(aW)) {
                            bW += aW;
                        } else {
                            bW += parseInt(aW);
                        }
                        width = (col == colSize - 1 ? Math.round(tableWidth - bW + aW) : aW);
                        break;
                    case 'last':
                        width = col == colSize - 1 ? tableWidth - allW : t;
                        break;
                    default:
                        width = t;
                }
                colWidths.push(width);

            }
            return colWidths;

        },
        _setCustomBorders: function (prf) {
            ood.resetRun(prf.getUid() + ":cborder", function () {
                if (!prf.renderId) return;
                var cborder = prf.getSubNode("CBORDER").get(0);
                ood.arr.each(prf.properties.layoutData.customBorders, function (conf) {
                    var itemId = ood.ExcelFormula.toCellId(conf.col, conf.row),
                        subSerialId = prf.ItemIdMapSubSerialId[itemId],
                        table = prf.getSubNode("TABLE").get(0),
                        td = prf.getSubNode("ITEM", subSerialId),
                        pos = td.offset(null, table),
                        id, div, style;
                    if (conf.top && conf.top.width) {
                        id = prf.key + "-CBT:" + prf.serialId + ":" + subSerialId;
                        div = ood.Dom.byId(id);
                        style = div && div.style;
                        if (!div) {
                            div = document.createElement("div");
                            div.id = id;
                            cborder.appendChild(div);
                        }
                        style = div.style;
                        style.backgroundColor = 'var(--' + conf.top.color + ')';
                        style.left = (pos.left - 1) + "px";
                        style.top = (pos.top - 1) + "px";
                        style.width = td.offsetWidth() + "px";
                        style.height = "1px";
                    }
                    if (conf.left && conf.left.width) {
                        id = prf.key + "-CBL:" + prf.serialId + ":" + subSerialId;
                        div = ood.Dom.byId(id);
                        if (!div) {
                            div = document.createElement("div");
                            div.id = id;
                            cborder.appendChild(div);
                        }
                        style = div.style;
                        style.backgroundColor = 'var(--' + conf.left.color + ')';
                        style.left = (pos.left - 1) + "px";
                        style.top = (pos.top - 1) + "px";
                        style.width = "1px";
                        style.height = td.offsetHeight() + "px";
                    }
                });
            });
        },
        _resizeTable: function (prf, size, force, reload) {

            if (prf.boxing()._isDesignMode()) {
                var t;
                if (t = prf.$htable) {
                    try {
                        var osize = prf.getSubNode("HOLDER").cssSize();
                        if (!force && (size.width != osize.width || size.height != osize.height) || reload) {
                            prf.getSubNode("HOLDER").cssSize(size);
                            size.manualRowResize = this._getRowHeights(prf, size.height, true);
                            size.manualColumnResize = this._getColWidths(prf, size.width);
                            size.mergeCells = ood.copy(ood.get(t.getPlugin("mergeCells"), ["mergedCellsCollection", "mergedCells"]));
                            t.updateSettings(size);
                        }

                    } catch (e) {

                    }

                }
            } else {
                prf.getSubNode("HOLDER").cssSize(size);
                var tb = prf.getSubNode("TABLE");
                var tr = prf.getSubNode("TR");

                if (tb.get(0)) {
                    if (prf.properties.stretchH && prf.properties.stretchH != 'none') {
                        var rw = size.width - (tb.offsetHeight() > size.height ? ood.Dom.getScrollBarSize() : 0);
                        tb.width(rw);
                    }

                    //if (force || !prf.properties.stretchH || prf.properties.stretchH == "all") {
                    var colWidths = this._getColWidths(prf, rw);
                    tb.first().children().each(function (node, i) {
                        // ignore the first one for th
                        if (i !== 0) {
                            var width = colWidths[i - 1];
                            if (!ood.str.endWith(width + '', 'px')) {
                                width = width + 'px';
                            }
                            node.style.width = width;
                        }
                    });
                    //   }
                    var cells = [], rowHeights = this._getRowHeights(prf, size.height);
                    if (prf.properties.stretchHeight != 'none') {
                        var rh = size.height - (tb.offsetHeight() > size.height ? ood.Dom.getScrollBarSize() : 0);
                        tb.height(rh);
                        prf.getSubNodes("ITEM", true).each(function (cell) {
                            if (cell.parentNode.attributes.rowid) {
                                var rowid = parseInt(cell.attributes.rowid.value);
                                var height = rowHeights[rowid];
                                var th = cell.parentNode.children[0];
                                th.style.height = height;
                                //cell.style.height = height;
                            }
                        });

                    }

                    // to trigger cells onsize

                    prf.getSubNodes("ITEM", true).each(function (cell) {
                        if (ood.Dom.$hasEventHandler(cell, 'onsize')) cells.push(cell);
                    });
                    if (cells.length) ood(cells).onSize(true);

                    // adjust custom borders
                    prf.box._setCustomBorders(prf);
                }
            }
        },
        _updateSetting: function (prf, opt) {
            var t = prf.$htable;
            if (typeof opt == "string") {
                var h = {};
                h[opt] = prf.properties[opt];
                opt = h;
            }
            // for merged cells
            opt.mergeCells = ood.copy(ood.get(t.getPlugin("mergeCells"), ["mergedCellsCollection", "mergedCells"]));
            if ((!opt["stretchHeight"] && !opt["stretchH"]) || (opt["stretchHeight"] == 'none' || opt["stretchH"] == 'none')) {
                t.updateSettings(opt);
            }


        },


        $beforeAppend: function (prf, target, subId) {
            if (!subId) return false;
            // only one allowed
            // if (target && target.size && target.size() == 1) {
            //     ood.arr.each(prf.children, function (v) {
            //         if (v[0] && subId == v[1] && v[0] !== target.get(0)) {
            //             v[0].boxing().destroy();
            //         }
            //     }, true);
            // }
        },
        $afterAppend: function (prf, target, subId) {
            if (!subId) return;
            // force dock for the only widget
            var lineSpacing = prf.properties.lineSpacing | 0;
            if (prf.renderId && target['ood.UI'] && target.size() == 1) {
                var item = prf.getItemByItemId(subId), inputPrf = target.get(0), iProp = inputPrf.properties;
                if (item) {
                    var cell = prf.getSubNode("ITEM", item._serialId),
                        isFormField = inputPrf.box._isFormField ? inputPrf.box._isFormField(inputPrf) : !!ood.get(inputPrf, ['properties', 'isFormField']),
                        mode = prf.boxing().getMode(),
                        show = mode != 'read' || target['ood.UI.RichEditor'];
                    if (isFormField && (!iProp.name || prf.ItemIdMapSubSerialId[iProp.name])) {
                        iProp.name = item.id;
                    }
                    // for form field only
                    // onsize for dom must here
                    if (cell && cell.get(0)) {
                        // if parent is re-rendered
                        if (inputPrf._cellresizeP != cell) {
                            var adjustSize = function () {
                                if (!cell.get(0)) return;
                                if (target['ood.UI.Image'] || target['ood.UI.ProgressBar'] || target['ood.UI.Button']) {
                                    return;
                                }
                                target.setPosition('absolute').setLeft(0).setTop(lineSpacing / 2).setBottom(lineSpacing / 2);
                                var height = cell.offsetHeight(), width = cell.offsetWidth();
                                // first row/col , 2 pix border
                                if (target.setWidth) target.setWidth(width - (item.col ? 1 : 2));
                                if (target.setHeight) target.setHeight(height - (item.row ? 1 : 2) - lineSpacing);
                            };
                            adjustSize();
                            cell.onSize(adjustSize, 'cellresize');
                            inputPrf._cellresizeP = cell;
                        }
                    }

                    if (!inputPrf._attached2cell) {
                        //console.log('afterappend',subId);
                        inputPrf._attached2cell = 1;
                        // for form field only
                        // prop and autoexpand
                        if (isFormField) {
                            if (show) {
                                inputPrf.locked = 1;
                                inputPrf.boxing().setDisplay('');
                                if (target.setLabelPos) target.setLabelPos('none').setLabelCaption('').setLabelSize('0');
                                if (target.setVAlign) target.setVAlign('middle');

                                if (target['ood.UI.Input']
                                    && target.getMultiLines && target.getMultiLines()
                                    && target.setAutoexpand
                                ) {
                                    // use the hidden one: _autoexpand
                                    // once: set minH from subId
                                    if (!parseFloat(inputPrf._autoexpand)) {
                                        // need set autoexpand in afterRowResize too
                                        inputPrf._autoexpand = (cell.offsetHeight() - 1) + "px";
                                        inputPrf.getSubNode("INPUT").addClass("autoexpand");
                                        inputPrf.$beforeAutoexpand = function (p, h) {
                                            h = target.getAutoexpandHeight();
                                            item._child_autoexpandH = h;
                                            if (prf.boxing()._isDesignMode()) {
                                                // ensure to trigger table render once
                                                ood.resetRun(prf.getUid("autoex"), function () {
                                                    if (prf.$htable) prf.$htable.render();
                                                });
                                            } else {
                                                cell.height(h);
                                            }
                                            // adjust custom borders
                                            if (!prf.boxing()._isDesignMode())
                                                prf.box._setCustomBorders(prf);
                                            return false;
                                        };
                                        // try to trigger aoutoexpand
                                        inputPrf.box._checkAutoexpand(inputPrf);
                                    }
                                }
                                if (mode == 'read') {
                                    if (target.setReadonly) target.setReadonly(true, true);
                                }
                            } else {
                                inputPrf.boxing().setDisplay('none');
                            }
                        }
                        inputPrf.$handleCustomVars = function (d) {
                            if (d) {
                                for (var i in d) if (d[i]) this[i] = d[i];
                            } else {
                                return {
                                    _attached2cell: this._attached2cell,
                                    _autoexpand: this._autoexpand,
                                    $beforeAutoexpand: this.$beforeAutoexpand
                                }
                            }
                        }
                    }
                }
            }
        },
        _IllegalDetect: function (pro, target, throwErr) {
            return null;
            // detect those with html table node
            var count = 0, detect = function (arr) {
                ood.arr.each(arr, function (c) {
                    c = c[0] || c;
                    if (c.box && c.box.HasHtmlTableNode) count++;
                    else detect(c.children);
                });
            };
            detect(target._nodes);
            if (count) {
                if (throwErr) throw new Error('Cant append control with HTML TABLE node into ' + pro.key);
                else return count;
            }
        },
        _onresize: function (prf, width, height) {
            var prop = prf.properties,
                // compare with px
                us = ood.$us(prf),
                adjustunit = function (v, emRate) {
                    return prf.$forceu(v, us > 0 ? 'em' : 'px', emRate)
                },
                root = prf.getRoot(),
                boxNode = prf.getSubNode('BOX'),
                offset = prf.box._getHeaderOffset(prf),
                // caculate by px
                ww = width ? prf.$px(width) : width,
                hh = height ? prf.$px(height) : height,
                t;
            if (width || height) {
                // reset here
                if (width) prop.width = adjustunit(ww);
                if (height) prop.height = adjustunit(hh);

                boxNode.css({
                    marginLeft: -offset.left + "px",
                    marginTop: -offset.top + "px",
                    width: width ? (ww + offset.left + 'px') : null,
                    height: height ? (hh + offset.top + 'px') : null
                });

                ood.resetRun(prf.getUid("resize"), function () {
                    if (prf && prf.box) prf.box._resizeTable(prf, prf.getSubNode('BOX').cssSize(), false);
                });
            }
        }
    }
});/**
 * FoldingTabs - 
 * CodeBuddy
 *
 * @class ood.UI.FoldingTabs
 * @extends ood.UI.Tabs
 * @version 1.0.0
 * @author CodeBuddy
 * @description 
 */
ood.Class("ood.UI.FoldingTabs", "ood.UI.Tabs", {
    /**
     * 
     * @namespace Instance
     */
    Instance: {
        //  iniProp 
        iniProp: {
            items: [
                {id: 'a', caption: 'tab1', message: "normal"},
                {id: 'b', caption: 'tab2', message: "with image", imageClass: "ri-image-line"},
                {id: 'c', caption: 'tab3', message: "height:100", height: 100},
                {
                    id: 'd',
                    caption: '$RAD.widgets.collapsible',
                    message: "with commands",
                    closeBtn: true,
                    optBtn: 'ood-uicmd-opt',
                    popBtn: true
                }
            ],
            value: 'a'
        },

        /**
         * 
         * @param {string} theme - : 'light', 'dark', 'high-contrast'
         * @returns {Object} this - 
         */
        setTheme: function (theme) {
            return this.each(function (profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();

                // 
                root.addClass('foldingtabs-themed')
                    .removeClass('foldingtabs-dark foldingtabs-hc');

                if (theme === 'dark') {
                    root.addClass('foldingtabs-dark');
                } else if (theme === 'high-contrast') {
                    root.addClass('foldingtabs-hc');
                }

                // 
                localStorage.setItem('foldingtabs-theme', theme);
            });
        },


        /**
         * 
         * @returns {Object} this - 
         */
        enhanceAccessibility: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    items = profile.getSubNodes('ITEM');

                // ARIA
                this._setContainerAccessibility(root);

                // ARIA
                items.forEach(function (item, index) {
                    this._setItemAccessibility(profile, item);
                }, this);
            });
        },


        /**
         * 
         * @returns {Object} this - 
         */
        adjustLayout: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    viewportWidth = ood(document.body).cssSize().width;
                // 
                this._applyResponsiveClasses(root, viewportWidth);
            });
        },


        /**
         * 
         * @returns {string} 
         */
        getTheme: function () {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('foldingtabs-theme') || 'light';
        },

        /**
         * 
         * @returns {Object} this - 
         */
        toggleTheme: function () {
            var currentTheme = this.getTheme();
            var nextTheme = currentTheme === 'light' ? 'dark' :
                (currentTheme === 'dark' ? 'high-contrast' : 'light');
            this.setTheme(nextTheme);
            return this;
        },


        /**
         * UI
         * @param {Object} box - 
         * @param {string} value - 
         * @param {Object} profile - 
         * @param {Object} item - 
         * @param {Event} event - 
         * @param {HTMLElement} source - 
         * @param {number} checktype - 
         * @private
         */
        _updateUIValue: function (box, value, profile, item, event, source, checktype) {
            if (box.getUIValue() !== value) {
                box.setUIValue(value, null, null, 'click');

                // 
                if (box.get(0) && box.getUIValue() === value) {
                    box.onItemSelected(profile, item, event, source, checktype);
                }
            }
        },
        /**
         * 
         * @namespace DataModel
         */

        /**
         * 
         * @param {Object} item - 
         * @param {Object} properties - 
         * @private
         */
        _setBackgroundInfo: function (item, properties) {
            var t;
            item._bginfo = "";

            // 
            if (t = item.panelBgClr || properties.panelBgClr) {
                item._bginfo += "background-color:" + t + ";";
            }

            // 
            if (t = item.panelBgImg || properties.panelBgImg) {
                item._bginfo += "background-image:url(" + ood.adjustRes(t) + ");";
            }

            // 
            if (t = item.panelBgImgPos || properties.panelBgImgPos) {
                item._bginfo += "background-position:" + t + ";";
            }

            // 
            if (t = item.panelBgImgRepeat || properties.panelBgImgRepeat) {
                item._bginfo += "background-repeat:" + t + ";";
            }

            // 
            if (t = item.panelBgImgAttachment || properties.panelBgImgAttachment) {
                item._bginfo += "background-attachment:" + t + ";";
            }
        },

        /**
         * 
         * @param {Object} item - 
         * @param {Object} properties - 
         * @private
         */
        _setOverflowStyle: function (item, properties) {
            if (ood.isStr(item.overflow)) {
                item._overflow = item.overflow.indexOf(':') != -1 ?
                    (item.overflow) :
                    (item.overflow ? ("overflow:" + item.overflow) : "");
            } else if (ood.isStr(properties.overflow)) {
                item._overflow = properties.overflow.indexOf(':') != -1 ?
                    (properties.overflow) :
                    (properties.overflow ? ("overflow:" + properties.overflow) : "");
            }
        },


        /**
         * 
         * @param {Object} profile - 
         * @param {Object} item - 
         * @private
         */
        _setItemAccessibility: function (profile, item) {
            var itemId = profile.getItemIdByDom(item),
                isExpanded = profile.getItemByItemId(itemId)._show || false;

            // 
            item.attr({
                'role': 'tab',
                'aria-selected': isExpanded,
                'aria-controls': 'foldingtabs-panel-' + itemId,
                'aria-expanded': isExpanded
            });

            // 
            var body = profile.getSubNode('BODY', profile.getSubIdByItemId(itemId));
            if (body) {
                body.attr({
                    'id': 'foldingtabs-panel-' + itemId,
                    'role': 'tabpanel',
                    'aria-labelledby': 'foldingtabs-tab-' + itemId
                });
            }

            // 
            var title = profile.getSubNode('TITLE', profile.getSubIdByItemId(itemId));
            if (title) {
                title.attr({
                    'id': 'foldingtabs-tab-' + itemId,
                    'role': 'button',
                    'tabindex': '0'
                });
            }
        },


        /**
         * 
         * @param {Object} root - 
         * @private
         */
        _setContainerAccessibility: function (root) {
            root.attr({
                'role': 'tablist',
                'aria-label': ''
            });
        },

        /**
         * 
         * @private
         */
        _initAnimationStyles: function () {
            if (!document.getElementById('ood-foldingtabs-animations')) {
                var style = document.createElement('style');
                style.id = 'ood-foldingtabs-animations';

                // 
                var duration = '0.3s';
                style.textContent = `
                    .ood-foldingtabs-body-open {
                        animation: ood-foldingtabs-open ${duration} ease-out;
                    }
                    
                    @keyframes ood-foldingtabs-open {
                        from { opacity: 0; transform: translateY(-10px); }
                        to { opacity: 1; transform: translateY(0); }
                    }
                `;
                document.head.appendChild(style);
            }
        },

        /**
         * 
         * @param {Object} properties - 
         * @private
         */
        _initTheme: function (properties) {
            if (properties.theme) {
                this.setTheme(properties.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('foldingtabs-theme');
                if (savedTheme) {
                    this.setTheme(savedTheme);
                }
            }
        },

        /**
         * 
         * @param {Object} root - 
         * @param {number} viewportWidth - 
         * @private
         */
        _applyResponsiveClasses: function (root, viewportWidth) {
            //  (< 768px)
            if (viewportWidth < 768) {
                root.addClass('foldingtabs-mobile');
            } else {
                root.removeClass('foldingtabs-mobile');
            }

            //  (< 480px)
            if (viewportWidth < 480) {
                root.addClass('foldingtabs-tiny');
            } else {
                root.removeClass('foldingtabs-tiny');
            }
        },


        /**
         * 
         * @param {Object} profile - 
         * @param {Object} properties - 
         * @param {Object} item - 
         * @param {Object} box - 
         * @param {Event} event - 
         * @param {HTMLElement} source - 
         * @private
         */
        _handleSelectionByMode: function (profile, properties, item, box, event, source) {
            switch (properties.selMode) {
                // 
                case 'multi':
                    this._handleMultiSelection(profile, properties, item, box, event, source);
                    break;

                // 
                case 'single':
                    this._handleSingleSelection(profile, item, box, event, source);
                    break;
            }
        },

        /**
         * 
         * @param {Object} profile - 
         * @param {Object} properties - 
         * @param {Object} item - 
         * @param {Object} box - 
         * @param {Event} event - 
         * @param {HTMLElement} source - 
         * @private
         */
        _handleMultiSelection: function (profile, properties, item, box, event, source) {
            var value = box.getUIValue(),
                arr = value ? value.split(properties.valueSeparator) : [],
                checktype = 1;

            if (arr.length) {
                // 
                if (ood.arr.indexOf(arr, item.id) !== -1) {
                    ood.arr.removeValue(arr, item.id);
                    checktype = -1;
                }
                // 
                else {
                    arr.push(item.id);
                }

                // 
                arr.sort();
                value = arr.join(properties.valueSeparator);

                // UI
                this._updateUIValue(box, value, profile, item, event, source, checktype);
            }
        },

        /**
         * 
         * @param {Object} profile - 
         * @param {Object} item - 
         * @param {Object} box - 
         * @param {Event} event - 
         * @param {HTMLElement} source - 
         * @private
         */
        _handleSingleSelection: function (profile, item, box, event, source) {
            if (box.getUIValue() !== item.id) {
                box.setUIValue(item.id, null, null, 'click');

                // 
                if (box.get(0) && box.getUIValue() === item.id) {
                    box.onItemSelected(profile, item, event, source, 1);
                }
            }
        },

        _afterInsertItems: null
    },
    Static: {
        Templates: {
            tagName: 'div',
            style: '{_style};',
            BOX: {
                $order: 0,
                tagName: 'div',
                ITEMS: {
                    tagName: 'div',
                    text: "{items}"
                }
            },
            $submap: {
                items: {
                    ITEM: {
                        tagName: 'div',
                        className: 'ood-uiborder-flat ood-uiborder-radius {_checked} {_precheked} {itemClass} {disabled} {readonly} ood-foldingtabs-item',
                        style: '{_itemDisplay} {itemStyle} ',
                        HEAD: {
                            tagName: 'div',
                            style: "{_itemColor}",
                            className: 'ood-uibar {_checked} {_precheked} ood-foldingtabs-header',
                            TITLE: {
                                tabindex: '{_tabindex}',
                                TLEFT: {
                                    $order: 0,
                                    tagName: 'div',
                                    LTAGCMDS: {
                                        $order: 0,
                                        tagName: 'span',
                                        style: '{_ltagDisplay}',
                                        text: "{ltagCmds}"
                                    },
                                    TOGGLE: {
                                        $order: 1,
                                        className: 'oodfont {_tlgchecked} ood-foldingtabs-toggle',
                                        $fonticon: 'ood-uicmd-toggle'
                                    },
                                    ICON: {
                                        $order: 2,
                                        className: 'oodcon {imageClass} {picClass} ood-foldingtabs-icon',
                                        style: '{backgroundImage}{backgroundPosition}{backgroundSize}{backgroundRepeat}{iconFontSize}{imageDisplay}{iconStyle} {_iconColor}',
                                        text: '{iconFontCode}'
                                    },
                                    CAPTION: {
                                        $order: 3,
                                        className: "ood-title-node ood-foldingtabs-caption",
                                        style: "{_fontColor}",
                                        text: '{caption}'
                                    }
                                },
                                TRIGHT: {
                                    $order: 1,
                                    tagName: 'div',
                                    style: '{_capDisplay}',
                                    className: 'ood-foldingtabs-tright',
                                    MESSAGE: {
                                        $order: 0,
                                        className: 'ood-foldingtabs-message',
                                        text: '{message}'
                                    },
                                    CMDS: {
                                        $order: 2,
                                        RTAGCMDS: {
                                            $order: 0,
                                            tagName: 'span',
                                            style: '{_rtagDisplay}',
                                            className: 'ood-foldingtabs-tag-commands',
                                            text: "{rtagCmds}"
                                        },
                                        OPT: {
                                            $order: 1,
                                            className: 'oodfont {_opt}',
                                            $fonticon: 'ood-uicmd-opt',
                                            style: '{_opt}'
                                        },
                                        POP: {
                                            className: 'oodfont {popDisplay}',
                                            $fonticon: 'ood-uicmd-pop',
                                            style: '{popDisplay}',
                                            $order: 1
                                        },
                                        CLOSE: {
                                            className: 'oodfont',
                                            $fonticon: 'ood-uicmd-close',
                                            style: '{closeDisplay}',
                                            $order: 2
                                        }
                                    }
                                }
                            }
                        },
                        BODY: {
                            $order: 1,
                            tagName: 'div',
                            className: 'ood-uibase ood-foldingtabs-body',
                            BODYI: {
                                tagName: 'div',
                                className: 'ood-foldingtabs-body-inner',
                                PANEL: {
                                    tagName: 'div',
                                    style: '{_itemHeight};{_overflow};{_bginfo}',
                                    className: 'ood-uibase ood-uicontainer ood-foldingtabs-panel',
                                    text: ood.UI.$childTag
                                }
                            }
                        }
                    }
                },
                'items.ltagCmds': function (profile, template, v, tag, result) {
                    var me = arguments.callee,
                        map = me._m || (me._m = {'text': '.text', 'button': '.button', 'image': '.image'});
                    ood.UI.$doTemplate(profile, template, v, "items.tagCmds" + (map[v.type] || '.button'), result)
                },
                'items.rtagCmds': function (profile, template, v, tag, result) {
                    var me = arguments.callee,
                        map = me._m || (me._m = {'text': '.text', 'button': '.button', 'image': '.image'});
                    ood.UI.$doTemplate(profile, template, v, "items.tagCmds" + (map[v.type] || '.button'), result)
                },
                'items.tagCmds.text': ood.UI.$getTagCmdsTpl('text'),
                'items.tagCmds.button': ood.UI.$getTagCmdsTpl('button'),
                'items.tagCmds.image': ood.UI.$getTagCmdsTpl('image')
            }
        },
        /**
         *  - CSS
         * DOMCSS
         * @namespace Appearances
         */
        Appearances: {
            KEY: {
                padding: 'var(--ood-spacing-xs)'
            },
            BOX: {
                'box-shadow': 'var(--ood-shadow-sm)',
                'border-radius': 'var(--ood-radius-md)',
                'overflow': 'hidden',
                'background-color': 'var(--ood-bg)'
            },
            'LTAGCMDS, RTAGCMDS': {
                padding: 0,
                margin: 0,
                'vertical-align': 'middle'
            },
            ITEMS: {
                border: 0,
                position: 'relative',
                'background-color': 'var(--ood-bg)'
            },
            ITEM: {
                marginBottom: 'var(--ood-spacing-md)',
                padding: 0,
                position: 'relative',
                overflow: 'hidden',
                'border-radius': 'var(--ood-radius-md)',
                'box-shadow': 'var(--ood-shadow-sm)',
                transition: 'all var(--ood-transition-normal)',
                'background-color': 'var(--ood-bg-card)'
            },
            'HEAD, BODY, BODYI, PANEL': {
                position: 'relative'
            },
            CMDS: {
                padding: '.25em 0 0 .25em',
                'vertical-align': 'middle',
                position: 'relative'
            },
            BODY: {
                display: 'none',
                position: 'relative',
                'max-height': '0',
                opacity: '0',
                transition: 'all var(--transition-normal)',
                'border-radius': '0 0 var(--radius-md) var(--radius-md)'
            },
            BODYI: {
                padding: '0 .25em'
            },
            PANEL: {
                overflow: 'auto',
                padding: '1rem',
                'border-radius': '0 0 var(--radius-md) var(--radius-md)'
            },
            'ITEM-hover': {
                'box-shadow': 'var(--ood-shadow-md)',
                transform: 'translateY(-2px)',
                transition: 'all var(--ood-transition-normal)'
            },
            'ITEM-active, ITEM-checked': {},
            'ITEM-checked': {
                $order: 2
            },
            'ITEM-checked BODY': {
                $order: 2,
                display: 'block',
                'max-height': '800px',
                opacity: '1'
            },
            HEAD: {
                cursor: 'pointer',
                position: 'relative',
                overflow: 'hidden',
                'border-radius': 'var(--ood-radius-md) var(--ood-radius-md) 0 0',
                transition: 'all var(--ood-transition-fast)',
                'background-color': 'var(--ood-bg-header)',
                'border-bottom': '1px solid var(--ood-border)'
            },
            TITLE: {
                $order: 1,
                display: 'flex',
                'align-items': 'center',
                position: 'relative',
                'white-space': 'nowrap',
                overflow: 'hidden',
                padding: 'var(--ood-spacing-md)'
            },
            'CAPTION, MESSAGE': {
                padding: 'var(--ood-spacing-xs)',
                'vertical-align': 'middle'
            },
            MESSAGE: {
                'font-size': 'var(--ood-font-size-base)',
                color: 'var(--ood-text-muted)'
            },
            CAPTION: {
                'white-space': 'nowrap',
                flex: 1,
                'font-size': 'var(--ood-font-size-lg)',
                'font-weight': 500,
                color: 'var(--ood-text-heading)'
            },
            'ITEM-checked CAPTION': {
                $order: 2,
                'font-weight': '600',
                color: 'var(--ood-primary)'
            },
            TLEFT: {
                display: 'flex',
                'align-items': 'center',
                position: 'relative',
                'white-space': 'nowrap',
                overflow: 'hidden',
                flex: 1
            },
            TRIGHT: {
                display: 'flex',
                'align-items': 'center',
                position: 'relative',
                'white-space': 'nowrap',
                overflow: 'hidden',
                marginLeft: 'auto'
            },
            /*  */
            '.ood-foldingtabs-toggle': {
                'font-size': '1.25rem',
                marginRight: '0.75rem',
                transition: 'transform var(--transition-normal)',
                color: 'var(--ood-text-secondary)'
            },
            '.ood-foldingtabs-toggle.-checked': {
                transform: 'rotate(90deg)',
                color: 'var(--ood-primary)'
            },
            '.ood-foldingtabs-icon': {
                'font-size': '1.25rem',
                marginRight: '0.75rem',
                transition: 'color var(--transition-fast)'
            },
            '.ood-foldingtabs-header:hover .ood-foldingtabs-icon': {
                color: 'var(--primary-color)'
            },
            '.ood-foldingtabs-caption': {
                transition: 'color var(--transition-fast)',
                'font-size': '1.1rem',
                'font-weight': 500
            },
            '.ood-foldingtabs-header:hover .ood-foldingtabs-caption': {
                color: 'var(--primary-color)'
            },
            '.ood-foldingtabs-body': {
                'border-radius': '0 0 var(--radius-md) var(--radius-md)',
                borderTop: 'none'
            },
            '.ood-foldingtabs-header': {
                'border-radius': 'var(--radius-md) var(--radius-md) 0 0',
                borderBottom: 'none'
            },
            '.ood-foldingtabs-item': {
                transition: 'all var(--transition-normal)'
            },
            '.ood-foldingtabs-item:hover': {
                'box-shadow': 'var(--shadow-md)',
                transform: 'translateY(-1px)'
            },
            '.ood-foldingtabs-panel': {
                'border-top': 'none'
            }
        },

        /**
         * 
         * @namespace Behaviors
         */
        Behaviors: {
            /**
             * 
             * @type {Array}
             */
            DraggableKeys: ['HEAD'],

            /**
             * 
             * @type {Object}
             */
            HoverEffected: {
                OPT: 'OPT',
                CLOSE: 'CLOSE',
                POP: 'POP',
                ITEM: 'HEAD'
            },

            /**
             * 
             * @type {Object}
             */
            ClickEffected: {
                OPT: 'OPT',
                CLOSE: 'CLOSE',
                POP: 'POP',
                ITEM: 'HEAD'
            },

            /**
             * 
             * @type {Object}
             */
            ITEMS: {
                onMousedown: null,
                onDrag: null,
                onDragstop: null
            },

            /**
             * 
             * @type {Object}
             */
            HEAD: {
                /**
                 * 
                 * @param {Object} profile - 
                 * @param {Event} e - 
                 * @param {HTMLElement} src - 
                 * @returns {boolean} 
                 */
                onClick: function (profile, e, src) {
                    // 
                    if (ood.Event.getBtn(e) !== 'left') return;

                    var prop = profile.properties,
                        item = profile.getItemByDom(src),
                        box = profile.boxing();

                    // 
                    if (!item) return;

                    // 
                    if (prop.disabled || item.disabled) return false;

                    // 
                    if (prop.readonly || item.readonly) return false;

                    // 
                    profile.getSubNode('TITLE').focus(true);

                    // 
                    profile.boxing()._handleSelectionByMode(profile, prop, item, box, e, src);
                },

                /**
                 * 
                 * @param {Object} profile - 
                 * @param {Event} e - 
                 * @param {HTMLElement} src - 
                 * @returns {boolean} 
                 */
                onKeydown: function (profile, e, src) {
                    var keys = ood.Event.getKey(e),
                        key = keys.key;

                    // 
                    if (key === ' ' || key === 'enter') {
                        profile.getSubNode('HEAD', profile.getSubId(src)).onClick();
                        return false;
                    }
                }
            }
        },

        DataModel: {
            /**
             * 
             * @type {Object}
             */
            expression: {
                ini: '',
                action: function () {
                    // 
                }
            },

            /**
             * 
             * @type {Object}
             */
            iconColors: null,

            /**
             * 
             * @type {Object}
             */
            itemColors: null,

            /**
             * 
             * @type {Object}
             */
            fontColors: null,

            /**
             * 
             * @type {Object}
             */
            autoFontColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },

            /**
             * 
             * @type {Object}
             */
            autoIconColor: {
                ini: true,
                action: function () {
                    this.boxing().refresh();
                }
            },

            /**
             * 
             * @type {Object}
             */
            autoItemColor: {
                ini: false,
                action: function () {
                    this.boxing().refresh();
                }
            },

            /**
             * 
             * @type {number}
             */
            $hborder: 0,

            /**
             * 
             * @type {number}
             */
            $vborder: 0,

            /**
             * 
             * @type {boolean}
             */
            noPanel: null,

            /**
             * 
             * @type {boolean}
             */
            noHandler: null,

            /**
             * 
             * @type {string}
             */
            HAlign: null,

            /**
             * 
             * @type {Object}
             */
            selMode: {
                ini: 'single',
                listbox: ['single', 'multi']
            },

            /**
             * 
             * @type {string}
             */
            theme: {
                ini: 'light',
                listbox: ['light', 'dark', 'high-contrast']
            },

            /**
             * 
             * @type {boolean}
             */
            responsive: {
                ini: true
            },

            /**
             * 
             * @type {string}
             */
            transitionDuration: {
                ini: 'normal',
                listbox: ['fast', 'normal', 'slow']
            },

            /**
             * 
             * @type {boolean}
             */
            collapsible: {
                ini: true
            },

            /**
             * 
             * @type {boolean}
             */
            enhancedAccessibility: {
                ini: true
            }
        },

        /**
         *  - 
         * @function RenderTrigger
         */
        RenderTrigger: function () {
            var self = this,
                pro = self.properties;

            // 
            self.boxing()._initAnimationStyles();

            // 
            self.boxing()._initTheme(pro);

            // 
            if (pro.responsive !== false) {
                self.boxing().adjustLayout();
            }

            // 
            self.boxing().enhanceAccessibility();
        },


        /**
         * 
         * @param {Object} profile - 
         * @param {Array} arr - 
         * @param {string} pid - ID
         * @returns {Array} 
         * @private
         */
        _prepareItems: function (profile, arr, pid) {
            // 
            if (arr.length) {
                arr[0]._precheked = profile.getClass('ITEM', '-prechecked');
            }

            // 
            ood.arr.each(arr, function (item) {
                if (!item.index) {
                    item.index = ood.arr.indexOf(arr, item);
                }
                profile.boxing()._autoColor(item, item.index, profile.properties);
            });

            var obj = arguments.callee.upper.apply(this, arguments);
            var height = profile.$em2px(profile.boxing().getHeight());
            this._adjustPanelHeight(profile, height);
            // 
            return obj;
        },

        /**
         * 
         * @param {Object} profile - 
         * @param {Object} item - 
         * @param {Object} oitem - 
         * @param {string} pid - ID
         * @param {number} index - 
         * @param {number} len - 
         * @private
         */
        _prepareItem: function (profile, item, oitem, pid, index, len) {
            var dpn = 'display:none',
                p = profile.properties,
                t;

            // 
            item.closeDisplay = item.closeBtn ? '' : dpn;
            item.popDisplay = item.popBtn ? '' : dpn;
            item._opt = item.optBtn ? '' : dpn;
            item._itemDisplay = item.hidden ? dpn : '';

            // 
            profile.boxing()._autoColor(item, index, p);

            // 
            if (item.height) {
                item._itemHeight = "height:" + profile.$forceu(item.height);
            }

            // 
            item._tabindex = p.tabindex;

            // 
            if (!item.caption) {
                item._capDisplay = dpn;
            }

            // 
            this._setBackgroundInfo(item, p);

            // 
            this._setOverflowStyle(item, p);

            // 
            if (item._show) {
                item._checked = profile.getClass('ITEM', '-checked');
                item._tlgchecked = profile.getClass('TOGGLE', '-checked');
            }

            // 
            this._prepareCmds(profile, item);


        },

        /**
         * 
         * @param {Object} item - 
         * @param {Object} properties - 
         * @private
         */
        _setBackgroundInfo: function (item, properties) {
            var t;
            item._bginfo = "";

            // 
            if (t = item.panelBgClr || properties.panelBgClr) {
                item._bginfo += "background-color:" + t + ";";
            }

            // 
            if (t = item.panelBgImg || properties.panelBgImg) {
                item._bginfo += "background-image:url(" + ood.adjustRes(t) + ");";
            }

            // 
            if (t = item.panelBgImgPos || properties.panelBgImgPos) {
                item._bginfo += "background-position:" + t + ";";
            }

            // 
            if (t = item.panelBgImgRepeat || properties.panelBgImgRepeat) {
                item._bginfo += "background-repeat:" + t + ";";
            }

            // 
            if (t = item.panelBgImgAttachment || properties.panelBgImgAttachment) {
                item._bginfo += "background-attachment:" + t + ";";
            }
        },

        /**
         * 
         * @param {Object} item - 
         * @param {Object} properties - 
         * @private
         */
        _setOverflowStyle: function (item, properties) {
            if (ood.isStr(item.overflow)) {
                item._overflow = item.overflow.indexOf(':') != -1 ?
                    (item.overflow) :
                    (item.overflow ? ("overflow:" + item.overflow) : "");
            } else if (ood.isStr(properties.overflow)) {
                item._overflow = properties.overflow.indexOf(':') != -1 ?
                    (properties.overflow) :
                    (properties.overflow ? ("overflow:" + properties.overflow) : "");
            }
        },

        /**
         * 
         * @param {Object} profile - 
         * @param {number} width - 
         * @param {number} height - 
         * @param {boolean} force - 
         * @param {string} key - 
         * @private
         */
        _onresize: function (profile, width, height, force, key) {
            // 
            if (force) {
                profile._w = profile._h = null;
            }


            // 
            this._adjustPanelHeight(profile, height);

            // 
            if (width && profile._w !== width) {
                this._adjustPanelWidth(profile, width);
            }

            // 
            if (profile.properties.responsive !== false) {
                profile.boxing().adjustLayout();
            }
        },

        /**
         * 
         * @param {Object} profile - 
         * @param {number} height - 
         * @private
         */
        _adjustPanelHeight: function (profile, height) {
            var panelCount = profile.getSubNode("PANEL", true).size();
            if (!ood.isNumb(height)) {
                height = profile.$em2px(height);
            }

            profile.getSubNode("PANEL", true).each(function (panel) {
                // 
                var headerHeight = (35 * panelCount) + 20;
                // 
                var contentHeight = profile.$addpx(height, 0 - headerHeight);
                // 
                panel.style.height = contentHeight;
            });
        },

        /**
         * 
         * @param {Object} profile - 
         * @param {number} width - 
         * @private
         */
        _adjustPanelWidth: function (profile, width) {
            profile._w = width;

            profile.getSubNode("PANEL", true).each(function (panel) {
                if (panel.offsetWidth) {
                    // 
                    ood(panel).width('auto');

                    // 
                    var panelWidth = ood(panel).width();
                    var prop = profile.properties;

                    // 
                    if (ood.$us(profile) > 0) {
                        panelWidth = profile.$px2em(panelWidth, panel) + 'em';
                    }

                    // 
                    ood(panel).width(panelWidth);

                    // 
                    ood.UI._adjustConW(profile, panel, panelWidth);
                } else {
                    var pxwidth = profile.$em2px(width);
                    ood(panel).width((pxwidth + 1) + "px");
                }
            });
        },

        /**
         * 
         * @returns {Object} this - 
         */
        enhanceAccessibility: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    items = profile.getSubNodes('ITEM');

                // ARIA
                this._setContainerAccessibility(root);

                // ARIA
                items.forEach(function (item, index) {
                    this._setItemAccessibility(profile, item);
                }, this);
            });
        },

        /**
         * 
         * @param {Object} root - 
         * @private
         */
        _setContainerAccessibility: function (root) {
            root.attr({
                'role': 'tablist',
                'aria-label': ''
            });
        },

        /**
         * 
         * @param {Object} profile - 
         * @param {Object} item - 
         * @private
         */
        _setItemAccessibility: function (profile, item) {
            var itemId = profile.getItemIdByDom(item),
                isExpanded = profile.getItemByItemId(itemId)._show || false;

            // 
            item.attr({
                'role': 'tab',
                'aria-selected': isExpanded,
                'aria-controls': 'foldingtabs-panel-' + itemId,
                'aria-expanded': isExpanded
            });

            // 
            var body = profile.getSubNode('BODY', profile.getSubIdByItemId(itemId));
            if (body) {
                body.attr({
                    'id': 'foldingtabs-panel-' + itemId,
                    'role': 'tabpanel',
                    'aria-labelledby': 'foldingtabs-tab-' + itemId
                });
            }

            // 
            var title = profile.getSubNode('TITLE', profile.getSubIdByItemId(itemId));
            if (title) {
                title.attr({
                    'id': 'foldingtabs-tab-' + itemId,
                    'role': 'button',
                    'tabindex': '0'
                });
            }
        },

        /**
         * 
         * @returns {Object} this - 
         */
        adjustLayout: function () {
            return this.each(function (profile) {
                var root = profile.getRoot(),
                    viewportWidth = ood(document.body).cssSize().width;
                // 
                this._applyResponsiveClasses(root, viewportWidth);
            });
        },

        /**
         * 
         * @param {Object} root - 
         * @param {number} viewportWidth - 
         * @private
         */
        _applyResponsiveClasses: function (root, viewportWidth) {
            //  (< 768px)
            if (viewportWidth < 768) {
                root.addClass('foldingtabs-mobile');
            } else {
                root.removeClass('foldingtabs-mobile');
            }

            //  (< 480px)
            if (viewportWidth < 480) {
                root.addClass('foldingtabs-tiny');
            } else {
                root.removeClass('foldingtabs-tiny');
            }
        },
        _adjustScroll:
            null
    }
});
ood.Class("ood.UI.FoldingList", ["ood.UI.List"],{
    Instance:{
        //  iniProp 
        iniProp: {
            items: [
                {id: 'a', caption: 'tab1', title: 'title1', text: 'text1'},
                {id: 'b', caption: 'tab2', title: 'title2', text: 'text2'},
                {id: 'c', caption: 'tab3', title: 'title3', text: 'text3'},
                {id: 'd', caption: 'tab4', title: 'title4', text: 'text4'},
                {id: 'e', caption: 'tab5', title: 'title5', text: 'text5'}
            ]
        },

        // 
        setTheme: function(theme) {
            return this.each(function(profile) {
                profile.properties.theme = theme;
                var root = profile.getRoot();

                // 
                root.addClass('foldinglist-themed');

                // 
                root.removeClass('foldinglist-dark foldinglist-hc');

                // 
                if (theme === 'dark') {
                    root.addClass('foldinglist-dark');
                } else if (theme === 'high-contrast') {
                    root.addClass('foldinglist-hc');
                }

                // 
                localStorage.setItem('foldinglist-theme', theme);
            });
        },

        // 
        getTheme: function() {
            var profile = this.get(0);
            return profile.properties.theme || localStorage.getItem('foldinglist-theme') || 'light';
        },

        // 
        toggleTheme: function() {
            const themes = ['light', 'dark', 'high-contrast'];
            const currentTheme = this.getTheme();
            const nextIndex = (themes.indexOf(currentTheme) + 1) % themes.length;
            this.setTheme(themes[nextIndex]);
            return this;
        },

        fillContent:function(id, obj){
            var profile=this.get(0),t,item;
            if(profile.renderId){
                if(item=profile.getItemByItemId(id)){
                    t=profile.getSubNodeByItemId('BODYI',id).html('');
                    if(obj){
                        item._obj = obj;
                        item._fill=true;
                        if(typeof obj=='string')t.html(obj);
                        else t.append(obj.render(true));
                    }else
                        item._obj=item._fill=null;
                }
            }
            return this;
        },
        toggle:function(id){
            var profile=this.get(0);
            if(profile.renderId){
                var properties = profile.properties,
                    items=properties.items,
                    item = profile.getItemByItemId(id),
                    subId = profile.getSubIdByItemId(id),
                    node = profile.getSubNode('ITEM',subId),
                    toggle = profile.getSubNode('TOGGLE',subId),
                    nodenext = node.next(),t
                ;
                if(item._show){
                    if(properties.activeLast && items.length)
                        if(items[items.length-1].id==item.id)
                            return false;

                    node.tagClass('-checked',false);
                    toggle.tagClass('-checked',false);
                    if(nodenext)
                        nodenext.tagClass('-prechecked',false);
                }else{
                    node.tagClass('-checked');
                    toggle.tagClass('-checked');
                    if(nodenext)
                        nodenext.tagClass('-prechecked');
                    //fill value
                    if(!item._fill){
                        var callback=function(o){
                            profile.boxing().fillContent(item.id, item._body=o);
                        };
                        if(profile.onGetContent){
                            var r = profile.boxing().onGetContent(profile, item, callback);
                            if(r) callback(r);
                        }else
                            callback(profile.box._buildBody(profile, item));
                    }
                }
                item._show=!item._show
            }
            return this;
        }
    },
    Initialize:function(){
        //modify default template for modern UI
        var t = this.getTemplate();
        t.ITEMS.className='{_bordertype} ood-foldinglist-items';
        t.$submap.items={
            ITEM:{
                tagName : 'div',
                className:'ood-uiborder-flat ood-uiborder-radius {_checked} {_precheked} {itemClass} {disabled} {readonly}',
                style:'{itemStyle}',
                HEAD:{
                    tagName : 'div',
                    className:'ood-uibar ood-foldinglist-header',
                    TITLE:{
                        tabindex: '{_tabindex}',
                        TLEFT:{
                            $order:0,
                            tagName:'div',
                            TOGGLE:{
                                $order:0,
                                className:'oodfont ood-foldinglist-toggle',
                                $fonticon:'{_fi_tlg}'
                            },
                            LTAGCMDS:{
                                $order:2,
                                tagName:'span',
                                text:"{ltagCmds}"
                            },
                            CAP1:{
                                $order:1,
                                className:"ood-title-node ood-foldinglist-title",
                                text:'{title}'
                            }
                        },
                        TRIGHT:{
                            $order:1,
                            tagName:'div',
                            style:'{_capDisplay}',
                            CAP2:{
                                $order:0,
                                text:'{caption}'
                            },
                            TAGCMDS:{
                                $order:60,
                                tagName:'span',
                                text:"{rtagCmds}"
                            }
                        }/*,
                        TCLEAR:{
                            $order:2,
                            tagName:'div'
                        }*/
                    }
                },
                BODY:{
                    $order:1,
                    tagName : 'div',
                    className:'ood-uibase ood-foldinglist-body',
                    BODYI:{
                        $order:0,
                        tagName : 'div',
                        text:'{_body}'
                    }
                }
            }
        }
        this.setTemplate(t);
    },
    Static:{
        Appearances:{
            KEY:{
                padding:'var(--ood-spacing-xs)'
            },
            ITEMS:{
                border:0,
                position:'relative',
                padding: 'var(--ood-spacing-md)',
                'background-color': 'var(--ood-bg)',
                'border-radius': 'var(--ood-radius-lg)'
            },
            ITEM:{
                marginBottom: 'var(--ood-spacing-md)',
                padding:0,
                position:'relative',
                overflow:'hidden',
                'border-radius': 'var(--ood-radius-md)',
                'box-shadow': 'var(--ood-shadow-sm)',
                transition: 'all var(--ood-transition-normal)',
                'background-color': 'var(--ood-bg-card)'
            },
            'HEAD, BODY, BODYI, TAIL':{
                position:'relative'
            },
            BODY:{
                display:'none',
                position:'relative',
                overflow:'auto',
                maxHeight: '500px',
                transition: 'all var(--ood-transition-normal)',
                'background-color': 'var(--ood-bg)'
            },
            BODYI:{
                padding: 'var(--ood-spacing-md)',
                position:'relative'
            },
            'ITEM-hover':{
                'box-shadow': 'var(--ood-shadow-md)',
                transform: 'translateY(-2px)',
                transition: 'all var(--ood-transition-normal)'
            },
            'ITEM-checked':{
                $order:2,
                'margin-bottom':'var(--ood-spacing-md)'
             },
            'ITEM-checked BODY':{
                $order:2,
                display:'block',
                animation: 'ood-foldinglist-open 0.3s ease-out'
            },
            HEAD:{
                cursor:'pointer',
                position:'relative',
                overflow:'hidden',
                transition: 'all var(--ood-transition-fast)',
                'background-color': 'var(--ood-bg-header)',
                'border-bottom': '1px solid var(--ood-border)'
            },
            TITLE:{
                $order:1,
                display:'flex',
                'align-items':'center',
                position:'relative',
                'white-space':'nowrap',
                overflow:'hidden',
                padding: 'var(--ood-spacing-md)'
            },
            'CAP1, CAP2':{
                padding:'var(--ood-spacing-xs)',
                'vertical-align':'middle'
            },
            CAP1:{
                cursor:'pointer',
                'white-space':'nowrap',
                flex: 1,
                fontSize: 'var(--ood-font-size-lg)',
                fontWeight: 500,
                color: 'var(--ood-text-heading)'
            },
            'ITEM-checked CAP1':{
                $order:2,
                'font-weight':'600',
                color: 'var(--ood-primary)'
            },
            TLEFT:{
                display: 'flex',
                'align-items': 'center',
                position:'relative',
                'white-space':'nowrap',
                overflow:'hidden',
                flex: 1
            },
            TRIGHT:{
                display: 'flex',
                'align-items': 'center',
                position:'relative',
                'white-space':'nowrap',
                overflow:'hidden',
                marginLeft: 'auto'
            },
            '.ood-foldinglist-toggle':{
                fontSize: 'var(--ood-font-size-xl)',
                marginRight: 'var(--ood-spacing-md)',
                transition: 'transform var(--ood-transition-normal)',
                color: 'var(--ood-text-muted)'
            },
            '.ood-foldinglist-toggle.-checked':{
                transform: 'rotate(90deg)',
                color: 'var(--ood-primary)'
            },
            '.ood-foldinglist-title':{
                transition: 'color var(--ood-transition-fast)',
                fontSize: 'var(--ood-font-size-lg)',
                fontWeight: 500,
                color: 'var(--ood-text-heading)'
            },
            '.ood-foldinglist-header:hover .ood-foldinglist-title':{
                color: 'var(--ood-primary)'
            },
            '.ood-foldinglist-header':{
                borderRadius: 'var(--ood-radius-md) var(--ood-radius-md) 0 0',
                borderBottom: 'none'
            },
            '.ood-foldinglist-body':{
                borderRadius: '0 0 var(--ood-radius-md) var(--ood-radius-md)',
                borderTop: 'none'
            }
        },
        Behaviors:{
            HoverEffected:{ITEM:'ITEM',HEAD:'HEAD',OPT:'OPT'},
            ClickEffected:{ITEM:null,HEAD:'HEAD'},
            ITEM:{onClick:null,onKeydown:null},
            HEAD:{
                onClick:function(profile, e, src){
                    profile.boxing().toggle(profile.getItemIdByDom(src));
                    return false;
                }
            },
            OPT:{
                onMousedown:function(){
                    return false;
                },
                onClick:function(profile, e, src){
                    profile.boxing().onShowOptions(profile, profile.getItemByDom(src), e, src);
                    return false;
                }
            }
        },
        DataModel:{
            expression:{
                ini:'',
                action:function () {
                }
            },
            value: null,
            borderType: null,
            activeLast: true,
            // 
            transitionDuration: 'normal', // : 'fast', 'normal', 'slow'
            collapsible: true,
            // 
            theme: {
                ini: 'light',
                listbox: ['light', 'dark', 'high-contrast'],
                action: function(value) {
                    this.boxing().setTheme(value);
                }
            },
            // 
            responsive: {
                ini: true,
                action: function(value) {
                    if (value) {
                        this.boxing().adjustLayout();
                    }
                }
            }
        },
        EventHandlers:{
            onGetContent:function(profile,item,onEnd){},
            onShowOptions:function(profile,item,e,src){}
        },
        RenderTrigger:function(){
            var self=this, pro=self.properties, items=pro.items, item;
            if(pro.activeLast && items.length>0){
                item=items[items.length-1];
                self.boxing().fillContent(item.id, item._body);
            }

            // 
            if(!document.getElementById('ood-foldinglist-animations')){
                var style = document.createElement('style');
                style.id = 'ood-foldinglist-animations';
                style.textContent = `
                    @keyframes ood-foldinglist-open {
                        from { opacity: 0; maxHeight: 0; }
                        to { opacity: 1; maxHeight: 500px; }
                    }
                `;
                document.head.appendChild(style);
            }

            // 
            if (pro.theme) {
                self.boxing().setTheme(pro.theme);
            } else {
                // 
                var savedTheme = localStorage.getItem('foldinglist-theme');
                if (savedTheme) {
                    self.boxing().setTheme(savedTheme);
                }
            }

            // 
            if (pro.responsive !== false) {
                self.boxing().adjustLayout();
            }

            // 
            self.boxing().enhanceAccessibility();
        },
        _prepareItems:function(profile, arr, pid){
            if(arr.length){
                arr[0]._precheked = profile.getClass('ITEM','-prechecked');
                if(profile.properties.activeLast){
                    //for properties.data
                    var item = arr[arr.length-1];
                    item._show = true;
                    item._fill = true;
                    item._body = profile.onGetContent?profile.boxing().onGetContent(profile,item,function(o){
                        profile.boxing().fillContent(item.id, item._body=o);
                    }) : profile.box._buildBody(profile, item);
                }
            }
            return arguments.callee.upper.apply(this, arguments);
        },
        _prepareItem:function(profile, item){
            var p = profile.properties,o,
                dpn = 'display:none';
            item._tabindex = p.tabindex;
            if(!item.caption)
                item._capDisplay=dpn;
            else
                item.caption = item.caption.replace(/</g,"&lt;");
            item._body= item._body || '...';

            if(item._show){
                item._checked = profile.getClass('ITEM','-checked');
                item._fi_tlg = 'oodfont-checked ood-uicmd-toggle ood-uicmd-toggle-checked';
            }else{
                item._fi_tlg = 'ood-uicmd-toggle';
            }

            this._prepareCmds(profile, item);
        },
        _buildBody:function(profile,item){
            return item.text?'<pre class="ood-node ood-node-div">'+item.text.replace(/</g,"&lt;")+'</pre>':'';
        },


        // 
        enhanceAccessibility: function() {
            return this.each(function(profile) {
                var root = profile.getRoot(),
                    items = profile.getSubNodes('ITEM'),
                    properties = profile.properties;

                // ARIA
                root.attr({
                    'role': 'tree',
                    'aria-label': ''
                });

                // ARIA
                items.forEach(function(item, index) {
                    var itemId = profile.getItemIdByDom(item),
                        isExpanded = profile.getItemByItemId(itemId)._show || false;

                    item.attr({
                        'role': 'treeitem',
                        'aria-expanded': isExpanded,
                        'aria-level': 1,
                        'aria-posinset': index + 1,
                        'aria-setsize': items.length
                    });

                    // ARIA
                    var title = profile.getSubNode('TITLE', profile.getSubIdByItemId(itemId));
                    if (title) {
                        title.attr({
                            'role': 'button',
                            'tabindex': '0'
                        });
                    }
                });
            });
        }
    }
});
ood.Class("ood.UI.Opinion", "ood.UI.List", {
    Instance: {
        //  iniProp 
        iniProp: {
            "columns": 1,
            width: "41.833333333333336em",
            items: [
                {
                    "caption": "",
                    "createDateStr": "2024-01-15",
                    "creatorName": "",
                    "department": "",
                    "id": "opinion1"
                },
                {
                    "caption": "",
                    "hidden": false,
                    "createDateStr": "2024-01-16",
                    "creatorName": "",
                    "department": "",
                    "id": "opinion2"
                },
                {
                    "caption": "",
                    "hidden": false,
                    "createDateStr": "2024-01-17",
                    "creatorName": "",
                    "department": "",
                    "level": "",
                    "id": "opinion3"
                }
            ]
        },

        getStatus: function (id) {
            var item = this.get(0).getItemByItemId(id);
            return (item && item._status) || 'ini';
        },
        _afterInsertItems: function (profile) {
            profile.getSubNodes("IMAGE", true).each(function (o) {
                if (o.src == ood.ini.img_bg) {
                    // bug fix for firefox
                    if (ood.browser.isFF) o.src = '';
                    o.src = o.title;
                    o.title = '';
                }
            });
        },
        updateItemData: function (profile, item) {
            this.get(0).box._prepareItem(this.get(0), item);
            this.get(0).boxing().refresh();
        }

    },
    Initialize: function () {
        //modify default template fro shell
        var t = this.getTemplate();
        t.$submap = {
            items: {
                ITEM: {
                    tabindex: '{_tabindex}',
                    className: 'ood-uitembg ood-uiborder-radius ood-showfocus {itemClass} {disabled} {readonly}',
                    style: 'padding:{itemPadding};margin:{itemMargin};{_itemSize};{itemStyle})',

                    ITEMFRAME: {
                        style: '{_inneritemSize};{_bgimg}; {_position}}',
                        COMMENT: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            text: '{comment}',
                            style: '{commentDisplay};{_color}',
                            $order: 2
                        },
                        CONTENT: {
                            tagName: 'div',
                            $order: 1,
                            className: '{contentClass}',
                            style: '{_loadbg}',

                            ICON: {
                                className: 'oodfont {_imageClass}',
                                style: "{_fontSize};{_color};{_icon};{_position};}",
                                text: '{iconFontCode}'
                            }
                        },
                        CAPTION: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            style: '{capDisplay}',
                            text: '{caption}',
                            $order: 0
                        },


                        PERSON: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            style: '{capDisplay}',
                            text: '{creatorName}',
                            $order: 3,
                            IMAGE: {
                                tagName: 'img',
                                src: ood.ini.img_bg,
                                title: '{image}',
                                style: '{_innerimgSize};{imgStyle}'
                            }

                        },
                        PERFORTIME: {
                            tagName: 'div',
                            className: 'ood-ui-ellipsis',
                            style: '{capDisplay}',
                            text: '{createDateStr}',
                            $order: 4
                        }

                    },
                    FLAG: {
                        $order: 20,
                        className: 'ood-display-none {flagClass}',
                        style: '{_flagStyle};{flagStyle}',
                        text: '{flagText}'
                    },
                    EXTRA: {
                        text: '{ext}',
                        $order: 30
                    }
                }
            }
        };
        this.setTemplate(t);

        // compitable
        ood.UI.IconList = ood.UI.Gallery;
        var key = "ood.UI.IconList";
        ood.absBox.$type[key.replace("ood.UI.", "")] = ood.absBox.$type[key] = key;
    },
    Static: {
        IMGNODE: 1,
        Appearances: {
            EXTRA: {
                display: 'none'
            },
            KEY: {
                overflow: 'visible'
            },
            ITEMS: {
                position: 'relative',
                overflow: 'auto',
                'overflow-x': 'hidden',
                zoom: ood.browser.ie6 ? 1 : null
            },
            'ITEMS-nowrap': {
                'white-space': 'nowrap'
            },
            ITEM: {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie67 ? 1 : null,
                //   'background-image': 'url({_bgimg})',
                position: 'relative',
                cursor: 'pointer',
                'vertical-align': 'top',
                margin: 0
            },
            ITEMFRAME: {
                display: ood.browser.ie67 ? ood.$inlineBlock : 'block',
                zoom: ood.browser.ie67 ? 1 : null,
                position: 'relative',
                overflow: 'hidden',
                border: 0,
                padding: 0,
                margin: 0,
//                width:'100%',
//                height:'100%',
                '-moz-box-flex': '1'
            },
            IBWRAP: {},
            IMAGE: {
                display: ood.$inlineBlock,
                zoom: ood.browser.ie6 ? 1 : null,
                visibility: 'hidden',
                'vertical-align': 'middle'
            },
            CAPTION: {
                'text-align': 'left',
                overflow: 'hidden',
                'right': "var(--ood-spacing-md)",
                'white-space': 'nowrap',
                'font-weight': 'bold',
                "font-size": "var(--ood-font-lg)",
                "margin-top": "var(--ood-spacing-md)",
                "height": "35px",
                "color": "var(--ood-text-primary)"
            },
            CONTENT: {
                'text-align': 'center',
                'white-space': 'nowrap',
                'background-repeat': 'no-repeat',
                //  'background-position': 'center center',
                'font-size': 'var(--ood-font-base)',
                "color": "var(--ood-text-secondary)"
            },
            COMMENT: {
                display: 'block',
                margin: 'var(--ood-spacing-xs)',
                'text-align': 'center',
                'font-size': 'var(--ood-font-sm)',
                "color": "var(--ood-text-tertiary)"
            },
            TIEM: {
                display: 'block',
                margin: '.25em',
                'text-align': 'center',
                'font-size': '1em'
            },
            PERSON: {
                display: 'block',
                'margin-top': 'var(--ood-spacing-sm)',
                'margin-right': 'var(--ood-spacing-lg)',
                'text-align': 'right',
                'font-size': 'var(--ood-font-base)',
                "color": "var(--ood-text-secondary)"
            },
            PERFORTIME: {
                display: 'block',
                'margin-top': 'var(--ood-spacing-xs)',
                'margin-right': 'var(--ood-spacing-md)',
                "text-align": "right",
                'font-size': 'var(--ood-font-base)',
                "color": "var(--ood-text-tertiary)"
            },


            FLAG: {
                'width': "2em",
                "height": "2em",
                'right': "1.5em",
                'top': "1em",
                'text-align': "left",
                'font-size': "16px",
                'color': "var(--ood-warning)",
                'position': 'absolute',
                'z-index': 10
            }
        },
        Behaviors: {
            IMAGE: {
                onLoad: function (profile, e, src) {
                    var img = ood.use(src).get(0), path = img.src;
                    if (path != ood.ini.img_bg) {
                        var p = profile.properties,
                            nn = ood.use(src),
                            node = nn.get(0),
                            item = profile.getItemByDom(src);
                        if (!item) return;
                        var icon = profile.getSubNodeByItemId('ICON', item.id);
                        if (item.autoImgSize || p.autoImgSize) {
                            nn.attr('width', '');
                            nn.attr('height', '');
                        } else {
                            nn.attr('width', item.imgWidth);
                            nn.attr('height', item.imgWidth);
                        }

                        icon.removeClass('ood-icon-loading');
                        // hide
                        if (!item.iconFontCode && !item.imageClass && !item.icon) {
                            icon.addClass("ood-display-none");
                        }
                        nn.onLoad(null).onError(null).$removeEventHandler('load').$removeEventHandler('error');

                        item._status = 'loaded';
                        // don't show img_blank
                        if (ood.ini.img_blank == path) {
                            node.style.visibility = "hidden";
                            node.style.display = "none";
                        } else {
                            node.style.visibility = "visible";
                            node.style.display = "";
                        }
                    }
                },
                onError: function (profile, e, src) {
                    var item = profile.getItemByDom(src);
                    if (item._status == 'error') return;

                    var p = profile.properties,
                        nn = ood.use(src),
                        node = nn.get(0),
                        icon = profile.getSubNodeByItemId('ICON', item.id);

                    icon.removeClass('ood-icon-loading ood-display-none').addClass('ood-load-error');
                    nn.onLoad(null).onError(null).$removeEventHandler('load').$removeEventHandler('error');
                    node.style.visibility = "hidden";
                    node.style.display = "none";
                    item._status = 'error';
                }
            },
            FLAG: {
                onClick: function (profile, e, src) {
                    var item = profile.getItemByDom(src),
                        box = profile.boxing();

                    if (profile.onFlagClick) {
                        box.onFlagClick(profile, item, e, src);
                        return false;
                    }
                }
            }
        },
        DataModel: {
            expression: {
                ini: '',
                caption: ood.getResText("DataModel.expression") || "",
                action: function () {
                }
            },
            tagCmds: {
                ini: null,
                caption: ood.getResText("DataModel.tagCmds") || ""
            },
            bgimg: {
                ini: null,
                caption: ood.getResText("DataModel.backgroundImage") || ""
            },
            iotStatus: {
                ini: null,
                caption: ood.getResText("DataModel.iotStatus") || "IoT"
            },
            flagText: {
                ini: null,
                caption: ood.getResText("DataModel.flagText") || ""
            },
            flagClass: {
                ini: null,
                caption: ood.getResText("DataModel.flagStyleClass") || ""

            },
            flagStyle: {
                ini: null,
                caption: ood.getResText("DataModel.flagStyle") || ""
            },
            tagCmdsAlign: {
                ini: null,
                caption: ood.getResText("DataModel.tagCmdsAlign") || ""
            },
            autoImgSize: {
                ini: false,
                caption: ood.getResText("DataModel.autoImgSize") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            autoItemSize: {
                ini: true,
                caption: ood.getResText("DataModel.autoItemSize") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            iconOnly: {
                ini: false,
                caption: ood.getResText("DataModel.iconOnly") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            iconFontSize: {
                ini: '',
                caption: ood.getResText("DataModel.iconFontSize") || "",
                action: function (v) {
                    this.getSubNode('ICON', true).css('font-size', v);
                }
            },
            itemMargin: {
                ini: 6,
                caption:ood.getResText("DataModel.itemMargin") || "",
                action: function (v) {
                    this.getSubNode('ITEM', true).css('margin', v || 0);
                }
            },
            itemPadding: {
                ini: 2,
                caption: ood.getResText("DataModel.itemPadding") || "",
                action: function (v) {
                    this.getSubNode('ITEM', true).css('padding', v || 0);
                }
            },
            itemWidth: {
                $spaceunit: 1,
                ini: 32,
                caption: ood.getResText("DataModel.itemWidth") || "",
                action: function (v) {
                    this.getSubNode('ITEMFRAME', true).width(v || '');
                }
            },
            itemHeight: {
                $spaceunit: 1,
                ini: 32,
                caption: ood.getResText("DataModel.itemHeight") || "",
                action: function (v) {
                    this.getSubNode('ITEMFRAME', true).height(v || '');
                }
            },
            imgWidth: {
                ini: 16,
                caption: ood.getResText("DataModel.imageWidth") || "",
                action: function (v) {
                    this.getSubNode('IMAGE', true).width(v || '');
                }
            },
            imgHeight: {
                ini: 16,
                caption: ood.getResText("DataModel.imageHeight") || "",
                action: function (v) {
                    this.getSubNode('IMAGE', true).height(v || '');
                }
            },
            width: {
                $spaceunit: 1,
                ini: '16rem',
                caption: ood.getResText("DataModel.width") || ""
            },
            height: {
                $spaceunit: 1,
                ini: '16rem',
                caption: ood.getResText("DataModel.height") || ""
            },
            columns: {
                ini: 0,
                caption: ood.getResText("DataModel.cols") || "",
                action: function () {
                    this.boxing().refresh();
                }
            },
            rows: {
                ini: 0,
                caption: ood.getResText("DataModel.rows") || "",
                action: function () {
                    this.boxing().refresh();
                }
            }
        },
        EventHandlers: {
            onCmd: null,
            onFlagClick: function (profile, item, e, src) {
            }
        },
        _prepareData: function (profile) {
            var d = arguments.callee.upper.call(this, profile), p = profile.properties;
            if (p.cols) d._itemscls1 = profile.getClass('ITEMS', '-nowrap');
            return d;
        },


        _prepareItem: function (profile, item) {
            var p = profile.properties,
                cols = p.columns,
                rows = p.rows,
                auto1 = item.autoItemSize || p.autoItemSize,
                auto2 = item.autoImgSize || p.autoImgSize,
                t;

            ood.arr.each(ood.toArr('itemWidth,bgimg,iotStatus,position,itemHeight,imgWidth,imgHeight,itemPadding,itemMargin,iconFontSize,autoItemSize,autoImgSize'), function (i) {
                item[i] = ood.isSet(item[i]) ? item[i] : p[i];
            });


            item.itemWidth = (!auto1 && (t = item.itemWidth)) ? profile.$forceu(t) : '';
            item.itemHeight = (!auto1 && (t = item.itemHeight)) ? profile.$forceu(t) : '';
            item.itemMargin = (t = item.itemMargin) ? profile.$forceu(t) : 0;
            item.itemPadding = (t = item.itemPadding) ? profile.$forceu(t) : 0;
            item.imgWidth = (!auto2 && (t = item.imgWidth)) ? profile.$forceu(t) : '';
            item.imgHeight = (!auto2 && (t = item.imgHeight)) ? profile.$forceu(t) : '';
            item._tabindex = p.tabindex;

            if (p.flagClass && !item.flagClass) {
                item.flagClass = p.flagClass;
            }
            if (p.flagStyle && !item.flagStyle) {
                item.flagStyle = p.flagStyle;
            }
            if (p.flagText && !item.flagText) {
                item.flagText = p.flagText;
            }

            if (item.icon) item._icon = "background-image: url(" + item.icon + ")";

            if (item.bgimg) item._bgimg = "background-image: url(/" + item.bgimg + ")";

            if (t = item.iconFontSize) item._fontSize = "font-size:" + t;

            item._imageClass = '';
            if (!item.iconFontCode && !item.imageClass) item._imageClass += 'ood-icon-loading';

            if (item.imageClass) {
                item._imageClass += ' ' + item.imageClass;
            } else {
                item._imageClass = ' icon1';
            }

            if (item.flagText || item.flagClass) item._flagStyle = 'display:block';
            if (!item.flagClass) item.flagClass = 'ood-uiflag-1';

            if (p.iconOnly) {
                delete item.caption;
                delete item.comment;
            }

            if (item.content) {
                item.caption = item.content;
            }


            if ((item.caption = item.caption || '') === '') item.capDisplay = 'display:none;';
            if ((item.comment = item.comment || '') === '') item.commentDisplay = 'display:none;';
            item._itemSize = '';
            if (cols)
                item._itemSize += 'width:' + (100 / cols + '%') + ';border:0;margin-left:0;margin-right:0;padding-left:0;padding-right:0;';
            if (rows)
                item._itemSize += 'height:' + (100 / rows + '%') + ';border:0;margin-top:0;margin-bottom:0;padding-top:0;padding-bottom:0;';

            if (!auto1) item._inneritemSize = (!cols && item.itemWidth ? ('width:' + item.itemWidth + ';') : '') +
                (!rows && item.itemHeight ? ('height:' + item.itemHeight) : '');
            if (!auto2)
                item._innerimgSize = (item.imgWidth ? ('width:' + item.imgWidth + ';') : '') + (!rows && item.imgHeight ? ('height:' + item.imgHeight) : '');
        }
        ,
        RenderTrigger: function () {
            this.boxing()._afterInsertItems(this);
        }
    }
});
