# Ooder Agent SDK 0.7.1 技术实现文档

> 本文档详细描述SDK 0.7.1版本的技术实现细节，包括架构设计、模块实现和API使用指南。

## 文档信息

- 版本：v0.7.1
- 创建日期：2026-02-17
- 状态：已发布

---

## 一、架构概述

### 1.1 模块架构

```
agent-sdk/
├── src/main/java/net/ooder/sdk/
│   ├── api/                          # 接口定义层
│   │   ├── storage/                  # 存储服务接口
│   │   │   ├── StorageService.java
│   │   │   └── TypeReference.java
│   │   ├── llm/                      # LLM服务接口
│   │   │   ├── LlmService.java
│   │   │   ├── ChatRequest.java
│   │   │   ├── FunctionDef.java
│   │   │   └── TokenUsage.java
│   │   ├── event/                    # 事件总线接口
│   │   │   ├── EventBus.java
│   │   │   ├── Event.java
│   │   │   └── Subscription.java
│   │   ├── network/                  # 网络服务接口
│   │   │   ├── NetworkService.java
│   │   │   ├── LinkInfo.java
│   │   │   ├── LinkQualityInfo.java
│   │   │   └── LinkListener.java
│   │   ├── scheduler/                 # 任务调度接口
│   │   │   ├── TaskScheduler.java
│   │   │   ├── TaskInfo.java
│   │   │   └── TaskStatus.java
│   │   ├── security/                  # 安全服务接口
│   │   │   ├── SecurityService.java
│   │   │   ├── KeyPair.java
│   │   │   └── TokenInfo.java
│   │   └── protocol/                  # 协议中枢接口
│   │       ├── ProtocolHub.java
│   │       ├── ProtocolHandler.java
│   │       ├── CommandPacket.java
│   │       └── CommandResult.java
│   └── service/                       # 实现层
│       ├── storage/
│       │   └── StorageServiceImpl.java
│       ├── llm/
│       │   └── LlmServiceImpl.java
│       ├── event/
│       │   └── EventBusImpl.java
│       ├── network/
│       │   └── NetworkServiceImpl.java
│       ├── scheduler/
│       │   └── TaskSchedulerImpl.java
│       ├── security/
│       │   └── SecurityServiceImpl.java
│       └── protocol/
│           └── ProtocolHubImpl.java
```

### 1.2 设计原则

1. **接口分离**: 每个服务模块独立接口定义
2. **异步优先**: 核心操作提供异步API
3. **类型安全**: 使用泛型和TypeReference确保类型安全
4. **可扩展性**: 支持监听器、处理器扩展

---

## 二、模块实现详情

### 2.1 StorageService 实现

#### 核心特性

| 特性 | 说明 |
|------|------|
| 类型安全 | 支持泛型和TypeReference |
| 异步操作 | CompletableFuture支持 |
| 批量操作 | saveBatch/loadBatch |
| 缓存机制 | 内存缓存提升性能 |

#### 使用示例

```java
// 创建存储服务
StorageService storage = new StorageServiceImpl("./data/storage");

// 简单存取
storage.save("user:001", user);
Optional<User> user = storage.load("user:001", User.class);

// 复杂类型
TypeReference<List<User>> typeRef = new TypeReference<List<User>>() {};
Optional<List<User>> users = storage.load("users:all", typeRef);

// 异步操作
storage.saveAsync("user:001", user)
    .thenAccept(key -> log.info("Saved: {}", key));

// 批量操作
Map<String, Object> batch = new HashMap<>();
batch.put("key1", value1);
batch.put("key2", value2);
storage.saveBatch(batch);
```

#### 实现细节

```java
public class StorageServiceImpl implements StorageService {
    private final ObjectMapper objectMapper;
    private final Map<String, Object> cache;
    private final ExecutorService executorService;
    private String basePath;
    private boolean useCache;

    // JSON文件存储
    private Path getKeyPath(String key) {
        String safeKey = key.replaceAll("[^a-zA-Z0-9_\\-:.]", "_");
        return Paths.get(basePath, safeKey + ".json");
    }

    // 类型安全加载
    @Override
    public <T> Optional<T> load(String key, TypeReference<T> typeRef) {
        JavaType javaType = objectMapper.constructType(typeRef.getType());
        // ... 实现
    }
}
```

### 2.2 LlmService 实现

#### 核心特性

| 特性 | 说明 |
|------|------|
| 流式输出 | chunk回调模式 |
| 多模型 | 动态模型切换 |
| Token管理 | 使用统计和计数 |
| Function Calling | 函数调用支持 |

#### 使用示例

```java
LlmService llm = new LlmServiceImpl(config);

// 简单对话
String response = llm.chat(ChatRequest.of("Hello!"));

// 流式输出
llm.chatStream(ChatRequest.of("Tell me a story"),
    chunk -> System.out.print(chunk),
    v -> System.out.println("\nDone!"),
    e -> log.error("Error", e)
);

// 多模型
List<String> models = llm.getAvailableModels();
llm.setModel("gpt-4");

// Token统计
int tokens = llm.countTokens("Hello world");
TokenUsage usage = llm.getTokenUsage();

// Function Calling
List<FunctionDef> functions = Arrays.asList(
    FunctionDef.of("get_weather", "Get weather info")
        .addParameter("city", "string", "City name", true)
);
String result = llm.chatWithFunctions(ChatRequest.of("What's the weather?"), functions);
```

### 2.3 EventBus 实现

#### 核心特性

| 特性 | 说明 |
|------|------|
| Topic订阅 | 基于主题的发布订阅 |
| 过滤订阅 | Predicate过滤 |
| 异步发布 | 非阻塞发布 |
| 类型安全 | 泛型事件类型 |

#### 使用示例

```java
EventBus eventBus = new EventBusImpl();

// 订阅
Subscription sub = eventBus.subscribe("user.created", User.class, user -> {
    log.info("User created: {}", user.getName());
});

// 过滤订阅
eventBus.subscribe("order.created", Order.class,
    order -> order.getAmount() > 1000,
    order -> log.info("Large order: {}", order.getId())
);

// 发布
eventBus.publish("user.created", newUser);

// 异步发布
eventBus.publishAsync("user.created", newUser)
    .thenRun(() -> log.info("Event published"));

// 取消订阅
eventBus.unsubscribe(sub.getSubscriptionId());
```

### 2.4 NetworkService 实现

#### 核心特性

| 特性 | 说明 |
|------|------|
| 链路管理 | 创建/删除/查询 |
| 质量监控 | 定时质量检测 |
| 路径计算 | Dijkstra最优路径 |
| 事件监听 | 链路状态变化通知 |

#### 使用示例

```java
NetworkService network = new NetworkServiceImpl();

// 创建链路
LinkInfo link = network.createLink("node1", "node2", LinkType.DIRECT);

// 获取质量
LinkQualityInfo quality = network.getLinkQuality(link.getLinkId());

// 启用监控
network.enableQualityMonitor(30000); // 30秒间隔

// 最优路径
List<LinkInfo> path = network.findOptimalPath("node1", "node5");

// 监听器
network.addLinkListener(new LinkListener() {
    void onQualityChanged(String linkId, LinkQualityInfo quality) {
        log.info("Quality changed: {} -> {}", linkId, quality);
    }
});
```

### 2.5 TaskScheduler 实现

#### 核心特性

| 特性 | 说明 |
|------|------|
| 延迟任务 | 一次性延迟执行 |
| 固定频率 | 周期性执行 |
| Cron表达式 | 灵活调度 |
| 任务持久化 | 重启恢复 |

#### 使用示例

```java
TaskScheduler scheduler = new TaskSchedulerImpl();

// 延迟任务
String taskId = scheduler.schedule(() -> {
    log.info("Task executed!");
}, 5000);

// 固定频率
String periodicId = scheduler.scheduleAtFixedRate(() -> {
    log.info("Periodic task");
}, 0, 60000);

// Cron任务
String cronId = scheduler.scheduleWithCron(() -> {
    log.info("Daily task");
}, "0 0 8 * * ?");

// 暂停/恢复
scheduler.pause(taskId);
scheduler.resume(taskId);

// 取消
scheduler.cancel(taskId);

// 持久化
scheduler.enablePersistence(storage);
scheduler.recoverTasks();
```

### 2.6 SecurityService 实现

#### 核心特性

| 特性 | 说明 |
|------|------|
| RSA加密 | 2048位非对称加密 |
| 数字签名 | SHA256withRSA |
| Token管理 | JWT风格Token |
| 场景组密钥 | 组级密钥管理 |
| 端到端加密 | Peer间加密通信 |

#### 使用示例

```java
SecurityService security = new SecurityServiceImpl();

// 生成密钥对
KeyPair keyPair = security.generateKeyPair();

// 加密解密
String encrypted = security.encrypt("secret data", keyPair.getPublicKey());
String decrypted = security.decrypt(encrypted, keyPair.getPrivateKey());

// 签名验证
String signature = security.sign("data", keyPair.getPrivateKey());
boolean valid = security.verify("data", signature, keyPair.getPublicKey());

// Token管理
String token = security.generateToken("user123", 3600000);
TokenInfo info = security.validateToken(token);

// 场景组密钥
KeyPair sceneKey = security.generateSceneKey("scene-001");
security.registerPeerPublicKey("scene-001", "peer-002", peerPublicKey);

// 端到端加密
String encryptedForPeer = security.encryptForPeer("scene-001", "peer-002", "secret");
String decrypted = security.decryptFromPeer("scene-001", "peer-002", encryptedForPeer);
```

### 2.7 ProtocolHub 实现

#### 核心特性

| 特性 | 说明 |
|------|------|
| 协议注册 | 动态注册处理器 |
| 命令路由 | 基于协议类型路由 |
| 统计监控 | 命令统计 |
| 异步处理 | 非阻塞命令处理 |

#### 使用示例

```java
ProtocolHub hub = new ProtocolHubImpl();

// 注册处理器
hub.registerProtocolHandler("MCP", new McpProtocolHandler());
hub.registerProtocolHandler("ROUTE", new RouteProtocolHandler());

// 处理命令
CommandPacket packet = CommandPacket.of("MCP", "REGISTER");
CommandResult result = hub.handleCommand(packet);

// 异步处理
hub.handleCommandAsync(packet)
    .thenAccept(r -> log.info("Result: {}", r));

// 获取统计
ProtocolStats stats = hub.getProtocolStats("MCP");
```

---

## 三、依赖关系

### 3.1 模块依赖

```
StorageService ─────┐
                    ├──> TaskScheduler (持久化)
EventBus ───────────┤
                    ├──> ProtocolHub (事件通知)
NetworkService ─────┤
                    ├──> SecurityService (链路加密)
SecurityService ────┘
```

### 3.2 外部依赖

| 依赖 | 版本 | 用途 |
|------|------|------|
| Spring Boot | 2.7.0 | 框架基础 |
| Jackson | 2.13.4 | JSON/YAML处理 |
| Fastjson | 1.2.83 | JSON处理 |
| SLF4J | 1.7.36 | 日志 |

---

## 四、性能优化

### 4.1 存储优化

- 内存缓存减少IO
- 批量操作减少文件操作
- 异步写入提升吞吐

### 4.2 网络优化

- 链路质量缓存
- 最优路径预计算
- 异步链路创建

### 4.3 安全优化

- 密钥缓存
- 异步加密操作
- Token验证缓存

---

## 五、测试覆盖

### 5.1 单元测试

| 模块 | 测试类 | 覆盖率目标 |
|------|--------|-----------|
| StorageService | StorageServiceImplTest | >80% |
| LlmService | LlmServiceImplTest | >80% |
| EventBus | EventBusImplTest | >80% |
| NetworkService | NetworkServiceImplTest | >80% |
| TaskScheduler | TaskSchedulerImplTest | >80% |
| SecurityService | SecurityServiceImplTest | >80% |
| ProtocolHub | ProtocolHubImplTest | >80% |

---

## 六、版本兼容性

### 6.1 API兼容性

| 版本 | 兼容性 |
|------|--------|
| 0.7.0 -> 0.7.1 | 完全兼容 |
| 0.6.x -> 0.7.1 | 需要迁移 |

### 6.2 数据兼容性

- 存储格式：JSON (向后兼容)
- 配置格式：YAML (向后兼容)

---

## 七、部署说明

### 7.1 Maven依赖

```xml
<dependency>
    <groupId>net.ooder</groupId>
    <artifactId>agent-sdk</artifactId>
    <version>0.7.1</version>
</dependency>
```

### 7.2 本地安装

```bash
cd agent-sdk
mvn clean install -DskipTests -Dgpg.skip=true
```

---

**文档维护者**: ooder Team  
**最后更新**: 2026-02-17
