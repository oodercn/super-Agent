# Ooder Agent SDK 0.7.0 技能闭环设计共识文档

> 本文档记录了关于0.7.0版本技能闭环设计的重要讨论和共识，作为后续实现和协议完善的参考依据。

## 文档信息

- 版本：v0.7.0
- 创建日期：2026-02-15
- 状态：共识讨论中

---

## 一、协议层分析

### 1.1 技能发现方法

协议定义了四种技能发现方法：

| 方法 | 范围 | 延迟 | 用途 | 协议章节 |
|------|------|------|------|----------|
| UDP Broadcast | 本地网络 | 低 | LAN发现 | 第5节 |
| DHT (Kademlia) | 全局 | 中 | P2P发现 | 第6节 |
| SkillCenter API | 全局 | 低 | 集中式目录 | 第7节 |
| mDNS/DNS-SD | 本地网络 | 低 | 服务发现 | 未详细定义 |

### 1.2 技能源概念

**核心概念：技能包 = 地址**

```
技能包 = 一个文件包 = 一个地址

地址格式：{协议}://{主机}/{路径}/skills/{技能ID}

示例：
- file:///local/path/skills/skill-org-feishu
- http://192.168.1.100:8080/skills/skill-org-feishu
- https://skillcenter.ooder.net/skills/skill-org-feishu
- github://ooderCN/guper-Agent/skills/skill-org-feishu
```

**技能源描述（最简形式）：**

```
技能源 = {协议}://{地址}/skills/

协议类型：
- file://     → 本地文件系统
- http://     → HTTP请求
- https://    → HTTPS请求
- github://   → GitHub API
- udp://      → UDP广播
- dht://      → DHT查询
```

### 1.3 零配置动态发现机制

**原则：不依赖配置文件或环境变量，通过协议自动感知**

发现时机：启动时自动扫描

| 发现方法 | 触发条件 | 发现结果 |
|----------|----------|----------|
| UDP Broadcast | 启动时自动广播 | 本地网络技能源 |
| mDNS/DNS-SD | 启动时自动查询 | 本地服务技能源 |
| DHT (Kademlia) | 连接引导节点后查询 | P2P全局技能源 |
| SkillCenter API | 预置官方地址 | 官方技能中心 |
| Local File System | 扫描标准路径 | 本地开发技能 |

---

## 二、两种工作模式

### 2.1 无SkillCenter模式（去中心化）

**特点：**
- 客户端自治，自己管理一切
- 技能版本去重（本地维护）
- 本地资源管理（CPU、内存、存储）
- 端口地址分配（本地协调）
- 无中心化依赖，适合单机/小团队

**发现方式：**
- UDP Broadcast（局域网）
- DHT/P2P（全局）
- mDNS/DNS-SD（本地服务）
- 本地文件系统

### 2.2 有SkillCenter模式（中心化）

**特点：**
- 中心化管理，统一协调
- 远程部署（技能运行在SkillCenter）
- 高级版本管理（多版本共存、回滚）
- 多场景多技能协同（跨技能编排）
- 资源池化，按需分配

**发现方式：**
- SkillCenter API（主要）
- 兼容无SkillCenter模式的所有发现方式

### 2.3 模式对比

| 功能维度 | 无SkillCenter | 有SkillCenter |
|----------|---------------|---------------|
| 技能发现 | UDP/DHT/mDNS/本地 | SkillCenter API + 兼容上述 |
| 版本管理 | 本地维护，简单去重 | 多版本共存、回滚、锁定、自动更新 |
| 部署模式 | 仅本地部署 | 远程托管 + 本地部署 |
| 资源管理 | 客户端自治 | 资源池化，按需分配 |
| 端口分配 | 客户端本地协调 | SkillCenter统一分配 |
| 技能协同 | 无 | 多技能编排、跨技能通信 |
| 安全性 | 本地控制 | 集中认证、权限管理 |
| 适用场景 | 单机/小团队/开发 | 企业/团队协作/生产环境 |

---

## 三、协议层抽象

```
Layer 4: 协调层（可选）
┌─────────────────────────────────────────────────────────────────────────────┐
│                    SkillCenter（中心化协调）                                  │
│  功能：远程部署管理、版本控制与回滚、多技能协同编排、资源池化管理、权限与安全    │
│  协议：SkillCenter API Protocol                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
Layer 3: 管理层（客户端自治）
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Local Registry（本地注册表）                               │
│  功能：本地技能版本管理、技能去重、端口分配、资源限制、场景-技能映射            │
│  协议：Local Registry Protocol                                               │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
Layer 2: 发现层
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Discovery（技能发现）                                      │
│  发现方法：UDP Broadcast、DHT/Kademlia、mDNS/DNS-SD、SkillCenter API、Local FS│
│  协议：Skill Discovery Protocol                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
Layer 1: 传输层
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Transport（技能传输）                                      │
│  传输协议：HTTP/HTTPS（下载）、P2P/DHT（点对点传输）、Local File（本地复制）   │
│  协议：Skill Package Protocol                                                │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 四、场景与技能的关系

### 4.1 核心概念

```
场景（Scene）= 契约/接口
┌─────────────────────────────────────────────────────────────────────────────┐
│ 静态的、共识的部分：                                                          │
│ - 能力需求定义                                                                │
│ - 角色定义                                                                    │
│ - 通信协议                                                                    │
│ - 安全策略                                                                    │
│ 场景定义了"做什么"                                                            │
└─────────────────────────────────────────────────────────────────────────────┘

技能（Skill）= 实现/实例
┌─────────────────────────────────────────────────────────────────────────────┐
│ 动态的、特有的部分：                                                          │
│ - 安装配置说明                                                                │
│ - 使用说明                                                                    │
│ - 程序实现                                                                    │
│ - 特有增强                                                                    │
│ 技能实现了"怎么做"                                                            │
└─────────────────────────────────────────────────────────────────────────────┘

关系：一个场景可以有多个技能实现

auth场景 ─┬─ skill-org-feishu（飞书实现）
          ├─ skill-org-dingding（钉钉实现）
          └─ skill-org-wework（企业微信实现）
```

### 4.2 场景分类

| 类型 | 定义 | 特点 |
|------|------|------|
| 主场景 | 技能的核心功能场景 | - 技能必须提供<br>- 技能是场景的主要提供者<br>- 场景生命周期与技能绑定 |
| 协作场景 | 技能依赖的其他场景 | - 技能依赖但不提供<br>- 需要加入已存在的场景<br>- 或触发新技能安装 |

### 4.3 技能目录结构

```
/skills/                              # 技能根目录
├── auth/                             # 场景目录（二级分类）
│   ├── scene.yaml                    # 场景定义（静态共识部分）
│   ├── skill-org-feishu/             # 技能实例
│   │   ├── skill.yaml                # 技能清单
│   │   ├── SKILLS.md                 # 场景说明（安装配置+使用说明）
│   │   ├── config/                   # 配置
│   │   └── src/                      # 程序实现
│   └── skill-org-dingding/
│       └── ...
├── ui-design/                        # 另一个场景
│   ├── scene.yaml
│   └── skill-a2ui/
│       └── ...
└── index.json                        # 可选，仅SkillCenter强约束时
```

---

## 五、两种运行模式

### 5.1 NLP友好检索模式（跨域资源发现）

**目的：让AI/人类能够方便地发现和检索技能**

**特点：**
- 跨域访问，不受网络限制
- 支持自然语言查询
- 返回技能元数据和描述
- 不包含敏感信息
- 用于发现阶段

**适用场景：**
- 技能搜索和发现
- AI辅助选型
- 技能评估和比较

### 5.2 严格模式（脱机程序自治）

**目的：确保技能安装后能够独立、安全、可控地运行**

**特点：**
- 完全自治，不依赖外部服务
- 强制包含配置、VFS资源、认证模式、身份证明
- 本地资源隔离
- 安全可审计
- 用于安装后运行

**强制包含：**
1. Configuration（配置）
2. VFS Resources（虚拟文件系统资源）
3. Auth Mode（认证模式/KEY）
4. Skill Identity（技能身份证明）

### 5.3 模式转换

```
NLP检索模式 ────[下载安装]────▶ 严格模式
     │                              │
     ▼                              ▼
发现阶段                          运行阶段
（跨域、开放）                    （本地、自治）
```

---

## 六、核心术语定义

| 术语 | 定义 |
|------|------|
| Skill（技能） | 场景的具体实现，包含程序、配置、资源 |
| Scene（场景） | 能力需求的抽象定义，描述"做什么" |
| SkillPackage（技能包） | 技能的分发单元，包含所有运行所需文件 |
| SkillSource（技能源） | 技能的来源地址，支持多种协议 |
| SkillCenter | 中心化的技能管理和分发服务 |
| LocalRegistry | 本地技能注册表，管理已安装技能 |
| SkillIdentity | 技能身份证明，用于认证和授权 |
| VFS（虚拟文件系统） | 技能的数据资源抽象层 |
| SceneGroup | 场景组，共享KEY和VFS资源的Agent集合 |
| SceneGroupKey | 场景组身份标识和访问凭证 |

---

## 七、完整元数据清单

### 7.1 文件清单

| 文件 | NLP模式可见 | 严格模式必须 | 说明 |
|------|-------------|--------------|------|
| skill.yaml | ✓ | ✓ | 技能清单 |
| SKILLS.md | ✓ | ✓ | 场景说明 |
| identity.yaml | ✗ | ✓ | 身份证明 |
| config/config.yaml | ✗ | ✓ | 运行配置 |
| config/config.schema | ✗ | ✓ | 配置Schema |
| vfs/vfs.yaml | ✗ | ✓ | VFS配置 |
| auth/auth.yaml | ✗ | ✓ | 认证配置 |
| auth/keys/* | ✗ | ✓ | 密钥文件 |
| src/* | ✓ | ✓ | 程序文件 |
| lib/* | ✓ | ✓ | 依赖库 |

### 7.2 元数据分类

| 分类 | 文件 | 用途 |
|------|------|------|
| 描述性元数据 | skill.yaml, SKILLS.md | 技能发现和检索 |
| 身份元数据 | identity.yaml | 来源验证和审计 |
| 配置元数据 | config/* | 运行时配置管理 |
| 资源元数据 | vfs/* | 数据和文件管理 |
| 安全元数据 | auth/* | 认证和授权管理 |

---

## 八、安装流程

### 8.1 阶段一：下载（NLP检索模式 → 本地）

1. 从技能源下载技能包
2. 验证校验和和签名
3. 解压到临时目录

### 8.2 阶段二：强制写入严格模式

**步骤1: 生成身份证明（identity.yaml）**
- 生成技能唯一标识
- 记录来源信息和下载时间
- 生成本地密钥对
- 生成数字签名

**步骤2: 初始化配置（config/）**
- 分配本地端口
- 设置资源限制
- 配置日志路径
- 生成配置Schema

**步骤3: 初始化VFS资源（vfs/）**
- 创建VFS目录结构
- 初始化数据文件
- 设置权限控制
- 配置加密

**步骤4: 初始化认证模式（auth/）**
- 根据skill.yaml中的配置需求初始化
- 生成或导入密钥
- 配置Token存储
- 设置安全策略

**步骤5: 注册到本地注册表**
- 更新本地技能索引
- 记录端口分配
- 记录资源使用
- 建立场景映射

### 8.3 阶段三：处理协作场景

对每个协作场景：

**步骤1: 检查场景是否存在**
- A. 场景存在且能力匹配 → 进入步骤3（申请加入）
- B. 场景不存在 → 进入步骤2（搜索安装）
- C. 场景存在但能力不匹配 → 评估是否需要扩展

**步骤2: 搜索并安装协作场景技能**
1. 发起场景搜索请求
2. 获取候选技能列表
3. 选择最佳匹配
4. 检测循环依赖
5. 递归安装协作技能

**步骤3: 申请加入协作场景**
1. 发送加入请求
2. 场景验证请求
3. 获取场景访问权
4. 建立安全通道

### 8.4 循环依赖处理策略

| 策略 | 说明 | 适用场景 |
|------|------|----------|
| skip | 跳过可选依赖 | required: false |
| use-existing | 使用已存在的场景 | 场景已部分满足 |
| lazy-load | 延迟加载，运行时再处理 | 非立即需要的依赖 |
| mock | 使用模拟服务 | 开发测试环境 |
| fail | 安装失败，报错退出 | required: true |

---

## 九、协作场景与EndAgent的区分

### 9.1 概念区分

**协作场景：**
- 是一个能力域，由一个或多个技能提供
- 技能可以加入场景，成为场景的参与者
- 场景内的技能可以互相通信和协作
- 场景有明确的角色和能力定义

**EndAgent：**
- 是Agent层级结构中的终端节点
- 直接与用户交互
- 调用技能提供的能力
- 不参与场景内的技能协作

### 9.2 架构关系

```
                    ┌─────────────────┐
                    │    EndAgent     │◀──── 用户交互
                    │   (终端节点)     │
                    └────────┬────────┘
                             │ 调用能力
                             ▼
         ┌───────────────────────────────────────┐
         │           Scene (messaging)           │
         │              消息场景                  │
         │  ┌─────────────┬─────────────┐       │
         │  │             │             │       │
         │  ▼             ▼             ▼       │
         │ ┌─────────┐ ┌─────────┐ ┌─────────┐ │
         │ │Skill-A  │ │Skill-B  │ │Skill-C  │ │
         │ │provider │ │consumer │ │consumer │ │
         │ └─────────┘ └─────────┘ └─────────┘ │
         │       ▲           │           │     │
         │       └───────────┴───────────┘     │
         │            场景内协作通信             │
         └───────────────────────────────────────┘
```

### 9.3 标识方式

```java
// 场景参与者类型
enum SceneParticipantType {
    SKILL_PROVIDER,    // 技能作为场景提供者
    SKILL_CONSUMER,    // 技能作为场景消费者
    END_AGENT          // EndAgent作为调用者
}
```

---

## 十、Capability机制

### 10.1 Cap定义

**Capability（能力）是场景提供的最小功能单元**

**特点：**
- 原子性：一个能力完成一个独立的功能
- 可组合：多个能力可以组合完成复杂任务
- 可发现：通过场景发现可用能力
- 可授权：能力访问需要权限验证

### 10.2 Cap调用流程

1. **发现能力**
   - `GET /api/scenes/{sceneId}/capabilities`
   - 返回: 可用能力列表

2. **验证权限**
   - `POST /api/capabilities/{capId}/check-permission`
   - 返回: `{allowed: true/false}`

3. **调用能力**
   - `POST /api/capabilities/{capId}/invoke`
   - Headers: Authorization, X-Scene-ID, X-Skill-ID
   - 返回: 执行结果

### 10.3 Cap授权模型

**角色权限矩阵：**

| 角色 | msg-send | msg-receive | msg-history |
|------|----------|-------------|-------------|
| sender | ✓ | ✗ | ✗ |
| receiver | ✗ | ✓ | ✓ |
| admin | ✓ | ✓ | ✓ |

---

## 十一、组网KEY安全机制

### 11.1 密钥层级结构

```
Layer 1: Root CA（根证书颁发机构）
├── Ooder Root CA
├── 用于签发SkillCenter CA和场景CA
└── 离线保存，高度安全
        │
        │ 签发
        ▼
Layer 2: Scene CA（场景证书颁发机构）
├── 每个场景有自己的CA
├── 用于签发场景内技能的证书
└── 场景创建时自动生成
        │
        │ 签发
        ▼
Layer 3: Skill Certificate（技能证书）
├── 每个技能安装时生成
├── 包含技能身份和权限信息
└── 用于场景内通信认证
        │
        │ 使用
        ▼
Layer 4: Session Key（会话密钥）
├── 技能间通信时临时生成
├── 用于加密具体通信内容
└── 定期轮换
```

### 11.2 场景组KEY结构

```
SceneGroupKey {
    groupId: "scene-auth-001",        # 场景组唯一标识
    sceneName: "auth",                # 场景名称
    version: 1,                       # KEY版本
    
    masterKey: "...",                 # 主密钥（加密存储）
    accessKey: "...",                 # 访问密钥
    
    permissions: {                    # 权限定义
        vfs: {
            "data/org-structure.json": ["read"],
            "data/user-mapping.json": ["read", "write"],
            "cache/*": ["read", "write", "delete"]
        },
        capabilities: {
            "org-data-read": true,
            "user-auth": true
        }
    },
    
    members: [                        # 成员列表
        {
            agentId: "route-agent-a",
            role: "PRIMARY",
            publicKey: "...",
            keyShare: "..."           # 密钥分片
        }
    ],
    
    createdAt: "2026-02-15T10:00:00Z",
    expiresAt: "2027-02-15T10:00:00Z",
    
    signature: "..."                  # MCP Agent签名
}
```

### 11.3 密钥分片机制（Shamir秘密共享）

- 主密钥分成N份，需要K份才能恢复
- 每个RouteAgent持有一份密钥分片
- 单个节点泄露不影响整体安全
- 故障恢复时，剩余节点协作恢复密钥

---

## 十二、运行期故障切换

### 12.1 RouteAgent角色定义

| 角色 | 描述 | 职责 |
|------|------|------|
| PRIMARY | 主RouteAgent | - 处理场景消息路由<br>- 管理场景组KEY<br>- 维护链路表<br>- 协调VFS资源访问 |
| BACKUP | 备用RouteAgent | - 监听PRIMARY状态<br>- 同步链路表<br>- 准备接管场景组<br>- 共享场景组KEY |

### 12.2 故障检测机制

- PRIMARY每5秒发送心跳到所有BACKUP
- BACKUP每10秒发送状态报告到PRIMARY
- 连续3次心跳超时（15秒）判定为故障

### 12.3 故障切换流程

**阶段1: 故障检测**
1. BACKUP未收到PRIMARY心跳，开始计时
2. 连续超时后触发故障检测
3. 向MCP Agent确认PRIMARY状态
4. MCP Agent确认故障，授权切换

**阶段2: 备用接管**
1. 选举新的PRIMARY（优先级: 技能完整性 > 网络延迟 > 资源可用性）
2. 继承场景组KEY（KEY不变，VFS资源访问权限自动继承）
3. 恢复链路表
4. 启动技能服务

**阶段3: 原链路恢复**
1. 原PRIMARY重新上线，发送恢复通知
2. 评估是否需要切换回原PRIMARY
3. 如决定切换：同步最新链路表，原PRIMARY接管
4. 如不切换：原PRIMARY以BACKUP角色加入

### 12.4 KEY与VFS资源访问权限绑定

**关键点：**
- 权限绑定在场景组KEY上，不是具体Agent
- 任何持有有效KEY的Agent都可以访问
- 备用RouteAgent切换后无需重新授权

---

## 十三、真实应用场景

### 场景1: 企业即时通讯系统故障切换

**背景：**
- 企业使用飞书作为即时通讯工具
- Route Agent A (PRIMARY) 运行在服务器A
- Route Agent B (BACKUP) 运行在服务器B

**故障：** 服务器A硬件故障宕机

**切换过程：**
1. Route Agent B检测到心跳超时
2. 向MCP Agent确认故障
3. 激活场景组KEY副本
4. 恢复链路表，重建连接
5. 启动技能服务
6. 用户无感知，消息服务继续运行
7. VFS资源（用户通讯录、消息历史）无缝访问

### 场景2: 跨区域协同办公系统

**背景：**
- 跨国企业多区域部署
- 北京: Route Agent A (PRIMARY)
- 上海: Route Agent B (BACKUP)
- 新加坡: Route Agent C (BACKUP)

**故障：** 北京区域网络中断

**切换过程：**
1. 上海和新加坡同时检测到故障
2. 上海Route Agent B被选为新PRIMARY
3. 从新加坡Route Agent C获取密钥分片
4. 恢复主密钥，访问VFS资源
5. 跨区域VFS资源访问权限随KEY迁移

### 场景3: 边缘计算场景的技能切换

**背景：**
- 工厂部署边缘Agent进行设备监控
- Route Agent A运行在边缘服务器
- Route Agent B运行在云端作为备份

**故障：** 边缘服务器断电

**切换过程：**
1. 云端Route Agent B检测到边缘节点失联
2. 接管PRIMARY角色
3. 使用场景组KEY访问云端VFS资源
4. 继续接收设备数据（通过网络上报到云端）
5. 告警规则继续生效，保障生产安全

### 场景4: P2P模式下的个人技能共享

**背景：**
- 用户A和用户B组成P2P场景组，共享AI写作技能
- 用户A的设备作为PRIMARY
- 用户B的设备作为BACKUP

**故障：** 用户A的设备离线

**切换过程：**
1. 用户B的设备检测到用户A离线
2. 自动接管PRIMARY角色
3. 使用场景组KEY访问共享的VFS资源
4. 用户B可以继续使用AI写作技能
5. 写作模板和历史文档保持可用

### 场景5: 多技能协同的复杂场景

**背景：**
- 智能客服系统，需要多个技能协同
- skill-nlp, skill-knowledge, skill-msg
- Route Agent A管理所有技能

**故障：** Route Agent A在处理客户咨询时故障

**切换过程：**
1. Route Agent B检测到故障
2. 接管场景组
3. 恢复所有技能的运行状态
4. 从VFS恢复对话上下文和知识库状态
5. 继续处理客户咨询，对话不中断

---

## 十四、待完善事项

### 14.1 协议补充

1. **技能源发现协议**：定义零配置动态发现机制
2. **场景定义规范**：定义scene.yaml的结构
3. **场景安装策略**：定义静态共识部分和增强部分的安装策略
4. **P2P共享协议**：定义DHT索引格式和节点间共享机制

### 14.2 术语优化

- [ ] 统一术语命名规范
- [ ] 完善术语定义的准确性
- [ ] 添加术语的中英文对照

### 14.3 流程分支

- [ ] 细化各种边界条件的处理流程
- [ ] 添加异常处理分支
- [ ] 完善回滚机制

### 14.4 元数据固化

- [ ] 确定所有元数据字段的最终定义
- [ ] 添加字段验证规则
- [ ] 定义字段默认值

---

## 十五、版本历史

| 版本 | 日期 | 变更说明 |
|------|------|----------|
| v0.1 | 2026-02-15 | 初始版本，记录核心共识 |

---

## 附录：参考资料

- [Agent协议文档](../protocol-release/v0.7.0/agent/agent-protocol.md)
- [P2P协议文档](../protocol-release/v0.7.0/p2p/p2p-protocol.md)
- [技能发现协议](../protocol-release/v0.7.0/skill/skill-discovery-protocol.md)
- [技能包协议](../protocol-release/v0.7.0/skill/skill-package-protocol.md)
- [技能清单规范](../protocol-release/v0.7.0/skill/skill-manifest-spec.md)
